UNITY PROJECT SCRIPTS - COMPRESSED FORMAT
Compression Stats: 551,436 → 365,093 chars (33.8% reduction)
Estimated tokens saved: ~46,585

This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my Unity game project.

 When you're tasked with editing: return each changed method in full; if edits touch ≤3 methods list those blocks only, else output the entire script—always copy-paste ready.

 This file is optimized for AI/LLM token efficiency. The following compression is applied:
- Removed: excess whitespace, common using statements, XML docs, attributes
- Preserved: code structure, important comments, logic flow

IMPORTANT FOR AI: When editing/creating scripts from this reference:
1. Re-add standard Unity using statements (System, UnityEngine, etc.)
2. Format with proper indentation and spacing
3. Add back regions and documentation as needed
4. Ensure proper C# code style

Common using statements (add these back when needed):
using System;

[Abracodabra.Genes]
  TemporaryFruitSpawnMarker (Assets\Scripts\Genes\Components/) L29
  GeneLibrary (Assets\Scripts\Genes/) L39
  PlantSequenceExecutor (Assets\Scripts\Genes/) L192
  PlantGrowth (Assets\Scripts\PlantSystem\Growth/) L372

[Abracodabra.Genes.Components]
  Creature (Assets\Scripts\Genes\Components/) L727
  Fruit (Assets\Scripts\Genes\Components/) L752
  NutritionComponent (Assets\Scripts\Genes\Components/) L781

[Abracodabra.Genes.Core]
  ActiveGene (Assets\Scripts\Genes\Core/) L793
  ActiveGeneContext (Assets\Scripts\Genes\Core/) L839
  ActiveGeneSlotConfig (Assets\Scripts\Genes\Core/) L858
  ModifierGene (Assets\Scripts\Genes\Core/) L870
  PassiveGene (Assets\Scripts\Genes\Core/) L901
  PayloadGene (Assets\Scripts\Genes\Core/) L933
  PlaceholderGene (Assets\Scripts\Genes\Core/) L978
  SafeGeneLoader (Assets\Scripts\Genes\Core/) L999
  GeneBase (Assets\Scripts\Genes/) L1032

[Abracodabra.Genes.Implementations]
  BasicFruitGene (Assets\Scripts\Genes\Implementations\Active/) L1108
  CostReductionGene (Assets\Scripts\Genes\Implementations\Modifier/) L1198
  GrowthSpeedGene (Assets\Scripts\Genes\Implementations\Passive/) L1226
  NutritiousPayload (Assets\Scripts\Genes\Implementations\Payload/) L1269

[Abracodabra.Genes.Runtime]
  PlantGeneRuntimeState (Assets\Scripts\Genes\Runtime/) L1320
  RuntimeGeneInstance (Assets\Scripts\Genes\Runtime/) L1376
  RuntimeSequenceSlot (Assets\Scripts\Genes\Runtime/) L1508

[Abracodabra.Genes.Services]
  DeterministicRandom (Assets\Scripts\Genes\Services/) L1563
  GeneEffectPool (Assets\Scripts\Genes\Services/) L1596
  GeneServices (Assets\Scripts\Genes\Services/) L1694

[Abracodabra.Genes.Templates]
  SeedTemplate (Assets\Scripts\Genes\Templates/) L1780

[Abracodabra.UI.Genes]
  GeneSequenceUI (Assets\Scripts\Genes\UI/) L1863
  GeneSlotUI (Assets\Scripts\Genes\UI/) L2095
  SequenceRowUI (Assets\Scripts\Genes\UI/) L2318
  InventoryBarController (Assets\Scripts\PlantSystem\UI/) L2389
  ItemView (Assets\Scripts\PlantSystem\UI/) L2560

[Unknown]
  GameEvent (Assets\Scripts\Core\Events/) L2655
  GameEventListener (Assets\Scripts\Core\Events/) L2682
  IGameEventListener (Assets\Scripts\Core\Events/) L2709
  GameInitializer (Assets\Scripts\Core/) L2717
  GeneSystemInitializer (Assets\Scripts\Core/) L2741
  SortableEntity (Assets\Scripts\Core/) L2755
  UIManager (Assets\Scripts\Core/) L2822
  WeatherManager (Assets\Scripts\Core/) L3029
  AnimalBehavior (Assets\Scripts\Ecosystem\Animals/) L3229
  AnimalController (Assets\Scripts\Ecosystem\Animals/) L3290
  AnimalDefinition (Assets\Scripts\Ecosystem\Animals/) L3573
  AnimalLibrary (Assets\Scripts\Ecosystem\Animals/) L3637
  AnimalMovement (Assets\Scripts\Ecosystem\Animals/) L3646
  AnimalNeeds (Assets\Scripts\Ecosystem\Animals/) L4059
  AnimalSpawnData (Assets\Scripts\Ecosystem\Animals/) L4216
  AnimalThoughtLibrary (Assets\Scripts\Ecosystem\Animals/) L4229
  FireflyController (Assets\Scripts\Ecosystem\Effects/) L4266
  FireflyDefinition (Assets\Scripts\Ecosystem\Effects/) L4576
  FireflyManager (Assets\Scripts\Ecosystem\Effects/) L4607
  PoopController (Assets\Scripts\Ecosystem\Environment/) L4880
  ScentDefinition (Assets\Scripts\Ecosystem\Environment/) L4973
  ScentLibrary (Assets\Scripts\Ecosystem\Environment/) L4988
  ScentSource (Assets\Scripts\Ecosystem\Environment/) L5007
  DietPreferenceSimplified (Assets\Scripts\Ecosystem\Food/) L5091
  FoodItem (Assets\Scripts\Ecosystem\Food/) L5167
  FoodType (Assets\Scripts\Ecosystem\Food/) L5239
  EcosystemManager (Assets\Scripts\Ecosystem\Management/) L5254
  FaunaManager (Assets\Scripts\Ecosystem\Management/) L5276
  FloraManager (Assets\Scripts\Ecosystem\Management/) L5519
  WaveManager (Assets\Scripts\Ecosystem\Management/) L5538
  WaveSpawnEntry (Assets\Scripts\Ecosystem\Spawning/) L5843
  IStatusEffectable (Assets\Scripts\Ecosystem\Status Effects/) L5872
  StatusEffect (Assets\Scripts\Ecosystem\Status Effects/) L5890
  StatusEffectIconUI (Assets\Scripts\Ecosystem\Status Effects/) L5928
  StatusEffectInstance (Assets\Scripts\Ecosystem\Status Effects/) L5976
  StatusEffectManager (Assets\Scripts\Ecosystem\Status Effects/) L5994
  StatusEffectUIManager (Assets\Scripts\Ecosystem\Status Effects/) L6145
  ThoughtBubbleController (Assets\Scripts\Ecosystem\UI/) L6256
  ThoughtTrigger (Assets\Scripts\Ecosystem\UI/) L6303
  RadiusPatternTesterEditor (Assets\Scripts\Editor/) L6316
  TileDefinitionEditor (Assets\Scripts\Editor/) L6377
  WaveDefinitionEditor (Assets\Scripts\Editor/) L6397
  WaveManagerEditor (Assets\Scripts\Editor/) L6534
  GeneLibraryLoader (Assets\Scripts\Genes\Core/) L6709
  ITriggerTarget (Assets\Scripts\PlantSystem\Data/) L6734
  LeafData (Assets\Scripts\PlantSystem\Data/) L6742
  NodeExecutor (Assets\Scripts\PlantSystem\Execution/) L6757
  PlantCell (Assets\Scripts\PlantSystem\Growth/) L6796
  PlantCellManager (Assets\Scripts\PlantSystem\Growth/) L6817
  PlantEnergySystem (Assets\Scripts\PlantSystem\Growth/) L6952
  PlantGrowthLogic (Assets\Scripts\PlantSystem\Growth/) L7014
  PlantVisualManager (Assets\Scripts\PlantSystem\Growth/) L7100
  InventoryBarItem (Assets\Scripts\PlantSystem\UI/) L7200
  InventoryColorManager (Assets\Scripts\PlantSystem\UI/) L7271
  InventoryGridController (Assets\Scripts\PlantSystem\UI/) L7331
  StartingInventory (Assets\Scripts\PlantSystem\UI/) L7474
  OutlinePartController (Assets\Scripts\PlantSystem\Visual/) L7490
  PlantOutlineController (Assets\Scripts\PlantSystem\Visual/) L7605
  PlantShadowController (Assets\Scripts\PlantSystem\Visual/) L7760
  ShadowPartController (Assets\Scripts\PlantSystem\Visual/) L7858
  GridDebugVisualizer (Assets\Scripts\Ticks/) L7959
  GridSnapStartup (Assets\Scripts\Ticks/) L8198
  TickDebugMonitor (Assets\Scripts\Ticks/) L8265
  TooltipTrigger (Assets\Scripts\UI\Tooltips/) L8301
  ITooltipDataProvider (Assets\Scripts\UI\Tooltips/) L8359
  ColorExtensions (Assets\Scripts\UI\Utilities/) L8590
  PrefabOrigin (Assets\Scripts\UI\Utilities/) L8601
  NightColorPostProcess (Assets\Scripts\Visual\Effects/) L8630
  RuntimeCircleDrawer (Assets\Scripts\Visual\Effects/) L8726
  WaterReflection (Assets\Scripts\Visual\Effects/) L8831
  WaterReflectionManager (Assets\Scripts\Visual\Effects/) L9229
  PlantGrowthModifierManager (Assets\Scripts\WorldInteraction\Placement/) L9265
  PlayerTileInteractor (Assets\Scripts\WorldInteraction\Placement/) L9431
  HarvestableTag (Assets\Scripts\WorldInteraction\Player/) L9557
  HarvestedItem (Assets\Scripts\WorldInteraction\Player/) L9565
  PlayerActionManager (Assets\Scripts\WorldInteraction\Player/) L9594
  PlayerHungerSystem (Assets\Scripts\WorldInteraction\Player/) L9761
  TileHoverColorManager (Assets\Scripts\WorldInteraction\Tiles/) L9823
  ToolRefillRule (Assets\Scripts\WorldInteraction\Tiles/) L9847
  TileInteractionRule (Assets\Scripts\WorldInteraction\Tiles/) L9867
  ToolDefinition (Assets\Scripts\WorldInteraction\Tools/) L9879
  ToolSwitcher (Assets\Scripts\WorldInteraction\Tools/) L9914
  ToolType (Assets\Scripts\WorldInteraction\Tools/) L10089

[WegoSystem]
  CameraController (Assets\Scripts\Core/) L10100
  CameraZoomController (Assets\Scripts\Core/) L10209
  InitializationManager (Assets\Scripts\Core/) L10258
  PixelGridSnapper (Assets\Scripts\Core/) L10306
  RunManager (Assets\Scripts\Core/) L10339
  SingletonMonoBehaviour (Assets\Scripts\Core/) L10475
  EnvironmentalStatusEffectSystem (Assets\Scripts\Ecosystem\Status Effects/) L10538
  MapConfiguration (Assets\Scripts\ProceduralGeneration/) L10674
  ResolutionManager (Assets\Scripts\ProceduralGeneration/) L10701
  SceneSetupManager (Assets\Scripts\ProceduralGeneration/) L10848
  GridEntity (Assets\Scripts\Ticks/) L10920
  GridPosition (Assets\Scripts\Ticks/) L11089
  GridPositionManager (Assets\Scripts\Ticks/) L11190
  GridRadiusUtility (Assets\Scripts\Ticks/) L11568
  TickConfiguration (Assets\Scripts\Ticks/) L11712
  ITickUpdateable (Assets\Scripts\Ticks/) L11795
  GardenerController (Assets\Scripts\WorldInteraction\Player/) L11947
  TileInteractionManager (Assets\Scripts\WorldInteraction\Tiles/) L12135

[WegoSystem.Editor]
  ResolutionManagerEditor (Assets\Scripts\ProceduralGeneration\Editor/) L12440

[WegoSystem.Editor']
  TileInteractionManagerEditor (Assets\Scripts\Editor/) L12472

[WegoSystem.EditorTools]
  MapBoundsVisualizer (Assets\Scripts\ProceduralGeneration/) L12513

[WegoSystem.ProceduralGeneration]
  BiomeLayer (Assets\Scripts\ProceduralGeneration/) L12569
  ProceduralMapGenerator (Assets\Scripts\ProceduralGeneration/) L12610
  SimplexNoise (Assets\Scripts\ProceduralGeneration/) L12728

[issue.]
  SceneSetupManagerEditor (Assets\Scripts\ProceduralGeneration\Editor/) L12880
  PlantPlacementManager (Assets\Scripts\WorldInteraction\Placement/) L12907
  HungerUI (Assets\Scripts\WorldInteraction\Player/) L13021
  TileDefinition (Assets\Scripts\WorldInteraction\Tiles/) L13069

[namespace]
  GeneEventBus (Assets\Scripts\Genes\Services/) L13110

[needs]
  ProceduralMapGeneratorEditor (Assets\Scripts\ProceduralGeneration\Editor/) L13162

================================================================================
SCRIPTS
================================================================================

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Components\TemporaryFruitSpawnMarker.cs

﻿using UnityEngine;

namespace Abracodabra.Genes {
pub cls TemporaryFruitSpawnMarker : MonoBehaviour {
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\GeneLibrary.cs

﻿using UnityEngine;
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Core;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Abracodabra.Genes {
pub cls GeneLibrary : ScriptableObject, IGeneLibrary {
pub stat GeneLibrary Instance { get; set; }

pub void SetActiveInstance() {
if (Instance != null && Instance != this) {
Debug.LogWarning("An existing GeneLibrary instance was already active. It is being overwritten.", this);
}
Instance = this;
Initialize();
}

pub List<PassiveGene> passiveGenes = new List<PassiveGene>();
pub List<ActiveGene> activeGenes = new List<ActiveGene>();
pub List<ModifierGene> modifierGenes = new List<ModifierGene>();
pub List<PayloadGene> payloadGenes = new List<PayloadGene>();

pub PlaceholderGene placeholderGene;

Dictionary<string, GeneBase> _guidLookup;
Dictionary<string, GeneBase> _nameLookup;

void Initialize() {
BuildLookupCaches();
}

void BuildLookupCaches() {
_guidLookup = new Dictionary<string, GeneBase>();
_nameLookup = new Dictionary<string, GeneBase>();

foreach (var gene in GetAllGenes()) {
if (gene == null) continue;

if (!string.IsNullOrEmpty(gene.GUID)) {
if (!_guidLookup.ContainsKey(gene.GUID)) {
_guidLookup[gene.GUID] = gene;
}
else {
Debug.LogWarning($"Gene Library: Duplicate GUID '{gene.GUID}' detected. The gene '{gene.name}' will be ignored by GUID lookup. The existing entry is '{_guidLookup[gene.GUID].name}'.", gene);
}
}

if (!string.IsNullOrEmpty(gene.geneName)) {
if (!_nameLookup.ContainsKey(gene.geneName)) {
_nameLookup[gene.geneName] = gene;
}
else {
Debug.LogWarning($"Gene Library: Duplicate gene name '{gene.geneName}' detected. The gene '{gene.name}' will be ignored by name lookup. The existing entry is '{_nameLookup[gene.geneName].name}'.", gene);
}
}
}
}

pub IEnumerable<GeneBase> GetAllGenes() {
foreach (var g in passiveGenes) if (g != null) yield ret g;
foreach (var g in activeGenes) if (g != null) yield ret g;
foreach (var g in modifierGenes) if (g != null) yield ret g;
foreach (var g in payloadGenes) if (g != null) yield ret g;
}

pub GeneBase GetGeneByGUID(string guid) {
if (string.IsNullOrEmpty(guid)) ret null;
if (_guidLookup == null) BuildLookupCaches();
ret _guidLookup.TryGetValue(guid, out var gene) ? gene : null;
}

pub GeneBase GetGeneByName(string name) {
if (string.IsNullOrEmpty(name)) ret null;
if (_nameLookup == null) BuildLookupCaches();
ret _nameLookup.TryGetValue(name, out var gene) ? gene : null;
}

pub GeneBase GetPlaceholderGene() {
if (placeholderGene == null) {
Debug.LogError("PlaceholderGene is not assigned in the GeneLibrary asset! The system may be unstable. Please assign it in the editor.", this);
placeholderGene = ScriptableObject.CreateInstance<PlaceholderGene>();
placeholderGene.name = "RUNTIME_PLACEHOLDER";
}
ret placeholderGene;
}

pub List<GeneBase> GetGenesOfCategory(GeneCategory category) {
switch (category) {
case GeneCategory.Passive: ret passiveGenes.Cast<GeneBase>().ToList();
case GeneCategory.Active: ret activeGenes.Cast<GeneBase>().ToList();
case GeneCategory.Modifier: ret modifierGenes.Cast<GeneBase>().ToList();
case GeneCategory.Payload: ret payloadGenes.Cast<GeneBase>().ToList();
default: ret new List<GeneBase>();
}
}

#if UNITY_EDITOR
void OnValidate() {
if (placeholderGene == null) {
string[] guids = AssetDatabase.FindAssets("t:PlaceholderGene");
if (guids.Length > 0) {
string path = AssetDatabase.GUIDToAssetPath(guids[0]);
placeholderGene = AssetDatabase.LoadAssetAtPath<PlaceholderGene>(path);
Debug.LogWarning("GeneLibrary's PlaceholderGene was unassigned. Auto-assigned from project assets.", this);
EditorUtility.SetDirty(this);
}
else {
Debug.LogError("Could not find a 'PlaceholderGene' asset in the project. Please create one.", this);
}
}
}

void AutoPopulate() {
passiveGenes.Clear();
activeGenes.Clear();
modifierGenes.Clear();
payloadGenes.Clear();

string[] guids = AssetDatabase.FindAssets("t:GeneBase");
foreach (string guid in guids) {
string path = AssetDatabase.GUIDToAssetPath(guid);
GeneBase gene = AssetDatabase.LoadAssetAtPath<GeneBase>(path);

if (gene is PlaceholderGene) continue;

if (gene is PassiveGene p)
passiveGenes.Add(p);
else if (gene is ActiveGene a)
activeGenes.Add(a);
else if (gene is ModifierGene m)
modifierGenes.Add(m);
else if (gene is PayloadGene pay)
payloadGenes.Add(pay);
}

passiveGenes = passiveGenes.OrderBy(g => g.name).ToList();
activeGenes = activeGenes.OrderBy(g => g.name).ToList();
modifierGenes = modifierGenes.OrderBy(g => g.name).ToList();
payloadGenes = payloadGenes.OrderBy(g => g.name).ToList();

EditorUtility.SetDirty(this);
Debug.Log($"Auto-populated library: {passiveGenes.Count} passive, {activeGenes.Count} active, {modifierGenes.Count} modifier, {payloadGenes.Count} payload genes.");
}
#endif
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\PlantSequenceExecutor.cs

﻿using UnityEngine;
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;

namespace Abracodabra.Genes {
pub cls PlantSequenceExecutor : MonoBehaviour {
pub PlantGrowth plantGrowth;
pub PlantGeneRuntimeState runtimeState;

IGeneEventBus eventBus;
IDeterministicRandom random;

void Awake() {
eventBus = GeneServices.Get<IGeneEventBus>();
random = GeneServices.Get<IDeterministicRandom>();

if (eventBus == null || random == null) {
Debug.LogError($"[{nameof(PlantSequenceExecutor)}] on {gameObject.name} could not retrieve required gene services! This indicates a critical initialization order problem. The component will be disabled.", this);
enabled = false;
}
}

void Start() {
if (plantGrowth == null) {
plantGrowth = GetComponent<PlantGrowth>();
}
}

pub void InitializeWithTemplate(SeedTemplate template) {
runtimeState = template.CreateRuntimeState();
}

pub void InitializeWithTemplate(PlantGeneRuntimeState state) {
this.runtimeState = state;
if (runtimeState == null || runtimeState.activeSequence == null || runtimeState.activeSequence.Count == 0) {
Debug.LogWarning($"Plant '{plantGrowth.name}' has no active gene sequence. Executor will remain idle.", this);
}
}

pub void OnTickUpdate(int currentTick) {
if (runtimeState == null || runtimeState.template == null || plantGrowth == null) {
return;
}

if (plantGrowth.CurrentState != PlantState.Mature) {
return;
}

var energySystem = plantGrowth.EnergySystem;
if (energySystem == null) {
return;
}

if (runtimeState.rechargeTicksRemaining > 0) {
runtimeState.rechargeTicksRemaining--;
return;
}

if (TryExecuteCurrentSlot()) {
runtimeState.currentPosition++;

if (runtimeState.currentPosition >= runtimeState.activeSequence.Count) {
OnSequenceComplete();
}
}
}

bool TryExecuteCurrentSlot() {
if (runtimeState.currentPosition >= runtimeState.activeSequence.Count) {
ret false;
}

var slot = runtimeState.activeSequence[runtimeState.currentPosition];

if (!slot.HasContent) {
ret true; // Skip empty slot, advance sequence
}

if (slot.delayTicksRemaining > 0) {
slot.delayTicksRemaining--;
ret false; // Still waiting, do not advance sequence
}

var activeGene = slot.activeInstance?.GetGene<ActiveGene>();
if (activeGene == null) {
Debug.LogError($"Active gene instance at sequence position {runtimeState.currentPosition} has a null or invalid gene reference! Skipping slot.", this);
ret true; // Skip invalid slot, advance sequence
}

float energyCost = slot.GetEnergyCost();
var energySystem = plantGrowth.EnergySystem;

if (!energySystem.HasEnergy(energyCost)) {
eventBus?.Publish(new GeneValidationFailedEvent {
GeneId = activeGene.GUID,
Reason = $"Insufficient energy. Has {energySystem.CurrentEnergy}, needs {energyCost}."
});
ret false; // Not enough energy, do not advance sequence
}

energySystem.SpendEnergy(energyCost);
slot.isExecuting = true;

var context = new ActiveGeneContext {
plant = plantGrowth,
activeInstance = slot.activeInstance,
modifiers = slot.modifierInstances,
payloads = slot.payloadInstances,
sequencePosition = runtimeState.currentPosition,
executor = this,
random = random
};

foreach (var modInstance in slot.modifierInstances) {
var modifierGene = modInstance?.GetGene<ModifierGene>();
if (modifierGene != null) {
modifierGene.PreExecution(context);
}
else {
Debug.LogWarning($"A modifier gene in the slot at position {runtimeState.currentPosition} is missing or invalid.", this);
}
}

if (activeGene.executionDelayTicks > 0) {
slot.delayTicksRemaining = activeGene.executionDelayTicks;
}
else {
PerformExecutionLogic(activeGene, context, slot);
}

ret true; // Execution successful, advance sequence
}

void PerformExecutionLogic(ActiveGene activeGene, ActiveGeneContext context, RuntimeSequenceSlot slot) {
activeGene.Execute(context);

foreach (var modInstance in slot.modifierInstances) {
var modifierGene = modInstance?.GetGene<ModifierGene>();
if (modifierGene != null) {
modifierGene.PostExecution(context);
}
}

eventBus?.Publish(new GeneExecutedEvent {
Gene = activeGene,
SequencePosition = context.sequencePosition,
Success = true,
EnergyCost = slot.GetEnergyCost()
});

StartCoroutine(ClearExecutionFlag(slot));
}

IEnumerator ClearExecutionFlag(RuntimeSequenceSlot slot) {
yield ret new WaitForSeconds(0.5f);
if(slot != null) {
slot.isExecuting = false;
}
}

void OnSequenceComplete() {
var energySystem = plantGrowth.EnergySystem;

eventBus?.Publish(new SequenceCompletedEvent {
TotalSlotsExecuted = runtimeState.activeSequence.Count,
TotalEnergyUsed = (energySystem != null) ? (energySystem.MaxEnergy - energySystem.CurrentEnergy) : 0f
});

runtimeState.currentPosition = 0;
runtimeState.rechargeTicksRemaining = runtimeState.template.baseRechargeTime;
}

}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantGrowth.cs

﻿using UnityEngine;
using WegoSystem;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Services;

namespace Abracodabra.Genes {
pub enum PlantState {
Initializing,
Growing,
Mature
}

pub cls PlantGrowth : MonoBehaviour, ITickUpdateable {
pub stat ro List<PlantGrowth> AllActivePlants = new List<PlantGrowth>();

pub SeedTemplate seedTemplate { get; set; }
pub PlantGeneRuntimeState geneRuntimeState { get; set; }
pub PlantSequenceExecutor sequenceExecutor { get; set; }

pub PlantCellManager CellManager { get; set; }
pub PlantGrowthLogic GrowthLogic { get; set; }
pub PlantEnergySystem EnergySystem { get; set; }
pub PlantVisualManager VisualManager { get; set; }

[SerializeField] pub float desiredPixelsPerCell = 1f;

pub float GetCellWorldSpacing() {
if (ResolutionManager.HasInstance && ResolutionManager.Instance.CurrentPPU > 0) {
ret desiredPixelsPerCell / ResolutionManager.Instance.CurrentPPU;
}
ret desiredPixelsPerCell / 16f;
}

pub float cellSpacingInPixels => desiredPixelsPerCell;
pub float cellSpacing => GetCellWorldSpacing();

[SerializeField] GameObject seedCellPrefab;
[SerializeField] GameObject stemCellPrefab;
[SerializeField] GameObject leafCellPrefab;
[SerializeField] GameObject berryCellPrefab;

[SerializeField] PlantShadowController shadowController;
[SerializeField] PlantOutlineController outlineController;
[SerializeField] GameObject outlinePartPrefab;
[SerializeField] bool enableOutline = true;
[SerializeField] FoodType leafFoodType;

[SerializeField] bool allowFruitsAroundLeaves = false;
[SerializeField] int fruitSearchRadius = 2;

[SerializeField] pub bool rechargeEnergyDuringGrowth = false;

pub float growthSpeedMultiplier = 1f;
pub float energyGenerationMultiplier = 1f;
pub float energyStorageMultiplier = 1f;
pub float fruitYieldMultiplier = 1f;

pub float baseGrowthChance;
pub int minHeight;
pub int maxHeight;
pub int leafDensity;
pub int leafGap;

pub PlantState CurrentState { get; set; } = PlantState.Initializing;

HashSet<Vector2Int> activeFruitPositions = new HashSet<Vector2Int>();
IDeterministicRandom _deterministicRandom;

void Awake() {
AllActivePlants.Add(this);

CellManager = new PlantCellManager(this, seedCellPrefab, stemCellPrefab, leafCellPrefab, berryCellPrefab, leafFoodType);
GrowthLogic = new PlantGrowthLogic(this);
EnergySystem = new PlantEnergySystem(this);
VisualManager = new PlantVisualManager(this, shadowController, null, outlineController, outlinePartPrefab, enableOutline);

_deterministicRandom = GeneServices.Get<IDeterministicRandom>();
if (_deterministicRandom == null) {
Debug.LogError($"[{nameof(PlantGrowth)}] could not retrieve IDeterministicRandom service! Growth will be non-deterministic.", this);
}
}

void OnDestroy() {
AllActivePlants.Remove(this);
var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}
}

pub void InitializeWithState(PlantGeneRuntimeState state) {
if (state == null || state.template == null) {
Debug.LogError($"Cannot initialize plant on '{gameObject.name}': Provided state or its template is null.", this);
Destroy(gameObject);
return;
}

this.seedTemplate = state.template;
this.geneRuntimeState = state;

this.baseGrowthChance = seedTemplate.baseGrowthChance;
this.minHeight = seedTemplate.minHeight;
this.maxHeight = seedTemplate.maxHeight;
this.leafDensity = seedTemplate.leafDensity;
this.leafGap = seedTemplate.leafGap;

sequenceExecutor = GetComponent<PlantSequenceExecutor>();
if (sequenceExecutor == null) {
sequenceExecutor = gameObject.AddComponent<PlantSequenceExecutor>();
}
sequenceExecutor.plantGrowth = this;

GrowthLogic.CalculateAndApplyPassiveStats();

EnergySystem.MaxEnergy = geneRuntimeState.template.maxEnergy * energyStorageMultiplier;
EnergySystem.CurrentEnergy = geneRuntimeState.template.startingEnergy;
EnergySystem.BaseEnergyPerLeaf = seedTemplate.energyRegenRate;

sequenceExecutor.InitializeWithTemplate(this.geneRuntimeState);

CellManager.SpawnCellVisual(PlantCellType.Seed, Vector2Int.zero);

CurrentState = PlantState.Initializing;

StartCoroutine(DelayedGrowthStart());

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}

Debug.Log($"Plant '{gameObject.name}' initialized from template '{seedTemplate.templateName}'. State: {CurrentState}");
}

IEnumerator DelayedGrowthStart() {
yield ret new WaitForSeconds(0.5f);
CurrentState = PlantState.Growing;
Debug.Log($"Plant '{gameObject.name}' transitioned to Growing state");
}

pub void OnTickUpdate(int currentTick) {
if (CurrentState == PlantState.Mature || rechargeEnergyDuringGrowth) {
EnergySystem.OnTickUpdate();
}

if (sequenceExecutor != null) {
sequenceExecutor.OnTickUpdate(currentTick);
}

if (VisualManager != null) {
VisualManager.UpdateUI();
}

if (CurrentState == PlantState.Growing) {
float randomValue = (_deterministicRandom != null) ?
_deterministicRandom.Range(0f, 1f) : Random.value;
if (randomValue < baseGrowthChance * growthSpeedMultiplier) {
GrowSomething();
}
}
}

void GrowSomething() {
int oldHeight = CellManager.cells.Count(c => c.Value == PlantCellType.Stem);

if (oldHeight < maxHeight) {
int newHeight = oldHeight + 1;
Vector2Int stemPos = new Vector2Int(0, newHeight);
CellManager.SpawnCellVisual(PlantCellType.Stem, stemPos);

if (newHeight > 0 && newHeight % leafGap == 0) {
int leafY = newHeight;

for (int i = 0; i < leafDensity; i++) {
int leafOffset = (i / 2) + 1;
int xOffset = (i % 2 == 0) ? -leafOffset : leafOffset;

var leafPos = new Vector2Int(xOffset, leafY);

if (!CellManager.HasCellAt(leafPos)) {
CellManager.SpawnCellVisual(PlantCellType.Leaf, leafPos);
}
}
}
}
else {
CurrentState = PlantState.Mature;
}
}

pub void HandleBeingEaten(AnimalController eater, PlantCell eatenCell) {
Debug.Log($"{eater.SpeciesName} ate cell at {eatenCell.GridCoord} on plant {name}");
CellManager?.ReportCellDestroyed(eatenCell.GridCoord);
}

pub void ReportCellDestroyed(Vector2Int coord) {
if (CellManager.cells.TryGetValue(coord, out var cellType) && cellType == PlantCellType.Fruit) {
activeFruitPositions.Remove(coord);
}
CellManager?.ReportCellDestroyed(coord);
}

pub GameObject GetCellGameObjectAt(Vector2Int coord) {
ret CellManager?.GetCellGameObjectAt(coord);
}

pub Transform[] GetFruitSpawnPoints() {
List<Transform> spawnPoints = new List<Transform>();
List<Vector2Int> sourcePositions = GetFruitSourcePositions();
HashSet<Vector2Int> emptyPositions = FindEmptyPositionsAround(sourcePositions);

var availablePositions = emptyPositions.Where(pos => !activeFruitPositions.Contains(pos)).ToList();

foreach (Vector2Int emptyPos in availablePositions) {
GameObject tempSpawnPoint = CreateTemporarySpawnPoint(emptyPos);
if (tempSpawnPoint != null) {
spawnPoints.Add(tempSpawnPoint.transform);
activeFruitPositions.Add(emptyPos);
}
}

if (spawnPoints.Count > 0) {
StartCoroutine(CleanupTemporarySpawnPoints(spawnPoints, 0.1f));
}

ret spawnPoints.ToArray();
}

List<Vector2Int> GetFruitSourcePositions() {
List<Vector2Int> sourcePositions = new List<Vector2Int>();

foreach (var kvp in CellManager.cells) {
if (kvp.Value == PlantCellType.Stem) {
sourcePositions.Add(kvp.Key);
}
}

if (allowFruitsAroundLeaves) {
foreach (var kvp in CellManager.cells) {
if (kvp.Value == PlantCellType.Leaf) {
sourcePositions.Add(kvp.Key);
}
}
}

ret sourcePositions;
}

HashSet<Vector2Int> FindEmptyPositionsAround(List<Vector2Int> sourcePositions) {
HashSet<Vector2Int> emptyPositions = new HashSet<Vector2Int>();

foreach (Vector2Int sourcePos in sourcePositions) {
for (int x = -fruitSearchRadius; x <= fruitSearchRadius; x++) {
for (int y = -fruitSearchRadius; y <= fruitSearchRadius; y++) {
if (x == 0 && y == 0) continue;

Vector2Int checkPos = sourcePos + new Vector2Int(x, y);

if (!CellManager.HasCellAt(checkPos)) {
float distance = Vector2Int.Distance(sourcePos, checkPos);
if (distance <= fruitSearchRadius) {
emptyPositions.Add(checkPos);
}
}
}
}
}

ret emptyPositions;
}

GameObject CreateTemporarySpawnPoint(Vector2Int gridPos) {
float spacing = GetCellWorldSpacing();
Vector3 worldPos = transform.position + new Vector3(gridPos.x * spacing, gridPos.y * spacing, 0);

GameObject spawnPoint = new GameObject($"TempFruitSpawnPoint_{gridPos.x}_{gridPos.y}");
spawnPoint.transform.position = worldPos;
spawnPoint.transform.SetParent(transform);

spawnPoint.AddComponent<TemporaryFruitSpawnMarker>();

ret spawnPoint;
}

IEnumerator CleanupTemporarySpawnPoints(List<Transform> spawnPoints, float delay) {
yield ret new WaitForSeconds(delay);

foreach (Transform spawnPoint in spawnPoints) {
if (spawnPoint != null && spawnPoint.GetComponent<TemporaryFruitSpawnMarker>() != null) {
Destroy(spawnPoint.gameObject);
}
}
}

#if UNITY_EDITOR
void OnDrawGizmos() {
if (!Application.isPlaying) return;
if (CellManager == null || CellManager.cells == null) return;

float spacing = GetCellWorldSpacing();

foreach (var cell in CellManager.cells) {
Vector2 cellWorldPos = (Vector2)transform.position + (Vector2)cell.Key * spacing;

switch (cell.Value) {
case PlantCellType.Stem: Gizmos.color = new Color(0, 1, 0, 0.5f); break;
case PlantCellType.Leaf: Gizmos.color = new Color(1, 1, 0, 0.5f); break;
case PlantCellType.Seed: Gizmos.color = new Color(1, 1, 1, 0.5f); break;
case PlantCellType.Fruit: Gizmos.color = new Color(1, 0, 0, 0.5f); break;
}

Gizmos.DrawCube(cellWorldPos, Vector3.one * spacing * 0.9f);
Gizmos.color = new Color(Gizmos.color.r, Gizmos.color.g, Gizmos.color.b, 1f);
Gizmos.DrawWireCube(cellWorldPos, Vector3.one * spacing);
}

Gizmos.color = new Color(0, 1, 1, 0.2f);
Vector3Int tilePos = GridPositionManager.Instance?.WorldToGrid(transform.position).ToVector3Int() ?? Vector3Int.zero;
Vector3 tileWorldPos = GridPositionManager.Instance?.GridToWorld(new GridPosition(tilePos)) ?? transform.position;
Gizmos.DrawWireCube(tileWorldPos, Vector3.one * 1f);

UnityEditor.Handles.Label(
transform.position + Vector3.up * (maxHeight + 1) * spacing,
$"Cell Spacing: {spacing:F4} wu\nPPU: {(ResolutionManager.HasInstance ? ResolutionManager.Instance.CurrentPPU.ToString() : "Unknown")}\nTile Aligned: {Mathf.Approximately(spacing, 1f)}"
);
}

void OnDrawGizmosSelected() {
if (!Application.isPlaying || CellManager == null) return;

List<Vector2Int> sourcePositions = GetFruitSourcePositions();
HashSet<Vector2Int> emptyPositions = FindEmptyPositionsAround(sourcePositions);

float spacing = GetCellWorldSpacing();

Gizmos.color = Color.green;
foreach (Vector2Int sourcePos in sourcePositions) {
Vector3 worldPos = transform.position + new Vector3(sourcePos.x * spacing, sourcePos.y * spacing, 0);
Gizmos.DrawWireSphere(worldPos, spacing * 0.2f);
}

Gizmos.color = Color.cyan;
foreach (Vector2Int emptyPos in emptyPositions) {
Vector3 worldPos = transform.position + new Vector3(emptyPos.x * spacing, emptyPos.y * spacing, 0);
Gizmos.DrawWireCube(worldPos, Vector3.one * spacing * 0.5f);
}
}
#endif
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Components\Creature.cs

﻿// File: Assets/Scripts/Genes/Components/Creature.cs

namespace Abracodabra.Genes.Components {
pub cls Creature : MonoBehaviour {
pub void Feed(float amount) {
Debug.Log($"{name} was fed for {amount} nutrition points.", this);
var animalNeeds = GetComponent<AnimalNeeds>();
if (animalNeeds != null) {
animalNeeds.ModifyHunger(-amount); // Negative amount to reduce hunger
}
}

pub void Heal(float amount) {
Debug.Log($"{name} was healed for {amount} HP.", this);
var animalNeeds = GetComponent<AnimalNeeds>();
if (animalNeeds != null) {
animalNeeds.Heal(amount);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Components\Fruit.cs

﻿// File: Assets/Scripts/Genes/Components/Fruit.cs
using Abracodabra.Genes.Core;

namespace Abracodabra.Genes.Components {
pub cls Fruit : MonoBehaviour {
pub PlantGrowth SourcePlant { get; set; }
pub float GrowthTime { get; set; }

pub void LaunchImmediate(Vector2 force) {
var rb = GetComponent<Rigidbody2D>() ?? gameObject.AddComponent<Rigidbody2D>();
rb.AddForce(force, ForceMode2D.Impulse);
}

pub void StartGrowing() {
Debug.Log($"Fruit '{gameObject.name}' has started growing for {GrowthTime}s.", this);
}

pub void AddVisualEffect(Color color) {
var renderer = GetComponent<SpriteRenderer>();
if (renderer != null) {
renderer.color = Color.Lerp(renderer.color, color, 0.5f);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Components\NutritionComponent.cs

﻿// File: Assets/Scripts/Genes/Components/NutritionComponent.cs

namespace Abracodabra.Genes.Components {
pub cls NutritionComponent : MonoBehaviour {
pub float nutritionValue;
pub float healAmount;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\ActiveGene.cs

﻿using UnityEngine;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
pub abs cls ActiveGene : GeneBase {
pub ovr GeneCategory Category => GeneCategory.Active;

pub float baseEnergyCost = 20f;
pub ActiveGeneSlotConfig slotConfig = new ActiveGeneSlotConfig();

pub bool canExecuteEmpty = false;

pub int executionDelayTicks = 0;

pub bool requiresTarget = false;

pub virt bool IsValidConfiguration(List<ModifierGene> modifiers, List<PayloadGene> payloads) {
if (!canExecuteEmpty && payloads.Count == 0)
ret false;

ret true;
}

pub virt bool CanExecuteNow(PlantGrowth plant, float availableEnergy) {
ret availableEnergy >= baseEnergyCost;
}

pub float GetFinalEnergyCost(List<RuntimeGeneInstance> modifiers) {
float cost = baseEnergyCost;
foreach (var modInstance in modifiers) {
if (modInstance == null) continue;

var modifier = modInstance.GetGene<ModifierGene>();
if (modifier != null)
cost = modifier.ModifyEnergyCost(cost, modInstance);
}
ret Mathf.Max(0, cost);
}

pub abs void Execute(ActiveGeneContext context);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\ActiveGeneContext.cs

﻿// File: Assets/Scripts/Genes/Core/ActiveGeneContext.cs
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Services;

namespace Abracodabra.Genes.Core {
pub cls ActiveGeneContext {
pub PlantGrowth plant;
pub RuntimeGeneInstance activeInstance;
pub List<RuntimeGeneInstance> modifiers;
pub List<RuntimeGeneInstance> payloads;
pub int sequencePosition;
pub PlantSequenceExecutor executor;
pub IDeterministicRandom random;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\ActiveGeneSlotConfig.cs

﻿// File: Assets/Scripts/Genes/Core/ActiveGeneSlotConfig.cs

namespace Abracodabra.Genes.Core {
pub cls ActiveGeneSlotConfig {
pub int modifierSlots = 1;
pub int payloadSlots = 1;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\ModifierGene.cs

﻿// File: Assets/Scripts/Genes/Core/ModifierGene.cs
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
pub abs cls ModifierGene : GeneBase {
pub ovr GeneCategory Category => GeneCategory.Modifier;

pub ModifierType modifierType;
pub float power = 1f;

pub virt float ModifyEnergyCost(float baseCost, RuntimeGeneInstance instance) => baseCost;
pub virt void PreExecution(ActiveGeneContext context) { }
pub virt void PostExecution(ActiveGeneContext context) { }
pub virt bool ModifyTriggerCondition(ActiveGene gene, PlantGrowth plant) => true;

pub ovr bool CanAttachTo(GeneBase other) {
ret other.Category == GeneCategory.Active;
}
}

pub enum ModifierType {
Cost,       // Affects energy consumption
Trigger,    // Changes when active executes
Behavior,   // Multi-cast, spread, etc.
Condition   // Adds requirements
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\PassiveGene.cs

﻿using UnityEngine;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
pub enum PassiveStatType {
GrowthSpeed,
EnergyGeneration,
EnergyStorage,
FruitYield,
}

pub abs cls PassiveGene : GeneBase {
pub ovr GeneCategory Category => GeneCategory.Passive;

pub PassiveStatType statToModify;
pub float baseValue = 1f;
pub bool stacksAdditively = true;
pub int maxStacks = -1; // -1 for unlimited

pub abs void ApplyToPlant(PlantGrowth plant, RuntimeGeneInstance instance);

pub abs string GetStatModificationText();

pub virt bool MeetsRequirements(PlantGrowth plant) => true;

pub virt bool IsCompatibleWith(PassiveGene other) => true;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\PayloadGene.cs

﻿// File: Assets/Scripts/Genes/Core/PayloadGene.cs
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Components; // FIX: Added using statement for Fruit

namespace Abracodabra.Genes.Core {
pub abs cls PayloadGene : GeneBase {
pub ovr GeneCategory Category => GeneCategory.Payload;

pub PayloadType payloadType;
pub float basePotency = 1f;

pub abs void ApplyPayload(PayloadContext context);

pub virt void ConfigureFruit(Fruit fruit, RuntimeGeneInstance instance) { }

pub virt void ApplyToTarget(GameObject target, RuntimeGeneInstance instance) { }

pub ovr bool CanAttachTo(GeneBase other) {
ret other.Category == GeneCategory.Active;
}

pub float GetFinalPotency(RuntimeGeneInstance instance) {
if (instance == null) ret basePotency;
ret basePotency * instance.GetValue("potency_multiplier", 1f);
}
}

pub enum PayloadType {
Substance,  // Damage/status effects
Nutrition,  // Healing/hunger
Special     // Unique effects
}

pub cls PayloadContext {
pub GameObject target;
pub PlantGrowth source;
pub ActiveGene parentGene;
pub RuntimeGeneInstance payloadInstance;
pub float effectMultiplier = 1f;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\PlaceholderGene.cs

﻿using UnityEngine;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
pub cls PlaceholderGene : PassiveGene {
pub ovr void ApplyToPlant(PlantGrowth plant, RuntimeGeneInstance instance) {
}

pub ovr string GetStatModificationText() {
ret "Missing Gene";
}

pub ovr string GetTooltip(GeneTooltipContext context) {
ret "This gene could not be loaded. It may have been deleted or renamed.";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\SafeGeneLoader.cs

﻿// File: Assets/Scripts/Genes/Core/SafeGeneLoader.cs
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
pub stat cls SafeGeneLoader {
pub stat GeneBase LoadGeneWithFallback(string guid, string fallbackName = null) {
var library = GeneServices.Get<IGeneLibrary>();
if (library == null) {
Debug.LogError("Gene Library service not available! Cannot load gene.");
ret null;
}

var gene = library.GetGeneByGUID(guid);
if (gene != null) ret gene;

if (!string.IsNullOrEmpty(fallbackName)) {
gene = library.GetGeneByName(fallbackName);
if (gene != null) {
Debug.LogWarning($"Gene with GUID '{guid}' not found, but a gene with the fallback name '{fallbackName}' was loaded instead. The original asset may have been deleted or its GUID changed.");
ret gene;
}
}

Debug.LogError($"Could not find gene with GUID '{guid}' or fallback name '{fallbackName}'. Returning placeholder.");
ret library.GetPlaceholderGene();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\GeneBase.cs

﻿using UnityEngine;
using Abracodabra.Genes.Runtime; // For RuntimeGeneInstance in context

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Abracodabra.Genes.Core {
pub abs cls GeneBase : ScriptableObject, ITooltipDataProvider {
pub string geneName;
pub string description;
pub Sprite icon;
pub int tier = 1;

pub Color geneColor = Color.white;
pub GameObject effectPrefab;

string _persistentGUID;
int _version = 1;

#if UNITY_EDITOR
void OnValidate() {
if (string.IsNullOrEmpty(_persistentGUID)) {
_persistentGUID = System.Guid.NewGuid().ToString();
EditorUtility.SetDirty(this);
}
}
#endif

pub string GUID {
get {
#if UNITY_EDITOR
if (string.IsNullOrEmpty(_persistentGUID)) {
_persistentGUID = System.Guid.NewGuid().ToString();
EditorUtility.SetDirty(this);
}
#endif
ret _persistentGUID;
}
}

pub int Version => _version;
pub abs GeneCategory Category { get; }

pub abs string GetTooltip(GeneTooltipContext context);
pub string GetTooltipTitle() => geneName;
pub string GetTooltipDescription() => $"Tier {tier} {Category} Gene";
pub string GetTooltipDetails(object source = null) {
if (source is GeneTooltipContext context) {
ret GetTooltip(context);
}
ret description;
}

pub virt bool CanAttachTo(GeneBase other) => false;
pub virt void MigrateFromVersion(int oldVersion, GeneInstanceData instanceData) { }
}

pub enum GeneCategory {
Passive,
Active,
Modifier,
Payload,
Seed // NEW: The dedicated category for the editor slot.
}

pub cls GeneTooltipContext {
pub PlantGrowth plant; // The plant the gene is on
pub bool showAdvanced; // Show detailed stats
pub RuntimeGeneInstance instance; // The specific instance with its current values
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Implementations\Active\BasicFruitGene.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Components;
using WegoSystem; // <-- ADDED this using statement for GridPosition and GridPositionManager

namespace Abracodabra.Genes.Implementations {
pub cls BasicFruitGene : ActiveGene {
pub GameObject fruitPrefab;
pub float growthTime = 2f;
pub int fruitCount = 1;
pub float launchForce = 5f;

pub ovr void Execute(ActiveGeneContext context) {
if (fruitPrefab == null) {
Debug.LogError($"BasicFruitGene '{geneName}' is missing its fruitPrefab!", this);
return;
}

Transform[] fruitPoints = context.plant.GetFruitSpawnPoints();

if (fruitPoints.Length == 0) {
Debug.LogWarning($"Plant '{context.plant.name}' has no empty spaces for fruit spawning.", context.plant);
return;
}

bool isInstant = false;
foreach (var modInstance in context.modifiers) {
if (modInstance.GetGene<ModifierGene>()?.modifierType == ModifierType.Trigger) {
isInstant = true;
break;
}
}

int count = Mathf.Min(fruitCount, fruitPoints.Length);
List<Transform> shuffledPoints = fruitPoints.OrderBy(x => Random.value).ToList();

for (int i = 0; i < count; i++) {
Vector3 spawnPosition = shuffledPoints[i].position;

GameObject fruitObj = Instantiate(fruitPrefab, spawnPosition, Quaternion.identity);

FoodItem foodItem = fruitObj.GetComponent<FoodItem>();
if (foodItem != null) {
GridPosition gridPos = GridPositionManager.Instance.WorldToGrid(spawnPosition);
foodItem.InitializeAsPlantPart(foodItem.foodType, gridPos);
}

Fruit fruit = fruitObj.GetComponent<Fruit>();
if (fruit != null) {
ConfigureFruit(fruit, context);

if (isInstant) {
float angle = context.random.Range(0f, 360f);
Vector2 direction = Quaternion.Euler(0, 0, angle) * Vector2.up;
fruit.LaunchImmediate(direction.normalized * launchForce);
}
else {
fruit.StartGrowing();
}
}
}
}

void ConfigureFruit(Fruit fruit, ActiveGeneContext context) {
fruit.SourcePlant = context.plant;
fruit.GrowthTime = growthTime;

foreach (var payloadInstance in context.payloads) {
payloadInstance.GetGene<PayloadGene>()?.ConfigureFruit(fruit, payloadInstance);
}
}

pub ovr bool IsValidConfiguration(List<ModifierGene> modifiers, List<PayloadGene> payloads) {
ret true;
}

pub ovr string GetTooltip(GeneTooltipContext context) {
ret $"{description}\n\n" +
$"Grows <b>{fruitCount}</b> fruit(s).\n" +
$"Growth Time: <b>{growthTime}s</b>\n" +
$"Energy Cost: <b>{baseEnergyCost} E</b>\n" +
$"Slots: <b>{slotConfig.modifierSlots}</b> Modifiers, <b>{slotConfig.payloadSlots}</b> Payloads";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Implementations\Modifier\CostReductionGene.cs

﻿// File: Assets/Scripts/Genes/Implementations/Modifier/CostReductionGene.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Implementations {
pub cls CostReductionGene : ModifierGene {
pub float costMultiplier = 0.75f; // i.e., 25% reduction

pub CostReductionGene() {
modifierType = ModifierType.Cost;
}

pub ovr float ModifyEnergyCost(float baseCost, RuntimeGeneInstance instance) {
float finalMultiplier = costMultiplier * instance.GetValue("efficiency", 1f);
ret baseCost * finalMultiplier;
}

pub ovr string GetTooltip(GeneTooltipContext context) {
float reduction = (1f - costMultiplier) * 100f;
ret $"{description}\n\n" +
$"Reduces the attached Active Gene's energy cost by <b>{reduction:F0}%</b>.";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Implementations\Passive\GrowthSpeedGene.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Implementations {
pub cls GrowthSpeedGene : PassiveGene {
pub GrowthSpeedGene() {
statToModify = PassiveStatType.GrowthSpeed;
baseValue = 1.5f; // This now represents a 50% increase
stacksAdditively = true;
}

pub ovr void ApplyToPlant(PlantGrowth plant, RuntimeGeneInstance instance) {
}

pub ovr string GetStatModificationText() {
float percentage = (baseValue - 1f) * 100f;
ret percentage >= 0
? $"+{percentage:F0}% Growth Speed"
: $"{percentage:F0}% Growth Speed";
}

pub ovr string GetTooltip(GeneTooltipContext context) {
float finalMultiplier = baseValue;
if (context.instance != null) {
finalMultiplier = baseValue * context.instance.GetValue("power_multiplier", 1f);
}
float finalPercentage = (finalMultiplier - 1f) * 100f;

string effectText = finalPercentage >= 0
? $"+{finalPercentage:F0}% Growth Speed"
: $"{finalPercentage:F0}% Growth Speed";

ret $"{description}\n\n" +
$"<b>Effect:</b> {effectText}\n" +
"Reduces the time required for the plant to reach maturity.";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Implementations\Payload\NutritiousPayload.cs

﻿// File: Assets/Scripts/Genes/Implementations/Payload/NutritiousPayload.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Components;

namespace Abracodabra.Genes.Implementations {
pub cls NutritiousPayload : PayloadGene {
pub float nutritionValue = 10f;
pub float healAmount = 5f;

pub NutritiousPayload() {
payloadType = PayloadType.Nutrition;
}

pub ovr void ApplyPayload(PayloadContext context) {
ApplyToTarget(context.target, context.payloadInstance);
}

pub ovr void ConfigureFruit(Fruit fruit, RuntimeGeneInstance instance) {
var nutrition = fruit.gameObject.GetComponent<NutritionComponent>() ?? fruit.gameObject.AddComponent<NutritionComponent>();
nutrition.nutritionValue = nutritionValue * GetFinalPotency(instance);
nutrition.healAmount = healAmount;

fruit.AddVisualEffect(geneColor);
}

pub ovr void ApplyToTarget(GameObject target, RuntimeGeneInstance instance) {
var creature = target.GetComponent<Creature>();
if (creature != null) {
float finalNutrition = nutritionValue * GetFinalPotency(instance);
creature.Feed(finalNutrition);
creature.Heal(healAmount);
}
}

pub ovr string GetTooltip(GeneTooltipContext context) {
float potency = 1f;
if (context.instance != null) {
potency = GetFinalPotency(context.instance);
}

ret $"{description}\n\n" +
$"Adds <b>{nutritionValue * potency:F0}</b> nutrition to the fruit.\n" +
$"Heals for <b>{healAmount:F0}</b> HP when consumed.";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Runtime\PlantGeneRuntimeState.cs

﻿using System;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Core;

namespace Abracodabra.Genes.Runtime {
pub cls PlantGeneRuntimeState {
pub SeedTemplate template;

pub List<RuntimeGeneInstance> passiveInstances = new List<RuntimeGeneInstance>();
pub List<RuntimeSequenceSlot> activeSequence = new List<RuntimeSequenceSlot>();

[NonSerialized] pub int currentPosition = 0;
[NonSerialized] pub int rechargeTicksRemaining = 0;
[NonSerialized] pub bool isExecuting = false;

pub void InitializeFromTemplate() {
if (template == null) return;

passiveInstances.Clear();
foreach (var entry in template.passiveGenes) {
if (entry.gene == null) continue;
var instance = new RuntimeGeneInstance(entry.gene);
instance.SetValue("power_multiplier", entry.powerMultiplier);
passiveInstances.Add(instance);
}

activeSequence.Clear();
foreach (var slotTemplate in template.activeSequence) {
var slot = new RuntimeSequenceSlot();
slot.InitializeFromTemplate(slotTemplate);
activeSequence.Add(slot);
}

}

pub void Reset() {
currentPosition = 0;
rechargeTicksRemaining = 0;
isExecuting = false;
}

pub float CalculateTotalEnergyCost() {
float total = 0;
foreach (var slot in activeSequence) {
if (slot.HasContent) {
total += slot.GetEnergyCost();
}
}
ret total;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Runtime\RuntimeGeneInstance.cs

﻿// File: Assets/Scripts/Genes/Runtime/RuntimeGeneInstance.cs
using Abracodabra.Genes.Core;

namespace Abracodabra.Genes.Runtime {
pub cls RuntimeGeneInstance : ISerializationCallbackReceiver {
[SerializeField] string geneGUID;
[SerializeField] string geneName; // Fallback for missing genes
[SerializeField] GeneInstanceData instanceData;

[NonSerialized] GeneBase cachedGene;

pub RuntimeGeneInstance(GeneBase sourceGene) {
if (sourceGene == null) {
Debug.LogError("Cannot create RuntimeGeneInstance from a null sourceGene!");
return;
}

geneGUID = sourceGene.GUID;
geneName = sourceGene.geneName;
instanceData = new GeneInstanceData();
cachedGene = sourceGene;
}

pub T GetGene<T>() where T : GeneBase {
if (cachedGene == null)
LoadGene();
ret cachedGene as T;
}

pub GeneBase GetGene() {
if (cachedGene == null)
LoadGene();
ret cachedGene;
}

void LoadGene() {
cachedGene = SafeGeneLoader.LoadGeneWithFallback(geneGUID, geneName);
if (cachedGene != null && instanceData != null) {
if (instanceData.version < cachedGene.Version) {
cachedGene.MigrateFromVersion(instanceData.version, instanceData);
instanceData.version = cachedGene.Version;
}
}
}

pub float GetValue(string key, float defaultValue = 0f) {
ret instanceData.GetValue(key, defaultValue);
}

pub void SetValue(string key, float value) {
instanceData.SetValue(key, value);
}

pub void ModifyValue(string key, float delta) {
instanceData.ModifyValue(key, delta);
}

pub void OnBeforeSerialize() {
if (cachedGene != null) {
geneGUID = cachedGene.GUID;
geneName = cachedGene.geneName;

if (instanceData != null && instanceData.version < cachedGene.Version) {
instanceData.version = cachedGene.Version;
}
}
}

pub void OnAfterDeserialize() {
cachedGene = null;
}
}

pub cls GeneInstanceData : ISerializationCallbackReceiver {
pub int version = 1;

[SerializeField] List<string> _keys = new List<string>();
[SerializeField] List<float> _values = new List<float>();

[NonSerialized] Dictionary<string, float> _runtimeValues = new Dictionary<string, float>();

pub int stackCount = 1;
pub float powerMultiplier = 1f;

pub float GetValue(string key, float defaultValue = 0f) {
ret _runtimeValues.TryGetValue(key, out float value) ? value : defaultValue;
}

pub void SetValue(string key, float value) {
_runtimeValues[key] = value;
}

pub void ModifyValue(string key, float delta) {
if (_runtimeValues.TryGetValue(key, out float currentValue)) {
_runtimeValues[key] = currentValue + delta;
}
else {
_runtimeValues[key] = delta;
}
}

pub void OnBeforeSerialize() {
_keys.Clear();
_values.Clear();

if (_runtimeValues == null) {
return;
}

foreach (var kvp in _runtimeValues) {
_keys.Add(kvp.Key);
_values.Add(kvp.Value);
}
}

pub void OnAfterDeserialize() {
_runtimeValues = new Dictionary<string, float>();

if (_keys != null && _values != null && _keys.Count == _values.Count) {
for (int i = 0; i < _keys.Count; i++) {
if (!string.IsNullOrEmpty(_keys[i]) && !_runtimeValues.ContainsKey(_keys[i])) {
_runtimeValues.Add(_keys[i], _values[i]);
}
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Runtime\RuntimeSequenceSlot.cs

﻿using System;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;

namespace Abracodabra.Genes.Runtime {
pub cls RuntimeSequenceSlot {
pub RuntimeGeneInstance activeInstance;
pub List<RuntimeGeneInstance> modifierInstances = new List<RuntimeGeneInstance>();
pub List<RuntimeGeneInstance> payloadInstances = new List<RuntimeGeneInstance>();

[NonSerialized] pub bool isHighlighted;
[NonSerialized] pub bool isExecuting;
[NonSerialized] pub int delayTicksRemaining = 0; // For tick-based delays

pub bool HasContent => activeInstance != null;

pub void InitializeFromTemplate(SequenceSlotTemplate template) {
if (template.activeGene != null)
activeInstance = new RuntimeGeneInstance(template.activeGene);

modifierInstances.Clear();
foreach (var modEntry in template.modifiers) {
if (modEntry?.gene == null) continue;
var instance = new RuntimeGeneInstance(modEntry.gene);
instance.SetValue("power_multiplier", modEntry.powerMultiplier);
modifierInstances.Add(instance);
}

payloadInstances.Clear();
foreach (var payloadEntry in template.payloads) {
if (payloadEntry?.gene == null) continue;
var instance = new RuntimeGeneInstance(payloadEntry.gene);
instance.SetValue("power_multiplier", payloadEntry.powerMultiplier);
payloadInstances.Add(instance);
}
}

pub float GetEnergyCost() {
var active = activeInstance?.GetGene<ActiveGene>();
if (active == null) ret 0;

ret active.GetFinalEnergyCost(modifierInstances);
}

pub void Clear() {
activeInstance = null;
modifierInstances.Clear();
payloadInstances.Clear();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Services\DeterministicRandom.cs

﻿// File: Assets/Scripts/Genes/Services/DeterministicRandom.cs

namespace Abracodabra.Genes.Services {
pub cls DeterministicRandom : IDeterministicRandom {
System.Random rng;
int currentSeed;

pub DeterministicRandom(int seed) {
SetSeed(seed);
}

pub void SetSeed(int seed) {
currentSeed = seed;
rng = new System.Random(seed);
}

pub float Range(float min, float max) {
ret (float)(rng.NextDouble() * (max - min) + min);
}

pub int Range(int min, int max) {
ret rng.Next(min, max);
}

pub void Reset() {
rng = new System.Random(currentSeed);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Services\GeneEffectPool.cs

﻿// File: Assets/Scripts/Genes/Services/GeneEffectPool.cs

namespace Abracodabra.Genes.Services {
pub cls GeneEffectPool : MonoBehaviour, IGeneEffectPool {
stat GeneEffectPool _instance;
pub stat GeneEffectPool Instance {
get {
if (_instance == null) {
var go = new GameObject("GeneEffectPool");
_instance = go.AddComponent<GeneEffectPool>();
DontDestroyOnLoad(go);
}
ret _instance;
}
}

Dictionary<GameObject, Queue<GameObject>> pools = new Dictionary<GameObject, Queue<GameObject>>();
Transform poolContainer;

void Awake() {
poolContainer = new GameObject("PooledEffects").transform;
poolContainer.SetParent(transform);
}

pub GameObject GetEffect(GameObject prefab, Vector3 position, Quaternion rotation) {
if (prefab == null) ret null;

if (!pools.ContainsKey(prefab))
pools[prefab] = new Queue<GameObject>();

GameObject effect;
if (pools[prefab].Count > 0) {
effect = pools[prefab].Dequeue();
effect.transform.SetPositionAndRotation(position, rotation);
effect.SetActive(true);
}
else {
effect = Instantiate(prefab, position, rotation);
var poolable = effect.AddComponent<PoolableEffect>();
poolable.sourcePrefab = prefab;
poolable.pool = this;
}

ret effect;
}

pub void ReturnEffect(GameObject effect, GameObject sourcePrefab) {
if (effect == null || sourcePrefab == null) return;

effect.SetActive(false);
effect.transform.SetParent(poolContainer);

if (!pools.ContainsKey(sourcePrefab))
pools[sourcePrefab] = new Queue<GameObject>();

pools[sourcePrefab].Enqueue(effect);
}

pub void PrewarmPool(GameObject prefab, int count) {
if (prefab == null || count <= 0) return;
var list = new List<GameObject>();
for (int i = 0; i < count; i++) {
var obj = GetEffect(prefab, Vector3.zero, Quaternion.identity);
list.Add(obj);
}

foreach (var obj in list) {
var poolable = obj.GetComponent<PoolableEffect>();
if (poolable != null)
ReturnEffect(obj, poolable.sourcePrefab);
}
}
}

pub cls PoolableEffect : MonoBehaviour {
pub GameObject sourcePrefab;
pub GeneEffectPool pool;
pub float lifetime = 2f;

void OnEnable() {
if (lifetime > 0)
Invoke(nameof(ReturnToPool), lifetime);
}

void OnDisable() {
CancelInvoke();
}

pub void ReturnToPool() {
if (pool != null && sourcePrefab != null)
pool.ReturnEffect(gameObject, sourcePrefab);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Services\GeneServices.cs

﻿using System;
using Abracodabra.Genes.Core;

namespace Abracodabra.Genes.Services {
pub stat cls GeneServices {
stat Dictionary<Type, object> services = new Dictionary<Type, object>();
stat bool isInitialized = false;

pub stat bool IsInitialized => isInitialized;

pub stat void Initialize() {
if (isInitialized) return;

Register<IGeneEventBus>(new GeneEventBus());
Register<IDeterministicRandom>(new DeterministicRandom(DateTime.Now.Millisecond));

isInitialized = true;
Debug.Log("Core Gene Services initialized (EventBus, Random).");
}

pub stat void Register<T>(T service) where T : class {
services[typeof(T)] = service;
}

pub stat T Get<T>() where T : class {
if (!isInitialized) {
Debug.LogWarning($"GeneServices accessed for type '{typeof(T).Name}' before explicit initialization. Auto-initializing now. Please check script execution order.");
Initialize(); // Auto-initialize if needed
}

if (typeof(T) == typeof(IGeneLibrary) && !services.ContainsKey(typeof(T))) {
Debug.LogWarning("IGeneLibrary service was requested before it was registered. Attempting to find and register it now.");
var library = GeneLibrary.Instance ?? Resources.FindObjectsOfTypeAll<GeneLibrary>().FirstOrDefault();
if (library != null) {
if (GeneLibrary.Instance == null) {
library.SetActiveInstance(); // Ensures the lookups are built
}
Register<IGeneLibrary>(library);
Debug.Log("Successfully found and registered IGeneLibrary service on-demand.");
}
else {
Debug.LogError("CRITICAL: Could not find any GeneLibrary asset to register as a fallback service!");
}
}

if (services.TryGetValue(typeof(T), out object service)) {
ret (T)service;
}

Debug.LogError($"Service {typeof(T).Name} not registered!");
ret null;
}

pub stat void Reset() {
services.Clear();
isInitialized = false;
}
}

pub ifc IGeneLibrary {
GeneBase GetGeneByGUID(string guid);
GeneBase GetGeneByName(string name);
GeneBase GetPlaceholderGene();
}

pub ifc IGeneEventBus {
void Subscribe<T>(Action<T> handler) where T : class;
void Unsubscribe<T>(Action<T> handler) where T : class;
void Publish<T>(T message) where T : class;
}

pub ifc IGeneEffectPool {
GameObject GetEffect(GameObject prefab, Vector3 position, Quaternion rotation);
void ReturnEffect(GameObject effect, GameObject sourcePrefab);
}

pub ifc IDeterministicRandom {
float Range(float min, float max);
int Range(int min, int max);
void SetSeed(int seed);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Templates\SeedTemplate.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Templates {
pub cls SeedTemplate : ScriptableObject {
pub string templateName;
pub string description;
pub Sprite icon;

[Range(1, 8)] pub int passiveSlotCount = 3;
[Range(1, 8)] pub int activeSequenceLength = 3;

pub List<GeneTemplateEntry> passiveGenes = new List<GeneTemplateEntry>();
pub List<SequenceSlotTemplate> activeSequence = new List<SequenceSlotTemplate>();

[Range(0f, 1f)] pub float baseGrowthChance = 0.1f;
pub int minHeight = 3;
pub int maxHeight = 5;
pub int leafDensity = 2;
pub int leafGap = 1;

pub int baseRechargeTime = 3;
pub float energyRegenRate = 10f;
pub float maxEnergy = 100f;
pub float startingEnergy = 0f; // <-- NEW FIELD

pub bool isUnlocked = true;
pub List<string> unlockRequirements = new List<string>();

pub bool IsValid() {
bool hasAtLeastOneActiveGene = false;
foreach (var slot in activeSequence) {
if (slot.activeGene == null) continue;
hasAtLeastOneActiveGene = true;
if (!slot.Validate()) ret false;
}
ret hasAtLeastOneActiveGene;
}

pub PlantGeneRuntimeState CreateRuntimeState() {
var state = new PlantGeneRuntimeState();
state.template = this;
state.InitializeFromTemplate();
ret state;
}

void OnValidate() {
while (passiveGenes.Count < passiveSlotCount) passiveGenes.Add(new GeneTemplateEntry());
while (passiveGenes.Count > passiveSlotCount) passiveGenes.RemoveAt(passiveGenes.Count - 1);

while (activeSequence.Count < activeSequenceLength) activeSequence.Add(new SequenceSlotTemplate());
while (activeSequence.Count > activeSequenceLength) activeSequence.RemoveAt(activeSequence.Count - 1);
}
}

pub cls GeneTemplateEntry {
pub GeneBase gene;
pub float powerMultiplier = 1f;
}

pub cls SequenceSlotTemplate {
pub ActiveGene activeGene;
pub List<GeneTemplateEntry> modifiers = new List<GeneTemplateEntry>();
pub List<GeneTemplateEntry> payloads = new List<GeneTemplateEntry>();

pub bool Validate() {
if (activeGene == null) ret true; // Empty slot is valid

if (modifiers.Count > activeGene.slotConfig.modifierSlots) ret false;
if (payloads.Count > activeGene.slotConfig.payloadSlots) ret false;

var modifierGenes = modifiers.Select(m => m.gene as ModifierGene).ToList();
var payloadGenes = payloads.Select(p => p.gene as PayloadGene).ToList();

ret activeGene.IsValidConfiguration(modifierGenes, payloadGenes);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\UI\GeneSequenceUI.cs

﻿using UnityEngine;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Core;
using Abracodabra.Genes;

namespace Abracodabra.UI.Genes {
pub cls GeneSequenceUI : MonoBehaviour {
pub Transform passiveGenesContainer;
pub Transform activeSequenceContainer;
[SerializeField] GeneSlotUI seedEditSlot;

pub GameObject sequenceRowPrefab;
pub GameObject passiveSlotPrefab;

pub TMPro.TextMeshProUGUI energyCostText;
pub TMPro.TextMeshProUGUI currentEnergyText;
pub TMPro.TextMeshProUGUI rechargeTimeText;
pub TMPro.TextMeshProUGUI validationMessage;
pub Slider rechargeProgress; // Restored this pub field

pub int maxPassiveSlots = 6;
pub int maxSequenceLength = 5;

PlantGeneRuntimeState runtimeState;
List<GeneSlotUI> passiveSlots = new List<GeneSlotUI>();
List<SequenceRowUI> sequenceRows = new List<SequenceRowUI>();
PlantSequenceExecutor executor;

void Start() {
ClearEditor();
}

pub void LoadSeedForEditing(InventoryBarItem seedItem) {
if (seedItem == null || seedItem.Type != InventoryBarItem.ItemType.Seed) {
ClearEditor();
return;
}

this.runtimeState = seedItem.SeedRuntimeState;
if (seedEditSlot != null) {
seedEditSlot.SetItem(seedItem);
}

GenerateSlotsFromState();
SetEditorLocked(false);
RefreshAllVisuals();
}

void ClearEditor() {
this.runtimeState = null;
if (seedEditSlot != null) {
seedEditSlot.ClearSlot();
}

foreach (var slot in passiveSlots) if(slot != null) Destroy(slot.gameObject);
foreach (var row in sequenceRows) if(row != null) Destroy(row.gameObject);
passiveSlots.Clear();
sequenceRows.Clear();

SetEditorLocked(true);
RefreshAllVisuals();
}

pub void CleanupOnPhaseEnd() {
if (seedEditSlot != null && seedEditSlot.CurrentItem != null) {
var itemToReturn = seedEditSlot.CurrentItem;
if (InventoryGridController.Instance != null) {
bool success = InventoryGridController.Instance.AddItemToInventory(itemToReturn);
if (!success) {
Debug.LogWarning($"Could not ret seed '{itemToReturn.GetDisplayName()}' to inventory on phase end, inventory may be full.");
}
}
}
ClearEditor();
}

void GenerateSlotsFromState() {
foreach (var slot in passiveSlots) if(slot != null) Destroy(slot.gameObject);
foreach (var row in sequenceRows) if(row != null) Destroy(row.gameObject);
passiveSlots.Clear();
sequenceRows.Clear();

if (runtimeState == null) return;

for (int i = 0; i < runtimeState.template.passiveSlotCount; i++) {
GameObject slotObj = Instantiate(passiveSlotPrefab, passiveGenesContainer);
slotObj.SetActive(true);
GeneSlotUI slot = slotObj.GetComponent<GeneSlotUI>();
slot.acceptedCategory = GeneCategory.Passive;
slot.slotIndex = i;
passiveSlots.Add(slot);
}

for (int i = 0; i < runtimeState.template.activeSequenceLength; i++) {
GameObject rowObj = Instantiate(sequenceRowPrefab, activeSequenceContainer);
rowObj.SetActive(true);
SequenceRowUI row = rowObj.GetComponent<SequenceRowUI>();
row.Initialize(i, this);
sequenceRows.Add(row);
}
}

void SetEditorLocked(bool isLocked) {
foreach (var slot in passiveSlots) slot.isLocked = isLocked;
foreach (var row in sequenceRows) {
if (row.activeSlot != null) row.activeSlot.isLocked = isLocked;
}
}

pub void UpdateDataForSlot(int slotIndex, GeneCategory slotCategory, InventoryBarItem newItem) {
if (runtimeState == null) return;
var newInstance = newItem?.GeneInstance;

if (slotCategory == GeneCategory.Passive) {
if (slotIndex < 0) return;
while (runtimeState.passiveInstances.Count <= slotIndex) runtimeState.passiveInstances.Add(null);
runtimeState.passiveInstances[slotIndex] = newInstance;
}
else {
if (slotIndex < 0 || slotIndex >= runtimeState.activeSequence.Count) return;
RuntimeSequenceSlot sequenceSlot = runtimeState.activeSequence[slotIndex];

switch (slotCategory) {
case GeneCategory.Active:
sequenceSlot.activeInstance = newInstance;
break;
case GeneCategory.Modifier:
if (sequenceSlot.modifierInstances.Count == 0) sequenceSlot.modifierInstances.Add(newInstance);
else sequenceSlot.modifierInstances[0] = newInstance;
break;
case GeneCategory.Payload:
if (sequenceSlot.payloadInstances.Count == 0) sequenceSlot.payloadInstances.Add(newInstance);
else sequenceSlot.payloadInstances[0] = newInstance;
break;
}
}
RefreshAllVisuals();
}

pub ActiveGene GetActiveGeneForRow(int rowIndex) {
if (runtimeState != null && rowIndex >= 0 && rowIndex < runtimeState.activeSequence.Count) {
ret runtimeState.activeSequence[rowIndex]?.activeInstance?.GetGene<ActiveGene>();
}
ret null;
}

void RefreshAllVisuals() {
if (runtimeState == null) {
UpdateDisplay();
return;
}

for (int i = 0; i < passiveSlots.Count; i++) {
if (i < runtimeState.passiveInstances.Count) {
var instance = runtimeState.passiveInstances[i];
passiveSlots[i].SetItem(instance != null && instance.GetGene() != null ? InventoryBarItem.FromGene(instance) : null);
}
else {
passiveSlots[i].ClearSlot();
}
}

for (int i = 0; i < sequenceRows.Count; i++) {
if (i < runtimeState.activeSequence.Count) {
sequenceRows[i].LoadSlot(runtimeState.activeSequence[i]);
}
else {
sequenceRows[i].ClearRow();
}
}
UpdateDisplay();
}

void UpdateDisplay() {
if (runtimeState == null) {
if (energyCostText != null) energyCostText.text = "Cost: --";
if (currentEnergyText != null) currentEnergyText.text = "Energy: --/--";
if (rechargeTimeText != null) rechargeTimeText.text = "Recharge: --";
if (validationMessage != null) {
validationMessage.gameObject.SetActive(true);
validationMessage.text = "Drop a seed into the slot above to begin editing.";
}
return;
}

float totalCost = runtimeState.CalculateTotalEnergyCost();
if (energyCostText != null) energyCostText.text = $"Cost: {totalCost:F0} E/cycle";
if (rechargeTimeText != null) rechargeTimeText.text = $"Recharge: {runtimeState.template.baseRechargeTime} ticks";
if (currentEnergyText != null) currentEnergyText.text = $"Energy: --/{runtimeState.template.maxEnergy:F0}";

bool isValid = ValidateConfiguration();
if (validationMessage != null) validationMessage.gameObject.SetActive(!isValid);
}

bool ValidateConfiguration() {
if (runtimeState == null) ret false;
bool hasActiveGene = false;
foreach (var slot in runtimeState.activeSequence) {
if (slot.HasContent) {
hasActiveGene = true;
break;
}
}
if (!hasActiveGene) {
if (validationMessage != null) validationMessage.text = "Sequence requires at least one Active Gene.";
ret false;
}
ret true;
}

pub void ConnectToExecutor(PlantSequenceExecutor exec) {
executor = exec;
}

void Update() {
if (executor != null && executor.plantGrowth != null && executor.plantGrowth.EnergySystem != null && runtimeState != null) {
var energySystem = executor.plantGrowth.EnergySystem;
if (rechargeProgress != null && runtimeState.template.baseRechargeTime > 0) {
float progress = 1f - (runtimeState.rechargeTicksRemaining / (float)runtimeState.template.baseRechargeTime);
rechargeProgress.value = progress;
}
if (currentEnergyText != null) {
currentEnergyText.text = $"Energy: {energySystem.CurrentEnergy:F0}/{energySystem.MaxEnergy:F0}";
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\UI\GeneSlotUI.cs

﻿using UnityEngine;
using UnityEngine.EventSystems;
using System.Reflection;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Runtime;
using Abracodabra.UI.Genes;
using Abracodabra.Genes.Templates;

namespace Abracodabra.UI.Genes {
pub cls GeneSlotUI : MonoBehaviour, IDropHandler, IPointerEnterHandler, IPointerExitHandler, IBeginDragHandler, IDragHandler, IEndDragHandler {
pub GeneCategory acceptedCategory;
pub int slotIndex;
pub bool isLocked = false;
pub bool isDraggable = true;

[SerializeField] Image slotBackground;
[SerializeField] GameObject emptyIndicator;
[SerializeField] GameObject lockedOverlay;
[SerializeField] GameObject executingEffect;
[SerializeField] ItemView itemView;

[SerializeField] Color normalColor = Color.white;
[SerializeField] Color highlightColor = Color.yellow;
[SerializeField] Color invalidColor = Color.red;
[SerializeField] Color executingColor = Color.cyan;

pub InventoryBarItem CurrentItem { get; set; }
GeneSequenceUI parentSequence;
IGeneEventBus eventBus;
GameObject draggedVisual;
Canvas canvas;
bool isPointerOver = false;

void Awake() {
parentSequence = GetComponentInParent<GeneSequenceUI>();
canvas = GetComponentInParent<Canvas>();
if (itemView == null) itemView = GetComponentInChildren<ItemView>(true);
if (itemView == null) Debug.LogError($"GeneSlotUI on {gameObject.name} is missing its ItemView child component.", this);
}

void Start() {
eventBus = GeneServices.Get<IGeneEventBus>();
UpdateVisuals();
}

void OnEnable() {
eventBus?.Subscribe<GeneExecutedEvent>(OnGeneExecuted);
}

void OnDisable() {
eventBus?.Unsubscribe<GeneExecutedEvent>(OnGeneExecuted);
}

pub void SetItem(InventoryBarItem item) {
CurrentItem = item;
UpdateVisuals();
}

pub void ClearSlot() {
SetItem(null);
}

void UpdateVisuals() {
if (itemView == null || slotBackground == null) return;
bool isEmpty = CurrentItem == null || !CurrentItem.IsValid();
if (emptyIndicator != null) emptyIndicator.SetActive(isEmpty);
itemView.gameObject.SetActive(!isEmpty);

if (!isEmpty) {
switch (CurrentItem.Type) {
case InventoryBarItem.ItemType.Gene:
itemView.InitializeAsGene(CurrentItem.GeneInstance);
slotBackground.color = CurrentItem.GeneInstance.GetGene().geneColor.WithAlpha(0.5f);
break;
case InventoryBarItem.ItemType.Seed:
itemView.InitializeAsSeed(CurrentItem.SeedTemplate);
if (InventoryColorManager.Instance != null)
slotBackground.color = InventoryColorManager.Instance.GetCellColorForItem(null, CurrentItem.SeedTemplate, null);
break;
case InventoryBarItem.ItemType.Tool:
itemView.InitializeAsTool(CurrentItem.ToolDefinition);
if (InventoryColorManager.Instance != null)
slotBackground.color = InventoryColorManager.Instance.GetCellColorForItem(null, null, CurrentItem.ToolDefinition);
break;
}
}
else {
slotBackground.color = normalColor;
}

if (lockedOverlay != null) lockedOverlay.SetActive(isLocked);
if (isPointerOver && !isLocked) {
slotBackground.color = highlightColor;
}
}

pub void OnDrop(PointerEventData eventData) {
if (isLocked) return;
GeneSlotUI sourceSlot = eventData.pointerDrag?.GetComponent<GeneSlotUI>();
if (sourceSlot == null || sourceSlot == this) return;

if (!IsValidDrop(sourceSlot, this)) {
ShowInvalidDropFeedback();
return;
}

var itemFromSource = sourceSlot.CurrentItem;
var itemFromDestination = this.CurrentItem;

UpdateSlotContents(sourceSlot, itemFromDestination);
UpdateSlotContents(this, itemFromSource);
}

bool IsItemValidForSlot(InventoryBarItem item, GeneSlotUI slot) {
if (item == null) ret true;

if (slot.acceptedCategory == GeneCategory.Seed) {
ret item.Type == InventoryBarItem.ItemType.Seed;
}

if (slot.parentSequence != null) {
if (item.Type != InventoryBarItem.ItemType.Gene) ret false;
var gene = item.GeneInstance.GetGene();
if (gene.Category != slot.acceptedCategory) ret false;

if (slot.acceptedCategory == GeneCategory.Modifier || slot.acceptedCategory == GeneCategory.Payload) {
var activeGene = slot.parentSequence.GetActiveGeneForRow(slot.slotIndex);
if (activeGene == null || !gene.CanAttachTo(activeGene)) ret false;
}
}
ret true;
}

bool IsValidDrop(GeneSlotUI source, GeneSlotUI destination) {
var sourceItem = source.CurrentItem;
var destinationItem = destination.CurrentItem;
ret IsItemValidForSlot(sourceItem, destination) && IsItemValidForSlot(destinationItem, source);
}

void UpdateSlotContents(GeneSlotUI slot, InventoryBarItem newItem) {
if (slot.acceptedCategory == GeneCategory.Seed && slot.parentSequence != null) {
slot.parentSequence.LoadSeedForEditing(newItem);
}
else if (slot.parentSequence != null) {
slot.parentSequence.UpdateDataForSlot(slot.slotIndex, slot.acceptedCategory, newItem);
}
else {
slot.SetItem(newItem);
}
}

pub void OnPointerEnter(PointerEventData eventData) {
isPointerOver = true;
UpdateVisuals();
}

pub void OnPointerExit(PointerEventData eventData) {
isPointerOver = false;
UpdateVisuals();
}

pub void OnBeginDrag(PointerEventData eventData) {
if (!isDraggable || CurrentItem == null || isLocked) { eventData.pointerDrag = null; return; }
CreateDragVisual();
}

pub void OnDrag(PointerEventData eventData) {
if (draggedVisual != null) draggedVisual.transform.position = eventData.position;
}

pub void OnEndDrag(PointerEventData eventData) {
if (draggedVisual != null) Destroy(draggedVisual);
}

void CreateDragVisual() {
if (canvas == null || CurrentItem == null) return;
draggedVisual = new GameObject("DragVisual");
draggedVisual.transform.SetParent(canvas.transform, false);
draggedVisual.transform.SetAsLastSibling();
var image = draggedVisual.AddComponent<Image>();
image.sprite = CurrentItem.GetIcon();
image.color = new Color(1, 1, 1, 0.7f);
image.raycastTarget = false;
var rect = draggedVisual.GetComponent<RectTransform>();
rect.sizeDelta = new Vector2(64, 64);
}

void ShowInvalidDropFeedback() {
StartCoroutine(FlashColor(invalidColor));
}

IEnumerator FlashColor(Color flashColor) {
if (slotBackground == null) yield break;
Color originalColor = slotBackground.color;
slotBackground.color = flashColor;
yield ret new WaitForSeconds(0.3f);
slotBackground.color = originalColor;
UpdateVisuals();
}

void OnGeneExecuted(GeneExecutedEvent evt) {
if (CurrentItem != null && CurrentItem.Type == InventoryBarItem.ItemType.Gene && CurrentItem.GeneInstance.GetGene()?.GUID == evt.Gene.GUID) {
ShowExecuting();
}
}

pub void ShowExecuting() {
if (executingEffect != null) executingEffect.SetActive(true);
if (slotBackground != null) slotBackground.color = executingColor;
Invoke(nameof(HideExecuting), 0.5f);
}

pub void HideExecuting() {
if (executingEffect != null) executingEffect.SetActive(false);
UpdateVisuals();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\UI\SequenceRowUI.cs

﻿// File: Assets/Scripts/UI/Genes/SequenceRowUI.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.UI.Genes {
pub cls SequenceRowUI : MonoBehaviour {
pub GeneSlotUI modifierSlot;
pub GeneSlotUI activeSlot;
pub GeneSlotUI payloadSlot;

int rowIndex;
GeneSequenceUI parentSequence;

pub void Initialize(int index, GeneSequenceUI parent) {
rowIndex = index;
parentSequence = parent;

if (modifierSlot != null) {
modifierSlot.acceptedCategory = GeneCategory.Modifier;
modifierSlot.slotIndex = index;
}
if (activeSlot != null) {
activeSlot.acceptedCategory = GeneCategory.Active;
activeSlot.slotIndex = index;
}
if (payloadSlot != null) {
payloadSlot.acceptedCategory = GeneCategory.Payload;
payloadSlot.slotIndex = index;
}
}

pub void LoadSlot(RuntimeSequenceSlot slotData) {
activeSlot?.SetItem(slotData.activeInstance != null ? InventoryBarItem.FromGene(slotData.activeInstance) : null);

var modInstance = slotData.modifierInstances.Count > 0 ? slotData.modifierInstances[0] : null;
modifierSlot?.SetItem(modInstance != null ? InventoryBarItem.FromGene(modInstance) : null);

var payloadInstance = slotData.payloadInstances.Count > 0 ? slotData.payloadInstances[0] : null;
payloadSlot?.SetItem(payloadInstance != null ? InventoryBarItem.FromGene(payloadInstance) : null);

UpdateAttachmentSlots(GetActiveGene());
}

pub void ClearRow() {
modifierSlot?.ClearSlot();
activeSlot?.ClearSlot();
payloadSlot?.ClearSlot();
UpdateAttachmentSlots(null);
}

pub ActiveGene GetActiveGene() {
ret activeSlot?.CurrentItem?.GeneInstance?.GetGene<ActiveGene>();
}

pub void UpdateAttachmentSlots(ActiveGene activeGene) {
bool hasActive = activeGene != null;
if (modifierSlot != null) {
modifierSlot.isLocked = !hasActive;
modifierSlot.gameObject.SetActive(hasActive && activeGene.slotConfig.modifierSlots > 0);
}
if (payloadSlot != null) {
payloadSlot.isLocked = !hasActive;
payloadSlot.gameObject.SetActive(hasActive && activeGene.slotConfig.payloadSlots > 0);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryBarController.cs

﻿using UnityEngine;
using Abracodabra.UI.Genes;

namespace Abracodabra.UI.Genes {
pub cls InventoryBarController : MonoBehaviour {
pub stat InventoryBarController Instance { get; set; }

[SerializeField] int barSlotCount = 8;
[SerializeField] GameObject inventorySlotPrefab;

[SerializeField] InventoryGridController inventoryGridController;
[SerializeField] Transform cellContainer;
[SerializeField] GameObject selectionHighlight;

List<GeneSlotUI> barSlots = new List<GeneSlotUI>();
int selectedSlot = 0;
Coroutine updateHighlightCoroutine;
RectTransform cellContainerRect; // Store a reference to the RectTransform

pub InventoryBarItem SelectedItem { get; set; }
pub event System.Action<InventoryBarItem> OnSelectionChanged;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
selectedSlot = 0;
}

void Start() {
if (inventoryGridController == null) Debug.LogError($"[{nameof(InventoryBarController)}] InventoryGridController not assigned!", this);
if (inventorySlotPrefab == null) Debug.LogError($"[{nameof(InventoryBarController)}] Inventory Slot Prefab not assigned!", this);
if (cellContainer == null) Debug.LogError($"[{nameof(InventoryBarController)}] Cell Container not assigned!", this);
else cellContainerRect = cellContainer.GetComponent<RectTransform>();

inventoryGridController.OnInventoryChanged += HandleInventoryChanged;

CreateBarSlots();

if (selectionHighlight != null) {
selectionHighlight.SetActive(false);
}

gameObject.SetActive(false);
}

void OnDestroy() {
if (inventoryGridController != null) {
inventoryGridController.OnInventoryChanged -= HandleInventoryChanged;
}
}

void CreateBarSlots() {
foreach (Transform child in cellContainer) {
Destroy(child.gameObject);
}
barSlots.Clear();

for (int i = 0; i < barSlotCount; i++) {
GameObject slotGO = Instantiate(inventorySlotPrefab, cellContainer);
GeneSlotUI slotUI = slotGO.GetComponent<GeneSlotUI>();
if (slotUI != null) {
slotUI.isDraggable = false;
barSlots.Add(slotUI);
}
}

if (cellContainerRect != null) {
LayoutRebuilder.ForceRebuildLayoutImmediate(cellContainerRect);
}
}

void UpdateBarDisplay() {
if (inventoryGridController == null) return;

List<InventoryBarItem> items = inventoryGridController.GetFirstNItems(barSlotCount);

for (int i = 0; i < barSlotCount; i++) {
if (i < barSlots.Count && i < items.Count) {
barSlots[i].SetItem(items[i]);
}
}
}

void HandleInventoryChanged() {
if (gameObject.activeInHierarchy) {
RefreshBar();
}
}

void Update() {
if (!gameObject.activeInHierarchy) return;
HandleNumberKeyInput();
}

pub void ShowBar() {
gameObject.SetActive(true);
RefreshBar();
SelectSlotByIndex(0);
}

pub void HideBar() {
gameObject.SetActive(false);
if (selectionHighlight != null) {
selectionHighlight.SetActive(false);
}
}

void RefreshBar() {
UpdateBarDisplay();
SelectSlot(selectedSlot);
}

void HandleNumberKeyInput() {
for (int i = 1; i <= 9; i++) {
if (i <= barSlotCount && Input.GetKeyDown(KeyCode.Alpha0 + i)) { SelectSlot(i - 1); return; }
}
if (barSlotCount >= 10 && Input.GetKeyDown(KeyCode.Alpha0)) { SelectSlot(9); }
}

pub void SelectSlot(int slotIndex) {
if (slotIndex < 0 || slotIndex >= barSlots.Count) {
return;
}

selectedSlot = slotIndex;
SelectedItem = barSlots[slotIndex].CurrentItem;

UpdateSelection();
}

void UpdateSelection() {
if (updateHighlightCoroutine != null) {
StopCoroutine(updateHighlightCoroutine);
}
updateHighlightCoroutine = StartCoroutine(UpdateSelectionVisualsAfterFrame());

OnSelectionChanged?.Invoke(SelectedItem);
}

IEnumerator UpdateSelectionVisualsAfterFrame() {
yield ret null;

if (selectionHighlight != null) {
if (selectedSlot < 0 || selectedSlot >= barSlots.Count) {
selectionHighlight.SetActive(false);
yield break;
}

bool itemIsValid = SelectedItem != null && SelectedItem.IsValid();
selectionHighlight.SetActive(itemIsValid);

if (itemIsValid) {
selectionHighlight.transform.position = barSlots[selectedSlot].transform.position;
}
}
updateHighlightCoroutine = null;
}

pub void SelectSlotByIndex(int slotIndex) {
int targetSlot = Mathf.Clamp(slotIndex, 0, barSlotCount - 1);
SelectSlot(targetSlot);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\ItemView.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/UI/ItemView.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.UI.Genes {
pub cls ItemView : MonoBehaviour {
[SerializeField] Image thumbnailImage;
[SerializeField] Image backgroundImage;
[SerializeField] Sprite fallbackThumbnail;

GeneBase _gene;
RuntimeGeneInstance _runtimeInstance;
ToolDefinition _toolDefinition;
SeedTemplate _seedTemplate;

Color _originalBackgroundColor;

pub void InitializeAsGene(RuntimeGeneInstance instance) {
_runtimeInstance = instance;
_gene = instance.GetGene();
_toolDefinition = null;
_seedTemplate = null;
SetupVisuals();
gameObject.SetActive(true);
}

pub void InitializeAsTool(ToolDefinition toolDef) {
_runtimeInstance = null;
_gene = null;
_toolDefinition = toolDef;
_seedTemplate = null;
SetupVisuals();
gameObject.SetActive(true);
}

pub void InitializeAsSeed(SeedTemplate seed) {
_runtimeInstance = null;
_gene = null;
_toolDefinition = null;
_seedTemplate = seed;
SetupVisuals();
gameObject.SetActive(true);
}

void SetupVisuals() {
Sprite spriteToShow = fallbackThumbnail;
Color tintColor = Color.white;
_originalBackgroundColor = Color.gray;

if (_gene != null) {
spriteToShow = _gene.icon ?? fallbackThumbnail;
tintColor = _gene.geneColor;
_originalBackgroundColor = _gene.geneColor.WithAlpha(0.5f);
}
else if (_toolDefinition != null) {
spriteToShow = _toolDefinition.icon ?? fallbackThumbnail;
tintColor = _toolDefinition.iconTint;
_originalBackgroundColor = InventoryColorManager.Instance.GetCellColorForItem(null, null, _toolDefinition);
}
else if (_seedTemplate != null) {
spriteToShow = _seedTemplate.icon ?? fallbackThumbnail;
tintColor = Color.white;
_originalBackgroundColor = InventoryColorManager.Instance.GetCellColorForItem(null, _seedTemplate, null);
}

if (thumbnailImage != null) {
thumbnailImage.sprite = spriteToShow;
thumbnailImage.color = tintColor;
thumbnailImage.enabled = (thumbnailImage.sprite != null);
}

if (backgroundImage != null) {
backgroundImage.color = _originalBackgroundColor;
}
}

pub void Clear() {
_gene = null;
_runtimeInstance = null;
_toolDefinition = null;
_seedTemplate = null;
gameObject.SetActive(false);
}

pub GeneBase GetGene() => _gene;
pub RuntimeGeneInstance GetRuntimeInstance() => _runtimeInstance;
pub ToolDefinition GetToolDefinition() => _toolDefinition;
pub SeedTemplate GetSeedTemplate() => _seedTemplate;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\Events\GameEvent.cs

﻿// Assets/Scripts/Core/Events/GameEvent.cs

pub cls GameEvent : ScriptableObject {
ro List<IGameEventListener> _listeners = new List<IGameEventListener>();

pub void Raise() {
for (int i = _listeners.Count - 1; i >= 0; i--) {
_listeners[i].OnEventRaised();
}
}

pub void RegisterListener(IGameEventListener listener) {
if (!_listeners.Contains(listener)) {
_listeners.Add(listener);
}
}

pub void UnregisterListener(IGameEventListener listener) {
if (_listeners.Contains(listener)) {
_listeners.Remove(listener);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\Events\GameEventListener.cs

﻿// Assets/Scripts/Core/Events/GameEventListener.cs

pub cls GameEventListener : MonoBehaviour, IGameEventListener {
[SerializeField] GameEvent gameEvent;

[SerializeField] UnityEvent response;

void OnEnable() {
if (gameEvent != null) {
gameEvent.RegisterListener(this);
}
}

void OnDisable() {
if (gameEvent != null) {
gameEvent.UnregisterListener(this);
}
}

pub void OnEventRaised() {
response.Invoke();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\Events\IGameEventListener.cs

﻿// Assets/Scripts/Core/Events/IGameEventListener.cs
pub ifc IGameEventListener {
void OnEventRaised();
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\GameInitializer.cs

﻿using UnityEngine;
using Abracodabra.Genes.Services;
using WegoSystem;

pub cls GameInitializer : MonoBehaviour {
void Awake() {
InitializeServices();

if (GeneEffectPool.Instance != null) {
GeneServices.Register<IGeneEffectPool>(GeneEffectPool.Instance);
}
else {
Debug.LogError("[GameInitializer] GeneEffectPool instance could not be created or found.");
}
}

stat void InitializeServices() {
GeneServices.Initialize();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\GeneSystemInitializer.cs

﻿using UnityEngine;
using Abracodabra.Genes.Services;

pub cls GeneSystemInitializer : MonoBehaviour {
void Awake() {
if (!GeneServices.IsInitialized) {
GeneServices.Initialize();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\SortableEntity.cs

﻿using UnityEngine;

pub cls SortableEntity : MonoBehaviour {
[SerializeField] float sortingLayerYOffset = 0f;

[SerializeField] bool useParentYCoordinate = false;

pub bool debugSorting = false;

SpriteRenderer spriteRenderer;

void Awake() {
spriteRenderer = GetComponent<SpriteRenderer>();

if (spriteRenderer == null)
spriteRenderer = GetComponentInChildren<SpriteRenderer>();

if (spriteRenderer == null) {
Debug.LogWarning($"[SortableEntity] No SpriteRenderer found on {gameObject.name}");
}
}

void Start() {
UpdateSortingOrder();
}

void LateUpdate() {
UpdateSortingOrder();
}

pub void UpdateSortingOrder() {
if (spriteRenderer == null) return;

float yPositionForSorting = useParentYCoordinate && transform.parent != null
? transform.parent.position.y
: transform.position.y;

int sortOrder = CalculateSortOrder(yPositionForSorting);
spriteRenderer.sortingOrder = sortOrder;

if (debugSorting) {
Debug.Log($"[SortableEntity] {gameObject.name} - Y: {yPositionForSorting}, Offset: {sortingLayerYOffset}, Sort Order: {sortOrder}");
}
}

int CalculateSortOrder(float yPosition) {
ret Mathf.RoundToInt(-(yPosition + sortingLayerYOffset) * 1000f);
}

pub int GetCurrentSortOrder() {
if (spriteRenderer == null) ret 0;
ret spriteRenderer.sortingOrder;
}

pub void SetSortingOrder(int order) {
if (spriteRenderer != null)
spriteRenderer.sortingOrder = order;
}

pub void SetUseParentYCoordinate(bool value) {
useParentYCoordinate = value;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\UIManager.cs

﻿using UnityEngine;
using UnityEngine.UI; // For Button
using TMPro;
using WegoSystem;
using Abracodabra.UI.Genes;

pub cls UIManager : MonoBehaviour {
pub stat UIManager Instance { get; set; }

[SerializeField] GameObject uiCanvasRoot;
[SerializeField] GameObject planningPanel;
[SerializeField] GameObject growthAndThreatPanel;
[SerializeField] GameObject geneSequenceUIPanel;

[SerializeField] Button startGrowthPhaseButton;
[SerializeField] Button startNewPlanningPhaseButton;
[SerializeField] Button endPlanningPhaseButton;
[SerializeField] Button advanceTickButton;

[SerializeField] TextMeshProUGUI tickCounterText;

RunManager runManager;
TickManager tickManager;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

if (uiCanvasRoot != null) {
uiCanvasRoot.SetActive(true);
Debug.Log($"[UIManager] Activated main UI canvas '{uiCanvasRoot.name}'.");
}
else {
Debug.LogWarning("[UIManager] UI Canvas Root is not assigned. UI may not appear.", this);
}
}

void OnDestroy() {
if (runManager != null) {
runManager.OnRunStateChanged -= HandleRunStateChanged;
runManager.OnPhaseChanged -= HandlePhaseChanged;
runManager.OnRoundChanged -= HandleRoundChanged;
}

if (tickManager != null) {
tickManager.OnTickAdvanced -= HandleTickAdvanced;
}
}

void Update() {
if (Input.GetKeyDown(KeyCode.Space)) {
if (runManager?.CurrentPhase == GamePhase.Planning) {
OnEndPlanningPhaseClicked();
}
}
if (Input.GetKeyDown(KeyCode.R) && (Application.isEditor || Debug.isDebugBuild)) {
runManager?.ForcePhase(GamePhase.Planning);
}
}

pub void Initialize() {
runManager = RunManager.Instance;
tickManager = TickManager.Instance;

if (runManager == null) {
Debug.LogError("[UIManager] RunManager.Instance not found! UI will not fn correctly.");
return;
}

runManager.OnRunStateChanged += HandleRunStateChanged;
runManager.OnPhaseChanged += HandlePhaseChanged;
runManager.OnRoundChanged += HandleRoundChanged;

if (tickManager != null) {
tickManager.OnTickAdvanced += HandleTickAdvanced;
}

SetupButtons();

HandleRunStateChanged(runManager.CurrentState);
UpdateTickDisplay();
}

void SetupButtons() {
startGrowthPhaseButton?.onClick.AddListener(OnStartGrowthPhaseClicked);
startNewPlanningPhaseButton?.onClick.AddListener(OnStartNewPlanningPhaseClicked);
endPlanningPhaseButton?.onClick.AddListener(OnEndPlanningPhaseClicked);
advanceTickButton?.onClick.AddListener(OnAdvanceTickClicked);
}

void HandleRunStateChanged(RunState newState) {
if (planningPanel != null) planningPanel.SetActive(newState == RunState.Planning);
if (growthAndThreatPanel != null) growthAndThreatPanel.SetActive(newState == RunState.GrowthAndThreat);

if (newState == RunState.GrowthAndThreat && geneSequenceUIPanel != null) {
var geneSequenceUI = geneSequenceUIPanel.GetComponent<GeneSequenceUI>();
if (geneSequenceUI != null) {
geneSequenceUI.CleanupOnPhaseEnd();
}
}

if (geneSequenceUIPanel != null) geneSequenceUIPanel.SetActive(newState == RunState.Planning);

if (InventoryGridController.Instance != null) {
InventoryGridController.Instance.gameObject.SetActive(newState == RunState.Planning);
}

if (newState == RunState.GrowthAndThreat) {
if (InventoryBarController.Instance != null) {
StartCoroutine(ShowInventoryBarDelayed());
}
}
else {
InventoryBarController.Instance?.HideBar();
}
UpdateButtonStates(newState);
}

void HandlePhaseChanged(GamePhase oldPhase, GamePhase newPhase) {
UpdateButtonStates(runManager.CurrentState);
}

void HandleRoundChanged(int newRound) {
}

void HandleTickAdvanced(int currentTick) {
UpdateTickDisplay();
}

void UpdateTickDisplay() {
if (tickCounterText != null && tickManager != null) {
tickCounterText.text = $"Tick: {tickManager.CurrentTick}";
}
}

void UpdateButtonStates(RunState state) {
bool isPlanning = (state == RunState.Planning);
bool isPlanningPhase = (runManager?.CurrentPhase == GamePhase.Planning);

if (startGrowthPhaseButton != null) startGrowthPhaseButton.interactable = isPlanning && isPlanningPhase;
if (startNewPlanningPhaseButton != null) startNewPlanningPhaseButton.interactable = !isPlanning;
if (endPlanningPhaseButton != null) endPlanningPhaseButton.interactable = isPlanning && isPlanningPhase;
if (advanceTickButton != null) advanceTickButton.interactable = !isPlanningPhase;
}

void OnStartGrowthPhaseClicked() { runManager?.StartGrowthAndThreatPhase(); }
void OnStartNewPlanningPhaseClicked() { runManager?.StartNewPlanningPhase(); }
void OnEndPlanningPhaseClicked() { runManager?.EndPlanningPhase(); }
void OnAdvanceTickClicked() { tickManager?.DebugAdvanceTick(); }

IEnumerator ShowInventoryBarDelayed() {
yield ret null;
InventoryBarController.Instance?.ShowBar();
}

pub void ShowNotification(string message, float duration = 3f) {
StartCoroutine(ShowNotificationCoroutine(message, duration));
}

IEnumerator ShowNotificationCoroutine(string message, float duration) {
GameObject notification = new GameObject("Notification");
notification.transform.SetParent(transform, false);

var canvasGroup = notification.AddComponent<CanvasGroup>();
var rectTransform = notification.AddComponent<RectTransform>();
var image = notification.AddComponent<Image>();
var text = new GameObject("Text").AddComponent<TextMeshProUGUI>();
text.transform.SetParent(notification.transform, false);

rectTransform.anchorMin = new Vector2(0.5f, 0.8f);
rectTransform.anchorMax = new Vector2(0.5f, 0.8f);
rectTransform.sizeDelta = new Vector2(300, 60);

image.color = new Color(0, 0, 0, 0.8f);
text.text = message;
text.color = Color.white;
text.alignment = TextAlignmentOptions.Center;
text.fontSize = 16;
text.rectTransform.sizeDelta = rectTransform.sizeDelta;

float elapsedTime = 0f;
while (elapsedTime < 0.5f) {
canvasGroup.alpha = elapsedTime / 0.5f;
elapsedTime += Time.deltaTime;
yield ret null;
}
canvasGroup.alpha = 1f;

yield ret new WaitForSeconds(duration - 1f);

elapsedTime = 0f;
while (elapsedTime < 0.5f) {
canvasGroup.alpha = 1f - (elapsedTime / 0.5f);
elapsedTime += Time.deltaTime;
yield ret null;
}

Destroy(notification);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\WeatherManager.cs

﻿// Assets/Scripts/Core/WeatherManager.cs
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using WegoSystem;

pub cls WeatherManager : MonoBehaviour, ITickUpdateable {
pub stat WeatherManager Instance { get; set; }

pub enum CyclePhase { Day, TransitionToNight, Night, TransitionToDay }

pub bool dayNightCycleEnabled = true;
pub AnimationCurve transitionCurve = AnimationCurve.Linear(0, 0, 1, 1);
pub float sunIntensity = 1f;

pub float fixedSunIntensity = 1f;
pub SpriteRenderer fadeSprite;
pub float minAlpha = 0f;
pub float maxAlpha = 1f;

pub bool IsPaused { get; set; } = false;

int currentPhaseTicks = 0;
int totalPhaseTicksTarget = 0;

pub CyclePhase CurrentPhase => currentPhase;
pub event Action<CyclePhase> OnPhaseChanged;

CyclePhase currentPhase = CyclePhase.Day;

pub float CurrentTotalPhaseTime => totalPhaseTicksTarget * (TickManager.Instance?.Config?.GetRealSecondsPerTick() ?? 0.5f);
pub float CurrentPhaseTimer => (totalPhaseTicksTarget - currentPhaseTicks) * (TickManager.Instance?.Config?.GetRealSecondsPerTick() ?? 0.5f);

pub float GetPhaseProgress() {
if (totalPhaseTicksTarget <= 0) ret 0f;
ret (float)currentPhaseTicks / totalPhaseTicksTarget;
}

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

pub void Initialize() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}

EnterPhase(CyclePhase.Day, true);
}

void OnDestroy() {
var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}
}

pub void OnTickUpdate(int currentTick) {
if (!dayNightCycleEnabled || IsPaused) return;

currentPhaseTicks++;

if (currentPhaseTicks >= totalPhaseTicksTarget) {
AdvanceToNextPhase();
}

UpdateSunIntensity();
}

void Update() {
UpdateFadeSprite();
}

void UpdateSunIntensity() {
if (TickManager.Instance?.Config != null) {
float dayProgress = TickManager.Instance.Config.GetDayProgressNormalized(TickManager.Instance.CurrentTick);

CyclePhase newPhase = currentPhase;

if (dayProgress < 0.4f) {
newPhase = CyclePhase.Day;
sunIntensity = 1f;
}
else if (dayProgress < 0.5f) {
newPhase = CyclePhase.TransitionToNight;
float transitionProgress = (dayProgress - 0.4f) / 0.1f;
sunIntensity = Mathf.Lerp(1f, 0f, transitionCurve.Evaluate(transitionProgress));
}
else if (dayProgress < 0.9f) {
newPhase = CyclePhase.Night;
sunIntensity = 0f;
}
else {
newPhase = CyclePhase.TransitionToDay;
float transitionProgress = (dayProgress - 0.9f) / 0.1f;
sunIntensity = Mathf.Lerp(0f, 1f, transitionCurve.Evaluate(transitionProgress));
}

if (newPhase != currentPhase) {
EnterPhase(newPhase, true);
}
}
}

void AdvanceToNextPhase() {
CyclePhase nextPhase = currentPhase;
switch (currentPhase) {
case CyclePhase.Day: nextPhase = CyclePhase.TransitionToNight; break;
case CyclePhase.TransitionToNight: nextPhase = CyclePhase.Night; break;
case CyclePhase.Night: nextPhase = CyclePhase.TransitionToDay; break;
case CyclePhase.TransitionToDay: nextPhase = CyclePhase.Day; break;
}
EnterPhase(nextPhase);
}

void EnterPhase(CyclePhase nextPhase, bool forceEvent = false) {
CyclePhase previousPhase = currentPhase;
currentPhase = nextPhase;

if (TickManager.Instance?.Config != null) {
var config = TickManager.Instance.Config;
switch (nextPhase) {
case CyclePhase.Day:
totalPhaseTicksTarget = config.dayPhaseTicks;
break;
case CyclePhase.Night:
totalPhaseTicksTarget = config.nightPhaseTicks;
break;
case CyclePhase.TransitionToNight:
case CyclePhase.TransitionToDay:
totalPhaseTicksTarget = config.transitionTicks;
break;
}
currentPhaseTicks = 0;
}

if (previousPhase != currentPhase || forceEvent) {
if (Debug.isDebugBuild) Debug.Log($"[WeatherManager] Phase Changed To: {currentPhase}");
OnPhaseChanged?.Invoke(currentPhase);
}
}

void UpdateFadeSprite() {
if (fadeSprite != null) {
float alpha = Mathf.Lerp(maxAlpha, minAlpha, sunIntensity);
Color c = fadeSprite.color;
c.a = alpha;
fadeSprite.color = c;
}
}

pub void PauseCycleAtDay() {
Debug.Log("[WeatherManager] PauseCycleAtDay called.");
IsPaused = true;
currentPhase = CyclePhase.Day;
currentPhaseTicks = 0;
totalPhaseTicksTarget = TickManager.Instance?.Config?.dayPhaseTicks ?? 60;
sunIntensity = 1.0f;
UpdateFadeSprite();
OnPhaseChanged?.Invoke(CyclePhase.Day);
}

pub void ResumeCycle() {
Debug.Log("[WeatherManager] ResumeCycle called.");
IsPaused = false;

currentPhaseTicks = 0;
EnterPhase(CyclePhase.Day, true);
}

pub void PauseCycle() {
Debug.Log("[WeatherManager] PauseCycle called.");
IsPaused = true;
}

pub int GetCurrentPhaseTicks() {
ret currentPhaseTicks;
}

pub int GetTotalPhaseTicksTarget() {
ret totalPhaseTicksTarget;
}

pub void ForcePhase(CyclePhase phase) {
if (Application.isEditor || Debug.isDebugBuild) {
EnterPhase(phase, true);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalBehavior.cs

﻿// REWORKED FILE: Assets/Scripts/Ecosystem/Animals/AnimalBehavior.cs
using WegoSystem;

pub cls AnimalBehavior : MonoBehaviour {
[SerializeField] Transform poopSpawnPoint;
[SerializeField] List<GameObject> poopPrefabs;
AnimalController controller;
AnimalDefinition definition;
bool isEating = false;
bool isPooping = false;
bool hasPooped = true;
GameObject currentEatingTarget = null;
int eatRemainingTicks = 0;
int poopDelayTick = 0;
int currentPoopCooldownTick = 0;
pub bool IsEating => isEating;
pub bool IsPooping => isPooping;
pub bool CanAct => !isEating && !isPooping && !controller.IsDying;

pub void Initialize(AnimalController controller, AnimalDefinition definition) { this.controller = controller; this.definition = definition; hasPooped = true; }
pub void OnTickUpdate(int currentTick) { if (isEating) { eatRemainingTicks--; if (eatRemainingTicks <= 0) { FinishEating(); } } if (poopDelayTick > 0) { poopDelayTick--; } if (currentPoopCooldownTick > 0) { currentPoopCooldownTick--; } if (!hasPooped && poopDelayTick <= 0 && currentPoopCooldownTick <= 0 && CanAct) { TryPoop(); } }
pub void StartEating(GameObject food) { if (food == null || !CanAct) return; FoodItem foodItem = food.GetComponent<FoodItem>(); if (foodItem == null || foodItem.foodType == null || !definition.diet.CanEat(foodItem.foodType)) { return; } controller.Movement.ClearMovementPlan(); isEating = true; currentEatingTarget = food; eatRemainingTicks = definition.eatDurationTicks; if (controller.CanShowThought()) { controller.ShowThought(ThoughtTrigger.Eating); } }

void FinishEating() {
isEating = false;

if (currentEatingTarget == null) {
return;
}

if (!currentEatingTarget.activeInHierarchy) {
currentEatingTarget = null;
return;
}

FoodItem foodItem = currentEatingTarget.GetComponent<FoodItem>();
if (foodItem != null) {
controller.Needs.Eat(foodItem);

var plantCell = currentEatingTarget.GetComponent<PlantCell>();
if (plantCell != null && plantCell.ParentPlantGrowth != null) {
plantCell.ParentPlantGrowth.HandleBeingEaten(this.controller, plantCell);
}

Destroy(currentEatingTarget);

hasPooped = false;
poopDelayTick = Random.Range(definition.minPoopDelayTicks, definition.maxPoopDelayTicks);
}

currentEatingTarget = null;
}

void TryPoop() { if (!CanAct) return; isPooping = true; currentPoopCooldownTick = definition.poopCooldownTicks; SpawnPoop(); hasPooped = true; isPooping = false; if (controller.CanShowThought()) { controller.ShowThought(ThoughtTrigger.Pooping); } }
void SpawnPoop() { if (poopPrefabs == null || poopPrefabs.Count == 0) return; int index = Random.Range(0, poopPrefabs.Count); GameObject prefab = poopPrefabs[index]; if (prefab == null) return; Transform spawnTransform = poopSpawnPoint != null ? poopSpawnPoint : transform; GameObject poopObj = Instantiate(prefab, spawnTransform.position, Quaternion.identity); if (GridPositionManager.Instance != null) { GridPositionManager.Instance.SnapEntityToGrid(poopObj); } }
pub void CancelCurrentAction() { isEating = false; eatRemainingTicks = 0; currentEatingTarget = null; isPooping = false; }
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalController.cs

﻿// Assets/Scripts/Ecosystem/Animals/AnimalController.cs
using TMPro;
using WegoSystem;

pub cls AnimalController : MonoBehaviour, ITickUpdateable, IStatusEffectable, ITriggerTarget {
[SerializeField] pub AnimalDefinition definition;

[SerializeField] GameObject thoughtBubblePrefab;
[SerializeField] Transform bubbleSpawnTransform;
[SerializeField] Animator animator;

[SerializeField] TextMeshProUGUI hpText;
[SerializeField] TextMeshProUGUI hungerText;
[SerializeField] KeyCode showStatsKey = KeyCode.LeftAlt;

AnimalMovement movement;
AnimalNeeds needs;
AnimalBehavior behavior;
GridEntity gridEntity;
SpriteRenderer spriteRenderer;
StatusEffectManager statusManager;
StatusEffectUIManager statusEffectUI;

bool isDying = false;
float deathFadeTimer = 0f;
float deathFadeDuration = 1f;
int thoughtCooldownTick = 0;

pub GridEntity GridEntity => gridEntity;
pub StatusEffectManager StatusManager => statusManager;
pub AnimalDefinition Definition => definition;
pub AnimalMovement Movement => movement;
pub AnimalNeeds Needs => needs;
pub AnimalBehavior Behavior => behavior;
pub bool IsDying => isDying;
pub string SpeciesName => definition != null ? definition.animalName : "Uninitialized";

void Awake() {
CacheComponents();
ValidateComponents();
}

void Start() {
InitializeAnimal();

if (TickManager.Instance == null) {
Debug.LogError($"[{GetType().Name}] TickManager not found! Disabling component.", this);
enabled = false;
return;
}

TickManager.Instance.RegisterTickUpdateable(this);

if (gridEntity != null) {
gridEntity.OnPositionChanged += OnGridPositionChanged;
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
if (gridEntity != null) {
gridEntity.OnPositionChanged -= OnGridPositionChanged;
}
}

void Update() {
if (!enabled) return;
if (isDying && deathFadeTimer > 0) {
deathFadeTimer -= Time.deltaTime;
UpdateDeathFade();
if (deathFadeTimer <= 0) Destroy(gameObject);
return;
}
bool showStats = Input.GetKey(showStatsKey);
SetStatsTextVisibility(showStats);
UpdateSpriteFlipping();
movement.UpdateVisuals();
}

void LateUpdate() {
transform.position = PixelGridSnapper.SnapToGrid(transform.position);
}

pub void OnTickUpdate(int currentTick) {
if (!enabled || definition == null) return;
if (!isDying && needs != null && needs.CurrentHealth <= 0) {
StartDying();
return;
}
if (isDying) return;

needs.OnTickUpdate(currentTick);
behavior.OnTickUpdate(currentTick);
movement.OnTickUpdate(currentTick);
statusManager.OnTickUpdate(currentTick);

if (gridEntity != null && statusManager != null) {
gridEntity.SetSpeedMultiplier(statusManager.VisualInterpolationSpeedMultiplier);
}

if (thoughtCooldownTick > 0) thoughtCooldownTick--;
UpdateAnimations();
}

void OnGridPositionChanged(GridPosition oldPos, GridPosition newPos) {
}

pub string GetDisplayName() { ret SpeciesName; }
pub void Heal(float amount) { if (needs != null) needs.Heal(amount); }
pub void ModifyHunger(float amount) { if (needs != null) needs.ModifyHunger(amount); }

pub void TakeDamage(float amount) {
if (isDying) return;
float finalDamage = amount;
if (statusManager != null) {
finalDamage *= statusManager.DamageResistanceMultiplier;
}
needs.TakeDamage(finalDamage);
}

void CacheComponents() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) gridEntity = gameObject.AddComponent<GridEntity>();
movement = GetComponent<AnimalMovement>();
if (movement == null) movement = gameObject.AddComponent<AnimalMovement>();
needs = GetComponent<AnimalNeeds>();
if (needs == null) needs = gameObject.AddComponent<AnimalNeeds>();
behavior = GetComponent<AnimalBehavior>();
if (behavior == null) behavior = gameObject.AddComponent<AnimalBehavior>();
spriteRenderer = GetComponentInChildren<SpriteRenderer>();
statusManager = GetComponent<StatusEffectManager>();
if (statusManager == null) statusManager = gameObject.AddComponent<StatusEffectManager>();
statusEffectUI = GetComponentInChildren<StatusEffectUIManager>(true);
if (statusEffectUI == null) Debug.LogWarning($"StatusEffectUIManager not found on a child of {gameObject.name}. Icons will not display.", this);
}

void ValidateComponents() {
if (definition == null) { Debug.LogError($"[{gameObject.name}] Missing AnimalDefinition!", this); enabled = false; return; }
if (definition.diet == null) { Debug.LogError($"[{gameObject.name}] AnimalDefinition missing diet!", this); enabled = false; return; }
}

void InitializeAnimal() {
movement.Initialize(this, definition);
needs.Initialize(this, definition);
behavior.Initialize(this, definition);
statusManager.Initialize(this);

if (statusEffectUI != null) {
statusEffectUI.Initialize(statusManager);
}

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
Debug.Log($"[AnimalController] {gameObject.name} snapped to grid position {gridEntity.Position}");
}
}

void StartDying() {
if (isDying) return;
isDying = true;

if (TickManager.Instance?.Config != null) {
deathFadeDuration = definition.deathFadeTicks / TickManager.Instance.Config.ticksPerRealSecond;
}
else {
deathFadeDuration = definition.deathFadeTicks * 0.5f;
}
deathFadeTimer = deathFadeDuration;

Debug.Log($"[AnimalController] {SpeciesName} is dying! Duration: {deathFadeDuration}s");

if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
movement.StopAllMovement();
behavior.CancelCurrentAction();

if (movement != null) movement.enabled = false;
if (behavior != null) behavior.enabled = false;
if (needs != null) needs.enabled = false;
}

void UpdateDeathFade() {
if (spriteRenderer == null) return;

float fadeProgress = 1f - (deathFadeTimer / deathFadeDuration);
Color color = spriteRenderer.color;
color.a = Mathf.Lerp(1f, 0f, fadeProgress);
spriteRenderer.color = color;
}

pub void ShowThought(ThoughtTrigger trigger) {
if (!CanShowThought()) return;

thoughtCooldownTick = definition.thoughtCooldownTicks;
if (definition.thoughtLibrary == null || thoughtBubblePrefab == null) return;

string message = "";
switch (trigger) {
case ThoughtTrigger.Hungry:
message = definition.thoughtLibrary?.hungryThoughts?.Length > 0 ? definition.thoughtLibrary.hungryThoughts[Random.Range(0, definition.thoughtLibrary.hungryThoughts.Length)] : "";
break;
case ThoughtTrigger.Eating:
message = definition.thoughtLibrary?.eatingThoughts?.Length > 0 ? definition.thoughtLibrary.eatingThoughts[Random.Range(0, definition.thoughtLibrary.eatingThoughts.Length)] : "";
break;
case ThoughtTrigger.HealthLow:
message = definition.thoughtLibrary?.healthLowThoughts?.Length > 0 ? definition.thoughtLibrary.healthLowThoughts[Random.Range(0, definition.thoughtLibrary.healthLowThoughts.Length)] : "";
break;
case ThoughtTrigger.Fleeing:
message = definition.thoughtLibrary?.fleeingThoughts?.Length > 0 ? definition.thoughtLibrary.fleeingThoughts[Random.Range(0, definition.thoughtLibrary.fleeingThoughts.Length)] : "";
break;
case ThoughtTrigger.Pooping:
message = definition.thoughtLibrary?.poopingThoughts?.Length > 0 ? definition.thoughtLibrary.poopingThoughts[Random.Range(0, definition.thoughtLibrary.poopingThoughts.Length)] : "";
break;
}

if (!string.IsNullOrEmpty(message)) {
Transform spawnT = bubbleSpawnTransform != null ? bubbleSpawnTransform : transform;
GameObject bubble = Instantiate(thoughtBubblePrefab, spawnT.position, Quaternion.identity);
ThoughtBubbleController controller = bubble.GetComponent<ThoughtBubbleController>();
if (controller != null) {
controller.Initialize(message, spawnT, 3f);
}
}
}

pub bool CanShowThought() {
ret thoughtCooldownTick <= 0 && !isDying;
}

void UpdateAnimations() {
if (animator == null) return;

bool isMoving = gridEntity != null && gridEntity.IsMoving;
bool isEating = behavior != null && behavior.IsEating;

animator.SetBool("isMoving", isMoving);
animator.SetBool("isEating", isEating);
animator.SetBool("isDying", isDying);
}

void UpdateSpriteFlipping() {
if (spriteRenderer == null || movement == null) return;

Vector2 moveDirection = movement.GetLastMoveDirection();
if (Mathf.Abs(moveDirection.x) > 0.01f) {
spriteRenderer.flipX = moveDirection.x < 0;
}
}

void SetStatsTextVisibility(bool visible) {
if (hpText != null) hpText.gameObject.SetActive(visible);
if (hungerText != null) hungerText.gameObject.SetActive(visible);

if (visible) {
UpdateUI();
}
}

pub void UpdateUI() {
if (needs == null) return;

if (hpText != null) {
hpText.text = $"{Mathf.CeilToInt(needs.CurrentHealth)}/{Mathf.CeilToInt(definition.maxHealth)}";
}
if (hungerText != null) {
hungerText.text = $"{Mathf.CeilToInt(needs.CurrentHunger)}/{Mathf.CeilToInt(definition.diet.maxHunger)}";
}
}

pub void SetSeekingScreenCenter(Vector2 target, Vector2 minBounds, Vector2 maxBounds) {
movement.SetSeekingScreenCenter(target, minBounds, maxBounds);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalDefinition.cs

﻿using UnityEngine;

pub cls AnimalDefinition : ScriptableObject {
pub string animalName = "DefaultAnimal";
pub GameObject prefab;

pub float maxHealth = 10f;

pub float movementSpeed = 2f;
pub int searchRadiusTiles = 5;
pub int eatDistanceTiles = 1;

pub AnimalDiet diet;
pub int thinkingTickInterval = 3;
pub int eatDurationTicks = 3;

pub int wanderPauseTickChance = 30;
pub int minWanderPauseTicks = 1;
pub int maxWanderPauseTicks = 4;

pub int starvationDamageTickInterval = 4;
pub float damagePerStarvationTick = 2f;
pub Color damageFlashColor = Color.red;
pub int damageFlashTicks = 1;
pub int deathFadeTicks = 3;

pub int minPoopDelayTicks = 10;
pub int maxPoopDelayTicks = 20;
pub int poopCooldownTicks = 2;
pub float poopColorVariation = 0.1f;

pub AnimalThoughtLibrary thoughtLibrary;
pub int thoughtCooldownTicks = 10;
pub List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();
pub List<ScentDefinition> repellentScentDefinitions = new List<ScentDefinition>();

void OnValidate() {
maxHealth = Mathf.Max(1f, maxHealth);
movementSpeed = Mathf.Max(0.1f, movementSpeed);

thinkingTickInterval = Mathf.Max(1, thinkingTickInterval);
searchRadiusTiles = Mathf.Max(1, searchRadiusTiles);
eatDistanceTiles = Mathf.Max(1, eatDistanceTiles);
eatDurationTicks = Mathf.Max(1, eatDurationTicks);

minWanderPauseTicks = Mathf.Max(1, minWanderPauseTicks);
maxWanderPauseTicks = Mathf.Max(minWanderPauseTicks, maxWanderPauseTicks);

starvationDamageTickInterval = Mathf.Max(1, starvationDamageTickInterval);
damagePerStarvationTick = Mathf.Max(0.1f, damagePerStarvationTick);
deathFadeTicks = Mathf.Max(1, deathFadeTicks);
damageFlashTicks = Mathf.Max(1, damageFlashTicks);

minPoopDelayTicks = Mathf.Max(1, minPoopDelayTicks);
maxPoopDelayTicks = Mathf.Max(minPoopDelayTicks, maxPoopDelayTicks);
poopCooldownTicks = Mathf.Max(1, poopCooldownTicks);

thoughtCooldownTicks = Mathf.Max(1, thoughtCooldownTicks);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalLibrary.cs

﻿using UnityEngine;

pub cls AnimalLibrary : ScriptableObject {
pub List<AnimalDefinition> animals;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalMovement.cs

﻿using UnityEngine;
using WegoSystem;
using Abracodabra.Genes; // Required for PlantCell

pub cls AnimalMovement : MonoBehaviour {
[SerializeField] bool showPathfindingDebugLine = false;

AnimalController controller;
AnimalDefinition definition;
GridEntity gridEntity;
LineRenderer pathDebugLine;

List<GridPosition> currentPath = new List<GridPosition>();
int currentPathIndex = 0;
GameObject currentTargetFood = null;
bool hasPlannedAction = false;
int wanderPauseTicks = 0;
int lastThinkTick = 0;

bool isSeekingScreenCenter = false;
Vector2 screenCenterTarget;
Vector2 minBounds;
Vector2 maxBounds;

Vector2 lastMoveDirection;
float _speedAccumulator = 0f;

pub bool HasTarget => currentTargetFood != null || hasPlannedAction;
pub GameObject CurrentTargetFood => currentTargetFood;

pub void Initialize(AnimalController controller, AnimalDefinition definition) {
this.controller = controller;
this.definition = definition;
this.gridEntity = controller.GridEntity;

SetupDebugLineRenderer();
}

pub void OnTickUpdate(int currentTick) {
if (!enabled || controller.IsDying || controller.Behavior.IsEating || controller.Behavior.IsPooping) {
_speedAccumulator = 0f; // Reset speed if action is interrupted
return;
}

if (wanderPauseTicks > 0) {
wanderPauseTicks--;
return;
}

_speedAccumulator += definition.movementSpeed;

if (currentTick - lastThinkTick >= definition.thinkingTickInterval) {
MakeMovementDecision();
lastThinkTick = currentTick;
}

if (hasPlannedAction && !gridEntity.IsMoving) {
ExecutePlannedMovement();
}
}

pub void UpdateVisuals() {
UpdatePathDebugLine();
}

void MakeMovementDecision() {
if (gridEntity.IsMoving) return;

if (isSeekingScreenCenter) {
HandleScreenCenterSeeking();
return;
}

if (controller.Needs.IsHungry) {
PlanFoodSeeking();
}
else {
PlanWandering();
}
}

void PlanFoodSeeking() {
if (GridDebugVisualizer.Instance != null && Debug.isDebugBuild) {
GridDebugVisualizer.Instance.VisualizeAnimalSearchRadius(controller, gridEntity.Position, definition.searchRadiusTiles);
}

if (controller.CanShowThought()) {
controller.ShowThought(ThoughtTrigger.Hungry);
}

GameObject nearestFood = FindNearestFood();
if (nearestFood != null) {
SetTargetFood(nearestFood);
}
else {
PlanWandering();
}
}

GameObject FindNearestFood() {
if (definition.diet == null) ret null;

var entitiesInRadius = GridPositionManager.Instance.GetEntitiesInRadius(
gridEntity.Position,
definition.searchRadiusTiles,
true // Use circle radius
);

GameObject bestFood = null;
float bestScore = -1f;

var foodItems = entitiesInRadius
.Select(entity => entity.GetComponent<FoodItem>())
.Where(foodItem => foodItem != null && foodItem.foodType != null && definition.diet.CanEat(foodItem.foodType));

foreach (var foodItem in foodItems) {
var pref = definition.diet.GetPreference(foodItem.foodType);
if (pref == null) continue;

GridEntity foodEntity = foodItem.GetComponent<GridEntity>();
if (foodEntity == null) continue;

float distance = gridEntity.Position.ManhattanDistance(foodEntity.Position);
float score = pref.preferencePriority / (1f + distance);

if (score > bestScore) {
bestScore = score;
bestFood = foodItem.gameObject;
}
}

ret bestFood;
}

GridPosition GetFoodGroundPosition(GameObject food) {
GridEntity foodEntity = food.GetComponent<GridEntity>();
if (foodEntity != null && foodEntity.enabled) {
ret foodEntity.Position;
}

Debug.LogWarning($"[AnimalMovement] Food item '{food.name}' did not have an enabled GridEntity. Using world position as fallback.", food);
ret GridPositionManager.Instance.WorldToGrid(food.transform.position);
}

void SetTargetFood(GameObject food) {
currentTargetFood = food;
GridPosition foodGroundPos = GetFoodGroundPosition(food);

List<GridPosition> validEatingPositions = GetValidEatingPositions(foodGroundPos);

GridPosition bestTarget = GridPosition.Zero;
float shortestDistance = float.MaxValue;
List<GridPosition> shortestPath = null;

foreach (var pos in validEatingPositions) {
if (!IsValidMove(pos)) continue;

var path = GridPositionManager.Instance.GetPath(gridEntity.Position, pos, false);
if (path != null && path.Count > 0) {
float distance = path.Count;
if (distance < shortestDistance) {
shortestDistance = distance;
bestTarget = pos;
shortestPath = path;
}
}
}

if (shortestPath != null) {
currentPath = shortestPath;
currentPathIndex = 0;
hasPlannedAction = true;
}
else {
currentTargetFood = null;
}
}

List<GridPosition> GetValidEatingPositions(GridPosition foodPos) {
var positions = new List<GridPosition>();
for (int x = -definition.eatDistanceTiles; x <= definition.eatDistanceTiles; x++) {
for (int y = -definition.eatDistanceTiles; y <= definition.eatDistanceTiles; y++) {
if (x == 0 && y == 0) continue; // Skip the food's own position

int distance = Mathf.Abs(x) + Mathf.Abs(y);
if (distance == definition.eatDistanceTiles) {
positions.Add(foodPos + new GridPosition(x, y));
}
}
}
ret positions;
}

void PlanWandering() {
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(controller);
}
ClearPathDebugLine();

currentPath.Clear();
currentTargetFood = null;

if (Random.Range(0, 100) < definition.wanderPauseTickChance) {
wanderPauseTicks = Random.Range(definition.minWanderPauseTicks, definition.maxWanderPauseTicks);
hasPlannedAction = false;
return;
}

GridPosition currentPos = gridEntity.Position;
GridPosition[] directions = {
GridPosition.Up, GridPosition.Down,
GridPosition.Left, GridPosition.Right
};

for (int i = 0; i < directions.Length; i++) {
int randomIndex = Random.Range(i, directions.Length);
GridPosition temp = directions[i];
directions[i] = directions[randomIndex];
directions[randomIndex] = temp;
}

foreach (var dir in directions) {
GridPosition targetPos = currentPos + dir;
if (IsValidMove(targetPos)) {
currentPath.Clear();
currentPath.Add(targetPos);
currentPathIndex = 0;
hasPlannedAction = true;
return;
}
}

hasPlannedAction = false;
}

void ExecutePlannedMovement() {
if (!hasPlannedAction || gridEntity.IsMoving) return;

if (currentTargetFood != null) {
if (currentTargetFood == null || !currentTargetFood.activeInHierarchy) {
ClearMovementPlan();
return;
}

GridPosition foodPos = GetFoodGroundPosition(currentTargetFood);
int distance = gridEntity.Position.ManhattanDistance(foodPos);

if (distance == definition.eatDistanceTiles) {
controller.Behavior.StartEating(currentTargetFood);
ClearMovementPlan();
return;
}
}

int tilesToMove = Mathf.FloorToInt(_speedAccumulator);
if (tilesToMove <= 0) return;

int tilesMovedSuccessfully = 0;
for (int i = 0; i < tilesToMove; i++) {
if (currentPath == null || currentPathIndex >= currentPath.Count) {
ClearMovementPlan();
break;
}

GridPosition nextPosition = currentPath[currentPathIndex];
if (TryMoveTo(nextPosition)) {
currentPathIndex++;
tilesMovedSuccessfully++;
}
else {
if (currentTargetFood != null) {
SetTargetFood(currentTargetFood);
}
else {
ClearMovementPlan();
}
break;
}
}

_speedAccumulator -= tilesMovedSuccessfully;

if (currentPath != null && currentPathIndex >= currentPath.Count) {
ClearMovementPlan();
}
}

bool TryMoveTo(GridPosition targetPos) {
if (!IsValidMove(targetPos))
ret false;

Vector3 currentWorld = transform.position;
Vector3 targetWorld = GridPositionManager.Instance.GridToWorld(targetPos);
lastMoveDirection = (targetWorld - currentWorld).normalized;

gridEntity.SetPosition(targetPos);
ret true;
}

bool IsValidMove(GridPosition pos) {
if (GridPositionManager.Instance == null) ret false;

if (!GridPositionManager.Instance.IsPositionValid(pos)) ret false;

var entitiesAtPos = GridPositionManager.Instance.GetEntitiesAt(pos);
foreach (var entity in entitiesAtPos) {
if (entity.GetComponent<PlantCell>() != null) {
ret false;
}
}

if (GridPositionManager.Instance.IsPositionOccupied(pos)) {
if (currentTargetFood != null) {
GridPosition foodPos = GetFoodGroundPosition(currentTargetFood);
if (pos == foodPos) ret false;
}
ret false;
}

ret true;
}

void HandleScreenCenterSeeking() {
Vector2 currentPos = transform.position;
bool centerWithinBounds = currentPos.x >= minBounds.x && currentPos.x <= maxBounds.x &&
currentPos.y >= minBounds.y && currentPos.y <= maxBounds.y;

if (centerWithinBounds) {
isSeekingScreenCenter = false;
hasPlannedAction = false;
}
else {
GridPosition targetGridPos = GridPositionManager.Instance.WorldToGrid(screenCenterTarget);
currentPath = GridPositionManager.Instance.GetPath(gridEntity.Position, targetGridPos, false);
currentPathIndex = 0;
hasPlannedAction = currentPath.Count > 0;
}
}

pub void SetSeekingScreenCenter(Vector2 target, Vector2 minBounds, Vector2 maxBounds) {
isSeekingScreenCenter = true;
screenCenterTarget = target;
this.minBounds = minBounds;
this.maxBounds = maxBounds;
}

pub void StopAllMovement() {
ClearMovementPlan();
wanderPauseTicks = 0;
isSeekingScreenCenter = false;
}

pub void ClearMovementPlan() {
currentPath.Clear();
currentPathIndex = 0;
currentTargetFood = null;
hasPlannedAction = false;
_speedAccumulator = 0f;
ClearPathDebugLine();

if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(controller);
}
}

pub Vector2 GetLastMoveDirection() {
ret lastMoveDirection;
}

void SetupDebugLineRenderer() {
if (!showPathfindingDebugLine) return;

GameObject lineObj = new GameObject("PathDebugLine");
lineObj.transform.SetParent(transform);
pathDebugLine = lineObj.AddComponent<LineRenderer>();
pathDebugLine.startWidth = 0.05f;
pathDebugLine.endWidth = 0.05f;
pathDebugLine.material = new Material(Shader.Find("Sprites/Default"));
pathDebugLine.startColor = Color.yellow;
pathDebugLine.endColor = Color.red;
pathDebugLine.sortingOrder = 100;
}

void UpdatePathDebugLine() {
if (!showPathfindingDebugLine || pathDebugLine == null || currentPath == null || currentPath.Count == 0) {
if (pathDebugLine != null) pathDebugLine.positionCount = 0;
return;
}

List<Vector3> positions = new List<Vector3>();

Vector3 groundPosition = GridPositionManager.Instance.GridToWorld(gridEntity.Position);
positions.Add(groundPosition);

for (int i = currentPathIndex; i < currentPath.Count; i++) {
Vector3 worldPos = GridPositionManager.Instance.GridToWorld(currentPath[i]);
positions.Add(worldPos);
}

pathDebugLine.positionCount = positions.Count;
pathDebugLine.SetPositions(positions.ToArray());
}

void ClearPathDebugLine() {
if (pathDebugLine != null) {
pathDebugLine.positionCount = 0;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalNeeds.cs

﻿using UnityEngine;
using WegoSystem;
using Abracodabra.Genes.Components;

pub cls AnimalNeeds : MonoBehaviour {
AnimalController controller;
AnimalDefinition definition;
AnimalDiet diet;
SpriteRenderer spriteRenderer;

float currentHealth;
float currentHunger;

int hungerTick = 0;
int starvationTick = 0;

float flashRemainingTime = 0f;
float flashDurationSeconds = 0.2f;
bool isFlashing = false;
Color originalColor;

pub float CurrentHealth => currentHealth;
pub float CurrentHunger => currentHunger;
pub bool IsHungry => currentHunger >= diet.hungerThreshold;
pub bool IsStarving => currentHunger >= diet.maxHunger;

pub void Initialize(AnimalController controller, AnimalDefinition definition) {
this.controller = controller;
this.definition = definition;
this.diet = definition.diet;

spriteRenderer = GetComponentInChildren<SpriteRenderer>();
if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}

if (TickManager.Instance?.Config != null) {
flashDurationSeconds = definition.damageFlashTicks / TickManager.Instance.Config.ticksPerRealSecond;
}

currentHealth = definition.maxHealth;
currentHunger = 0f;
}

pub void OnTickUpdate(int currentTick) {
UpdateHunger();
UpdateStarvation();
}

void UpdateHunger() {
if (TickManager.Instance?.Config == null || diet == null) return;

hungerTick++;
if (hungerTick >= TickManager.Instance.Config.animalHungerTickInterval) {
hungerTick = 0;

currentHunger += diet.hungerIncreaseRate;
currentHunger = Mathf.Min(currentHunger, diet.maxHunger);

controller.UpdateUI();
}
}

void UpdateStarvation() {
if (!IsStarving) {
starvationTick = 0;
return;
}

starvationTick++;
if (starvationTick >= definition.starvationDamageTickInterval) {
starvationTick = 0;
ApplyStarvationDamage();
}
}

void Update() {
if (!isFlashing || spriteRenderer == null) return;

flashRemainingTime -= Time.deltaTime;

if (flashRemainingTime <= 0) {
spriteRenderer.color = originalColor;
isFlashing = false;
}
else {
float t = (flashRemainingTime / flashDurationSeconds);
spriteRenderer.color = Color.Lerp(originalColor, definition.damageFlashColor, t);
}
}

pub void TakeDamage(float amount) {
currentHealth -= amount;
currentHealth = Mathf.Clamp(currentHealth, 0f, definition.maxHealth);

StartDamageFlash();
controller.UpdateUI();

if (currentHealth <= definition.maxHealth * 0.3f && controller.CanShowThought()) {
controller.ShowThought(ThoughtTrigger.HealthLow);
}
}

void ApplyStarvationDamage() {
currentHealth -= definition.damagePerStarvationTick;
currentHealth = Mathf.Clamp(currentHealth, 0f, definition.maxHealth);

StartDamageFlash();
controller.UpdateUI();

Debug.Log($"[AnimalNeeds] {controller.SpeciesName} taking starvation damage. Health: {currentHealth}");
}

pub void Eat(FoodItem foodItem) {
if (foodItem == null || foodItem.foodType == null || diet == null) return;

float satiationGain = 0f;

NutritionComponent nutrition = foodItem.GetComponent<NutritionComponent>();
if (nutrition != null) {
satiationGain = nutrition.nutritionValue;
}
else {
satiationGain = diet.GetSatiationValue(foodItem.foodType);
}

currentHunger -= satiationGain;
currentHunger = Mathf.Max(0f, currentHunger);

controller.UpdateUI();

Debug.Log($"[AnimalNeeds] {controller.SpeciesName} ate {foodItem.foodType.foodName} for {satiationGain} satiation. Hunger: {currentHunger}/{diet.maxHunger}");
}

pub void Heal(float amount) {
currentHealth += amount;
currentHealth = Mathf.Clamp(currentHealth, 0f, definition.maxHealth);
controller.UpdateUI();
}

pub void ModifyHunger(float amount) {
currentHunger += amount;
currentHunger = Mathf.Clamp(currentHunger, 0f, diet.maxHunger);
controller.UpdateUI();
}

void StartDamageFlash() {
if (spriteRenderer == null) return;

isFlashing = true;
flashRemainingTime = flashDurationSeconds;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalSpawnData.cs

﻿using UnityEngine;

pub cls AnimalSpawnData {
pub AnimalDefinition animalDefinition;
pub float spawnRateMultiplier = 1f;
pub int maximumSpawned = 0;

pub float spawnTimer = 0f;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalThoughtLibrary.cs

﻿using UnityEngine;

pub cls AnimalThoughtLibrary : ScriptableObject {
pub string[] hungryThoughts = new string[] {
"I'm hungry!",
"Need food...",
"Where's the food?"
};

pub string[] eatingThoughts = new string[] {
"Yum!",
"Delicious!",
"Nom nom nom"
};

pub string[] healthLowThoughts = new string[] {
"I don't feel good...",
"Help me!",
"Ouch!"
};

pub string[] fleeingThoughts = new string[] {
"Run away!",
"Scary!",
"Help!"
};

pub string[] poopingThoughts = new string[] {
"Nature calls!",
"Gotta go!",
"..."
};
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Effects\FireflyController.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes;
using UnityEngine.Rendering.Universal;
using WegoSystem;

pub cls FireflyController : MonoBehaviour, ITickUpdateable {
[SerializeField] FireflyDefinition definition;

[SerializeField] Light2D glowLight;
[SerializeField] Light2D groundLight;
[SerializeField] SpriteRenderer spriteRenderer;
[SerializeField] TrailRenderer trailRenderer;
[SerializeField] ParticleSystem glowParticles;

[SerializeField] float groundLightRadiusMultiplier = 2.5f;

GridEntity gridEntity;

int lifetimeTicks;
int lastMovementTick = 0;

float currentLifetimeSeconds = 0f;
float maxLifetimeSeconds = 0f;

Vector3 currentTileCenter;
Vector3 localTargetPosition;
float currentLocalSpeed;

float baseGlowIntensity;
float currentGlowIntensity;
float baseGroundLightIntensity;
float baseGroundLightOuterRadius;
float glowFlickerTime;
Color originalColor;

pub bool IsAlive { get; set; } = true;
pub Transform AttractionTarget { get; set; }

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
Debug.LogError($"[FireflyController] Firefly prefab is missing the required GridEntity component!", this);
enabled = false;
return;
}

if (glowLight != null) {
baseGlowIntensity = glowLight.intensity;
currentGlowIntensity = glowLight.intensity;
}

if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}

if (groundLight != null) {
baseGroundLightIntensity = groundLight.intensity;
baseGroundLightOuterRadius = groundLight.pointLightOuterRadius;
}
}

void Start() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

void OnDestroy() {
var tickManager = TickManager.Instance;
if (tickManager != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}

if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
}

pub void Initialize() {
if (FireflyManager.Instance?.defaultFireflyDefinition == null || gridEntity == null) {
Debug.LogError("[FireflyController] Initialization failed: Missing definition or GridEntity!", this);
enabled = false;
return;
}

definition = FireflyManager.Instance.defaultFireflyDefinition;

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
currentTileCenter = GridPositionManager.Instance.GridToWorld(gridEntity.Position);
}

lifetimeTicks = Random.Range(definition.minLifetimeTicks, definition.maxLifetimeTicks + 1);
currentLocalSpeed = Random.Range(definition.minLocalSpeed, definition.maxLocalSpeed);

SetRandomLocalTarget();

if (glowParticles != null) {
glowParticles.Play();
}

if (TickManager.Instance?.Config != null) {
maxLifetimeSeconds = lifetimeTicks / TickManager.Instance.Config.ticksPerRealSecond;
}
else {
maxLifetimeSeconds = lifetimeTicks * 0.5f;
}
}

pub void OnTickUpdate(int currentTick) {
if (!IsAlive) return;

currentLifetimeSeconds += Time.deltaTime;
if (currentLifetimeSeconds >= maxLifetimeSeconds) {
Die();
return;
}

if (currentTick - lastMovementTick >= definition.movementTickInterval) {
UpdateMovement();
lastMovementTick = currentTick;
}

UpdatePhotosynthesisVisualization();
}

void Update() {
if (!IsAlive) return;

UpdateLocalMovement();
UpdateGlowEffect();
UpdateGroundLight();
}

void UpdateMovement() {
FindAttractionTarget();

if (AttractionTarget != null) {
Vector3 attractionDirection = (AttractionTarget.position - currentTileCenter).normalized;
localTargetPosition = currentTileCenter + attractionDirection * Random.Range(0.1f, 0.3f);
}
else {
SetRandomLocalTarget();
}
}

void UpdatePhotosynthesisVisualization() {
if (GridDebugVisualizer.Instance != null && FireflyManager.Instance != null && gridEntity != null) {
int photosynthesisRadius = Mathf.RoundToInt(FireflyManager.Instance.photosynthesisRadius);
if (photosynthesisRadius > 0) {
GridDebugVisualizer.Instance.VisualizeFireflyPhotosynthesisRadius(this, gridEntity.Position, photosynthesisRadius);
}
}
}

void FindAttractionTarget() {
if (definition == null || gridEntity == null) return;

float bestScore = 0f;
Transform bestTarget = null;

GridPosition currentPos = gridEntity.Position;
int searchRadius = definition.tileSearchRadius;

for (int x = currentPos.x - searchRadius; x <= currentPos.x + searchRadius; x++) {
for (int y = currentPos.y - searchRadius; y <= currentPos.y + searchRadius; y++) {
GridPosition checkPos = new GridPosition(x, y);
if (!GridPositionManager.Instance.IsPositionValid(checkPos)) continue;

float distance = Vector2.Distance(currentPos.ToVector2Int(), checkPos.ToVector2Int());
if (distance > searchRadius) continue;

var entitiesAtPosition = GridPositionManager.Instance.GetEntitiesAt(checkPos);
foreach (var entity in entitiesAtPosition) {
var scentSources = entity.GetComponentsInChildren<ScentSource>();
foreach (var source in scentSources) {
if (definition.attractiveScentDefinitions.Contains(source.Definition)) {
float score = definition.scentAttractionWeight / (distance + 1f);
if (score > bestScore) {
bestScore = score;
bestTarget = entity.transform;
}
}
}

var plantGrowth = entity.GetComponent<PlantGrowth>();
if (plantGrowth != null && plantGrowth.CurrentState == PlantState.Growing) {
float score = definition.growingPlantAttraction / (distance + 1f);
if (score > bestScore) {
bestScore = score;
bestTarget = entity.transform;
}
}
}
}
}

AttractionTarget = bestTarget;
}

void SetRandomLocalTarget() {
if (definition == null) return;

Vector2 randomOffset = new Vector2(
Random.Range(-definition.flightBounds.x * 0.5f, definition.flightBounds.x * 0.5f),
Random.Range(definition.flightHeightOffset, definition.flightHeightOffset + definition.flightBounds.y)
);

localTargetPosition = currentTileCenter + (Vector3)randomOffset;
}

void UpdateLocalMovement() {
if (definition == null) return;

transform.position = Vector3.MoveTowards(transform.position, localTargetPosition, currentLocalSpeed * Time.deltaTime);

Vector3 direction = (localTargetPosition - transform.position).normalized;
if (direction.magnitude > 0.1f) {
float targetAngle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
float currentAngle = transform.eulerAngles.z;
float newAngle = Mathf.MoveTowardsAngle(currentAngle, targetAngle, definition.localMovementTurnSpeed * Time.deltaTime);
transform.rotation = Quaternion.AngleAxis(newAngle, Vector3.forward);
}
}

void UpdateGlowEffect() {
if (glowParticles == null) return;

glowFlickerTime += Time.deltaTime * definition.glowFlickerSpeed;
float flicker = Mathf.Sin(glowFlickerTime) * definition.glowFlickerAmount;
currentGlowIntensity = Mathf.Clamp01(baseGlowIntensity + flicker);

var emission = glowParticles.emission;
emission.rateOverTime = currentGlowIntensity * 10f;
}

void UpdateGroundLight() {
if (groundLight == null) return;

groundLight.transform.position = currentTileCenter;

float height = Mathf.Max(0, transform.position.y - currentTileCenter.y);
float maxFlightHeight = definition.flightBounds.y + definition.flightHeightOffset;
float heightT = (maxFlightHeight > 0) ? Mathf.Clamp01(height / maxFlightHeight) : 0f;

float heightBasedIntensity = Mathf.Lerp(baseGroundLightIntensity, baseGroundLightIntensity * 0.5f, heightT); // Dims to 50% at max height
float heightBasedRadiusMultiplier = Mathf.Lerp(1f, groundLightRadiusMultiplier, heightT); // Scales from 1x to the max multiplier
float finalRadius = baseGroundLightOuterRadius * heightBasedRadiusMultiplier;

glowFlickerTime += Time.deltaTime * definition.glowFlickerSpeed;
float flicker = Mathf.Sin(glowFlickerTime) * definition.glowFlickerAmount;

groundLight.intensity = Mathf.Clamp(heightBasedIntensity + flicker, definition.groundLightMinIntensity, 1f);
groundLight.pointLightOuterRadius = finalRadius;
}

void Die() {
IsAlive = false;

if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}

if (FireflyManager.Instance != null) {
FireflyManager.Instance.ReportFireflyDespawned(this);
}

if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}

if (glowParticles != null) {
glowParticles.Stop();
Destroy(gameObject, glowParticles.main.duration);
}
else {
Destroy(gameObject);
}
}

void OnDrawGizmosSelected() {
if (definition == null) return;

float tileSize = 1f;
if (Application.isPlaying && GridPositionManager.Instance?.GetTilemapGrid() != null) {
tileSize = GridPositionManager.Instance.GetTilemapGrid().cellSize.x;
}

Gizmos.color = new Color(1f, 1f, 0f, 0.3f);
Gizmos.DrawWireSphere(transform.position, definition.tileSearchRadius * tileSize);

if (Application.isPlaying && FireflyManager.Instance != null) {
Gizmos.color = new Color(0f, 1f, 0.5f, 0.3f);
Gizmos.DrawWireSphere(transform.position, FireflyManager.Instance.photosynthesisRadius * tileSize);
}

if (Application.isPlaying) {
Vector3 flightBoxCenter = currentTileCenter + new Vector3(0, definition.flightHeightOffset + definition.flightBounds.y / 2f, 0);
Gizmos.color = new Color(0f, 1f, 1f, 0.5f);
Gizmos.DrawWireCube(flightBoxCenter, new Vector3(definition.flightBounds.x, definition.flightBounds.y, 0.1f));

Gizmos.color = Color.yellow;
Gizmos.DrawLine(transform.position, localTargetPosition);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Effects\FireflyDefinition.cs

﻿using System.Collections.Generic;

pub cls FireflyDefinition : ScriptableObject {
pub int movementTickInterval = 5;
pub int tileSearchRadius = 3;

pub Vector2 flightBounds = new Vector2(0.4f, 0.4f);
pub float flightHeightOffset = 0.2f;
pub float localMovementTurnSpeed = 90f;
pub float minLocalSpeed = 0.5f;
pub float maxLocalSpeed = 1.0f;

pub int minLifetimeTicks = 40;
pub int maxLifetimeTicks = 90;
pub float fadeInSeconds = 1.5f;
pub float fadeOutSeconds = 2.5f;
pub float glowFlickerAmount = 0.2f;
pub float glowFlickerSpeed = 5.0f;
[Range(0f, 1f)] pub float groundLightMinIntensity = 0.1f;

pub List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();
pub float scentAttractionWeight = 2.0f;
pub float growingPlantAttraction = 1.0f;

[HideInInspector] pub bool useSpawnEffect = true;
[HideInInspector] pub int spawnEffectTicks = 3;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Effects\FireflyManager.cs

﻿// FILE: Assets/Scripts/Ecosystem/Effects/FireflyManager.cs
using WegoSystem;

pub cls FireflyManager : MonoBehaviour, ITickUpdateable {
pub stat FireflyManager Instance { get; set; }

[SerializeField] WeatherManager weatherManager;
[SerializeField] GameObject fireflyPrefab;
[SerializeField] pub FireflyDefinition defaultFireflyDefinition;
[SerializeField] Transform fireflyParent;

[SerializeField] int maxFireflies = 50;
[SerializeField] int spawnIntervalTicks = 3;
[SerializeField] [Range(0f, 1f)] float nightThreshold = 0.25f;

[SerializeField] bool useMapCenterAsSpawnArea = true;
[SerializeField] Vector2 customSpawnCenter = Vector2.zero;
[SerializeField] Vector2 spawnAreaSize = new Vector2(20f, 10f);

pub float photosynthesisRadius = 3f;
pub float photosynthesisIntensityPerFly = 0.05f;
pub float maxPhotosynthesisBonus = 0.5f;

[SerializeField] bool showAttractionLinesRuntime = false;
[SerializeField] Color attractionLineColorRuntime = Color.magenta;
[SerializeField] GameObject lineVisualizerPrefab;
[SerializeField] Transform lineContainer;

List<FireflyController> activeFireflies = new List<FireflyController>();
Dictionary<FireflyController, LineRenderer> activeLineVisualizers = new Dictionary<FireflyController, LineRenderer>();
int spawnTickCounter = 0;
bool isNight = false;

pub bool ShowAttractionLinesRuntime => showAttractionLinesRuntime;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

ValidateReferences();
}

pub void Initialize() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

void OnDestroy() {
if (Instance == this) Instance = null;

var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}

CleanupVisualizers();
}

void ValidateReferences() {
if (weatherManager == null) {
Debug.LogError($"[{nameof(FireflyManager)}] WeatherManager not assigned!", this);
enabled = false;
return;
}

if (fireflyPrefab == null) {
Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab not assigned!", this);
enabled = false;
return;
}

if (defaultFireflyDefinition == null) {
Debug.LogError($"[{nameof(FireflyManager)}] Default Firefly Definition not assigned!", this);
enabled = false;
return;
}

FireflyController controller = fireflyPrefab.GetComponent<FireflyController>();
if (controller == null) {
Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab missing FireflyController script!", this);
enabled = false;
return;
}

if (fireflyParent == null) {
fireflyParent = transform;
}
}

pub void OnTickUpdate(int currentTick) {
isNight = weatherManager.sunIntensity <= nightThreshold;

if (isNight) {
spawnTickCounter++;
if (spawnTickCounter >= spawnIntervalTicks) {
TrySpawnFirefly();
spawnTickCounter = 0;
}
}
else {
spawnTickCounter = 0;
}

activeFireflies.RemoveAll(f => f == null || !f.IsAlive);
}

void Update() {
UpdateRuntimeLineVisualizers();
}

Vector2 GetEffectiveSpawnCenter() {
if (useMapCenterAsSpawnArea && GridPositionManager.Instance != null) {
ret GridPositionManager.Instance.GetMapCenterWorld();
}
ret customSpawnCenter;
}

void TrySpawnFirefly() {
if (activeFireflies.Count >= maxFireflies) return;

GridPosition spawnGridPos = FindValidSpawnPosition();
if (spawnGridPos == GridPosition.Zero) return;

Vector3 spawnWorldPos = GridPositionManager.Instance.GridToWorld(spawnGridPos);

GameObject fireflyGO = Instantiate(fireflyPrefab, spawnWorldPos, Quaternion.identity, fireflyParent);
FireflyController controller = fireflyGO.GetComponent<FireflyController>();

if (controller != null) {
controller.Initialize();
activeFireflies.Add(controller);
}
}

GridPosition FindValidSpawnPosition() {
Vector2 center = GetEffectiveSpawnCenter();
Vector2 minBounds = center - spawnAreaSize * 0.5f;
Vector2 maxBounds = center + spawnAreaSize * 0.5f;

GridPosition minGrid = GridPositionManager.Instance.WorldToGrid(minBounds);
GridPosition maxGrid = GridPositionManager.Instance.WorldToGrid(maxBounds);

for (int i = 0; i < 10; i++) {
int x = Random.Range(minGrid.x, maxGrid.x + 1);
int y = Random.Range(minGrid.y, maxGrid.y + 1);
GridPosition pos = new GridPosition(x, y);

if (GridPositionManager.Instance.IsPositionValid(pos) &&
!GridPositionManager.Instance.IsPositionOccupied(pos)) {
ret pos;
}
}

ret GridPosition.Zero;
}

pub void ReportFireflyDespawned(FireflyController firefly) {
activeFireflies.Remove(firefly);

if (activeLineVisualizers.TryGetValue(firefly, out LineRenderer line)) {
if (line != null) Destroy(line.gameObject);
activeLineVisualizers.Remove(firefly);
}
}

pub int GetNearbyFireflyCount(Vector3 position, float radius) {
int count = 0;
float radiusSq = radius * radius;

for (int i = activeFireflies.Count - 1; i >= 0; i--) {
if (activeFireflies[i] == null) {
activeFireflies.RemoveAt(i);
continue;
}

if ((activeFireflies[i].transform.position - position).sqrMagnitude <= radiusSq) {
count++;
}
}

ret count;
}

void UpdateRuntimeLineVisualizers() {
if (!Application.isPlaying || !showAttractionLinesRuntime) {
CleanupVisualizers();
return;
}

var toRemove = new List<FireflyController>();
foreach (var kvp in activeLineVisualizers) {
if (kvp.Key == null || kvp.Value == null) {
toRemove.Add(kvp.Key);
continue;
}

Transform target = kvp.Key.AttractionTarget;
if (target != null) {
kvp.Value.enabled = true;
kvp.Value.SetPosition(0, kvp.Key.transform.position);
kvp.Value.SetPosition(1, target.position);
kvp.Value.startColor = attractionLineColorRuntime;
kvp.Value.endColor = attractionLineColorRuntime;
}
else {
kvp.Value.enabled = false;
}
}

foreach (var firefly in toRemove) {
if (activeLineVisualizers.TryGetValue(firefly, out var line) && line != null) {
Destroy(line.gameObject);
}
activeLineVisualizers.Remove(firefly);
}

if (lineVisualizerPrefab != null && lineContainer != null) {
foreach (var firefly in activeFireflies) {
if (firefly == null || activeLineVisualizers.ContainsKey(firefly)) continue;

if (firefly.AttractionTarget != null) {
GameObject lineGO = Instantiate(lineVisualizerPrefab, lineContainer);
LineRenderer newLine = lineGO.GetComponent<LineRenderer>();

if (newLine != null) {
newLine.SetPosition(0, firefly.transform.position);
newLine.SetPosition(1, firefly.AttractionTarget.position);
newLine.startColor = attractionLineColorRuntime;
newLine.endColor = attractionLineColorRuntime;
newLine.enabled = true;
activeLineVisualizers.Add(firefly, newLine);
}
else {
Debug.LogError($"Line Visualizer Prefab missing LineRenderer!", lineVisualizerPrefab);
Destroy(lineGO);
}
}
}
}
}

void CleanupVisualizers() {
foreach (var kvp in activeLineVisualizers) {
if (kvp.Value != null) {
Destroy(kvp.Value.gameObject);
}
}
activeLineVisualizers.Clear();
}

void OnDrawGizmosSelected() {
Vector2 center = GetEffectiveSpawnCenter();
Gizmos.color = new Color(1f, 1f, 0f, 0.3f);
Gizmos.DrawWireCube(center, spawnAreaSize);

if (Application.isPlaying) {
Gizmos.color = new Color(0f, 1f, 0.5f, 0.2f);
foreach (var firefly in activeFireflies) {
if (firefly != null) {
Gizmos.DrawWireSphere(firefly.transform.position, photosynthesisRadius);
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\PoopController.cs

﻿using UnityEngine;
using WegoSystem;

pub cls PoopController : MonoBehaviour, ITickUpdateable {
[SerializeField] int lifetimeTicks = 20;

[SerializeField] float fadeRealTimeDuration = 1f;

GridEntity gridEntity;
SpriteRenderer spriteRenderer;
int currentLifetimeTicks;
bool isFading = false;
float fadeTimer = 0f;
Color originalColor;

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = gameObject.AddComponent<GridEntity>();
}
gridEntity.isTileOccupant = false;

spriteRenderer = GetComponent<SpriteRenderer>();
if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
}
else {
Debug.LogError($"[{gameObject.name}] GridPositionManager not found on Awake! Poop will not be registered correctly.");
}
}

void Start() {
currentLifetimeTicks = lifetimeTicks;

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}

}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

void Update() {
if (isFading && fadeTimer > 0) {
fadeTimer -= Time.deltaTime;
UpdateFade();

if (fadeTimer <= 0) {
Destroy(gameObject);
}
}
}

pub void OnTickUpdate(int currentTick) {
if (isFading) return;

currentLifetimeTicks--;

if (currentLifetimeTicks <= 0) {
StartFading();
}
}

void StartFading() {
isFading = true;
fadeTimer = fadeRealTimeDuration;

if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

void UpdateFade() {
if (spriteRenderer == null) return;

float fadeProgress = 1f - (fadeTimer / fadeRealTimeDuration);
Color color = originalColor;
color.a = Mathf.Lerp(1f, 0f, fadeProgress);
spriteRenderer.color = color;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\ScentDefinition.cs

﻿using UnityEngine;

pub cls ScentDefinition : ScriptableObject {
pub string scentID = "default_scent"; // Still useful for debugging/lookup
pub string displayName = "Default Scent";

pub float baseRadius = 1f;
pub float baseStrength = 1f;

pub GameObject particleEffectPrefab;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\ScentLibrary.cs

﻿using UnityEngine;

pub cls ScentLibrary : ScriptableObject {
pub List<ScentDefinition> scents;

pub ScentDefinition GetScentByID(string id) {
if (string.IsNullOrEmpty(id) || scents == null) ret null;
ret scents.FirstOrDefault(s => s != null && s.scentID == id);
}

pub List<ScentDefinition> GetAllDefinitions() {
ret scents?.Where(s => s != null).ToList() ?? new List<ScentDefinition>();
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\ScentSource.cs

﻿using Abracodabra.Genes;
using WegoSystem;

pub cls ScentSource : MonoBehaviour {
[SerializeField] ScentDefinition definition;
[SerializeField] float radiusModifier = 0f;
[SerializeField] float strengthModifier = 0f;

pub ScentDefinition Definition => definition;
pub float EffectiveRadius => definition != null ? Mathf.Max(0f, definition.baseRadius + radiusModifier) : 0f;
pub float EffectiveStrength => definition != null ? Mathf.Max(0f, definition.baseStrength + strengthModifier) : 0f;

GridEntity gridEntity;

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = gameObject.AddComponent<GridEntity>();
}
}

void Start() {
if (GetComponentInParent<PlantGrowth>() == null) {
if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
}
}
}

void Update() {
UpdateRadiusVisualization();
}

void UpdateRadiusVisualization() {
if (GridDebugVisualizer.Instance != null && definition != null && gridEntity != null) {
float effectiveRadius = EffectiveRadius;
if (effectiveRadius > 0.01f) {
int radiusTiles = Mathf.RoundToInt(effectiveRadius);
GridDebugVisualizer.Instance.VisualizeScentRadius(this, gridEntity.Position, radiusTiles);
}
else {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
}
}

pub void SetDefinition(ScentDefinition newDefinition) {
definition = newDefinition;
UpdateRadiusVisualization(); // Update visualization when definition changes
}

pub void SetRadiusModifier(float modifier) {
radiusModifier = modifier;
}

pub void SetStrengthModifier(float modifier) {
strengthModifier = modifier;
}

pub void ApplyModifiers(float radiusMod, float strengthMod) {
radiusModifier += radiusMod;
strengthModifier += strengthMod;
}

void OnDestroy() {
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
}

void OnDisable() {
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
}

void OnEnable() {
UpdateRadiusVisualization();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Food\AnimalDiet.cs

﻿using UnityEngine;

pub cls DietPreferenceSimplified {
pub FoodType foodType;
pub float preferencePriority = 1f;
}

pub cls AnimalDiet : ScriptableObject {
pub List<DietPreferenceSimplified> acceptableFoods = new List<DietPreferenceSimplified>();

pub float maxHunger = 20f;

pub float hungerIncreaseRate = 0.5f;

pub float hungerThreshold = 10f;

pub bool CanEat(FoodType food) {
if (food == null) ret false;
ret acceptableFoods.Any(pref => pref.foodType == food);
}

pub DietPreferenceSimplified GetPreference(FoodType food) {
if (food == null) ret null;
ret acceptableFoods.FirstOrDefault(p => p.foodType == food);
}

pub float GetSatiationValue(FoodType food) {
if (food != null && CanEat(food)) {
ret food.baseSatiationValue;
}
ret 0f;
}

pub GameObject FindBestFood(Collider2D[] nearbyColliders, Vector3 animalPosition) {
GameObject bestTarget = null;
float highestScore = -1f;

foreach (var collider in nearbyColliders) {
if (collider == null) continue;

PoopController poopController = collider.GetComponent<PoopController>();
if (poopController != null) continue;

FoodItem foodItem = collider.GetComponent<FoodItem>();
if (foodItem != null && foodItem.foodType != null && CanEat(foodItem.foodType)) {
DietPreferenceSimplified pref = GetPreference(foodItem.foodType);
if (pref == null) continue;

float distance = Vector3.Distance(animalPosition, collider.transform.position);
float score = pref.preferencePriority / (1f + distance); // Inverse distance weighting

if (score > highestScore) {
highestScore = score;
bestTarget = collider.gameObject;
}
}
}
ret bestTarget;
}

void OnValidate() {
maxHunger = Mathf.Max(1f, maxHunger);
hungerIncreaseRate = Mathf.Max(0.1f, hungerIncreaseRate);
hungerThreshold = Mathf.Clamp(hungerThreshold, 0f, maxHunger);

foreach (var pref in acceptableFoods) {
if (pref != null) {
pref.preferencePriority = Mathf.Max(0.1f, pref.preferencePriority);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Food\FoodItem.cs

﻿using UnityEngine;
using Abracodabra.Genes;
using WegoSystem;

pub cls FoodItem : MonoBehaviour {
pub FoodType foodType;

GridEntity gridEntity;
bool isInitialized = false; // Prevents Start() from running if manually initialized

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = gameObject.AddComponent<GridEntity>();
}
}

void Start() {
if (isInitialized) return; // If initialized by PlantCellManager, do nothing.

if (foodType == null) {
Debug.LogWarning($"FoodItem on GameObject '{gameObject.name}' is missing its FoodType reference!", gameObject);
enabled = false;
return;
}

gridEntity.isTileOccupant = false;
gridEntity.enabled = true;

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
Debug.Log($"[FoodItem] Registered STANDALONE food '{foodType.foodName}' at grid position {gridEntity.Position}");
}

isInitialized = true;
}

pub void InitializeAsPlantPart(FoodType type, GridPosition gridPosition) {
if (isInitialized) return;

this.foodType = type;

gridEntity.isTileOccupant = false;
gridEntity.enabled = true;

if (GridPositionManager.Instance != null) {
gridEntity.SetPosition(gridPosition, true); // Instantly set logical state
GridPositionManager.Instance.RegisterEntity(gridEntity); // Manually register
Debug.Log($"[FoodItem] Registered PLANT food '{foodType.name}' at grid position {gridPosition}");
}

isInitialized = true;
}

pub bool CanBeEatenBy(AnimalController animal) {
if (animal == null || animal.Definition == null || animal.Definition.diet == null)
ret false;

ret animal.Definition.diet.CanEat(foodType);
}

pub float GetSatiationValueFor(AnimalController animal) {
if (animal == null || animal.Definition == null || animal.Definition.diet == null)
ret 0f;

ret animal.Definition.diet.GetSatiationValue(foodType);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Food\FoodType.cs

﻿using UnityEngine;

pub cls FoodType : ScriptableObject {
pub string foodName = "Default Food";
pub Sprite icon;

pub enum FoodCategory { Plant_Leaf, Plant_Fruit, Plant_Stem, Plant_Seed, Other }
pub FoodCategory category = FoodCategory.Other;

pub float baseSatiationValue = 5f;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\EcosystemManager.cs

﻿// Assets/Scripts/Ecosystem/Management/EcosystemManager.cs
using WegoSystem;

pub cls EcosystemManager : SingletonMonoBehaviour<EcosystemManager> {
pub Transform animalParent;
pub Transform plantParent;

pub ScentLibrary scentLibrary;

pub bool sortAnimalsBySpecies = true;
pub bool sortPlantsBySpecies = true;

prot ovr void OnAwake() {
if (scentLibrary == null) {
Debug.LogWarning($"[{nameof(EcosystemManager)}] Scent Library not assigned! Scent effects will not work.", this);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\FaunaManager.cs

﻿// FILE: Assets/Scripts/Ecosystem/Management/FaunaManager.cs
using WegoSystem;

pub cls FaunaManager : MonoBehaviour {
[SerializeField] bool useMapCenterAsSpawnArea = true;
[SerializeField] Vector2 customSpawnCenter = Vector2.zero;
[SerializeField] Vector2 spawnAreaSize = new Vector2(20f, 10f);

[SerializeField] Transform ecosystemParent;

[SerializeField] [Min(0f)] float screenBoundsPadding = 0.5f;
[SerializeField] [Min(0f)] float offscreenSpawnMargin = 2.0f;
[SerializeField] [Range(-10f, 10f)] float boundsOffsetX = 0f;
[SerializeField] [Range(-10f, 10f)] float boundsOffsetY = 0f;

[SerializeField] bool showBoundsGizmos = false;

List<Coroutine> activeSpawnCoroutines = new List<Coroutine>();
Camera mainCamera;

pub void Initialize() {
InitializeManager();
}

void InitializeManager() {
activeSpawnCoroutines.Clear();
if (WaveManager.Instance != null) mainCamera = WaveManager.Instance.GetMainCamera();
if (mainCamera == null) mainCamera = Camera.main;
if (mainCamera == null) Debug.LogError("[FaunaManager] Cannot find Main Camera!", this);

if (ecosystemParent == null) {
if (EcosystemManager.Instance != null && EcosystemManager.Instance.animalParent != null) {
ecosystemParent = EcosystemManager.Instance.animalParent;
Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned from EcosystemManager.animalParent.", this);
}
else {
ecosystemParent = transform;
Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned to self as fallback.", this);
}
}
}

Vector2 GetEffectiveSpawnCenter() {
if (useMapCenterAsSpawnArea && GridPositionManager.Instance != null) {
ret GridPositionManager.Instance.GetMapCenterWorld();
}
ret customSpawnCenter;
}

pub void ExecuteSpawnWave(WaveDefinition waveDef) {
if (waveDef == null) { Debug.LogError("[FaunaManager] ExecuteSpawnWave called with null WaveDefinition!", this); return; }
if (waveDef.spawnEntries == null || waveDef.spawnEntries.Count == 0) { Debug.LogWarning($"[FaunaManager] Wave '{waveDef.waveName}' has no spawn entries.", this); return; }

Debug.Log($"[FaunaManager] Executing spawn for Wave: '{waveDef.waveName}'");
StopAllSpawnCoroutines();

foreach (WaveSpawnEntry entry in waveDef.spawnEntries) {
if (entry.animalDefinition == null) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', null AnimalDefinition for wave '{waveDef.waveName}'."); continue; }
if (entry.spawnCount <= 0) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', Spawn Count <= 0 for wave '{waveDef.waveName}'."); continue; }

if (RunManager.Instance != null && RunManager.Instance.CurrentState != RunState.GrowthAndThreat) {
Debug.Log($"[FaunaManager] Halting further spawn entry processing for wave '{waveDef.waveName}', RunManager not in GrowthAndThreat state.");
break;
}

WaveSpawnEntry currentEntry = entry;
Coroutine spawnCoroutine = StartCoroutine(SpawnWaveEntryCoroutine(currentEntry, waveDef.waveName));
activeSpawnCoroutines.Add(spawnCoroutine);
}
Debug.Log($"[FaunaManager] Started {activeSpawnCoroutines.Count} spawn entry coroutine(s) for '{waveDef.waveName}'.");
}

pub void StopAllSpawnCoroutines() {
if (activeSpawnCoroutines.Count > 0) {
Debug.Log($"[FaunaManager] Stopping all ({activeSpawnCoroutines.Count}) active spawn coroutines.");
foreach (Coroutine co in activeSpawnCoroutines) {
if (co != null) StopCoroutine(co);
}
activeSpawnCoroutines.Clear();
}
}

IEnumerator SpawnWaveEntryCoroutine(WaveSpawnEntry entry, string waveNameForDebug) {
if (entry.delayAfterSpawnTime > 0) {
yield ret new WaitForSeconds(entry.delayAfterSpawnTime);
}

for (int i = 0; i < entry.spawnCount; i++) {
if (RunManager.Instance != null && RunManager.Instance.CurrentState != RunState.GrowthAndThreat) {
Debug.Log($"[FaunaManager] Halting spawn for entry '{entry.description}' in wave '{waveNameForDebug}', RunManager no longer in GrowthAndThreat state.");
break;
}

Vector2 spawnPos = CalculateSpawnPosition(entry.spawnLocationType, entry.spawnRadius);
bool isOffscreen = entry.spawnLocationType == WaveSpawnLocationType.Offscreen;
GameObject spawnedAnimal = SpawnAnimal(entry.animalDefinition, spawnPos, isOffscreen);

if (entry.spawnInterval > 0 && i < entry.spawnCount - 1) {
yield ret new WaitForSeconds(entry.spawnInterval);
}
}
}

Vector2 CalculateSpawnPosition(WaveSpawnLocationType locationType, float radius) {
if (mainCamera == null) {
Debug.LogError("[FaunaManager] Missing Main Camera for CalculateSpawnPosition!");
ret GetEffectiveSpawnCenter();
}

Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

Vector2 spawnPos;
float camHeight = mainCamera.orthographicSize * 2f;
float camWidth = camHeight * mainCamera.aspect;

switch (locationType) {
case WaveSpawnLocationType.Offscreen:
float marginMinX = effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin;
float marginMaxX = effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin;
float marginMinY = effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin;
float marginMaxY = effectiveCamPos.y + camHeight / 2f - offscreenSpawnMargin;
float extraOffset = 0.1f;
int edge = Random.Range(0, 4);
if (edge == 0) { spawnPos.x = marginMinX - extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
else if (edge == 1) { spawnPos.x = marginMaxX + extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
else if (edge == 2) { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMinY - extraOffset; }
else { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMaxY + extraOffset; }
break;

case WaveSpawnLocationType.RandomNearPlayer:
Transform playerT = FindPlayerTransform();
if (playerT != null) {
spawnPos = (Vector2)playerT.position + Random.insideUnitCircle * radius;
}
else {
Debug.LogWarning("[FaunaManager] Player not found for RandomNearPlayer. Falling back to Global.");
goto case WaveSpawnLocationType.GlobalSpawnArea;
}
break;

case WaveSpawnLocationType.GlobalSpawnArea:
default:
Vector2 center = GetEffectiveSpawnCenter();
spawnPos.x = center.x + Random.Range(-spawnAreaSize.x / 2f, spawnAreaSize.x / 2f);
spawnPos.y = center.y + Random.Range(-spawnAreaSize.y / 2f, spawnAreaSize.y / 2f);
break;
}
ret spawnPos;
}

Transform FindPlayerTransform() {
GameObject playerGO = GameObject.FindGameObjectWithTag("Player");
if (playerGO != null) ret playerGO.transform;

PlayerTileInteractor pti = FindAnyObjectByType<PlayerTileInteractor>();
if (pti != null) ret pti.transform;

GardenerController gc = FindAnyObjectByType<GardenerController>();
if (gc != null) ret gc.transform;

ret null;
}

GameObject SpawnAnimal(AnimalDefinition definition, Vector2 position, bool isOffscreenSpawn) {
if (definition == null || definition.prefab == null) {
Debug.LogError("[FaunaManager] Cannot spawn animal: null definition or prefab.");
ret null;
}

if (mainCamera == null) {
Debug.LogError("[FaunaManager] Missing Main Camera for SpawnAnimal bounds calculation!");
ret null;
}

Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

Vector2 minPaddedBounds, maxPaddedBounds;
float camHeight = mainCamera.orthographicSize * 2f;
float camWidth = camHeight * mainCamera.aspect;

minPaddedBounds.x = effectiveCamPos.x - camWidth / 2f + screenBoundsPadding;
maxPaddedBounds.x = effectiveCamPos.x + camWidth / 2f - screenBoundsPadding;
minPaddedBounds.y = effectiveCamPos.y - camHeight / 2f + screenBoundsPadding;
maxPaddedBounds.y = effectiveCamPos.y + camHeight / 2f - screenBoundsPadding;

GameObject animalObj = Instantiate(definition.prefab, position, Quaternion.identity);

if (ecosystemParent != null) {
Transform speciesParent = ecosystemParent;
if (EcosystemManager.Instance != null && EcosystemManager.Instance.sortAnimalsBySpecies && !string.IsNullOrEmpty(definition.animalName)) {
speciesParent = ecosystemParent.Find(definition.animalName);
if (speciesParent == null) {
GameObject subParentGO = new GameObject(definition.animalName);
subParentGO.transform.SetParent(ecosystemParent);
speciesParent = subParentGO.transform;
}
}
animalObj.transform.SetParent(speciesParent);
}

AnimalController controller = animalObj.GetComponent<AnimalController>();
if (controller != null) {
if (isOffscreenSpawn) {
Vector2 screenCenter = (minPaddedBounds + maxPaddedBounds) / 2f;
controller.SetSeekingScreenCenter(screenCenter, minPaddedBounds, maxPaddedBounds);
}
}
else {
Debug.LogError($"[FaunaManager] Spawned animal prefab '{definition.prefab.name}' missing AnimalController script!", animalObj);
}

ret animalObj;
}

void OnDrawGizmos() {
if (!showBoundsGizmos) return;

Vector2 center = GetEffectiveSpawnCenter();
Gizmos.color = new Color(0f, 0.5f, 1f, 0.5f); // Blue for spawn area
Gizmos.DrawWireCube(center, spawnAreaSize);

if (mainCamera == null) return;

Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;
float camHeight = mainCamera.orthographicSize * 2f;
float camWidth = camHeight * mainCamera.aspect;
Vector2 paddedMin = new Vector2(effectiveCamPos.x - camWidth / 2f + screenBoundsPadding, effectiveCamPos.y - camHeight / 2f + screenBoundsPadding);
Vector2 paddedMax = new Vector2(effectiveCamPos.x + camWidth / 2f - screenBoundsPadding, effectiveCamPos.y + camHeight / 2f - screenBoundsPadding);
DrawWireRectangleGizmo(paddedMin, paddedMax, Color.green);
Vector2 marginMin = new Vector2(effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin, effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin);
Vector2 marginMax = new Vector2(effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin, effectiveCamPos.y + camHeight / 2f - offscreenSpawnMargin);
DrawWireRectangleGizmo(marginMin, marginMax, Color.red);
}

void DrawWireRectangleGizmo(Vector2 min, Vector2 max, Color color) { Gizmos.color = color; Gizmos.DrawLine(new Vector3(min.x, min.y, 0), new Vector3(max.x, min.y, 0)); Gizmos.DrawLine(new Vector3(max.x, min.y, 0), new Vector3(max.x, max.y, 0)); Gizmos.DrawLine(new Vector3(max.x, max.y, 0), new Vector3(min.x, max.y, 0)); Gizmos.DrawLine(new Vector3(min.x, max.y, 0), new Vector3(min.x, min.y, 0)); }
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\FloraManager.cs

﻿// REWORKED FILE: Assets/Scripts/Ecosystem/Management/FloraManager.cs

pub cls FloraManager : MonoBehaviour {
pub stat FloraManager Instance { get; set; }

[SerializeField] pub float basePhotosynthesisRatePerLeaf = 0.1f;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\WaveManager.cs

﻿// Assets/Scripts/Ecosystem/Management/WaveManager.cs
using TMPro;
using WegoSystem;

pub enum WaveState {
Idle,           // No wave active
Active,         // Wave is currently running
Spawning        // Currently spawning enemies
}

pub cls WaveManager : MonoBehaviour {
pub stat WaveManager Instance { get; set; }

[SerializeField] Camera mainCamera;
[SerializeField] FaunaManager faunaManager;
[SerializeField] List<WaveDefinition> wavesSequence;

[SerializeField] int waveDurationInDays = 1;
[SerializeField] float spawnTimeNormalized = 0.1f;
[SerializeField] bool continuousSpawning = false;

[SerializeField] bool deletePreviousWaveAnimals = true;

[SerializeField] TextMeshProUGUI waveStatusText;
[SerializeField] TextMeshProUGUI timeTrackerText;

WaveState currentState = WaveState.Idle;
WaveDefinition currentWaveDef = null;
int currentWaveIndex = -1;

int waveStartTick = 0;
int waveEndTick = 0;
int waveSpawnTick = 0;
bool hasSpawnedThisWave = false;

Coroutine activeSpawnCoroutine = null;

pub bool IsWaveActive => currentState != WaveState.Idle;
pub bool IsCurrentWaveDefeated() => currentState == WaveState.Idle && currentWaveIndex >= 0;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

ValidateReferences();
}

pub void Initialize() {
if (TickManager.Instance != null) {
TickManager.Instance.OnTickAdvanced += OnTickAdvanced;
Debug.Log("[WaveManager] Initialized and subscribed to TickManager events.");
}
else {
Debug.LogError("[WaveManager] Initialization failed: TickManager not found!");
}
}

void OnDestroy() {
var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.OnTickAdvanced -= OnTickAdvanced;
}
StopAllCoroutines();
}

void ValidateReferences() {
if (faunaManager == null) {
faunaManager = FindAnyObjectByType<FaunaManager>();
if (faunaManager != null) {
Debug.LogWarning("[WaveManager] FaunaManager was not assigned in the Inspector. Found it automatically.", this);
}
}

if (faunaManager == null) {
Debug.LogError("[WaveManager] CRITICAL: FaunaManager is missing and could not be found in the scene! Waves will not spawn.", this);
}

if (wavesSequence == null || wavesSequence.Count == 0)
Debug.LogWarning("[WaveManager] Wave Sequence empty. No waves will spawn.", this);
}

void OnTickAdvanced(int currentTick) {
if (currentState == WaveState.Active) {
if (currentTick >= waveEndTick) {
EndCurrentWave();
}
else if (!hasSpawnedThisWave && currentTick >= waveSpawnTick) {
StartSpawning();
}
else if (continuousSpawning && hasSpawnedThisWave) {
}
}
}

pub void StartWaveForRound(int roundNumber) {
if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat) {
Debug.LogWarning("[WaveManager] Cannot start wave - not in GrowthAndThreat state.");
return;
}

currentWaveIndex = roundNumber - 1;

if (!IsValidWaveIndex(currentWaveIndex)) {
Debug.LogWarning($"[WaveManager] No wave definition for round {roundNumber}");
currentState = WaveState.Idle;
return;
}

currentWaveDef = wavesSequence[currentWaveIndex];
if (currentWaveDef == null) {
Debug.LogError($"[WaveManager] Wave definition at index {currentWaveIndex} is null!");
currentState = WaveState.Idle;
return;
}

StartWave();
}

void StartWave() {
if (deletePreviousWaveAnimals) {
ClearAllActiveAnimals();
}

var config = TickManager.Instance?.Config;
if (config == null) {
Debug.LogError("[WaveManager] No TickConfiguration found!");
return;
}

waveStartTick = TickManager.Instance.CurrentTick;
int waveDurationTicks = config.ticksPerDay * waveDurationInDays;
waveEndTick = waveStartTick + waveDurationTicks;

waveSpawnTick = waveStartTick + Mathf.RoundToInt(waveDurationTicks * spawnTimeNormalized);

hasSpawnedThisWave = false;
currentState = WaveState.Active;

Debug.Log($"[WaveManager] Starting wave '{currentWaveDef.waveName}' " +
$"Duration: {waveDurationTicks} ticks ({waveDurationInDays} days) " +
$"Spawn at tick: {waveSpawnTick}");
}

void StartSpawning() {
if (currentWaveDef == null || faunaManager == null) return;

hasSpawnedThisWave = true;
currentState = WaveState.Spawning;

Debug.Log($"[WaveManager] Beginning spawn for wave '{currentWaveDef.waveName}'");

if (activeSpawnCoroutine != null) {
StopCoroutine(activeSpawnCoroutine);
}

activeSpawnCoroutine = StartCoroutine(ExecuteWaveSpawn());
}

IEnumerator ExecuteWaveSpawn() {
faunaManager.ExecuteSpawnWave(currentWaveDef);

yield ret new WaitForSeconds(1f);

if (currentState == WaveState.Spawning) {
currentState = WaveState.Active;
}

activeSpawnCoroutine = null;
}

void EndCurrentWave() {
Debug.Log($"[WaveManager] Ending wave '{currentWaveDef?.waveName}'");

StopCurrentWaveSpawning();
currentWaveDef = null;
currentState = WaveState.Idle;

if (RunManager.Instance != null) {
RunManager.Instance.StartNewPlanningPhase();
}
}

pub void StopCurrentWaveSpawning() {
if (activeSpawnCoroutine != null) {
StopCoroutine(activeSpawnCoroutine);
activeSpawnCoroutine = null;
}

faunaManager?.StopAllSpawnCoroutines();
}

pub void ResetForNewRound() {
Debug.Log("[WaveManager] Resetting for new round");

StopCurrentWaveSpawning();

if (deletePreviousWaveAnimals) {
ClearAllActiveAnimals();
}

currentWaveDef = null;
currentWaveIndex = -1;
currentState = WaveState.Idle;
hasSpawnedThisWave = false;
waveStartTick = 0;
waveEndTick = 0;
waveSpawnTick = 0;
}

void ClearAllActiveAnimals() {
AnimalController[] animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
int count = 0;

foreach (var animal in animals) {
if (animal != null) {
Destroy(animal.gameObject);
count++;
}
}

Debug.Log($"[WaveManager] Cleared {count} animals");
}

bool IsValidWaveIndex(int index) {
ret wavesSequence != null &&
index >= 0 &&
index < wavesSequence.Count;
}

void Update() {
UpdateUI();
}

void UpdateUI() {
UpdateTimeTracker();
UpdateWaveStatus();
}

void UpdateTimeTracker() {
if (timeTrackerText == null || TickManager.Instance == null) return;

var config = TickManager.Instance.Config;
if (config == null) return;

float dayProgress = config.GetDayProgressNormalized(TickManager.Instance.CurrentTick);
int dayNumber = TickManager.Instance.CurrentTick / config.ticksPerDay + 1;

timeTrackerText.text = $"Day {dayNumber} - {(dayProgress * 100):F0}%";

if (currentState != WaveState.Idle) {
int ticksIntoWave = TickManager.Instance.CurrentTick - waveStartTick;
int totalWaveTicks = waveEndTick - waveStartTick;
float waveProgress = totalWaveTicks > 0 ? (float)ticksIntoWave / totalWaveTicks : 0;
timeTrackerText.text += $" | Wave: {(waveProgress * 100):F0}%";
}
}

void UpdateWaveStatus() {
if (waveStatusText == null) return;

if (RunManager.Instance == null) {
waveStatusText.text = "System Offline";
return;
}

if (RunManager.Instance.CurrentState == RunState.Planning) {
waveStatusText.text = $"Prepare for Round {RunManager.Instance.CurrentRoundNumber}";
}
else if (RunManager.Instance.CurrentState == RunState.GrowthAndThreat) {
if (currentWaveDef != null) {
int ticksRemaining = Mathf.Max(0, waveEndTick - TickManager.Instance.CurrentTick);
string waveName = string.IsNullOrEmpty(currentWaveDef.waveName)
? $"Wave {currentWaveIndex + 1}"
: currentWaveDef.waveName;

string status = currentState == WaveState.Spawning ? " [SPAWNING]" : "";
waveStatusText.text = $"{waveName}{status} - {ticksRemaining} ticks left";
}
else {
waveStatusText.text = "No active wave";
}
}
}

pub Camera GetMainCamera() => mainCamera;

void Debug_ForceEndWave() {
if (Application.isEditor && currentState != WaveState.Idle) {
EndCurrentWave();
}
}

void Debug_ForceSpawn() {
if (Application.isEditor && currentState == WaveState.Active && !hasSpawnedThisWave) {
StartSpawning();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Spawning\WaveDefinition.cs

﻿using UnityEngine;

pub enum WaveSpawnLocationType {
GlobalSpawnArea,
RandomNearPlayer,
Offscreen
}

pub cls WaveSpawnEntry {
pub string description = "Spawn Group";
pub AnimalDefinition animalDefinition;
pub int spawnCount = 1;
[Tooltip("Delay (in seconds) AFTER the designated wave spawn time (e.g. Day 50%) before *this entry* begins spawning.")] // Clarified Tooltip
pub float delayAfterSpawnTime = 0f; // Renamed from delayAfterWaveStart
pub float spawnInterval = 0.5f;
pub WaveSpawnLocationType spawnLocationType = WaveSpawnLocationType.GlobalSpawnArea;
pub float spawnRadius = 5f;
}

pub cls WaveDefinition : ScriptableObject {
pub string waveName = "New Wave";

pub List<WaveSpawnEntry> spawnEntries = new List<WaveSpawnEntry>();

}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\IStatusEffectable.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/IStatusEffectable.cs
using WegoSystem; // For GridEntity

pub ifc IStatusEffectable {
GridEntity GridEntity { get; }

StatusEffectManager StatusManager { get; }

string GetDisplayName();

void TakeDamage(float amount);
void Heal(float amount);
void ModifyHunger(float amount); // Can be left empty for player
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffect.cs

﻿using UnityEngine;

pub cls StatusEffect : ScriptableObject {
pub string effectID = "status_effect";
pub string displayName = "Status Effect";
pub Sprite icon;
pub string unicodeSymbol = "?";
pub Color effectColor = Color.white;

pub bool isPermanent = false;
pub int durationTicks = 10;

pub bool modifyAnimalColor = false;
pub Color animalTintColor = Color.white;
pub GameObject visualEffectPrefab;

pub bool damagePerTick = false;
pub float damageAmount = 0f;

pub bool healPerTick = false;
pub float healAmount = 0f;

pub bool modifyHunger = false;
pub float hungerModifier = 0f;

pub float visualInterpolationSpeedMultiplier = 1f;

pub float damageResistanceMultiplier = 1f;

pub int additionalMoveTicks = 0;

pub bool canStack = false;
pub int maxStacks = 1;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffectIconUI.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/StatusEffectIconUI.cs
using TMPro;

pub cls StatusEffectIconUI : MonoBehaviour {
Image iconImage;
TextMeshProUGUI iconText;
StatusEffect currentEffect;

pub void Initialize(StatusEffectInstance instance) {
currentEffect = instance.effect;

Transform iconTransform = transform.Find("Icon");
if (iconTransform != null) {
iconTransform.gameObject.SetActive(true);

iconImage = iconTransform.GetComponent<Image>();
iconText = iconTransform.GetComponentInChildren<TextMeshProUGUI>();

if (currentEffect.icon != null) {
if (iconImage != null) {
iconImage.sprite = currentEffect.icon;
iconImage.color = currentEffect.effectColor;
iconImage.enabled = true;
}
if (iconText != null) {
iconText.enabled = false;
}
}
else {
if (iconImage != null) {
iconImage.enabled = false;
}
if (iconText != null) {
iconText.text = currentEffect.unicodeSymbol;
iconText.color = currentEffect.effectColor;
iconText.enabled = true;
}
}
}
else {
Debug.LogError("Could not find child GameObject named 'Icon' in the StatusEffectIcon prefab!", this);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffectInstance.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/StatusEffectInstance.cs

pub cls StatusEffectInstance {
pub StatusEffect effect;
pub int remainingTicks;
pub int stackCount = 1;
pub GameObject visualEffectInstance;

pub StatusEffectInstance(StatusEffect effect) {
this.effect = effect;
this.remainingTicks = effect.durationTicks;
this.stackCount = 1;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffectManager.cs

﻿using UnityEngine;

pub cls StatusEffectManager : MonoBehaviour {
IStatusEffectable owner;
List<StatusEffectInstance> activeEffects = new List<StatusEffectInstance>();
Dictionary<string, StatusEffectInstance> effectLookup = new Dictionary<string, StatusEffectInstance>();

float cachedVisualInterpolationSpeedMultiplier = 1f;
float cachedDamageResistanceMultiplier = 1f;
int cachedAdditionalMoveTicks = 0;
Color originalColor;
SpriteRenderer spriteRenderer;

pub float VisualInterpolationSpeedMultiplier => cachedVisualInterpolationSpeedMultiplier;
pub float DamageResistanceMultiplier => cachedDamageResistanceMultiplier;
pub int AdditionalMoveTicks => cachedAdditionalMoveTicks;

pub void Initialize(IStatusEffectable owner) {
this.owner = owner;

Component ownerComponent = owner as Component;
if (ownerComponent != null) {
spriteRenderer = ownerComponent.GetComponentInChildren<SpriteRenderer>();
if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}
}
}

pub void OnTickUpdate(int currentTick) {
if (owner == null || (owner as Component) == null) {
Destroy(this);
return;
}

ProcessStatusEffects();
UpdateCachedModifiers();
UpdateVisualEffects();
}

pub void ApplyStatusEffect(StatusEffect effect) {
if (effect == null) return;

if (effectLookup.ContainsKey(effect.effectID)) {
var existing = effectLookup[effect.effectID];
if (effect.canStack && existing.stackCount < effect.maxStacks) {
existing.stackCount++;
existing.remainingTicks = effect.durationTicks;
}
else if (!effect.canStack) {
existing.remainingTicks = effect.durationTicks;
}
}
else {
var instance = new StatusEffectInstance(effect);
activeEffects.Add(instance);
effectLookup[effect.effectID] = instance;

if (effect.visualEffectPrefab != null) {
instance.visualEffectInstance = Instantiate(
effect.visualEffectPrefab,
(owner as Component).transform.position,
Quaternion.identity,
(owner as Component).transform
);
}
Debug.Log($"[StatusEffect] Applied {effect.displayName} to {owner.GetDisplayName()}");
}

UpdateCachedModifiers();
}

pub void RemoveStatusEffect(string effectID) {
if (!effectLookup.ContainsKey(effectID)) return;
var instance = effectLookup[effectID];
if (instance.visualEffectInstance != null) {
Destroy(instance.visualEffectInstance);
}
activeEffects.Remove(instance);
effectLookup.Remove(effectID);
Debug.Log($"[StatusEffect] Removed {instance.effect.displayName} from {owner.GetDisplayName()}");
UpdateCachedModifiers();
}

void ProcessStatusEffects() {
for (int i = activeEffects.Count - 1; i >= 0; i--) {
var instance = activeEffects[i];
var effect = instance.effect;

if (effect.damagePerTick) owner.TakeDamage(effect.damageAmount * instance.stackCount);
if (effect.healPerTick) owner.Heal(effect.healAmount * instance.stackCount);
if (effect.modifyHunger) owner.ModifyHunger(effect.hungerModifier * instance.stackCount);

if (!effect.isPermanent) {
instance.remainingTicks--;
if (instance.remainingTicks <= 0) {
RemoveStatusEffect(effect.effectID);
}
}
}
}

void UpdateCachedModifiers() {
cachedVisualInterpolationSpeedMultiplier = 1f;
cachedDamageResistanceMultiplier = 1f;
cachedAdditionalMoveTicks = 0;

foreach (var instance in activeEffects) {
var effect = instance.effect;
cachedVisualInterpolationSpeedMultiplier *= effect.visualInterpolationSpeedMultiplier;
cachedDamageResistanceMultiplier *= effect.damageResistanceMultiplier;
cachedAdditionalMoveTicks += effect.additionalMoveTicks * instance.stackCount;
}
}

pub bool HasStatusEffect(string effectID) {
ret effectLookup.ContainsKey(effectID);
}
void UpdateVisualEffects() {
if (spriteRenderer == null) return;
Color targetColor = originalColor;
bool hasColorEffect = false;
foreach (var instance in activeEffects) {
if (instance.effect.modifyAnimalColor) {
targetColor = instance.effect.animalTintColor;
hasColorEffect = true;
break;
}
}
spriteRenderer.color = hasColorEffect ? targetColor : originalColor;
}
pub List<StatusEffectInstance> GetActiveEffects() {
ret new List<StatusEffectInstance>(activeEffects);
}
pub void ClearAllEffects() {
for (int i = activeEffects.Count - 1; i >= 0; i--) {
RemoveStatusEffect(activeEffects[i].effect.effectID);
}
}
void OnDestroy() {
foreach (var instance in activeEffects) {
if (instance.visualEffectInstance != null) {
Destroy(instance.visualEffectInstance);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffectUIManager.cs

﻿// Assets/Scripts/Ecosystem/Status Effects/StatusEffectUIManager.cs
using TMPro;
using WegoSystem;

pub cls StatusEffectUIManager : MonoBehaviour {
[SerializeField] Transform effectIconContainer;
[SerializeField] GameObject effectIconPrefab;

StatusEffectManager statusManager;
Dictionary<string, StatusEffectIconUI> activeIcons = new Dictionary<string, StatusEffectIconUI>();

pub void Initialize(StatusEffectManager manager) {
statusManager = manager;

if (effectIconPrefab == null) {
CreateDefaultIconPrefab();
}
}

void Update() {
if (statusManager == null || effectIconContainer == null) return;

UpdateStatusIcons();
}

void UpdateStatusIcons() {
var currentEffectInstances = statusManager.GetActiveEffects();
var currentEffectIDs = currentEffectInstances.Select(e => e.effect.effectID).ToList();
var displayedIconIDs = activeIcons.Keys.ToList();

foreach (var id in displayedIconIDs) {
if (!currentEffectIDs.Contains(id)) {
if (activeIcons.TryGetValue(id, out StatusEffectIconUI iconToDestroy)) {
if (iconToDestroy != null) Destroy(iconToDestroy.gameObject);
}
activeIcons.Remove(id);
}
}

foreach (var instance in currentEffectInstances) {
if (!activeIcons.ContainsKey(instance.effect.effectID)) {
CreateEffectIcon(instance);
}
}

for (int i = 0; i < currentEffectInstances.Count; i++) {
string effectID = currentEffectInstances[i].effect.effectID;
if (activeIcons.TryGetValue(effectID, out StatusEffectIconUI iconUI)) {
iconUI.transform.SetSiblingIndex(i);
}
}
}

void CreateEffectIcon(StatusEffectInstance instance) {
if (effectIconPrefab == null) {
Debug.LogError("Effect Icon Prefab is missing!", this);
return;
}

GameObject iconObj = Instantiate(effectIconPrefab, effectIconContainer);
iconObj.SetActive(true);
StatusEffectIconUI iconUI = iconObj.GetComponent<StatusEffectIconUI>();

if (iconUI == null) iconUI = iconObj.AddComponent<StatusEffectIconUI>();

iconUI.Initialize(instance);
activeIcons[instance.effect.effectID] = iconUI;
}

void CreateDefaultIconPrefab() {
float iconSize = 0.32f; // e.g., 0.32 world units
float iconPadding = 0.04f;
float fontSize = 0.2f;

GameObject prefab = new GameObject("StatusEffectIcon");
prefab.AddComponent<RectTransform>().sizeDelta = new Vector2(iconSize, iconSize);
prefab.AddComponent<LayoutElement>();

GameObject bg = new GameObject("Background");
bg.transform.SetParent(prefab.transform, false);
Image bgImage = bg.AddComponent<Image>();
bgImage.color = new Color(0, 0, 0, 0.5f);
bg.GetComponent<RectTransform>().sizeDelta = new Vector2(iconSize, iconSize);

GameObject icon = new GameObject("Icon");
icon.transform.SetParent(prefab.transform, false);
Image iconImage = icon.AddComponent<Image>();
iconImage.enabled = false;
icon.GetComponent<RectTransform>().sizeDelta = new Vector2(iconSize - iconPadding, iconSize - iconPadding);

GameObject unicodeTextGO = new GameObject("UnicodeText");
unicodeTextGO.transform.SetParent(icon.transform, false);
TextMeshProUGUI tmpText = unicodeTextGO.AddComponent<TextMeshProUGUI>();
tmpText.text = "?";
tmpText.fontSize = fontSize; // Use the smaller font size
tmpText.alignment = TextAlignmentOptions.Center;
tmpText.enabled = false;
RectTransform textRect = tmpText.GetComponent<RectTransform>();
textRect.anchorMin = Vector2.zero;
textRect.anchorMax = Vector2.one;
textRect.sizeDelta = Vector2.zero;
textRect.anchoredPosition = Vector2.zero;

effectIconPrefab = prefab;
effectIconPrefab.SetActive(false);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\UI\ThoughtBubbleController.cs

﻿// Assets/Scripts/Ecosystem/UI/ThoughtBubbleController.cs

using TMPro;
using WegoSystem;

pub cls ThoughtBubbleController : MonoBehaviour {
pub TMP_Text messageText;

float lifetimeTicks;
Transform followTarget;
TickManager _tickManagerInstance; // Cached instance

void Start() {
_tickManagerInstance = TickManager.Instance;
if (_tickManagerInstance == null) {
Debug.LogWarning($"[{GetType().Name}] TickManager not found! Lifetime will use a fallback duration.", this);
}
}

pub void Initialize(string message, Transform target, float durationInTicks) {
if (messageText != null)
messageText.text = message;

followTarget = target;
lifetimeTicks = durationInTicks;
}

void Update() {
if (_tickManagerInstance?.Config != null) {
lifetimeTicks -= _tickManagerInstance.Config.ticksPerRealSecond * Time.deltaTime;
}
else {
lifetimeTicks -= 2f * Time.deltaTime;
}

if (lifetimeTicks <= 0f)
Destroy(gameObject);

if (followTarget != null) {
transform.position = followTarget.position;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\UI\ThoughtTrigger.cs

﻿using UnityEngine;

pub enum ThoughtTrigger {
Hungry,
Eating,
HealthLow,
Fleeing,
Pooping,
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\RadiusPatternTester.cs

﻿using UnityEngine;
using WegoSystem;

#if UNITY_EDITOR
using UnityEditor;

pub cls RadiusPatternTesterEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

RadiusPatternTester tester = (RadiusPatternTester)target;

if (GUILayout.Button("Test Radius Pattern")) {
tester.TestRadiusPattern();
}

if (GUILayout.Button("Compare All Patterns")) {
tester.CompareAllPatterns();
}
}
}
#endif

pub cls RadiusPatternTester : MonoBehaviour {
pub int testRadius = 3;

pub void TestRadiusPattern() {
GridRadiusUtility.DebugPrintRadius(GridPosition.Zero, testRadius);
}

pub void CompareAllPatterns() {
Debug.Log("=== RADIUS PATTERN COMPARISON ===");

for (int r = 1; r <= 5; r++) {
Debug.Log($"\n--- Radius {r} ---");

var circleTiles = GridRadiusUtility.GetTilesInCircle(GridPosition.Zero, r);
Debug.Log($"Circle tiles: {circleTiles.Count}");

GridRadiusUtility.DebugPrintRadius(GridPosition.Zero, r);

int manhattanCount = 0;
int chebyshevCount = 0;

for (int x = -r; x <= r; x++) {
for (int y = -r; y <= r; y++) {
if (Mathf.Abs(x) + Mathf.Abs(y) <= r) manhattanCount++;
if (Mathf.Max(Mathf.Abs(x), Mathf.Abs(y)) <= r) chebyshevCount++;
}
}

Debug.Log($"Manhattan (diamond): {manhattanCount} tiles");
Debug.Log($"Chebyshev (square): {chebyshevCount} tiles");
Debug.Log($"Circle (ours): {circleTiles.Count} tiles");
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\TileDefinitionEditor.cs

﻿#if UNITY_EDITOR
using UnityEditor;

pub cls TileDefinitionEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

TileDefinition tileDefinition = (TileDefinition)target;

EditorGUILayout.Space();
if (GUILayout.Button("UPDATE COLOR IN SCENE", GUILayout.Height(30))) {
tileDefinition.UpdateColor();
}
}
}
#endif

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\WaveDefinitionEditor.cs

﻿using UnityEngine;
using UnityEditor;
using UnityEditorInternal;

pub cls WaveDefinitionEditor : Editor {
ReorderableList spawnList;
SerializedProperty spawnEntries;

void OnEnable() {
spawnEntries = serializedObject.FindProperty("spawnEntries");

spawnList = new ReorderableList(serializedObject, spawnEntries, true, true, true, true);

spawnList.drawHeaderCallback = (Rect rect) => {
EditorGUI.LabelField(rect, "Spawn Entries");
};

spawnList.elementHeightCallback = (int index) => {
ret EditorGUIUtility.singleLineHeight * 4 + 10;
};

spawnList.drawElementCallback = (Rect rect, int index, bool isActive, bool isFocused) => {
var element = spawnEntries.GetArrayElementAtIndex(index);
rect.y += 2;

float lineHeight = EditorGUIUtility.singleLineHeight;
float spacing = 2;

Rect descRect = new Rect(rect.x, rect.y, rect.width * 0.4f, lineHeight);
Rect animalRect = new Rect(rect.x + rect.width * 0.42f, rect.y, rect.width * 0.58f, lineHeight);

EditorGUI.PropertyField(descRect, element.FindPropertyRelative("description"), GUIContent.none);
EditorGUI.PropertyField(animalRect, element.FindPropertyRelative("animalDefinition"), GUIContent.none);

rect.y += lineHeight + spacing;

Rect countRect = new Rect(rect.x, rect.y, rect.width * 0.3f, lineHeight);
Rect delayRect = new Rect(rect.x + rect.width * 0.32f, rect.y, rect.width * 0.3f, lineHeight);
Rect intervalRect = new Rect(rect.x + rect.width * 0.64f, rect.y, rect.width * 0.36f, lineHeight);

EditorGUI.LabelField(countRect, "Count:");
countRect.x += 40;
countRect.width -= 40;
EditorGUI.PropertyField(countRect, element.FindPropertyRelative("spawnCount"), GUIContent.none);

EditorGUI.LabelField(delayRect, "Delay:");
delayRect.x += 35;
delayRect.width -= 35;
EditorGUI.PropertyField(delayRect, element.FindPropertyRelative("delayAfterSpawnTime"), GUIContent.none);

EditorGUI.LabelField(intervalRect, "Interval:");
intervalRect.x += 45;
intervalRect.width -= 45;
EditorGUI.PropertyField(intervalRect, element.FindPropertyRelative("spawnInterval"), GUIContent.none);

rect.y += lineHeight + spacing;

Rect locTypeRect = new Rect(rect.x, rect.y, rect.width * 0.6f, lineHeight);
Rect radiusRect = new Rect(rect.x + rect.width * 0.62f, rect.y, rect.width * 0.38f, lineHeight);

EditorGUI.PropertyField(locTypeRect, element.FindPropertyRelative("spawnLocationType"), GUIContent.none);

EditorGUI.LabelField(radiusRect, "Radius:");
radiusRect.x += 45;
radiusRect.width -= 45;
EditorGUI.PropertyField(radiusRect, element.FindPropertyRelative("spawnRadius"), GUIContent.none);
};

spawnList.onAddCallback = (ReorderableList list) => {
var index = list.serializedProperty.arraySize;
list.serializedProperty.arraySize++;
list.index = index;

var element = list.serializedProperty.GetArrayElementAtIndex(index);
element.FindPropertyRelative("description").stringValue = "New Spawn Entry";
element.FindPropertyRelative("spawnCount").intValue = 1;
element.FindPropertyRelative("delayAfterSpawnTime").floatValue = 0f;
element.FindPropertyRelative("spawnInterval").floatValue = 0.5f;
element.FindPropertyRelative("spawnRadius").floatValue = 5f;
};
}

pub ovr void OnInspectorGUI() {
serializedObject.Update();

WaveDefinition waveDef = (WaveDefinition)target;

EditorGUILayout.LabelField("Wave Definition", EditorStyles.boldLabel);
EditorGUILayout.Space();

EditorGUILayout.BeginHorizontal();
EditorGUILayout.LabelField("Wave Name:", GUILayout.Width(80));
SerializedProperty waveNameProp = serializedObject.FindProperty("waveName");
waveNameProp.stringValue = EditorGUILayout.TextField(waveNameProp.stringValue);
EditorGUILayout.EndHorizontal();

EditorGUILayout.Space();

int totalEnemies = 0;
float totalDuration = 0;

foreach (WaveSpawnEntry entry in waveDef.spawnEntries) {
if (entry != null) {
totalEnemies += entry.spawnCount;
totalDuration = Mathf.Max(totalDuration,
entry.delayAfterSpawnTime + (entry.spawnCount - 1) * entry.spawnInterval);
}
}

EditorGUILayout.HelpBox(
$"Total Enemies: {totalEnemies}\n" +
$"Spawn Duration: ~{totalDuration:F1} seconds",
MessageType.Info
);

EditorGUILayout.Space();

spawnList.DoLayoutList();

serializedObject.ApplyModifiedProperties();

EditorGUILayout.Space();

if (GUILayout.Button("Clear All Entries")) {
if (EditorUtility.DisplayDialog("Clear All Entries",
"Are you sure you want to remove all spawn entries?",
"Clear", "Cancel")) {
waveDef.spawnEntries.Clear();
EditorUtility.SetDirty(waveDef);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\WaveManagerEditor.cs

﻿using UnityEngine;
using UnityEditor;
using WegoSystem;

pub cls WaveManagerEditor : Editor {
SerializedProperty waveDurationInDays;
SerializedProperty spawnTimeNormalized;
SerializedProperty continuousSpawning;
SerializedProperty deletePreviousWaveAnimals;
SerializedProperty wavesSequence;

bool showTimingSettings = true;
bool showWaveSequence = true;
bool showDebugInfo = false;

void OnEnable() {
waveDurationInDays = serializedObject.FindProperty("waveDurationInDays");
spawnTimeNormalized = serializedObject.FindProperty("spawnTimeNormalized");
continuousSpawning = serializedObject.FindProperty("continuousSpawning");
deletePreviousWaveAnimals = serializedObject.FindProperty("deletePreviousWaveAnimals");
wavesSequence = serializedObject.FindProperty("wavesSequence");
}

pub ovr void OnInspectorGUI() {
serializedObject.Update();

WaveManager waveManager = (WaveManager)target;

EditorGUILayout.LabelField("Wave Manager", EditorStyles.boldLabel);
EditorGUILayout.Space();

DrawPropertiesExcluding(serializedObject,
"waveDurationInDays",
"spawnTimeNormalized",
"continuousSpawning",
"deletePreviousWaveAnimals",
"wavesSequence"
);

EditorGUILayout.Space();

showTimingSettings = EditorGUILayout.BeginFoldoutHeaderGroup(showTimingSettings, "Wave Timing Settings");
if (showTimingSettings) {
EditorGUI.indentLevel++;

EditorGUILayout.BeginHorizontal();
EditorGUILayout.PropertyField(waveDurationInDays, new GUIContent("Wave Duration (Days)"));
EditorGUILayout.EndHorizontal();

if (Application.isPlaying && TickManager.Instance?.Config != null) {
var config = TickManager.Instance.Config;
int totalTicks = config.ticksPerDay * waveDurationInDays.intValue;
EditorGUILayout.HelpBox($"Wave will last {totalTicks} ticks", MessageType.Info);
}

EditorGUILayout.Space();

float spawnPercent = spawnTimeNormalized.floatValue * 100f;
EditorGUILayout.LabelField($"Spawn Start: {spawnPercent:F0}% into wave");
spawnTimeNormalized.floatValue = EditorGUILayout.Slider("Spawn Time", spawnTimeNormalized.floatValue, 0f, 1f);

DrawTimingBar(spawnTimeNormalized.floatValue);

EditorGUILayout.Space();

EditorGUILayout.PropertyField(continuousSpawning, new GUIContent("Continuous Spawning", "If enabled, enemies spawn throughout the wave"));

EditorGUI.indentLevel--;
}
EditorGUILayout.EndFoldoutHeaderGroup();

EditorGUILayout.Space();

EditorGUILayout.PropertyField(deletePreviousWaveAnimals, new GUIContent("Clear Previous Wave", "Delete all animals when starting a new wave"));

EditorGUILayout.Space();

showWaveSequence = EditorGUILayout.BeginFoldoutHeaderGroup(showWaveSequence, "Wave Sequence");
if (showWaveSequence) {
EditorGUI.indentLevel++;

if (wavesSequence.arraySize == 0) {
EditorGUILayout.HelpBox("No waves defined! Add wave definitions to the sequence.", MessageType.Warning);
}

for (int i = 0; i < wavesSequence.arraySize; i++) {
EditorGUILayout.BeginHorizontal();

var element = wavesSequence.GetArrayElementAtIndex(i);
var waveDef = element.objectReferenceValue as WaveDefinition;

string label = $"Round {i + 1}";
if (waveDef != null && !string.IsNullOrEmpty(waveDef.waveName)) {
label += $": {waveDef.waveName}";
}

EditorGUILayout.PropertyField(element, new GUIContent(label));

if (GUILayout.Button("X", GUILayout.Width(20))) {
wavesSequence.DeleteArrayElementAtIndex(i);
break;
}

EditorGUILayout.EndHorizontal();
}

EditorGUILayout.BeginHorizontal();
GUILayout.FlexibleSpace();
if (GUILayout.Button("Add Wave", GUILayout.Width(100))) {
wavesSequence.InsertArrayElementAtIndex(wavesSequence.arraySize);
}
EditorGUILayout.EndHorizontal();

EditorGUI.indentLevel--;
}
EditorGUILayout.EndFoldoutHeaderGroup();

EditorGUILayout.Space();

if (Application.isPlaying) {
showDebugInfo = EditorGUILayout.BeginFoldoutHeaderGroup(showDebugInfo, "Runtime Debug");
if (showDebugInfo) {
EditorGUI.indentLevel++;

EditorGUILayout.LabelField("Status", waveManager.IsWaveActive ? "Wave Active" : "Idle");

if (waveManager.IsWaveActive && TickManager.Instance != null) {
EditorGUILayout.Space();
DrawRuntimeWaveProgress(waveManager);
}

EditorGUILayout.Space();

EditorGUILayout.BeginHorizontal();
if (GUILayout.Button("Force End Wave")) {
waveManager.SendMessage("Debug_ForceEndWave", SendMessageOptions.DontRequireReceiver);
}
if (GUILayout.Button("Force Spawn")) {
waveManager.SendMessage("Debug_ForceSpawn", SendMessageOptions.DontRequireReceiver);
}
EditorGUILayout.EndHorizontal();

EditorGUI.indentLevel--;
}
EditorGUILayout.EndFoldoutHeaderGroup();
}

serializedObject.ApplyModifiedProperties();
}

void DrawTimingBar(float spawnTime) {
Rect rect = GUILayoutUtility.GetRect(0, 20, GUILayout.ExpandWidth(true));

EditorGUI.DrawRect(rect, new Color(0.2f, 0.2f, 0.2f));

Rect waveRect = new Rect(rect.x, rect.y, rect.width, rect.height);
EditorGUI.DrawRect(waveRect, new Color(0.3f, 0.5f, 0.3f));

float spawnX = rect.x + (rect.width * spawnTime);
Rect spawnRect = new Rect(spawnX - 2, rect.y, 4, rect.height);
EditorGUI.DrawRect(spawnRect, Color.yellow);

GUI.Label(new Rect(rect.x, rect.y, 50, rect.height), "Start", EditorStyles.miniLabel);
GUI.Label(new Rect(rect.x + rect.width - 30, rect.y, 30, rect.height), "End", EditorStyles.miniLabel);
GUI.Label(new Rect(spawnX - 25, rect.y - 20, 50, 20), "Spawn", EditorStyles.centeredGreyMiniLabel);
}

void DrawRuntimeWaveProgress(WaveManager waveManager) {
EditorGUILayout.HelpBox("Wave progress visualization requires exposing runtime data", MessageType.Info);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\GeneLibraryLoader.cs

﻿using UnityEngine;
using Abracodabra.Genes;
using Abracodabra.Genes.Services;

pub cls GeneLibraryLoader : MonoBehaviour {
GeneLibrary geneLibraryAsset;

void Awake() {

if (geneLibraryAsset == null) {
Debug.LogError("CRITICAL: The GeneLibrary Asset is not assigned in the GeneLibraryLoader component! The gene system will not work.", this);
return;
}

geneLibraryAsset.SetActiveInstance();

GeneServices.Register<IGeneLibrary>(geneLibraryAsset);

Debug.Log("GeneLibrary instance was successfully set, initialized, and registered by GeneLibraryLoader.");
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\ITriggerTarget.cs

﻿// Assets/Scripts/PlantSystem/Execution/ITriggerTarget.cs

pub ifc ITriggerTarget {
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\LeafData.cs

﻿using UnityEngine;

pub struct LeafData {
pub Vector2Int GridCoord;
pub bool IsActive; // True if the leaf exists, false if it was eaten

pub LeafData(Vector2Int coord, bool isActive = true) {
GridCoord = coord;
IsActive = isActive;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Execution\NodeExecutor.cs

﻿using UnityEngine;
using Abracodabra.Genes;
using WegoSystem;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;

pub cls NodeExecutor : MonoBehaviour {
[SerializeField] GameObject plantPrefab;

pub GameObject SpawnPlantFromState(PlantGeneRuntimeState runtimeState, Vector3 plantingPosition, Transform parentTransform) {
if (runtimeState == null) {
Debug.LogError("[NodeExecutor] Cannot spawn plant: Provided PlantGeneRuntimeState is null!");
ret null;
}

if (plantPrefab == null) {
Debug.LogError("[NodeExecutor] Plant prefab not assigned!");
ret null;
}

GameObject plantObj = Instantiate(plantPrefab, plantingPosition, Quaternion.identity, parentTransform);

PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
if (growthComponent != null) {
growthComponent.InitializeWithState(runtimeState);
Debug.Log($"[NodeExecutor] Plant spawned from seed template '{runtimeState.template.templateName}'");
ret plantObj;
}
else {
Debug.LogError($"[NodeExecutor] Plant prefab is missing the required PlantGrowth component!");
Destroy(plantObj);
ret null;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantCell.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/Growth/PlantCell.cs

using Abracodabra.Genes;

pub enum PlantCellType { Seed, Stem, Leaf, Flower, Fruit }

pub cls PlantCell : MonoBehaviour {
[HideInInspector] pub PlantGrowth ParentPlantGrowth;
[HideInInspector] pub Vector2Int GridCoord;
[HideInInspector] pub PlantCellType CellType;

void OnDestroy() {
if (ParentPlantGrowth != null) {
ParentPlantGrowth.ReportCellDestroyed(GridCoord);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantCellManager.cs

﻿using UnityEngine;
using Abracodabra.Genes;
using WegoSystem;

pub cls PlantCellManager {
ro PlantGrowth plant;
ro GameObject seedCellPrefab;
ro GameObject stemCellPrefab;
ro GameObject leafCellPrefab;
ro GameObject berryCellPrefab;
ro FoodType _leafFoodType;

pub ro Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
ro List<GameObject> activeCellGameObjects = new List<GameObject>();

pub List<LeafData> LeafDataList { get; } = new List<LeafData>();
pub GameObject RootCellInstance { get; set; }

pub PlantCellManager(PlantGrowth plant, GameObject seedPrefab, GameObject stemPrefab, GameObject leafPrefab, GameObject berryPrefab, FoodType leafFoodType) {
this.plant = plant;
this.seedCellPrefab = seedPrefab;
this.stemCellPrefab = stemPrefab;
this.leafCellPrefab = leafPrefab;
this.berryCellPrefab = berryPrefab;
this._leafFoodType = leafFoodType;
}

pub GameObject SpawnCellVisual(PlantCellType cellType, Vector2Int coords) {
if (cells.ContainsKey(coords)) {
Debug.LogWarning($"[{plant.gameObject.name}] Cell already exists at {coords}. Skipping spawn.");
ret GetCellGameObjectAt(coords);
}

GameObject prefab = GetPrefabForType(cellType);
if (prefab == null) ret null;

float spacing = plant.GetCellWorldSpacing();
Vector3 cellLocalPos = new Vector3(coords.x * spacing, coords.y * spacing, 0);
Vector3 cellWorldPos = plant.transform.position + cellLocalPos;

GameObject instance = Object.Instantiate(prefab, cellWorldPos, Quaternion.identity, plant.transform);

PlantCell cellComponent = instance.GetComponent<PlantCell>();
if (cellComponent == null) {
cellComponent = instance.AddComponent<PlantCell>();
}
cellComponent.ParentPlantGrowth = plant;
cellComponent.GridCoord = coords;
cellComponent.CellType = cellType;

cells[coords] = cellType;
activeCellGameObjects.Add(instance);

if (cellType == PlantCellType.Seed) {
RootCellInstance = instance;
}
else if (cellType == PlantCellType.Leaf) {
LeafDataList.Add(new LeafData(coords, true));

var foodItem = instance.GetComponent<FoodItem>();
if (foodItem != null) {
if (_leafFoodType == null) {
Debug.LogError($"[PlantCellManager] Cannot assign FoodType to new leaf on '{plant.name}' because the 'Leaf Food Type' field is not set!", plant);
}

GridPosition gridPos = GridPositionManager.Instance.WorldToGrid(cellWorldPos);

foodItem.InitializeAsPlantPart(_leafFoodType, gridPos);
}
else {
Debug.LogWarning($"[{plant.gameObject.name}] Leaf prefab is missing FoodItem component.", plant);
}
}

plant.VisualManager.RegisterShadowForCell(instance, cellType.ToString());
plant.VisualManager.RegisterOutlineForCell(instance, cellType.ToString());

ret instance;
}

pub void ReportCellDestroyed(Vector2Int coord) {
if (cells.TryGetValue(coord, out PlantCellType cellType)) {
GameObject cellObj = GetCellGameObjectAt(coord);

if (cellObj != null) {
plant.VisualManager.UnregisterShadowForCell(cellObj);
plant.VisualManager.OutlineController?.OnPlantCellRemoved(coord);
activeCellGameObjects.Remove(cellObj);
Object.Destroy(cellObj);
}

if (cellType == PlantCellType.Leaf) {
for (int i = 0; i < LeafDataList.Count; i++) {
if (LeafDataList[i].GridCoord == coord) {
LeafDataList[i] = new LeafData(coord, false);
break;
}
}
}

cells.Remove(coord);
}
}

pub void ClearAllVisuals() {
foreach (GameObject cellGO in new List<GameObject>(activeCellGameObjects)) {
if (cellGO != null) {
Object.Destroy(cellGO);
}
}
activeCellGameObjects.Clear();
cells.Clear();
RootCellInstance = null;
}

GameObject GetPrefabForType(PlantCellType cellType) {
switch (cellType) {
case PlantCellType.Seed: ret seedCellPrefab;
case PlantCellType.Stem: ret stemCellPrefab;
case PlantCellType.Leaf: ret leafCellPrefab;
case PlantCellType.Fruit: ret berryCellPrefab;
default:
Debug.LogError($"[{plant.gameObject.name}] No prefab assigned for PlantCellType.{cellType}!");
ret null;
}
}

pub bool HasCellAt(Vector2Int coord) => cells.ContainsKey(coord);
pub GameObject GetCellGameObjectAt(Vector2Int coord) => activeCellGameObjects.FirstOrDefault(go => go != null && go.GetComponent<PlantCell>()?.GridCoord == coord);
pub int GetActiveLeafCount() => LeafDataList.Count(leaf => leaf.IsActive);
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantEnergySystem.cs

﻿using Abracodabra.Genes;
using WegoSystem;

pub cls PlantEnergySystem {
ro PlantGrowth plant;

pub float CurrentEnergy { get; set; }
pub float MaxEnergy { get; set; }
pub float BaseEnergyPerLeaf { get; set; } // Base rate from template

ro FireflyManager fireflyManagerInstance;

pub PlantEnergySystem(PlantGrowth plant) {
this.plant = plant;
this.fireflyManagerInstance = FireflyManager.Instance;
}

pub void OnTickUpdate() {
if (plant.CurrentState == PlantState.Growing &&
plant.gameObject.GetComponent<PlantGrowth>()?.rechargeEnergyDuringGrowth == false) {
return;
}

if (plant.GrowthLogic == null || MaxEnergy <= 0) return;

int leafCount = plant.CellManager.GetActiveLeafCount();
if (leafCount <= 0) return;

float sunlight = (WeatherManager.Instance != null) ? WeatherManager.Instance.sunIntensity : 1f;

float fireflyBonusRate = 0f;
if (fireflyManagerInstance != null && fireflyManagerInstance.isActiveAndEnabled) {
int nearbyFlyCount = fireflyManagerInstance.GetNearbyFireflyCount(plant.transform.position, fireflyManagerInstance.photosynthesisRadius);
fireflyBonusRate = Mathf.Min(
nearbyFlyCount * fireflyManagerInstance.photosynthesisIntensityPerFly,
fireflyManagerInstance.maxPhotosynthesisBonus
);
}

float effectiveRate = BaseEnergyPerLeaf * plant.energyGenerationMultiplier;
float totalPhotosynthesisRatePerLeaf = (effectiveRate * sunlight) + fireflyBonusRate;
float energyThisTick = totalPhotosynthesisRatePerLeaf * leafCount;

CurrentEnergy = UnityEngine.Mathf.Clamp(CurrentEnergy + energyThisTick, 0f, MaxEnergy);
}

pub void SpendEnergy(float amount) {
CurrentEnergy = UnityEngine.Mathf.Max(0f, CurrentEnergy - amount);
}

pub void AddEnergy(float amount) {
CurrentEnergy = UnityEngine.Mathf.Clamp(CurrentEnergy + amount, 0f, MaxEnergy);
}

pub bool HasEnergy(float amount) {
ret CurrentEnergy >= amount;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantGrowthLogic.cs

﻿using UnityEngine;
using Abracodabra.Genes;
using Abracodabra.Genes.Core;

pub cls PlantGrowthLogic {
ro PlantGrowth plant;

pub int TargetStemLength { get; set; }
pub int GrowthTicksPerStage { get; set; }
pub float PhotosynthesisEfficiencyPerLeaf { get; set; }

pub PlantGrowthLogic(PlantGrowth plant) {
this.plant = plant;
}

pub void CalculateAndApplyPassiveStats() {
if (plant.geneRuntimeState == null) {
Debug.LogError($"[{plant.gameObject.name}] CalculateAndApplyStats called with null geneRuntimeState!");
return;
}

plant.growthSpeedMultiplier = 1f;
plant.energyGenerationMultiplier = 1f;
plant.energyStorageMultiplier = 1f;
plant.fruitYieldMultiplier = 1f;

var additiveBonuses = new Dictionary<PassiveStatType, float>();
var multiplicativeBonuses = new Dictionary<PassiveStatType, float>();

foreach (var instance in plant.geneRuntimeState.passiveInstances) {
var passiveGene = instance.GetGene<PassiveGene>();
if (passiveGene == null) continue;

float value = passiveGene.baseValue * instance.GetValue("power_multiplier", 1f);

if (passiveGene.stacksAdditively) {
if (!additiveBonuses.ContainsKey(passiveGene.statToModify))
additiveBonuses[passiveGene.statToModify] = 0f;
additiveBonuses[passiveGene.statToModify] += (value - 1f);
}
else {
if (!multiplicativeBonuses.ContainsKey(passiveGene.statToModify))
multiplicativeBonuses[passiveGene.statToModify] = 1f;
multiplicativeBonuses[passiveGene.statToModify] *= value;
}
}

foreach (var kvp in additiveBonuses) {
ApplyStat(kvp.Key, 1f + kvp.Value); // Apply the summed bonuses
}
foreach (var kvp in multiplicativeBonuses) {
ApplyStat(kvp.Key, kvp.Value); // Apply the compounded multipliers
}

if (plant.EnergySystem != null) {
plant.EnergySystem.BaseEnergyPerLeaf = PhotosynthesisEfficiencyPerLeaf;
}

Debug.Log($"[{plant.gameObject.name}] Final stats after passives: " +
$"GrowthSpeed={plant.growthSpeedMultiplier:F2}x, " +
$"EnergyGen={plant.energyGenerationMultiplier:F2}x, " +
$"EnergyStore={plant.energyStorageMultiplier:F2}x, " +
$"FruitYield={plant.fruitYieldMultiplier:F2}x");
}

void ApplyStat(PassiveStatType stat, float value) {
switch (stat) {
case PassiveStatType.GrowthSpeed:
plant.growthSpeedMultiplier *= value;
break;
case PassiveStatType.EnergyGeneration:
plant.energyGenerationMultiplier *= value;
break;
case PassiveStatType.EnergyStorage:
plant.energyStorageMultiplier *= value;
break;
case PassiveStatType.FruitYield:
plant.fruitYieldMultiplier *= value;
break;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantVisualManager.cs

﻿using UnityEngine;
using Abracodabra.Genes;
using TMPro;

pub cls PlantVisualManager {
ro PlantGrowth plant;
ro PlantShadowController shadowController;
ro GameObject shadowPartPrefab;
ro bool enableOutline;
pub PlantOutlineController OutlineController { get; set; }
ro GameObject outlinePartPrefab;
TMP_Text energyText;

pub PlantVisualManager(PlantGrowth plant, PlantShadowController shadowController, GameObject shadowPartPrefab, PlantOutlineController outlineController, GameObject outlinePartPrefab, bool enableOutline) {
this.plant = plant;
this.shadowController = shadowController;
this.shadowPartPrefab = shadowPartPrefab;
this.OutlineController = outlineController;
this.outlinePartPrefab = outlinePartPrefab;
this.enableOutline = enableOutline;

FindEnergyTextComponent();
}

void FindEnergyTextComponent() {
energyText = plant.GetComponentInChildren<TMP_Text>(true);

if (energyText == null) {
GameObject textObj = new GameObject("EnergyText");
textObj.transform.SetParent(plant.transform);
textObj.transform.localPosition = new Vector3(0, -0.5f, 0);

energyText = textObj.AddComponent<TextMeshPro>();
energyText.text = "0/0";
energyText.fontSize = 2;
energyText.alignment = TextAlignmentOptions.Center;

MeshRenderer textRenderer = energyText.GetComponent<MeshRenderer>();
if (textRenderer != null) {
textRenderer.sortingOrder = 100; // Ensure it renders on top
}
}
}

pub void RegisterShadowForCell(GameObject cellInstance, string cellTypeName) {
if (shadowController != null && shadowPartPrefab != null && cellInstance != null &&
cellInstance.TryGetComponent<SpriteRenderer>(out var partRenderer)) {
shadowController.RegisterPlantPart(partRenderer, shadowPartPrefab);
}
}

pub void UnregisterShadowForCell(GameObject cellInstance) {
if (shadowController != null && cellInstance != null &&
cellInstance.TryGetComponent<SpriteRenderer>(out var partRenderer)) {
shadowController.UnregisterPlantPart(partRenderer);
}
}

pub void RegisterOutlineForCell(GameObject cellInstance, string cellTypeName) {
if (enableOutline && OutlineController != null && cellInstance != null &&
cellInstance.TryGetComponent<SpriteRenderer>(out var partRenderer)) {
OutlineController.RegisterPlantPart(partRenderer, outlinePartPrefab);
}
}

pub void UpdateUI() {
if (energyText == null) {
FindEnergyTextComponent();
if (energyText == null) return;
}

if (plant.CurrentState == PlantState.Growing || plant.CurrentState == PlantState.Initializing) {
UpdateGrowthPercentageUI();
}
else {
UpdateEnergyUI();
}
}

void UpdateGrowthPercentageUI() {
if (energyText != null) {
int currentHeight = plant.CellManager.cells.Count(c => c.Value == PlantCellType.Stem);
int maxHeight = plant.maxHeight;
float percentage = (maxHeight > 0) ? (currentHeight / (float)maxHeight * 100f) : 0f;
energyText.text = $"Growing {percentage:F0}%";
}
}

void UpdateEnergyUI() {
if (energyText == null || plant.EnergySystem == null) return;

float currentEnergy = plant.EnergySystem.CurrentEnergy;
float maxEnergy = plant.EnergySystem.MaxEnergy;
energyText.text = $"{currentEnergy:F0}/{maxEnergy:F0}";
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryBarItem.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Templates;

pub cls InventoryBarItem {
pub enum ItemType { Gene, Seed, Tool }

pub ItemType Type { get; set; }
pub RuntimeGeneInstance GeneInstance { get; set; }
pub ToolDefinition ToolDefinition { get; set; }

pub SeedTemplate SeedTemplate { get; set; }
pub PlantGeneRuntimeState SeedRuntimeState { get; set; }

pub stat InventoryBarItem FromGene(RuntimeGeneInstance instance) {
if (instance == null) ret null;
ret new InventoryBarItem {
Type = ItemType.Gene,
GeneInstance = instance
};
}

pub stat InventoryBarItem FromSeed(SeedTemplate seed) {
if (seed == null) ret null;
ret new InventoryBarItem {
Type = ItemType.Seed,
SeedTemplate = seed,
SeedRuntimeState = seed.CreateRuntimeState()
};
}

pub stat InventoryBarItem FromTool(ToolDefinition tool) {
if (tool == null) ret null;
ret new InventoryBarItem {
Type = ItemType.Tool,
ToolDefinition = tool
};
}

pub string GetDisplayName() {
switch (Type) {
case ItemType.Gene: ret GeneInstance?.GetGene()?.geneName ?? "Unknown Gene";
case ItemType.Seed: ret SeedTemplate?.templateName ?? "Unknown Seed";
case ItemType.Tool: ret ToolDefinition?.displayName ?? "Unknown Tool";
default: ret "Invalid Item";
}
}

pub Sprite GetIcon() {
switch (Type) {
case ItemType.Gene: ret GeneInstance?.GetGene()?.icon;
case ItemType.Seed: ret SeedTemplate?.icon;
case ItemType.Tool: ret ToolDefinition?.icon;
default: ret null;
}
}

pub bool IsValid() {
switch (Type) {
case ItemType.Gene: ret GeneInstance?.GetGene() != null;
case ItemType.Seed: ret SeedTemplate != null && SeedRuntimeState != null;
case ItemType.Tool: ret ToolDefinition != null;
default: ret false;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryColorManager.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/UI/InventoryColorManager.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;

pub cls InventoryColorManager : MonoBehaviour {
pub stat InventoryColorManager Instance { get; set; }

[SerializeField] Color toolCellColor = new Color(0.5f, 0.5f, 0.5f, 1f);
[SerializeField] Color seedCellColor = new Color(0.8f, 1f, 0.8f, 1f);
[SerializeField] Color passiveGeneCellColor = new Color(0.8f, 0.8f, 1f, 1f);
[SerializeField] Color activeGeneCellColor = new Color(1f, 0.8f, 0.8f, 1f);
[SerializeField] Color modifierGeneCellColor = new Color(1f, 1f, 0.7f, 1f); // Yellowish
[SerializeField] Color payloadGeneCellColor = new Color(1f, 0.7f, 1f, 1f);
[SerializeField] Color defaultCellColor = new Color(0.9f, 0.9f, 0.9f, 1f);

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;
}

pub Color GetCellColorForItem(GeneBase gene, SeedTemplate seed, ToolDefinition tool) {
switch (GetItemCategory(gene, seed, tool)) {
case ItemCategory.Tool: ret toolCellColor;
case ItemCategory.Seed: ret seedCellColor;
case ItemCategory.PassiveGene: ret passiveGeneCellColor;
case ItemCategory.ActiveGene: ret activeGeneCellColor;
case ItemCategory.ModifierGene: ret modifierGeneCellColor;
case ItemCategory.PayloadGene: ret payloadGeneCellColor;
default: ret defaultCellColor;
}
}

pub enum ItemCategory {
Tool,
Seed,
PassiveGene,
ActiveGene,
ModifierGene,
PayloadGene,
Default
}

pub ItemCategory GetItemCategory(GeneBase gene, SeedTemplate seed, ToolDefinition tool) {
if (tool != null) ret ItemCategory.Tool;
if (seed != null) ret ItemCategory.Seed;
if (gene != null) {
switch (gene.Category) {
case GeneCategory.Passive: ret ItemCategory.PassiveGene;
case GeneCategory.Active: ret ItemCategory.ActiveGene;
case GeneCategory.Modifier: ret ItemCategory.ModifierGene;
case GeneCategory.Payload: ret ItemCategory.PayloadGene;
}
}
ret ItemCategory.Default;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryGridController.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Templates;
using Abracodabra.UI.Genes;

pub cls InventoryGridController : MonoBehaviour {
pub stat InventoryGridController Instance { get; set; }

[SerializeField][Min(1)] int inventoryRows = 4;
[SerializeField][Min(1)] int inventoryColumns = 4;
[SerializeField] Vector2 cellSize = new Vector2(64f, 64f);
[SerializeField] float cellMargin = 10f;

[SerializeField] GameObject itemSlotPrefab;
[SerializeField] Transform cellContainer;
[SerializeField] StartingInventory startingInventory;

List<GeneSlotUI> inventorySlots = new List<GeneSlotUI>();

pub event System.Action OnInventoryChanged;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

void OnDestroy() {
if (Instance == this) {
Instance = null;
}
}

void Start() {
if (cellContainer == null) Debug.LogError("InventoryGridController: Cell Container not assigned!", this);
if (itemSlotPrefab == null) Debug.LogError("InventoryGridController: Item Slot Prefab not assigned!", this);

if (startingInventory == null) {
Debug.LogError("InventoryGridController: Starting Inventory asset is not assigned! The player will have no items.", this);
}

CreateInventoryCells();
PopulateInitialInventory();
}

void CreateInventoryCells() {
if (itemSlotPrefab == null || cellContainer == null) return;

foreach (Transform child in cellContainer) {
Destroy(child.gameObject);
}
inventorySlots.Clear();

var gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
if (gridLayout == null) {
gridLayout = cellContainer.gameObject.AddComponent<GridLayoutGroup>();
}
gridLayout.cellSize = cellSize;
gridLayout.spacing = new Vector2(cellMargin, cellMargin);
gridLayout.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
gridLayout.constraintCount = inventoryColumns;

for (int i = 0; i < inventoryRows * inventoryColumns; i++) {
GameObject slotObj = Instantiate(itemSlotPrefab, cellContainer);
slotObj.name = $"ItemSlot_{i}";
GeneSlotUI slot = slotObj.GetComponent<GeneSlotUI>();
if (slot != null) {
slot.slotIndex = i;
inventorySlots.Add(slot);
}
else {
Debug.LogError($"[InventoryGridController] The 'itemSlotPrefab' is missing the required GeneSlotUI component!", itemSlotPrefab);
Destroy(slotObj);
}
}
}

void PopulateInitialInventory() {
if (startingInventory == null) return;

foreach (var tool in startingInventory.startingTools) {
if (tool != null) AddItemToInventory(InventoryBarItem.FromTool(tool));
}

foreach (var seed in startingInventory.startingSeeds) {
if (seed != null) AddItemToInventory(InventoryBarItem.FromSeed(seed));
}

foreach (var gene in startingInventory.startingGenes) {
if (gene != null) AddItemToInventory(InventoryBarItem.FromGene(new RuntimeGeneInstance(gene)));
}
}

pub bool AddItemToInventory(InventoryBarItem item) {
if (item == null || !item.IsValid()) ret false;

GeneSlotUI emptySlot = inventorySlots.FirstOrDefault(slot => slot.CurrentItem == null);
if (emptySlot == null) {
Debug.LogWarning($"Inventory is full! Cannot add item: {item.GetDisplayName()}", this);
ret false;
}

emptySlot.SetItem(item);
OnInventoryChanged?.Invoke();
ret true;
}

pub void RemoveItemFromInventory(InventoryBarItem item) {
if (item == null) return;
GeneSlotUI slot = inventorySlots.FirstOrDefault(s => s.CurrentItem == item);
if (slot != null) {
slot.ClearSlot();
OnInventoryChanged?.Invoke();
}
}

pub List<InventoryBarItem> GetAllItems() {
ret inventorySlots
.Where(s => s.CurrentItem != null && s.CurrentItem.IsValid())
.Select(s => s.CurrentItem)
.ToList();
}

pub List<InventoryBarItem> GetFirstNItems(int count) {
var items = new List<InventoryBarItem>();
for (int i = 0; i < count; i++) {
if (i < inventorySlots.Count) {
items.Add(inventorySlots[i].CurrentItem);
}
else {
items.Add(null);
}
}
ret items;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\StartingInventory.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;
using Abracodabra.UI.Genes; // Assuming ToolDefinition is here for now

pub cls StartingInventory : ScriptableObject {
pub List<GeneBase> startingGenes = new List<GeneBase>();

pub List<SeedTemplate> startingSeeds = new List<SeedTemplate>();

pub List<ToolDefinition> startingTools = new List<ToolDefinition>();
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\OutlinePartController.cs

﻿using UnityEngine;
using Abracodabra.Genes;

pub cls OutlinePartController : MonoBehaviour {
SpriteRenderer outlineRenderer;
Transform cachedTransform;
SpriteRenderer sourcePlantPartRenderer;

pub Vector2Int gridCoord;

void Awake() {
outlineRenderer = GetComponent<SpriteRenderer>();
cachedTransform = transform;

if (outlineRenderer != null) {
outlineRenderer.drawMode = SpriteDrawMode.Simple;
outlineRenderer.enabled = false;
}
}

pub void Initialize(SpriteRenderer sourceRenderer, Vector2Int myCoord, PlantOutlineController controller) {
if (sourceRenderer == null || controller == null) {
Destroy(gameObject);
return;
}

sourcePlantPartRenderer = sourceRenderer;
gridCoord = myCoord;

if (outlineRenderer != null) {
outlineRenderer.sortingLayerID = controller.OutlineSortingLayer;
outlineRenderer.sortingOrder = controller.OutlineSortingOrder;
outlineRenderer.color = controller.OutlineColor;
}

cachedTransform.SetParent(controller.transform, true);

PlantGrowth plant = controller.GetComponentInParent<PlantGrowth>();
float spacing = 1f; // Default fallback

if (plant != null) {
spacing = plant.GetCellWorldSpacing();
}

cachedTransform.localPosition = (Vector2)myCoord * spacing;

if (outlineRenderer != null) {
outlineRenderer.enabled = IsSourceRendererValid() &&
sourcePlantPartRenderer.enabled &&
sourcePlantPartRenderer.sprite != null;
}

SyncSpriteAndTransform();
}

void LateUpdate() {
if (outlineRenderer == null || !outlineRenderer.enabled) return;

if (!IsSourceRendererValid()) {
SetVisibility(false);
return;
}

if (!sourcePlantPartRenderer.enabled || sourcePlantPartRenderer.sprite == null) {
SetVisibility(false);
return;
}

SyncSpriteAndTransform();
}

pub bool IsSourceRendererValid() {
if (sourcePlantPartRenderer == null) ret false;
if (!sourcePlantPartRenderer.gameObject.activeInHierarchy) ret false;
ret true;
}

pub void UpdateSourceRenderer(SpriteRenderer newSource) {
if (newSource != null) {
sourcePlantPartRenderer = newSource;
SetVisibility(outlineRenderer != null && sourcePlantPartRenderer.enabled && sourcePlantPartRenderer.sprite != null);
SyncSpriteAndTransform();
}
else {
SetVisibility(false);
}
}

pub void SyncSpriteAndTransform() {
if (!IsSourceRendererValid() || outlineRenderer == null) return;
if (outlineRenderer.sprite != sourcePlantPartRenderer.sprite) {
outlineRenderer.sprite = sourcePlantPartRenderer.sprite;
}
cachedTransform.localScale = sourcePlantPartRenderer.transform.localScale;
outlineRenderer.flipX = sourcePlantPartRenderer.flipX;
outlineRenderer.flipY = sourcePlantPartRenderer.flipY;
}

pub void SetVisibility(bool isVisible) {
if (outlineRenderer != null && outlineRenderer.enabled != isVisible) {
outlineRenderer.enabled = isVisible;
}
}

pub void DestroyOutlinePart() {
if (this != null && gameObject != null) {
if (Application.isPlaying) { Destroy(gameObject); }
else { DestroyImmediate(gameObject); }
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\PlantOutlineController.cs

﻿// REWORKED FILE: Assets/Scripts/PlantSystem/Visual/PlantOutlineController.cs
using Abracodabra.Genes;

pub cls PlantOutlineController : MonoBehaviour {
[SerializeField] Color outlineColor = Color.black;
[SerializeField] pub GameObject outlinePartPrefab;
[SerializeField] string outlineSortingLayerName = "Default";
[SerializeField] int outlineSortingOrder = -1;
[SerializeField] bool debugLogging = false;

pub Color OutlineColor => outlineColor;
pub int OutlineSortingLayer => outlineSortingLayerID;
pub int OutlineSortingOrder => outlineSortingOrder;

int outlineSortingLayerID;
PlantGrowth parentPlantGrowth;
Dictionary<Vector2Int, OutlinePartController> outlinePartMap = new Dictionary<Vector2Int, OutlinePartController>();
HashSet<Vector2Int> plantCellCoords = new HashSet<Vector2Int>();

stat ro Vector2Int[] neighborOffsets = {
new Vector2Int(-1, -1), new Vector2Int(0, -1), new Vector2Int(1, -1),
new Vector2Int(-1, 0),                         new Vector2Int(1, 0),
new Vector2Int(-1, 1),  new Vector2Int(0, 1),  new Vector2Int(1, 1)
};

void Awake() {
parentPlantGrowth = GetComponentInParent<PlantGrowth>();
if (parentPlantGrowth == null) {
Debug.LogError($"[{gameObject.name}] Missing PlantGrowth parent!", gameObject);
enabled = false;
return;
}
outlineSortingLayerID = SortingLayer.NameToID(outlineSortingLayerName);
}

pub void RegisterPlantPart(SpriteRenderer plantPartRenderer, GameObject prefab) {
if (plantPartRenderer == null) return;
PlantCell plantCell = plantPartRenderer.GetComponentInParent<PlantCell>();
if (plantCell != null) {
OnPlantCellAdded(plantCell.GridCoord, plantCell.gameObject);
}
}

pub void OnPlantCellAdded(Vector2Int plantCoord, GameObject plantCellGO) {
if (plantCellGO == null) return;

plantCellCoords.Add(plantCoord);
RemoveOutlinePartIfExists(plantCoord);

SpriteRenderer plantRenderer = plantCellGO.GetComponentInChildren<SpriteRenderer>();
if (plantRenderer == null) return;

foreach (var offset in neighborOffsets) {
Vector2Int neighborCoord = plantCoord + offset;
if (!plantCellCoords.Contains(neighborCoord) && !outlinePartMap.ContainsKey(neighborCoord)) {
CreateOutlinePart(neighborCoord, plantRenderer);
}
}
}

pub void OnPlantCellRemoved(Vector2Int plantCoord) {
if (!plantCellCoords.Remove(plantCoord)) return;

if (!outlinePartMap.ContainsKey(plantCoord)) {
SpriteRenderer sourceRenderer = FindValidNeighborRenderer(plantCoord);
if (sourceRenderer != null) {
CreateOutlinePart(plantCoord, sourceRenderer);
}
}

foreach (var offset in neighborOffsets) {
Vector2Int neighborCoord = plantCoord + offset;
if (outlinePartMap.TryGetValue(neighborCoord, out var outlinePart)) {
if (outlinePart == null) {
outlinePartMap.Remove(neighborCoord);
continue;
}
if (!HasPlantNeighbor(neighborCoord)) {
RemoveOutlinePartIfExists(neighborCoord);
}
else if (!outlinePart.IsSourceRendererValid()) {
SpriteRenderer newSource = FindValidNeighborRenderer(neighborCoord);
if (newSource != null) {
outlinePart.UpdateSourceRenderer(newSource);
}
else {
RemoveOutlinePartIfExists(neighborCoord);
}
}
}
}
}

void CreateOutlinePart(Vector2Int coord, SpriteRenderer sourceRenderer) {
if (outlinePartMap.ContainsKey(coord) || sourceRenderer == null || outlinePartPrefab == null) {
return;
}

GameObject outlineInstance = Instantiate(outlinePartPrefab, transform);

float spacing = 1f / 6f; // Default fallback (1 world unit at 6 PPU)
if (parentPlantGrowth != null) {
spacing = parentPlantGrowth.GetCellWorldSpacing();
}

outlineInstance.transform.localPosition = (Vector2)coord * spacing;

OutlinePartController outlineController = outlineInstance.GetComponent<OutlinePartController>();
if (outlineController != null) {
outlineController.Initialize(sourceRenderer, coord, this);
outlinePartMap.Add(coord, outlineController);

if (debugLogging) {
Debug.Log($"[{gameObject.name}] Created outline at {coord}, spacing: {spacing:F4} world units");
}
}
else {
Debug.LogError("Outline Part Prefab is missing the OutlinePartController script!", outlinePartPrefab);
Destroy(outlineInstance);
}
}

void RemoveOutlinePartIfExists(Vector2Int coord) {
if (outlinePartMap.TryGetValue(coord, out var part)) {
if (part != null) part.DestroyOutlinePart();
outlinePartMap.Remove(coord);
}
}

bool HasPlantNeighbor(Vector2Int coord) {
foreach (var offset in neighborOffsets)
if (plantCellCoords.Contains(coord + offset)) ret true;
ret false;
}

SpriteRenderer FindValidNeighborRenderer(Vector2Int coord) {
foreach (var offset in neighborOffsets) {
Vector2Int neighborCoord = coord + offset;
if (plantCellCoords.Contains(neighborCoord)) {
GameObject plantGO = parentPlantGrowth.GetCellGameObjectAt(neighborCoord);
if (plantGO != null && plantGO.TryGetComponent<SpriteRenderer>(out var renderer)) {
ret renderer;
}
}
}
if (debugLogging)
Debug.LogWarning($"[{gameObject.name}] Could not find any valid neighbor renderer for outline at {coord}");
ret null;
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\PlantShadowController.cs

﻿using UnityEngine;

pub cls PlantShadowController : MonoBehaviour {
[SerializeField] Color shadowColor = new Color(0f, 0f, 0f, 0.5f);
float squashFactor = 0.6f;
float shadowAngleDegrees = 270f; // Default to directly downwards
bool flipShadow = false;

[SerializeField] bool enableDistanceFade = true;
[SerializeField] float fadeStartDistance = 1.5f;
[SerializeField] float fadeEndDistance = 3.0f;
[SerializeField] [Range(0f, 1f)] float minFadeAlpha = 0.0f;

string shadowSortingLayerName = "Default";
int shadowSortingOrder = -1;

int shadowSortingLayerID;

pub Color ShadowColor => shadowColor;
pub int ShadowSortingLayer => shadowSortingLayerID;
pub int ShadowSortingOrder => shadowSortingOrder;

pub bool EnableDistanceFade => enableDistanceFade;
pub float FadeStartDistance => fadeStartDistance;
pub float FadeEndDistance => fadeEndDistance;
pub float MinFadeAlpha => minFadeAlpha;

Vector3 baseLocalScale;
Quaternion baseLocalRotation;
Vector3 baseLocalPosition;

Dictionary<SpriteRenderer, ShadowPartController> shadowPartMap = new Dictionary<SpriteRenderer, ShadowPartController>();

void Awake() {
shadowSortingLayerID = SortingLayer.NameToID(shadowSortingLayerName);
if (shadowSortingLayerID == 0 && shadowSortingLayerName != "Default") {
Debug.LogWarning($"Sorting Layer '{shadowSortingLayerName}' not found. Shadow will use 'Default'.", this);
shadowSortingLayerID = SortingLayer.NameToID("Default");
}

baseLocalScale = transform.localScale;
baseLocalRotation = transform.localRotation;
baseLocalPosition = transform.localPosition;
if (baseLocalPosition != Vector3.zero) {
Debug.LogWarning($"'{gameObject.name}' initial localPosition is not zero ({baseLocalPosition}). Shadow origin might be slightly offset from plant root.", gameObject);
}
}

void LateUpdate() {
transform.localPosition = baseLocalPosition; // Should typically be Vector3.zero

Quaternion angleRotation = Quaternion.Euler(0, 0, shadowAngleDegrees);
transform.localRotation = baseLocalRotation * angleRotation;

Vector3 finalScale = baseLocalScale; // Start with original scale
finalScale.y *= squashFactor;

if (flipShadow) {
finalScale.x *= -1f;
}
transform.localScale = finalScale;

}

pub void RegisterPlantPart(SpriteRenderer plantPartRenderer, GameObject shadowPartPrefab) {
if (plantPartRenderer == null || shadowPartPrefab == null) return;
if (shadowPartMap.ContainsKey(plantPartRenderer)) return;
GameObject shadowInstance = Instantiate(shadowPartPrefab, transform);
ShadowPartController shadowController = shadowInstance.GetComponent<ShadowPartController>();
if (shadowController != null) { shadowController.Initialize(plantPartRenderer, this); shadowPartMap.Add(plantPartRenderer, shadowController); }
else { Debug.LogError($"Shadow Part Prefab '{shadowPartPrefab.name}' missing ShadowPartController.", shadowPartPrefab); Destroy(shadowInstance); }
}

pub void UnregisterPlantPart(SpriteRenderer plantPartRenderer) {
if (plantPartRenderer != null && shadowPartMap.TryGetValue(plantPartRenderer, out ShadowPartController shadowController)) {
if (shadowController != null) { shadowController.OnPlantPartDestroyed(); }
shadowPartMap.Remove(plantPartRenderer);
}
}

void OnDestroy() {
foreach (var kvp in shadowPartMap) {
if (kvp.Value != null) {
if (Application.isPlaying) {
Destroy(kvp.Value.gameObject);
}
else {
DestroyImmediate(kvp.Value.gameObject);
}
}
}
shadowPartMap.Clear(); // Prevent memory leaks from the dictionary itself
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\ShadowPartController.cs

﻿using UnityEngine;

pub cls ShadowPartController : MonoBehaviour {
SpriteRenderer shadowRenderer;
Transform cachedTransform;

SpriteRenderer plantPartRenderer;
Transform plantPartTransform;
Transform shadowRootTransform;
PlantShadowController mainShadowController;

void Awake() {
shadowRenderer = GetComponent<SpriteRenderer>();
cachedTransform = transform;

shadowRenderer.drawMode = SpriteDrawMode.Simple;
shadowRenderer.enabled = false;
}

pub void Initialize(SpriteRenderer targetPlantPartRenderer, PlantShadowController controller) {
if (targetPlantPartRenderer == null || controller == null) {
Destroy(gameObject);
return;
}

plantPartRenderer = targetPlantPartRenderer;
plantPartTransform = targetPlantPartRenderer.transform;
mainShadowController = controller;
shadowRootTransform = controller.transform;

shadowRenderer.sortingLayerID = mainShadowController.ShadowSortingLayer;
shadowRenderer.sortingOrder = mainShadowController.ShadowSortingOrder;

cachedTransform.SetParent(shadowRootTransform, true); // Parent first

shadowRenderer.enabled = plantPartRenderer.enabled && plantPartRenderer.sprite != null;
UpdateColorAndFade();
}

void LateUpdate() {
if (plantPartRenderer == null || !plantPartRenderer.enabled || plantPartRenderer.sprite == null || shadowRenderer == null || mainShadowController == null) {
if (shadowRenderer != null)
shadowRenderer.enabled = false;
return;
}

shadowRenderer.enabled = true;
shadowRenderer.sprite = plantPartRenderer.sprite;

Vector3 plantPartPosRelativeToPlantRoot = plantPartTransform.parent.InverseTransformPoint(plantPartTransform.position);
cachedTransform.localPosition = plantPartPosRelativeToPlantRoot;
cachedTransform.localRotation = plantPartTransform.localRotation;
cachedTransform.localScale = plantPartTransform.localScale;

shadowRenderer.flipX = plantPartRenderer.flipX;
shadowRenderer.flipY = plantPartRenderer.flipY;

UpdateColorAndFade();
}

void UpdateColorAndFade() {
if (mainShadowController == null || shadowRenderer == null) return;

Color baseShadowColor = mainShadowController.ShadowColor;
float finalAlpha = baseShadowColor.a; // Start with the controller's base alpha

if (mainShadowController.EnableDistanceFade) {
float distance = Vector3.Distance(cachedTransform.position, shadowRootTransform.position); // Distance from shadow part to shadow root

float fadeStart = mainShadowController.FadeStartDistance;
float fadeEnd = mainShadowController.FadeEndDistance;
float minAlpha = mainShadowController.MinFadeAlpha;

if (distance >= fadeEnd) {
finalAlpha *= minAlpha; // Apply min alpha
}
else if (distance > fadeStart) {
float t = Mathf.InverseLerp(fadeStart, fadeEnd, distance);
float distanceAlphaMultiplier = Mathf.Lerp(1f, minAlpha, t);
finalAlpha *= distanceAlphaMultiplier; // Modulate base alpha
}
}

shadowRenderer.color = new Color(baseShadowColor.r, baseShadowColor.g, baseShadowColor.b, finalAlpha);
}

pub void OnPlantPartDestroyed() {
if (this != null && gameObject != null) {
if (Application.isPlaying) {
Destroy(gameObject);
}
else {
DestroyImmediate(gameObject);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridDebugVisualizer.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes;
using WegoSystem;

pub cls GridDebugVisualizer : MonoBehaviour {
pub stat GridDebugVisualizer Instance { get; set; }

pub enum RadiusType {
AnimalSearch,
PlantPoop,
Scent,
FireflyPhotosynthesis,
ToolUse
}

[SerializeField] bool showRadiusVisualizations = true;
[SerializeField] float tileVisualizationAlpha = 0.3f;
[SerializeField] GameObject tilePrefab;

[SerializeField] pub Color animalSearchRadiusColor = new Color(1f, 0.5f, 0f, 0.3f);
[SerializeField] pub Color plantPoopRadiusColor = new Color(0.6f, 0.4f, 0.2f, 0.3f);
[SerializeField] pub Color scentRadiusColor = new Color(1f, 1f, 0f, 0.3f);
[SerializeField] pub Color fireflyPhotosynthesisColor = new Color(0f, 1f, 0.5f, 0.3f);
[SerializeField] pub Color toolUseRadiusColor = new Color(0f, 0.5f, 1f, 0.3f);

[SerializeField] bool enableAnimalSearchRadius = true;
[SerializeField] bool enablePlantPoopRadius = true;
[SerializeField] bool enableScentRadius = true;
[SerializeField] bool enableFireflyPhotosynthesis = true;
[SerializeField] bool enableToolUseRadius = true;

cls RadiusRequest {
pub GridPosition Center;
pub int Radius;
pub RadiusType Type;
}

ro Dictionary<object, List<GameObject>> oneShotVisualizations = new Dictionary<object, List<GameObject>>();
ro Dictionary<object, RadiusRequest> continuousRequests = new Dictionary<object, RadiusRequest>();
ro Dictionary<object, (GridPosition center, int radius)> lastDrawnState = new Dictionary<object, (GridPosition, int)>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

void OnDestroy() {
ClearAllVisualizations();
if (Instance == this) Instance = null;
}

void Update() {
ProcessContinuousRequests();
}

pub void ShowContinuousRadius(object source, GridPosition center, int radius, RadiusType type) {
if (!showRadiusVisualizations || source == null || !IsTypeEnabled(type)) return;

if (!continuousRequests.ContainsKey(source)) {
continuousRequests.Add(source, new RadiusRequest());
}
continuousRequests[source].Center = center;
continuousRequests[source].Radius = radius;
continuousRequests[source].Type = type;
}

pub void HideContinuousRadius(object source) {
if (source == null) return;

if (continuousRequests.Remove(source)) {
ClearVisualization(source);
}
}

pub void VisualizeRadius(object source, GridPosition center, int radius, Color color, float duration = 0f) {
if (!showRadiusVisualizations || tilePrefab == null) return;

ClearVisualization(source);

var tiles = GridRadiusUtility.GetTilesInCircle(center, radius);
var tileObjects = new List<GameObject>();

foreach (var tile in tiles) {
Vector3 worldPos = GridPositionManager.Instance.GridToWorld(tile);
GameObject tileVis = Instantiate(tilePrefab, worldPos, Quaternion.identity, transform);

SpriteRenderer sr = tileVis.GetComponent<SpriteRenderer>();
if (sr != null) {
Color finalColor = color;
finalColor.a = tileVisualizationAlpha;
sr.color = finalColor;
sr.sortingOrder = -100;
}
tileObjects.Add(tileVis);

if (duration > 0) {
Destroy(tileVis, duration);
}
}

if (duration <= 0) {
oneShotVisualizations[source] = tileObjects;
}
}

pub void ClearVisualization(object source) {
if (oneShotVisualizations.TryGetValue(source, out var tiles)) {
foreach (var tile in tiles) {
if (tile != null) Destroy(tile);
}
oneShotVisualizations.Remove(source);
}
if (lastDrawnState.ContainsKey(source)) {
lastDrawnState.Remove(source);
}
}

pub void VisualizeAnimalSearchRadius(AnimalController animal, GridPosition center, int radius) {
ShowContinuousRadius(animal, center, radius, RadiusType.AnimalSearch);
}

pub void VisualizePlantPoopRadius(PlantGrowth plant, GridPosition center, int radius) {
ShowContinuousRadius(plant, center, radius, RadiusType.PlantPoop);
}

pub void VisualizeScentRadius(ScentSource scentSource, GridPosition center, int radius) {
ShowContinuousRadius(scentSource, center, radius, RadiusType.Scent);
}

pub void VisualizeFireflyPhotosynthesisRadius(FireflyController firefly, GridPosition center, int radius) {
ShowContinuousRadius(firefly, center, radius, RadiusType.FireflyPhotosynthesis);
}

pub void VisualizeToolUseRadius(object tool, GridPosition center, int radius) {
ShowContinuousRadius(tool, center, radius, RadiusType.ToolUse);
}

pub void SetAnimalSearchRadiusEnabled(bool enabled) { enableAnimalSearchRadius = enabled; }
pub void SetPlantPoopRadiusEnabled(bool enabled) { enablePlantPoopRadius = enabled; }
pub void SetScentRadiusEnabled(bool enabled) { enableScentRadius = enabled; }
pub void SetFireflyPhotosynthesisEnabled(bool enabled) { enableFireflyPhotosynthesis = enabled; }
pub void SetToolUseRadiusEnabled(bool enabled) { enableToolUseRadius = enabled; }

pub void SetRadiusVisualizationsEnabled(bool enabled) {
showRadiusVisualizations = enabled;
if (!enabled) {
ClearAllVisualizations();
}
}

pub Color GetColorForType(RadiusType type) {
switch (type) {
case RadiusType.AnimalSearch: ret animalSearchRadiusColor;
case RadiusType.PlantPoop: ret plantPoopRadiusColor;
case RadiusType.Scent: ret scentRadiusColor;
case RadiusType.FireflyPhotosynthesis: ret fireflyPhotosynthesisColor;
case RadiusType.ToolUse: ret toolUseRadiusColor;
default: ret Color.white;
}
}

bool IsTypeEnabled(RadiusType type) {
switch (type) {
case RadiusType.AnimalSearch: ret enableAnimalSearchRadius;
case RadiusType.PlantPoop: ret enablePlantPoopRadius;
case RadiusType.Scent: ret enableScentRadius;
case RadiusType.FireflyPhotosynthesis: ret enableFireflyPhotosynthesis;
case RadiusType.ToolUse: ret enableToolUseRadius;
default: ret true;
}
}

void ProcessContinuousRequests() {
if (!showRadiusVisualizations || tilePrefab == null) return;

List<object> sourcesToRemove = new List<object>();
foreach (var drawnSource in lastDrawnState.Keys) {
if (!continuousRequests.ContainsKey(drawnSource)) {
sourcesToRemove.Add(drawnSource);
}
}
foreach (var source in sourcesToRemove) {
ClearVisualization(source);
}

foreach (var kvp in continuousRequests) {
object source = kvp.Key;
RadiusRequest request = kvp.Value;

if (!IsTypeEnabled(request.Type)) {
if (lastDrawnState.ContainsKey(source)) {
ClearVisualization(source);
}
continue;
}

bool needsRedraw = false;
if (lastDrawnState.TryGetValue(source, out var lastState)) {
if (lastState.center != request.Center || lastState.radius != request.Radius) {
needsRedraw = true;
}
}
else {
needsRedraw = true;
}

if (needsRedraw) {
Color color = GetColorForType(request.Type);
VisualizeRadius(source, request.Center, request.Radius, color, 0);
lastDrawnState[source] = (request.Center, request.Radius);
}
}
}

void ClearAllVisualizations() {
foreach (var kvp in oneShotVisualizations) {
foreach (var tile in kvp.Value) {
if (tile != null) Destroy(tile);
}
}
oneShotVisualizations.Clear();
continuousRequests.Clear();
lastDrawnState.Clear();
}

pub bool IsRadiusVisualizationEnabled => showRadiusVisualizations;
pub bool IsAnimalSearchRadiusEnabled => enableAnimalSearchRadius;
pub bool IsPlantPoopRadiusEnabled => enablePlantPoopRadius;
pub bool IsScentRadiusEnabled => enableScentRadius;
pub bool IsFireflyPhotosynthesisEnabled => enableFireflyPhotosynthesis;
pub bool IsToolUseRadiusEnabled => enableToolUseRadius;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridSnapStartup.cs

﻿// Assets\Scripts\Core\GridSnapStartup.cs

using Abracodabra.Genes;
using WegoSystem;

pub cls GridSnapStartup : MonoBehaviour {
[SerializeField] bool snapAllAnimals = true;
[SerializeField] bool snapAllPlants = true;
[SerializeField] bool snapPlayer = true;
[SerializeField] bool debugLog = true;

void Awake() {
if (GridPositionManager.Instance == null) {
Debug.LogError("[GridSnapStartup] GridPositionManager not found! Cannot snap entities.");
return;
}
}

void Start() {
PerformGridSnapping();
}

void PerformGridSnapping() {
int snappedCount = 0;

if (snapPlayer) {
GardenerController[] gardeners = FindObjectsByType<GardenerController>(FindObjectsSortMode.None);
foreach (var gardener in gardeners) {
GridPositionManager.Instance.SnapEntityToGrid(gardener.gameObject);
snappedCount++;
}
}

if (snapAllAnimals) {
AnimalController[] animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
foreach (var animal in animals) {
GridPositionManager.Instance.SnapEntityToGrid(animal.gameObject);
snappedCount++;
}
}

if (snapAllPlants) {
PlantGrowth[] plants = FindObjectsByType<PlantGrowth>(FindObjectsSortMode.None);
foreach (var plant in plants) {
GridPositionManager.Instance.SnapEntityToGrid(plant.gameObject);
snappedCount++;
}
}

if (debugLog) {
Debug.Log($"[GridSnapStartup] Snapped {snappedCount} entities to grid on startup");
}
}

void SnapAllEntitiesNow() {
if (GridPositionManager.Instance == null) {
Debug.LogError("GridPositionManager not found in scene!");
return;
}

PerformGridSnapping();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\TickDebugMonitor.cs

﻿// REWORKED FILE: Assets/Scripts/Ticks/TickDebugMonitor.cs
using TMPro;
using WegoSystem;
using Abracodabra.Genes;

pub cls TickDebugMonitor : MonoBehaviour {
[SerializeField] GameObject monitorPanel;
[SerializeField] TextMeshProUGUI tickCounterText;
[SerializeField] TextMeshProUGUI animalCountText;
[SerializeField] TextMeshProUGUI plantCountText;
[SerializeField] KeyCode toggleKey = KeyCode.F3;

void Update() {
if (Input.GetKeyDown(toggleKey)) {
monitorPanel.SetActive(!monitorPanel.activeSelf);
}

if (monitorPanel.activeSelf) {
UpdateDisplay();
}
}

void UpdateDisplay() {
if (TickManager.Instance == null) return;

tickCounterText.text = $"Tick: {TickManager.Instance.CurrentTick}";
animalCountText.text = $"Animals: {FindObjectsByType<AnimalController>(FindObjectsSortMode.None).Length}";

plantCountText.text = $"Plants: {PlantGrowth.AllActivePlants.Count}";

}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Tooltips\TooltipTrigger.cs

﻿// Reworked File: Assets/Scripts/UI/Tooltips/TooltipTrigger.cs
using UnityEngine.EventSystems;
using Abracodabra.UI.Genes; // For ItemView
using Abracodabra.Genes.Core; // For GeneTooltipContext

pub cls TooltipTrigger : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler {
ItemView _itemView;
bool _isShowingTooltip = false;

void Awake() {
_itemView = GetComponent<ItemView>();
}

pub void OnPointerEnter(PointerEventData eventData) {
if (UniversalTooltipManager.Instance == null || _isShowingTooltip || _itemView == null) return;
ShowTooltip();
}

pub void OnPointerExit(PointerEventData eventData) {
if (UniversalTooltipManager.Instance == null || !_isShowingTooltip) return;
HideTooltip();
}

void ShowTooltip() {
ITooltipDataProvider provider = null;
GeneTooltipContext context = new GeneTooltipContext();

if (_itemView.GetGene() != null) {
provider = _itemView.GetGene();
context.instance = _itemView.GetRuntimeInstance();
}
else if (_itemView.GetToolDefinition() != null) {
provider = _itemView.GetToolDefinition();
}
else if (_itemView.GetSeedTemplate() != null) {
}

if (provider != null) {
UniversalTooltipManager.Instance.ShowTooltip(provider, transform, context);
_isShowingTooltip = true;
}
}

void HideTooltip() {
UniversalTooltipManager.Instance?.HideTooltip();
_isShowingTooltip = false;
}

void OnDisable() {
if (_isShowingTooltip) {
HideTooltip();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Tooltips\UniversalTooltipManager.cs

﻿using UnityEngine;
using TMPro;

pub ifc ITooltipDataProvider {
string GetTooltipTitle();
string GetTooltipDescription();
string GetTooltipDetails(object source = null);
}

pub cls UniversalTooltipManager : MonoBehaviour {
pub stat UniversalTooltipManager Instance { get; set; }

[SerializeField] GameObject tooltipPanel;
[SerializeField] TextMeshProUGUI titleText;
[SerializeField] TextMeshProUGUI descriptionText;
[SerializeField] TextMeshProUGUI detailsText;
[SerializeField] Image backgroundImage;
[SerializeField] CanvasGroup canvasGroup;
[SerializeField] VerticalLayoutGroup layoutGroup;

[SerializeField] float fadeDuration = 0.15f;
[SerializeField] bool moveTooltipWithMouse = true;
[SerializeField] Vector2 mouseFollowOffset = new Vector2(15f, -15f);

[SerializeField] Color backgroundColor = new Color(0.1f, 0.1f, 0.1f, 0.95f);
[SerializeField] Color titleColor = Color.white;
[SerializeField] Color descriptionColor = new Color(0.8f, 0.8f, 0.8f, 1f);
[SerializeField] Color detailsColor = new Color(0.7f, 0.7f, 0.7f, 1f);
[SerializeField] int titleFontSize = 18;
[SerializeField] int descriptionFontSize = 14;
[SerializeField] int detailsFontSize = 12;

Coroutine _fadeCoroutine;
object _currentTarget;
bool _isVisible = false;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

if (!ValidateReferences()) {
enabled = false;
return;
}

SetupTooltipPanel();
if (tooltipPanel != null) tooltipPanel.SetActive(false);
if (canvasGroup != null) canvasGroup.alpha = 0f;
_isVisible = false;
}

void Update() {
if (_isVisible && IsTargetNullOrDestroyed(_currentTarget)) {
HideTooltip();
}
}

pub void ShowTooltip(ITooltipDataProvider provider, Transform anchor = null, object source = null) {
if (provider == null) return;

if (_isVisible && ReferenceEquals(_currentTarget, provider)) return;

_currentTarget = provider;

string title = provider.GetTooltipTitle();
string description = provider.GetTooltipDescription();
string details = provider.GetTooltipDetails(source);

ShowTooltipInternal(title, description, details, anchor);
}

pub void HideTooltip() {
_currentTarget = null;
if (tooltipPanel == null || canvasGroup == null) return;

if (_fadeCoroutine != null) {
StopCoroutine(_fadeCoroutine);
}

if (fadeDuration > 0f && gameObject.activeInHierarchy) {
_fadeCoroutine = StartCoroutine(FadeTooltip(false));
}
else {
canvasGroup.alpha = 0f;
if (tooltipPanel != null) tooltipPanel.SetActive(false);
_isVisible = false;
}
}

void ShowTooltipInternal(string title, string description, string details, Transform itemAnchor) {
if (tooltipPanel == null || canvasGroup == null) return;

if (_fadeCoroutine != null) {
StopCoroutine(_fadeCoroutine);
}

if (titleText != null) {
titleText.text = title;
titleText.gameObject.SetActive(!string.IsNullOrEmpty(title));
}
if (descriptionText != null) {
descriptionText.text = description;
descriptionText.gameObject.SetActive(!string.IsNullOrEmpty(description));
}
if (detailsText != null) {
detailsText.text = details;
detailsText.gameObject.SetActive(!string.IsNullOrEmpty(details));
}

tooltipPanel.SetActive(true);
if (layoutGroup != null) {
LayoutRebuilder.ForceRebuildLayoutImmediate(layoutGroup.GetComponent<RectTransform>());
}

if (moveTooltipWithMouse) {
PositionTooltipWithMouse();
}

if (fadeDuration > 0f) {
_fadeCoroutine = StartCoroutine(FadeTooltip(true));
}
else {
canvasGroup.alpha = 1f;
_isVisible = true;
}
}

void PositionTooltipWithMouse() {
var tooltipRect = tooltipPanel.GetComponent<RectTransform>();
var rootCanvas = tooltipPanel.GetComponentInParent<Canvas>()?.rootCanvas;

if (tooltipRect == null || rootCanvas == null || !Input.mousePresent) return;

Vector2 targetScreenPos = Input.mousePosition;
targetScreenPos += mouseFollowOffset; // Apply user offset

var panelRect = tooltipRect.rect;
targetScreenPos.x = Mathf.Clamp(targetScreenPos.x, 0, Screen.width - panelRect.width);
targetScreenPos.y = Mathf.Clamp(targetScreenPos.y, 0, Screen.height - panelRect.height);

var parentRect = tooltipRect.parent as RectTransform;
if (parentRect == null) return;

Camera renderCamera = (rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay) ? null : rootCanvas.worldCamera;
if (RectTransformUtility.ScreenPointToLocalPointInRectangle(parentRect, targetScreenPos, renderCamera, out var localPos)) {
tooltipRect.localPosition = localPos;
}
}

IEnumerator FadeTooltip(bool fadeIn) {
if (canvasGroup == null) yield break;

float elapsed = 0f;
float startAlpha = canvasGroup.alpha;
float targetAlpha = fadeIn ? 1f : 0f;

if (fadeIn) _isVisible = true;

if (fadeIn && tooltipPanel != null && !tooltipPanel.activeSelf)
tooltipPanel.SetActive(true);

while (elapsed < fadeDuration) {
elapsed += Time.unscaledDeltaTime;
float t = (fadeDuration > 0) ? elapsed / fadeDuration : 1f;
canvasGroup.alpha = Mathf.Lerp(startAlpha, targetAlpha, t);
yield ret null;
}

canvasGroup.alpha = targetAlpha;

if (!fadeIn) {
if (tooltipPanel != null) tooltipPanel.SetActive(false);
_isVisible = false;
}
}

bool IsTargetNullOrDestroyed(object target) {
if (target is UnityEngine.Object unityObject) {
ret unityObject == null;
}
ret System.Object.ReferenceEquals(target, null);
}

void SetupTooltipPanel() {
if (canvasGroup != null) {
canvasGroup.alpha = 0f;
canvasGroup.interactable = false;
canvasGroup.blocksRaycasts = false;
}
if (backgroundImage != null) backgroundImage.color = backgroundColor;
ApplyTextStyles();
}

void ApplyTextStyles() {
if (titleText != null) { titleText.color = titleColor; titleText.fontSize = titleFontSize; titleText.fontStyle = FontStyles.Bold; }
if (descriptionText != null) { descriptionText.color = descriptionColor; descriptionText.fontSize = descriptionFontSize; }
if (detailsText != null) { detailsText.color = detailsColor; detailsText.fontSize = detailsFontSize; }
}

bool ValidateReferences() {
if (tooltipPanel == null) { Debug.LogError("[UniversalTooltipManager] Tooltip Panel not assigned!"); ret false; }

if (canvasGroup == null) canvasGroup = tooltipPanel.GetComponent<CanvasGroup>() ?? tooltipPanel.AddComponent<CanvasGroup>();
if (layoutGroup == null) layoutGroup = tooltipPanel.GetComponent<VerticalLayoutGroup>();
if (backgroundImage == null) backgroundImage = tooltipPanel.GetComponent<Image>();
if (titleText == null) titleText = FindTextComponent("Title");
if (descriptionText == null) descriptionText = FindTextComponent("Description");
if (detailsText == null) detailsText = FindTextComponent("Details");

if (titleText == null) { Debug.LogError("[UniversalTooltipManager] Missing required title text component!"); ret false; }

ret true;
}

TextMeshProUGUI FindTextComponent(string nameContains) {
if (tooltipPanel == null) ret null;
foreach (var text in tooltipPanel.GetComponentsInChildren<TextMeshProUGUI>(true)) {
if (text.name.ToLower().Contains(nameContains.ToLower()))
ret text;
}
ret null;
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Utilities\ColorExtensions.cs

﻿using UnityEngine;

pub stat cls ColorExtensions {
pub stat Color WithAlpha(this Color c, float alpha) {
ret new Color(c.r, c.g, c.b, alpha);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Utilities\PrefabOrigin.cs

﻿// Assets/Scripts/Utility/PrefabOrigin.cs

pub cls PrefabOrigin : MonoBehaviour {
pub Transform originTransform;

void Awake() {
if (originTransform == null) {
Debug.LogError($"[PrefabOrigin] The 'Origin Transform' is not assigned on '{gameObject.name}'. The script cannot function.", this);
Destroy(this); // Destroy self if not configured
return;
}

if (!originTransform.IsChildOf(transform)) {
Debug.LogError($"[PrefabOrigin] The assigned 'Origin Transform' ('{originTransform.name}') is not a child of '{gameObject.name}'. The script cannot function.", this);
Destroy(this); // Destroy self if configuration is invalid
return;
}

Vector3 worldOffset = transform.TransformVector(originTransform.localPosition);

transform.position -= worldOffset;

Destroy(this);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\NightColorPostProcess.cs

﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

pub cls NightColorPostProcess : MonoBehaviour {
pub WeatherManager weatherManager;

pub Volume globalVolume;

pub Color dayColorFilter = Color.white;
pub Color nightColorFilter = new Color(0.75f, 0.8f, 1f, 1f);

pub float dayPostExposure = 0f;
pub float nightPostExposure = -0.5f;

pub float daySaturation = 0f;
pub float nightSaturation = -50f;

pub float dayFilmGrainIntensity = 0.1f;
pub float nightFilmGrainIntensity = 0.5f;

pub float dayVignetteIntensity = 0.2f;
pub float nightVignetteIntensity = 0.5f;

pub float dayVignetteSmoothness = 0.2f;
pub float nightVignetteSmoothness = 0.3f;

[SerializeField] float transitionSmoothingSpeed = 5f;

ColorAdjustments colorAdjustments;
FilmGrain filmGrain;
Vignette vignette;

float smoothedSunIntensity;

void Start() {
if (!weatherManager) {
Debug.LogError($"[{nameof(NightColorPostProcess)}] WeatherManager not assigned!", this);
enabled = false; // Disable script if core references are missing
return;
}
if (!globalVolume) {
Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume not assigned!", this);
enabled = false;
return;
}
if (globalVolume.profile == null) {
Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume has no profile assigned!", this);
enabled = false;
return;
}

if (!globalVolume.profile.TryGet<ColorAdjustments>(out colorAdjustments)) {
Debug.LogWarning($"[{nameof(NightColorPostProcess)}] ColorAdjustments ovr not found in Volume profile.", this);
}
if (!globalVolume.profile.TryGet<FilmGrain>(out filmGrain)) {
Debug.LogWarning($"[{nameof(NightColorPostProcess)}] FilmGrain ovr not found in Volume profile.", this);
}
if (!globalVolume.profile.TryGet<Vignette>(out vignette)) {
Debug.LogWarning($"[{nameof(NightColorPostProcess)}] Vignette ovr not found in Volume profile.", this);
}

smoothedSunIntensity = weatherManager.sunIntensity;
}

void Update() {
if (colorAdjustments == null && filmGrain == null && vignette == null)
return; // Nothing to update if no overrides were found

if (weatherManager != null) {
smoothedSunIntensity = Mathf.Lerp(smoothedSunIntensity, weatherManager.sunIntensity, transitionSmoothingSpeed * Time.deltaTime);
}

float sun = Mathf.Clamp01(smoothedSunIntensity); // Use the smoothed value
float t = 1f - sun;  // t=0 at day, t=1 at night

if (colorAdjustments != null) {
colorAdjustments.colorFilter.value = Color.Lerp(dayColorFilter, nightColorFilter, t);
colorAdjustments.postExposure.value = Mathf.Lerp(dayPostExposure, nightPostExposure, t);
colorAdjustments.saturation.value = Mathf.Lerp(daySaturation, nightSaturation, t);
}

if (filmGrain != null) {
filmGrain.intensity.value = Mathf.Lerp(dayFilmGrainIntensity, nightFilmGrainIntensity, t);
}

if (vignette != null) {
vignette.intensity.value = Mathf.Lerp(dayVignetteIntensity, nightVignetteIntensity, t);
vignette.smoothness.value = Mathf.Lerp(dayVignetteSmoothness, nightVignetteSmoothness, t);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\RuntimeCircleDrawer.cs

﻿using UnityEngine;

pub cls RuntimeCircleDrawer : MonoBehaviour {
pub int segments = 30; // Number of line segments to approximate the circle
pub float radius = 1.0f;
pub float lineWidth = 0.02f;
pub Color color = Color.yellow;
pub Material lineMaterial; // Assign the same material used for firefly lines, or a specific one

LineRenderer lineRenderer;
bool needsRedraw = true; // Flag to force redraw on first UpdateCircle call or when params change
float currentRadius = -1f; // Store current values to detect changes
Color currentColor = Color.clear;

void Awake() {
lineRenderer = GetComponent<LineRenderer>();
if (lineRenderer == null) { // Should not happen with RequireComponent
Debug.LogError($"[{gameObject.name}] RuntimeCircleDrawer: Missing required LineRenderer component!");
enabled = false; // Disable script if component missing
return;
}
ConfigureLineRendererDefaults();
lineRenderer.enabled = false; // Start hidden
}

void ConfigureLineRendererDefaults() {
lineRenderer.useWorldSpace = false; // Draw relative to this object's transform
lineRenderer.loop = true; // Connect the last point to the first
lineRenderer.startWidth = lineWidth;
lineRenderer.endWidth = lineWidth;

if (lineMaterial != null && lineRenderer.material == null) {
lineRenderer.material = lineMaterial;
}

SpriteRenderer parentSprite = GetComponentInParent<SpriteRenderer>();
if (parentSprite != null) {
lineRenderer.sortingLayerName = parentSprite.sortingLayerName;
lineRenderer.sortingOrder = parentSprite.sortingOrder + 1; // Draw slightly in front
} else {
lineRenderer.sortingLayerName = "Default";
lineRenderer.sortingOrder = 1;
}
}

pub void UpdateCircle(float newRadius, Color newColor) {
bool radiusChanged = !Mathf.Approximately(currentRadius, newRadius);
bool colorChanged = currentColor != newColor;

if (!needsRedraw && !radiusChanged && !colorChanged) {
if (!lineRenderer.enabled) lineRenderer.enabled = true;
return; // No change needed
}

currentRadius = newRadius;
radius = newRadius; // Update pub field for potential inspector viewing
currentColor = newColor;
color = newColor; // Update pub field

lineRenderer.startColor = currentColor;
lineRenderer.endColor = currentColor;

if (colorChanged && Debug.isDebugBuild) {
Debug.Log($"[RuntimeCircleDrawer] Updated color to: {newColor}", gameObject);
}

DrawCircle(); // Recalculate points
lineRenderer.enabled = true; // Ensure it's visible
needsRedraw = false; // Mark as drawn
}

pub void HideCircle() {
if (lineRenderer != null && lineRenderer.enabled) {
lineRenderer.enabled = false;
needsRedraw = true; // Needs redraw next time it's shown
}
}

void DrawCircle() {
if (lineRenderer == null || segments <= 2 || radius <= 0f) {
lineRenderer.positionCount = 0; // Clear points if invalid params
return;
};

if (lineRenderer.positionCount != segments + 1) {
lineRenderer.positionCount = segments + 1;
}

float angleStep = 360f / segments;
Vector3[] points = new Vector3[segments + 1];

for (int i = 0; i <= segments; i++) {
float currentAngle = Mathf.Deg2Rad * (i * angleStep);
float x = Mathf.Cos(currentAngle) * radius;
float y = Mathf.Sin(currentAngle) * radius;
points[i] = new Vector3(x, y, 0); // Z is 0 for local space relative to transform
}

lineRenderer.SetPositions(points);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\WaterReflection.cs

﻿using UnityEngine;
using UnityEngine.Tilemaps;
using WegoSystem;
#if UNITY_EDITOR
using UnityEditor;
#endif

pub cls WaterReflection : MonoBehaviour {
pub cls OverrideSettings {
pub bool reflectionOpacity = false;
pub bool reflectionTint = false;
pub bool gradientFadeBaseMaterial = false;
pub bool sortingOrderOffset = false;
pub bool useWaterMasking = false;
pub bool waterTilemapTag = false;
pub bool showDebugInfo = false;
}
[SerializeField] OverrideSettings overrides;

[SerializeField] bool useParentAsReference = false; // This remains a local setting

[SerializeField] float yOffset = -1f; // This remains a local setting

[SerializeField] [Range(0f, 1f)] float localReflectionOpacity = 0.5f;

[SerializeField] Color localReflectionTint = Color.white;

[SerializeField] bool enableDistanceFade = true; // This remains local as it depends on material
[SerializeField] float fadeStartDistance = 0.0f; // Local
[SerializeField] float fadeEndDistance = 1.0f; // Local
[SerializeField] [Range(0f, 1f)] float minFadeAlpha = 0.0f; // Local
[SerializeField] Material localGradientFadeBaseMaterial;

[SerializeField] int localSortingOrderOffset = -1;

[SerializeField] bool localUseWaterMasking = true;
[SerializeField] string localWaterTilemapTag = "Water";

[SerializeField] bool localShowDebugInfo = false;

SpriteRenderer originalRenderer;
Animator originalAnimator;
GameObject reflectionObject;
SpriteRenderer reflectionRenderer;
Animator reflectionAnimator;
Material reflectionMaterialInstance; // Instanced material for this reflection

float _actualReflectionOpacity;
Color _actualReflectionTint;
Material _actualGradientFadeBaseMaterial;
int _actualSortingOrderOffset;
bool _actualUseWaterMasking;
string _actualWaterTilemapTag;
bool _actualShowDebugInfo;

Sprite lastSprite;
Color lastOriginalColor;
bool lastFlipX, lastFlipY;
bool lastEnabled;
Vector3 lastScale;
Vector3 lastPosition;
float lastParentY;

void Awake() {
_actualReflectionOpacity = localReflectionOpacity;
_actualReflectionTint = localReflectionTint;
_actualGradientFadeBaseMaterial = localGradientFadeBaseMaterial;
_actualSortingOrderOffset = localSortingOrderOffset;
_actualUseWaterMasking = localUseWaterMasking;
_actualWaterTilemapTag = localWaterTilemapTag;
_actualShowDebugInfo = localShowDebugInfo;

originalRenderer = GetComponent<SpriteRenderer>();
originalAnimator = GetComponent<Animator>();

if (originalRenderer == null) {
if (_actualShowDebugInfo) Debug.LogError($"[WaterReflection] No SpriteRenderer found on {gameObject.name}! Component disabled.", this);
enabled = false;
return;
}

if (useParentAsReference && transform.parent == null) {
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] 'Use Parent As Reference' is true on {gameObject.name}, but it has no parent. Will use self as reference.", this);
useParentAsReference = false;
}

if (Application.isPlaying) {
if (enableDistanceFade && _actualGradientFadeBaseMaterial == null) {
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection Awake] '{gameObject.name}': 'Enable Distance Fade' is true, but no 'Gradient Fade Base Material' (local or global) is assigned/found. Distance fade will not use the custom shader.", this);
}
}

CreateReflectionObject();

if (_actualUseWaterMasking) {
SetupWaterMaskingInteraction();
}
}

void ResolveSettings() {
if (WaterReflectionManager.Instance != null) {
_actualReflectionOpacity = overrides.reflectionOpacity ? localReflectionOpacity : WaterReflectionManager.Instance.defaultReflectionOpacity;
_actualReflectionTint = overrides.reflectionTint ? localReflectionTint : WaterReflectionManager.Instance.defaultReflectionTint;
_actualGradientFadeBaseMaterial = overrides.gradientFadeBaseMaterial ? localGradientFadeBaseMaterial : WaterReflectionManager.Instance.defaultGradientFadeMaterial;
_actualSortingOrderOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : WaterReflectionManager.Instance.defaultSortingOrderOffset;
_actualUseWaterMasking = overrides.useWaterMasking ? localUseWaterMasking : WaterReflectionManager.Instance.defaultUseWaterMasking;
_actualWaterTilemapTag = overrides.waterTilemapTag && !string.IsNullOrEmpty(localWaterTilemapTag) ? localWaterTilemapTag : WaterReflectionManager.Instance.defaultWaterTilemapTag;
_actualShowDebugInfo = overrides.showDebugInfo ? localShowDebugInfo : WaterReflectionManager.Instance.globalShowDebugInfo;
}
else // Fallback if no manager in scene {
_actualReflectionOpacity = localReflectionOpacity;
_actualReflectionTint = localReflectionTint;
_actualGradientFadeBaseMaterial = localGradientFadeBaseMaterial;
_actualSortingOrderOffset = localSortingOrderOffset;
_actualUseWaterMasking = localUseWaterMasking;
_actualWaterTilemapTag = localWaterTilemapTag;
_actualShowDebugInfo = localShowDebugInfo;
if (Application.isPlaying) Debug.LogWarning("[WaterReflection] WaterReflectionManager not found in scene. Using local settings for all reflections.", this);
}
}

void Start() {
ResolveSettings(); // Now resolve settings after all Awake() calls are completed
UpdateReflectionVisuals();
UpdateReflectionTransform();
CacheCurrentState();
}

void LateUpdate() {
if (originalRenderer == null || reflectionObject == null) {
if (reflectionObject != null) reflectionObject.SetActive(false);
return;
}
UpdateReflectionTransform();
if (HasVisualStateChanged()) {
UpdateReflectionVisuals();
CacheCurrentState();
}
}

void CreateReflectionObject() {
reflectionObject = new GameObject($"{gameObject.name}_Reflection");
reflectionObject.transform.SetParent(transform.parent, false);
reflectionObject.transform.SetSiblingIndex(transform.GetSiblingIndex() + 1);

reflectionRenderer = reflectionObject.AddComponent<SpriteRenderer>();
reflectionRenderer.sortingLayerName = originalRenderer.sortingLayerName;
reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + _actualSortingOrderOffset; // Use resolved
reflectionRenderer.drawMode = originalRenderer.drawMode;

if (enableDistanceFade && _actualGradientFadeBaseMaterial != null) // Use resolved {
reflectionMaterialInstance = new Material(_actualGradientFadeBaseMaterial);
reflectionRenderer.material = reflectionMaterialInstance;
if (_actualShowDebugInfo && Application.isPlaying) Debug.Log($"[{gameObject.name}] Instantiated gradient material for reflection using '{_actualGradientFadeBaseMaterial.name}'.", this);
}
else {
reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
if (enableDistanceFade && _actualGradientFadeBaseMaterial == null && _actualShowDebugInfo && Application.isPlaying) {
Debug.Log($"[{gameObject.name}] Using sharedMaterial for reflection as no gradientFadeBaseMaterial (local or global) was resolved during CreateReflectionObject.", this);
}
}

if (originalAnimator != null) {
reflectionAnimator = reflectionObject.AddComponent<Animator>();
reflectionAnimator.runtimeAnimatorController = originalAnimator.runtimeAnimatorController;
}
SortableEntity originalSortable = GetComponent<SortableEntity>();
if (originalSortable != null) {
reflectionObject.AddComponent<SortableEntity>();
}
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Created reflection for {gameObject.name}", this);
}

void UpdateReflectionTransform() {
if (reflectionObject == null || originalRenderer == null) return;
Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
Vector3 originalWorldPos = transform.position;
Vector3 reflectionWorldPos = originalWorldPos;
float referenceYForOffset = referenceTransform.position.y;
reflectionWorldPos.y = referenceYForOffset + yOffset - (originalWorldPos.y - referenceYForOffset);
reflectionObject.transform.position = reflectionWorldPos;
reflectionObject.transform.rotation = transform.rotation;
reflectionObject.transform.localScale = transform.localScale;
Vector3 currentLocalScale = reflectionObject.transform.localScale;
currentLocalScale.y *= -1;
reflectionObject.transform.localScale = currentLocalScale;
}

void UpdateReflectionVisuals() {
if (reflectionRenderer == null || originalRenderer == null) return;

reflectionRenderer.sprite = originalRenderer.sprite;
reflectionRenderer.flipX = originalRenderer.flipX;
reflectionRenderer.flipY = originalRenderer.flipY;

Color baseOriginalSpriteColor = originalRenderer.color;
Color finalReflectionTintedColor = baseOriginalSpriteColor * _actualReflectionTint; // Use resolved
float finalCombinedAlpha = baseOriginalSpriteColor.a * _actualReflectionOpacity; // Use resolved
reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);

if (enableDistanceFade && reflectionMaterialInstance != null) {
Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
float waterSurfaceY = referenceTransform.position.y;
reflectionMaterialInstance.SetFloat("_FadeStart", fadeStartDistance);
reflectionMaterialInstance.SetFloat("_FadeEnd", fadeEndDistance);
reflectionMaterialInstance.SetFloat("_MinAlpha", minFadeAlpha);
reflectionMaterialInstance.SetFloat("_OriginalY", waterSurfaceY);
Color materialBaseColor = _actualReflectionTint; // Use resolved
materialBaseColor.a = _actualReflectionOpacity * baseOriginalSpriteColor.a; // Use resolved
reflectionMaterialInstance.SetColor("_Color", materialBaseColor);
}
else if (!enableDistanceFade && reflectionMaterialInstance != null) {
reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
Destroy(reflectionMaterialInstance);
reflectionMaterialInstance = null;
}

reflectionRenderer.enabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;

if (reflectionAnimator != null && originalAnimator != null) {
reflectionAnimator.enabled = originalAnimator.enabled;
if (originalAnimator.runtimeAnimatorController != null && originalAnimator.parameterCount > 0) {
foreach (AnimatorControllerParameter param in originalAnimator.parameters) {
try {
switch (param.type) {
case AnimatorControllerParameterType.Bool:
reflectionAnimator.SetBool(param.name, originalAnimator.GetBool(param.name));
break;
case AnimatorControllerParameterType.Float:
reflectionAnimator.SetFloat(param.name, originalAnimator.GetFloat(param.name));
break;
case AnimatorControllerParameterType.Int:
reflectionAnimator.SetInteger(param.name, originalAnimator.GetInteger(param.name));
break;
}
} catch (System.Exception e) {
if(_actualShowDebugInfo) Debug.LogWarning($"Failed to sync animator param '{param.name}': {e.Message}", reflectionAnimator);
}
}
}
}
}

bool HasVisualStateChanged() {
if (originalRenderer == null) ret false;
bool parentYChanged = false;
if (useParentAsReference && transform.parent != null) {
parentYChanged = !Mathf.Approximately(lastParentY, transform.parent.position.y);
}
ret lastSprite != originalRenderer.sprite ||
!ColorsApproximatelyEqual(lastOriginalColor, originalRenderer.color) ||
lastFlipX != originalRenderer.flipX ||
lastFlipY != originalRenderer.flipY ||
lastEnabled != (originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy) ||
lastScale != transform.localScale ||
lastPosition != transform.position ||
parentYChanged;
}

void CacheCurrentState() {
if (originalRenderer == null) return;
lastSprite = originalRenderer.sprite;
lastOriginalColor = originalRenderer.color;
lastFlipX = originalRenderer.flipX;
lastFlipY = originalRenderer.flipY;
lastEnabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;
lastScale = transform.localScale;
lastPosition = transform.position;
if (useParentAsReference && transform.parent != null) {
lastParentY = transform.parent.position.y;
}
}

bool ColorsApproximatelyEqual(Color c1, Color c2, float tolerance = 0.001f) {
ret Mathf.Abs(c1.r - c2.r) < tolerance &&
Mathf.Abs(c1.g - c2.g) < tolerance &&
Mathf.Abs(c1.b - c2.b) < tolerance &&
Mathf.Abs(c1.a - c2.a) < tolerance;
}

void SetupWaterMaskingInteraction() {
if (!_actualUseWaterMasking || reflectionRenderer == null) return; // Use resolved
GameObject waterTilemapGO = FindWaterTilemapByTag(); // FindWaterTilemapByTag will use resolved tag
if (waterTilemapGO == null) {
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Water tilemap for masking not found on {gameObject.name} using tag '{_actualWaterTilemapTag}'. Masking disabled.", this);
return;
}
SpriteMask maskComponent = waterTilemapGO.GetComponent<SpriteMask>();
if (maskComponent == null) {
maskComponent = waterTilemapGO.AddComponent<SpriteMask>();
maskComponent.sprite = null;
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Added SpriteMask to water tilemap '{waterTilemapGO.name}' for object '{gameObject.name}'.", waterTilemapGO);
}
reflectionRenderer.maskInteraction = SpriteMaskInteraction.VisibleInsideMask;
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Reflection of '{gameObject.name}' will be masked by '{waterTilemapGO.name}'.", this);
}

GameObject FindWaterTilemapByTag() {
if (string.IsNullOrEmpty(_actualWaterTilemapTag)) ret FindWaterTilemapFallback();
GameObject taggedWater = GameObject.FindGameObjectWithTag(_actualWaterTilemapTag);
if (taggedWater != null && taggedWater.GetComponent<Tilemap>() != null) {
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Found water tilemap by tag '{_actualWaterTilemapTag}': {taggedWater.name} for {gameObject.name}", this);
ret taggedWater;
}
if (taggedWater != null && taggedWater.GetComponent<Tilemap>() == null && _actualShowDebugInfo) {
Debug.LogWarning($"[WaterReflection] GameObject '{taggedWater.name}' (tag '{_actualWaterTilemapTag}') has no Tilemap component!", this);
}
ret FindWaterTilemapFallback();
}

GameObject FindWaterTilemapFallback() {
if (TileInteractionManager.Instance != null) {
var mappings = TileInteractionManager.Instance.tileDefinitionMappings;
if (mappings != null) {
foreach (var mapping in mappings) {
if (mapping?.tileDef != null && mapping.tilemapModule != null && mapping.tileDef.isWaterTile) {
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null && renderTilemapTransform.GetComponent<Tilemap>() != null) {
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Auto-detected water tilemap via TIM: {renderTilemapTransform.name} for {gameObject.name}", this);
ret renderTilemapTransform.gameObject;
}
}
}
}
}
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Could not auto-detect water tilemap via TileInteractionManager for {gameObject.name}.", this);
ret null;
}

void OnDestroy() {
if (reflectionObject != null) {
if (Application.isPlaying) Destroy(reflectionObject);
else DestroyImmediate(reflectionObject);
}
if (reflectionMaterialInstance != null) {
if (Application.isPlaying) Destroy(reflectionMaterialInstance);
else DestroyImmediate(reflectionMaterialInstance);
}
}

void OnValidate() {
#if UNITY_EDITOR
EditorApplication.delayCall -= EditorUpdatePreview; // Remove previous requests to avoid stacking
EditorApplication.delayCall += EditorUpdatePreview; // Add a new request
#endif
}

#if UNITY_EDITOR
void EditorUpdatePreview() {
if (this == null || gameObject == null) // The object could be destroyed before the call {
return;
}

if (Application.isEditor && !Application.isPlaying) {
if (localShowDebugInfo) {
bool localMaterialNeeded = enableDistanceFade && (!overrides.gradientFadeBaseMaterial || localGradientFadeBaseMaterial == null);
bool globalMaterialMightBeUsed = enableDistanceFade && !overrides.gradientFadeBaseMaterial && localGradientFadeBaseMaterial == null;

if (localMaterialNeeded && !globalMaterialMightBeUsed) // Warn if local ovr is on but local material missing {
Debug.LogWarning($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true and 'Override Gradient Material' is true, but 'Local Gradient Fade Base Material' is not assigned. Assign local material or uncheck override.", this);
}
else if (globalMaterialMightBeUsed) // Inform that global will be used if local isn't set {
Debug.Log($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true. If 'Local Gradient Fade Base Material' remains unassigned and ovr is false, the global default from WaterReflectionManager will be used in Play mode.", this);
}
}

if (reflectionRenderer != null && originalRenderer != null) {
Color previewTint = overrides.reflectionTint ? localReflectionTint : Color.white; // Default to white if no manager
float previewOpacity = overrides.reflectionOpacity ? localReflectionOpacity : 0.5f;
int previewSortOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : -1;

reflectionRenderer.sprite = originalRenderer.sprite;
reflectionRenderer.flipX = originalRenderer.flipX;
reflectionRenderer.flipY = originalRenderer.flipY;
reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + previewSortOffset;
Color baseOriginalSpriteColor = originalRenderer.color;
Color finalReflectionTintedColor = baseOriginalSpriteColor * previewTint;
float finalCombinedAlpha = baseOriginalSpriteColor.a * previewOpacity;
reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);
UpdateReflectionTransform(); // Keep transform updated
}
}
}
#endif

pub void SetLocalReflectionOpacity(float opacity) // Example of changing a local-only value {
localReflectionOpacity = Mathf.Clamp01(opacity);
if (overrides.reflectionOpacity) // Only re-resolve and update if this local value is being used {
ResolveSettings();
if (Application.isPlaying && originalRenderer != null) UpdateReflectionVisuals();
}
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\WaterReflectionManager.cs

﻿using UnityEngine;

pub cls WaterReflectionManager : MonoBehaviour {
pub stat WaterReflectionManager Instance { get; set; }

pub Material defaultGradientFadeMaterial;

[Range(0f, 1f)] pub float defaultReflectionOpacity = 0.5f;

pub Color defaultReflectionTint = Color.white;

pub int defaultSortingOrderOffset = -1;

pub bool defaultUseWaterMasking = true;

pub string defaultWaterTilemapTag = "Water";

pub bool globalShowDebugInfo = false;

void Awake() {
if (Instance != null && Instance != this) {
Debug.LogWarning($"[WaterReflectionManager] Duplicate instance found on {gameObject.name}. Destroying self.", gameObject);
Destroy(gameObject);
return;
}
Instance = this;

if (defaultGradientFadeMaterial == null) {
Debug.LogWarning("[WaterReflectionManager] Default Gradient Fade Material is not assigned. Distance fade may not work correctly for reflections that don't have their own material specified.", this);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Placement\PlantGrowthModifierManager.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes;
using WegoSystem;

pub cls PlantGrowthModifierManager : MonoBehaviour, ITickUpdateable {
pub stat PlantGrowthModifierManager Instance { get; set; }

pub cls TileGrowthModifier {
pub TileDefinition tileDefinition;
pub float growthSpeedMultiplier = 1.0f;
pub float energyRechargeMultiplier = 1.0f;
}

pub float defaultGrowthSpeedMultiplier = 1.0f;
pub float defaultEnergyRechargeMultiplier = 1.0f;

pub List<TileGrowthModifier> tileModifiers = new List<TileGrowthModifier>();

[SerializeField] TileInteractionManager tileInteractionManager;
[SerializeField] bool showDebugMessages = true;
[SerializeField] bool showTileChangeMessages = true;

Dictionary<string, TileGrowthModifier> modifierLookup = new Dictionary<string, TileGrowthModifier>();
Dictionary<PlantGrowth, TileDefinition> plantTiles = new Dictionary<PlantGrowth, TileDefinition>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

BuildModifierLookup();
}

pub void Initialize() {
if (tileInteractionManager == null) {
tileInteractionManager = TileInteractionManager.Instance;
if (tileInteractionManager == null && showDebugMessages) {
Debug.LogWarning("PlantGrowthModifierManager: TileInteractionManager not found!");
}
}

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
else {
Debug.LogError("[PlantGrowthModifierManager] TickManager not found! Modifiers will not update.");
}
}

void OnDestroy() {
var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}
}

pub void OnTickUpdate(int currentTick) {
UpdateAllPlantTiles();
}

void UpdateAllPlantTiles() {
if (tileInteractionManager == null) return;

List<PlantGrowth> plantsToCheck = new List<PlantGrowth>(plantTiles.Keys);

foreach (PlantGrowth plant in plantsToCheck) {
if (plant == null) {
plantTiles.Remove(plant);
continue;
}

Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);

if (plantTiles.TryGetValue(plant, out TileDefinition previousTileDef) && currentTileDef != previousTileDef) {
plantTiles[plant] = currentTileDef;

if (showTileChangeMessages) {
string previousTileName = previousTileDef != null ? previousTileDef.displayName : "None";
string currentTileName = currentTileDef != null ? currentTileDef.displayName : "None";
Debug.Log($"Plant '{plant.name}' tile changed: {previousTileName} -> {currentTileName}");
}
}
}
}

void BuildModifierLookup() {
modifierLookup.Clear();
foreach (var modifier in tileModifiers) {
if (modifier.tileDefinition != null && !string.IsNullOrEmpty(modifier.tileDefinition.displayName) && !modifierLookup.ContainsKey(modifier.tileDefinition.displayName)) {
modifierLookup.Add(modifier.tileDefinition.displayName, modifier);
}
}
}

pub void RegisterPlantTile(PlantGrowth plant, TileDefinition tileDef) {
if (plant == null) return;
plantTiles[plant] = tileDef;

if (showDebugMessages) {
string tileName = tileDef != null ? tileDef.displayName : "Unknown Tile";
Debug.Log($"Registered plant {plant.name} on tile {tileName}");
}
}

pub void UnregisterPlant(PlantGrowth plant) {
if (plant != null) {
plantTiles.Remove(plant);
}
}

pub float GetGrowthSpeedMultiplier(PlantGrowth plant) {
if (plant == null) ret defaultGrowthSpeedMultiplier;

if (!plantTiles.ContainsKey(plant)) {
RegisterNewPlant(plant); // Auto-register if not found
}

if (plantTiles.TryGetValue(plant, out TileDefinition tileDef) && tileDef != null) {
if (modifierLookup.TryGetValue(tileDef.displayName, out TileGrowthModifier modifier)) {
ret modifier.growthSpeedMultiplier;
}
}

ret defaultGrowthSpeedMultiplier;
}

pub float GetEnergyRechargeMultiplier(PlantGrowth plant) {
if (plant == null) ret defaultEnergyRechargeMultiplier;

if (!plantTiles.ContainsKey(plant)) {
RegisterNewPlant(plant); // Auto-register if not found
}

if (plantTiles.TryGetValue(plant, out TileDefinition tileDef) && tileDef != null) {
if (modifierLookup.TryGetValue(tileDef.displayName, out TileGrowthModifier modifier)) {
ret modifier.energyRechargeMultiplier;
}
}

ret defaultEnergyRechargeMultiplier;
}

void RegisterNewPlant(PlantGrowth plant) {
if (plant == null || tileInteractionManager == null) return;

Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
plantTiles[plant] = currentTileDef;

if (showDebugMessages) {
string tileName = currentTileDef != null ? currentTileDef.displayName : "Unknown Tile";
Debug.Log($"Auto-registered new plant {plant.name} on tile {tileName}");
}
}

void OnValidate() {
BuildModifierLookup();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Placement\PlayerTileInteractor.cs

﻿// REWORKED FILE: Assets/Scripts/WorldInteraction/Placement/PlayerTileInteractor.cs

using Abracodabra.UI.Genes;
using WegoSystem;

pub sealed cls PlayerTileInteractor : MonoBehaviour {
[SerializeField] InventoryBarController inventoryBar;
[SerializeField] TileInteractionManager tileInteractionManager;
[SerializeField] Transform playerTransform;
[SerializeField] bool showDebug = false;

bool pendingLeftClick;
bool pendingRightClick;

void Awake() {
if (playerTransform == null) playerTransform = transform;
}

void Start() {
FindSingletons();
}

void Update() {
if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat) return;
if (Input.GetMouseButtonDown(0)) pendingLeftClick = true;
if (Input.GetMouseButtonDown(1)) pendingRightClick = true;
}

void LateUpdate() {
if (pendingLeftClick) {
pendingLeftClick = false;
HandleLeftClick();
}
if (pendingRightClick) {
pendingRightClick = false;
HandleRightClick();
}
}

void HandleRightClick() {
if (!EnsureManagers()) return;

InventoryBarItem selected = inventoryBar.SelectedItem;
if (selected == null || !selected.IsValid()) return;

if (selected.Type == InventoryBarItem.ItemType.Gene) {
var itemData = new HarvestedItem(selected.GeneInstance);
if (!itemData.IsConsumable()) return;

GardenerController player = playerTransform.GetComponent<GardenerController>();
if (player == null || player.HungerSystem == null) return;

player.HungerSystem.Eat(itemData.GetNutritionValue());

System.Action onSuccess = () => {
InventoryGridController.Instance.RemoveItemFromInventory(selected);

inventoryBar.ShowBar();
};

PlayerActionManager.Instance.ExecutePlayerAction(PlayerActionType.Interact,
tileInteractionManager.WorldToCell(playerTransform.position), "Eating", onSuccess);
}
}

void HandleLeftClick() {
if (!EnsureManagers()) return;

InventoryBarItem selected = inventoryBar.SelectedItem;
if (selected == null || !selected.IsValid()) {
if (showDebug) Debug.Log("[PlayerTileInteractor] Left-click ignored: No valid item selected.");
return;
}

if (!tileInteractionManager.IsWithinInteractionRange) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Left-click ignored: Target cell is out of range according to TileInteractionManager.");
return;
}

Vector3Int cellPos = tileInteractionManager.CurrentlyHoveredCell.Value;

if (showDebug) Debug.Log($"[PlayerTileInteractor] Attempting action '{selected.Type}' with item '{selected.GetDisplayName()}' at {cellPos}.");

switch (selected.Type) {
case InventoryBarItem.ItemType.Tool:
var toolDef = selected.ToolDefinition;

if (ToolSwitcher.Instance != null && ToolSwitcher.Instance.CurrentTool != toolDef) {
ToolSwitcher.Instance.SelectToolByDefinition(toolDef);
}

if (ToolSwitcher.Instance != null) {
if (!ToolSwitcher.Instance.TryConsumeUse()) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Action blocked: Tool '{selected.GetDisplayName()}' is out of uses.");
return;
}
}

PlayerActionManager.Instance.ExecutePlayerAction(PlayerActionType.UseTool, cellPos, toolDef);
break;

case InventoryBarItem.ItemType.Seed:
System.Action onSuccess = () => {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Successfully planted '{selected.GetDisplayName()}'. Removing from inventory.");
InventoryGridController.Instance?.RemoveItemFromInventory(selected);
inventoryBar.SelectSlotByIndex(0);
};
PlayerActionManager.Instance.ExecutePlayerAction(PlayerActionType.PlantSeed, cellPos, selected, onSuccess);
break;
}
}

bool EnsureManagers() {
if (tileInteractionManager == null || inventoryBar == null) FindSingletons();
ret tileInteractionManager != null && inventoryBar != null;
}

void FindSingletons() {
if (inventoryBar == null) inventoryBar = InventoryBarController.Instance;
if (tileInteractionManager == null) tileInteractionManager = TileInteractionManager.Instance;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\HarvestableTag.cs

﻿using UnityEngine;

pub cls HarvestableTag : MonoBehaviour {
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\HarvestedItem.cs

﻿// Reworked File: Assets/Scripts/WorldInteraction/Player/HarvestedItem.cs
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Implementations; // For NutritionComponent

pub cls HarvestedItem {
pub RuntimeGeneInstance HarvestedGeneInstance { get; set; }

pub HarvestedItem(RuntimeGeneInstance instance) {
HarvestedGeneInstance = instance;
}

pub float GetNutritionValue() {
if (HarvestedGeneInstance == null) ret 0f;

if (HarvestedGeneInstance.GetGene() is NutritiousPayload nutritiousGene) {
ret nutritiousGene.nutritionValue;
}

ret 0f; // Default if not a nutritious gene
}

pub bool IsConsumable() {
ret GetNutritionValue() > 0;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\PlayerActionManager.cs

﻿using System;
using WegoSystem;
using Abracodabra.Genes;
using Abracodabra.UI.Genes;

pub enum PlayerActionType {
Move,
UseTool,
PlantSeed,
Harvest,
Interact
}

pub cls PlayerActionManager : MonoBehaviour {
pub stat PlayerActionManager Instance { get; set; }

pub cls ToolActionData {
pub ToolDefinition Tool;
pub Vector3Int GridPosition;
}

[SerializeField] bool debugMode = true;
[SerializeField] int tickCostPerAction = 1;
[SerializeField] float multiTickActionDelay = 0.5f;

pub event Action<PlayerActionType, object> OnActionExecuted;
pub event Action<string> OnActionFailed;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

pub bool ExecutePlayerAction(PlayerActionType actionType, Vector3Int gridPosition, object actionData = null, Action onSuccessCallback = null) {
if (debugMode) Debug.Log($"[PlayerActionManager] Executing {actionType} at {gridPosition}");

bool success = false;
int tickCost = tickCostPerAction;
object eventPayload = actionData;

var toolDefForCheck = actionData as ToolDefinition;
if (actionType == PlayerActionType.UseTool && toolDefForCheck != null && toolDefForCheck.toolType == ToolType.HarvestPouch) {
actionType = PlayerActionType.Harvest;
}

switch (actionType) {
case PlayerActionType.UseTool:
var toolDef = actionData as ToolDefinition;
success = ExecuteToolUse(gridPosition, toolDef);
if (success) {
eventPayload = new ToolActionData { Tool = toolDef, GridPosition = gridPosition };
}
break;

case PlayerActionType.PlantSeed:
tickCost = 2; // Planting takes longer
var seedItem = actionData as InventoryBarItem;
success = ExecutePlantSeed(gridPosition, seedItem);
break;

case PlayerActionType.Harvest:
success = ExecuteHarvest(gridPosition);
break;

case PlayerActionType.Interact:
success = ExecuteInteraction(gridPosition, actionData);
break;
}

if (success) {
AdvanceGameTick(tickCost);
onSuccessCallback?.Invoke();
OnActionExecuted?.Invoke(actionType, eventPayload);
}
else {
OnActionFailed?.Invoke($"{actionType} failed at {gridPosition}");
}
ret success;
}

bool ExecuteToolUse(Vector3Int gridPosition, ToolDefinition tool) {
if (tool == null) ret false;
TileInteractionManager.Instance?.ApplyToolAction(tool);
ret true;
}

bool ExecutePlantSeed(Vector3Int gridPosition, InventoryBarItem seedItem) {
if (debugMode) Debug.Log($"[ExecutePlantSeed] Attempting to plant {seedItem?.GetDisplayName()} at {gridPosition}");

if (seedItem == null || seedItem.Type != InventoryBarItem.ItemType.Seed) {
Debug.LogError("[ExecutePlantSeed] Action failed: Provided item was not a valid seed.");
ret false;
}

bool result = PlantPlacementManager.Instance?.TryPlantSeedFromInventory( seedItem.SeedRuntimeState, gridPosition, TileInteractionManager.Instance.interactionGrid.GetCellCenterWorld(gridPosition)
) ?? false;

if (debugMode) Debug.Log($"[ExecutePlantSeed] PlantPlacementManager returned: {result}");
ret result;
}

bool ExecuteHarvest(Vector3Int gridPosition) {
var plantEntity = GridPositionManager.Instance?.GetEntitiesAt(new GridPosition(gridPosition))
.FirstOrDefault(e => e.GetComponent<PlantGrowth>() != null);

if (plantEntity == null) {
if (debugMode) Debug.Log($"Harvest failed: No plant found at {gridPosition}");
ret false;
}

var plant = plantEntity.GetComponent<PlantGrowth>();
if (plant == null) ret false;

Debug.LogWarning("PlayerActionManager.ExecuteHarvest needs to be updated to handle returned items from PlantGrowth.");
bool wasHarvested = true;

ret wasHarvested;
}

bool ExecuteInteraction(Vector3Int gridPosition, object interactionData) {
if (debugMode) Debug.Log($"[PlayerActionManager] Interaction at {gridPosition}");
ret true;
}

IEnumerator ExecuteDelayedAction(Func<bool> action, int tickCost, Action onSuccessCallback, PlayerActionType actionType, object actionData) {
for (int i = 0; i < tickCost -1; i++) {
yield ret new WaitForSeconds(multiTickActionDelay);
AdvanceGameTick(1);
}

bool success = action.Invoke();

if (success) {
AdvanceGameTick(1); // Final tick
onSuccessCallback?.Invoke();
OnActionExecuted?.Invoke(actionType, actionData);
}
else {
OnActionFailed?.Invoke($"{actionType} (delayed) failed");
}
}

pub int GetMovementTickCost(Vector3 worldPosition, Component movingEntity = null) {
int totalCost = tickCostPerAction;
if (movingEntity != null) {
IStatusEffectable effectable = movingEntity.GetComponent<IStatusEffectable>();
if (effectable != null) {
totalCost += effectable.StatusManager.AdditionalMoveTicks;
}
}
ret totalCost;
}

void AdvanceGameTick(int tickCount = 1) {
if (TickManager.Instance == null) return;
for (int i = 0; i < tickCount; i++) {
TickManager.Instance.AdvanceTick();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\PlayerHungerSystem.cs

﻿using System;
using WegoSystem;

pub cls PlayerHungerSystem : MonoBehaviour, ITickUpdateable {
[SerializeField] float maxHunger = 100f;
[SerializeField] float startingHunger = 100f;
[SerializeField] float hungerDepletionPerTick = 0.1f; // Default: 1 hunger per 10 ticks

pub float CurrentHunger { get; set; }
pub float MaxHunger => maxHunger;

pub event Action<float, float> OnHungerChanged; // current, max
pub event Action OnStarvation;

bool hasStarved = false;

void Start() {
CurrentHunger = startingHunger;
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
else {
Debug.LogError("[PlayerHungerSystem] TickManager not found! Hunger will not deplete.");
}
}

void OnDestroy() {
var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}
}

pub void OnTickUpdate(int currentTick) {
if (hasStarved) return;

CurrentHunger -= hungerDepletionPerTick;
CurrentHunger = Mathf.Max(0, CurrentHunger);

OnHungerChanged?.Invoke(CurrentHunger, maxHunger);

if (CurrentHunger <= 0) {
hasStarved = true;
OnStarvation?.Invoke();
Debug.LogWarning("Player has starved to death!");
}
}

pub void Eat(float nutritionValue) {
if (hasStarved || nutritionValue <= 0) return;

CurrentHunger += nutritionValue;
CurrentHunger = Mathf.Clamp(CurrentHunger, 0, maxHunger);

Debug.Log($"Player ate food. Restored {nutritionValue} hunger. Current hunger: {CurrentHunger}/{maxHunger}");
OnHungerChanged?.Invoke(CurrentHunger, maxHunger);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileHoverColorManager.cs

﻿using UnityEngine;

pub cls TileHoverColorManager : ScriptableObject {
Color withinRangeColor = new Color(1f, 1f, 1f, 0.8f);

Color outsideRangeColor = new Color(1f, 1f, 1f, 0.3f);

pub Color WithinRangeColor => withinRangeColor;
pub Color OutsideRangeColor => outsideRangeColor;

pub Color GetColorForRange(bool isWithinRange) {
ret isWithinRange ? withinRangeColor : outsideRangeColor;
}

void OnValidate() {
if (withinRangeColor.a < outsideRangeColor.a) {
Debug.LogWarning("[TileHoverColorManager] Within range alpha should typically be higher than outside range alpha for better visibility.");
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileInteractionLibrary.cs

﻿using System.Collections.Generic;
using System; // Needed for [Serializable]

[Serializable] // Make it visible in the Inspector
pub cls ToolRefillRule {
pub ToolDefinition toolToRefill;

pub TileDefinition refillSourceTile;
}

pub cls TileInteractionLibrary : ScriptableObject {
pub List<TileInteractionRule> rules; // Existing transformation rules

[Header("Tool Refill Rules")] // <<< NEW HEADER
pub List<ToolRefillRule> refillRules; // <<< NEW LIST FOR REFILLS
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileInteractionRule.cs

﻿using System;

pub cls TileInteractionRule {
pub ToolDefinition tool;

pub TileDefinition fromTile;
pub TileDefinition toTile;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tools\ToolDefinition.cs

﻿using UnityEngine;
using System.Text;

pub cls ToolDefinition : ScriptableObject, ITooltipDataProvider {

pub ToolType toolType;
pub string displayName;

pub Sprite icon;
pub Color iconTint = Color.white;

pub bool limitedUses = false;
pub int initialUses = 10;

pub bool autoAddToInventory = true;

pub string GetTooltipTitle() {
ret displayName ?? "Unknown Tool";
}

pub string GetTooltipDescription() {
ret $"Tool Type: {toolType}";
}

pub string GetTooltipDetails(object source = null) {
var sb = new StringBuilder();
sb.Append(limitedUses ? $"<b>Uses:</b> {initialUses}" : "<b>Uses:</b> Unlimited");
ret sb.ToString().TrimEnd();
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tools\ToolSwitcher.cs

﻿using System;

pub cls ToolSwitcher : MonoBehaviour {
pub stat ToolSwitcher Instance { get; set; }

pub ToolDefinition[] toolDefinitions;

int currentIndex = 0;

pub ToolDefinition CurrentTool { get; set; } = null;
pub int CurrentRemainingUses { get; set; } = -1; // -1 for unlimited

pub event Action<ToolDefinition> OnToolChanged;
pub event Action<int> OnUsesChanged;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

void Start() {
InitializeToolState(true); // Initialize and fire events
}

void OnDestroy() {
if (Instance == this) {
Instance = null;
}
}

void Update() {
if (toolDefinitions == null || toolDefinitions.Length == 0) return;

bool toolChanged = false;
int previousIndex = currentIndex;

if (Input.GetKeyDown(KeyCode.Q)) {
currentIndex--;
if (currentIndex < 0)
currentIndex = toolDefinitions.Length - 1;
toolChanged = true;
}
else if (Input.GetKeyDown(KeyCode.E)) {
currentIndex++;
if (currentIndex >= toolDefinitions.Length)
currentIndex = 0;
toolChanged = true;
}

if (toolChanged) {
if (currentIndex >= 0 && currentIndex < toolDefinitions.Length && toolDefinitions[currentIndex] != null) {
InitializeToolState(false); // Update state for the new tool and fire events
}
else {
Debug.LogError($"[ToolSwitcher Update] Attempted to switch to an invalid/NULL tool definition at index {currentIndex}. Reverting.");
currentIndex = previousIndex; // Revert to the last valid index
}
}
}

void InitializeToolState(bool isInitialSetup) {
ToolDefinition previousTool = CurrentTool; // Store previous tool for change check
int previousUses = CurrentRemainingUses; // Store previous uses

if (toolDefinitions == null || toolDefinitions.Length == 0 || currentIndex < 0 || currentIndex >= toolDefinitions.Length || toolDefinitions[currentIndex] == null) {
CurrentTool = null;
CurrentRemainingUses = -1; // No tool = unlimited uses conceptually
}
else {
CurrentTool = toolDefinitions[currentIndex];
if (CurrentTool.limitedUses) {
CurrentRemainingUses = CurrentTool.initialUses;
}
else {
CurrentRemainingUses = -1; // Mark as unlimited
}
}

LogToolChange("[ToolSwitcher InitializeToolState]"); // Log the state after update

bool toolActuallyChanged = previousTool != CurrentTool;
bool usesActuallyChanged = previousUses != CurrentRemainingUses;

if (isInitialSetup || toolActuallyChanged) {
Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnToolChanged for tool: {CurrentTool?.displayName ?? "NULL"}");
OnToolChanged?.Invoke(CurrentTool);
}
if (isInitialSetup || usesActuallyChanged || toolActuallyChanged) // Fire uses changed if tool changed too (to reset UI) {
Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnUsesChanged with value: {CurrentRemainingUses}");
OnUsesChanged?.Invoke(CurrentRemainingUses);
}
}

pub void SelectToolByDefinition(ToolDefinition toolDef) {
if (toolDef == null || toolDefinitions == null) return;

for (int i = 0; i < toolDefinitions.Length; i++) {
if (toolDefinitions[i] == toolDef) {
currentIndex = i;
InitializeToolState(false);
Debug.Log($"[ToolSwitcher] Externally selected tool: {toolDef.displayName} at index {i}");
return;
}
}

Debug.LogWarning($"[ToolSwitcher] Tool '{toolDef.displayName}' not found in definitions array");
}

pub void RefillCurrentTool() {
if (CurrentTool == null) {
Debug.LogWarning("[ToolSwitcher RefillCurrentTool] Cannot refill: No tool selected.");
return;
}

if (!CurrentTool.limitedUses) {
Debug.LogWarning($"[ToolSwitcher RefillCurrentTool] Cannot refill tool '{CurrentTool.displayName}': It has unlimited uses.");
return;
}

if (CurrentRemainingUses == CurrentTool.initialUses) {
if(Debug.isDebugBuild) Debug.Log($"[ToolSwitcher RefillCurrentTool] Tool '{CurrentTool.displayName}' is already full ({CurrentRemainingUses} uses).");
return;
}

int previousUses = CurrentRemainingUses;
CurrentRemainingUses = CurrentTool.initialUses;

Debug.Log($"[ToolSwitcher RefillCurrentTool] Refilled tool '{CurrentTool.displayName}' to {CurrentRemainingUses} uses (was {previousUses}).");

OnUsesChanged?.Invoke(CurrentRemainingUses);
}

pub bool TryConsumeUse() {
if (CurrentTool == null) {
Debug.LogWarning("[ToolSwitcher TryConsumeUse] Cannot consume use: No tool selected.");
ret false; // Cannot use a non-existent tool
}

if (!CurrentTool.limitedUses || CurrentRemainingUses == -1) {
ret true;
}

if (CurrentRemainingUses > 0) {
CurrentRemainingUses--;
Debug.Log($"[ToolSwitcher TryConsumeUse] Consumed use for '{CurrentTool.displayName}'. Remaining: {CurrentRemainingUses}");
OnUsesChanged?.Invoke(CurrentRemainingUses); // Notify listeners
ret true;
}
else {
Debug.Log($"[ToolSwitcher TryConsumeUse] Tool '{CurrentTool.displayName}' is out of uses (0 remaining).");
ret false;
}
}

void LogToolChange(string prefix = "[ToolSwitcher]") {
string toolName = (CurrentTool != null && !string.IsNullOrEmpty(CurrentTool.displayName))
? CurrentTool.displayName
: "(none)";
string usesSuffix = "";
if (CurrentTool != null && CurrentTool.limitedUses && CurrentRemainingUses >= 0) {
usesSuffix = $" ({CurrentRemainingUses}/{CurrentTool.initialUses})";
}
else if (CurrentTool != null && !CurrentTool.limitedUses) {
}

Debug.Log($"{prefix} Switched tool to: {toolName}{usesSuffix} (Index: {currentIndex})");
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tools\ToolType.cs

﻿pub enum ToolType {
None,
Hoe,
WateringCan,
SeedPouch,
HarvestPouch // <<< NEW
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\CameraController.cs

﻿using UnityEngine;
using UnityEngine.U2D;
using WegoSystem;

namespace WegoSystem {
pub cls CameraController : MonoBehaviour {
[SerializeField] MapConfiguration mapConfig;
[SerializeField] pub Transform followTarget;
[SerializeField] Camera cam;

[SerializeField] bool enableFollow = false;
[SerializeField] float smoothSpeed = 5f;
[SerializeField] Vector2 offset = Vector2.zero;

[SerializeField] bool constrainToMap = true;
[SerializeField] float boundaryPadding = 2f; // Tiles from edge

PixelPerfectCamera pixelPerfectCam;
Vector2 minBounds, maxBounds;

void Awake() {
if (cam == null) cam = GetComponent<Camera>();
pixelPerfectCam = GetComponent<PixelPerfectCamera>();

if (mapConfig == null) {
Debug.LogError("[CameraController] MapConfiguration is not assigned! Camera cannot calculate bounds.", this);
enabled = false;
}
}

void Start() {
CalculateCameraBounds();

if (followTarget == null) {
var player = FindFirstObjectByType<GardenerController>();
if (player != null) {
followTarget = player.transform;
Debug.Log("[CameraController] Follow target not set, automatically assigned to GardenerController.", this);
}
}
}

void LateUpdate() {
if (!enableFollow || followTarget == null || mapConfig == null) return;

Vector3 desiredPosition = followTarget.position + (Vector3)offset;
desiredPosition.z = transform.position.z; // Keep Z unchanged

if (constrainToMap) {
desiredPosition.x = Mathf.Clamp(desiredPosition.x, minBounds.x, maxBounds.x);
desiredPosition.y = Mathf.Clamp(desiredPosition.y, minBounds.y, maxBounds.y);
}

Vector3 smoothedPosition = Vector3.Lerp(
transform.position,
desiredPosition,
smoothSpeed * Time.deltaTime
);

if (pixelPerfectCam != null && pixelPerfectCam.enabled) {
float pixelSize = 1f / pixelPerfectCam.assetsPPU;
smoothedPosition.x = Mathf.Round(smoothedPosition.x / pixelSize) * pixelSize;
smoothedPosition.y = Mathf.Round(smoothedPosition.y / pixelSize) * pixelSize;
}

transform.position = smoothedPosition;
}

void CalculateCameraBounds() {
if (mapConfig == null) return;

float height = cam.orthographicSize * 2;
float width = height * cam.aspect;

minBounds.x = (width / 2f) + boundaryPadding;
maxBounds.x = mapConfig.mapSize.x - (width / 2f) - boundaryPadding;
minBounds.y = (height / 2f) + boundaryPadding;
maxBounds.y = mapConfig.mapSize.y - (height / 2f) - boundaryPadding;

if (maxBounds.x < minBounds.x) {
float center = mapConfig.mapSize.x / 2f;
minBounds.x = maxBounds.x = center;
}
if (maxBounds.y < minBounds.y) {
float center = mapConfig.mapSize.y / 2f;
minBounds.y = maxBounds.y = center;
}
}

pub void SnapToTarget() {
if (followTarget == null) return;
Vector3 targetPos = followTarget.position + (Vector3)offset;
targetPos.z = transform.position.z;
transform.position = targetPos;
}

pub void OnResolutionChanged() {
CalculateCameraBounds();
var zoomController = GetComponent<CameraZoomController>();
if (zoomController != null) {
zoomController.StoreBaseSize();
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\CameraZoomController.cs

﻿using UnityEngine;
using WegoSystem;

ns WegoSystem {
pub cls CameraZoomController : MonoBehaviour {
[SerializeField] Camera targetCamera;
[SerializeField] float zoomSpeed = 0.5f;
[SerializeField] float minZoom = 0.5f;  // 2x closer
[SerializeField] float maxZoom = 3.0f;  // 3x further
[SerializeField] bool enableZoom = true;

float baseOrthographicSize;
float currentZoomLevel = 1f;

void Start() {
if (targetCamera == null) targetCamera = Camera.main;
StoreBaseSize();
}

void Update() {
if (!enableZoom) return;

float scroll = Input.GetAxis("Mouse ScrollWheel");
if (Mathf.Abs(scroll) > 0.01f) {
ZoomCamera(-scroll * zoomSpeed);
}
}

void ZoomCamera(float zoomDelta) {
currentZoomLevel = Mathf.Clamp(currentZoomLevel + zoomDelta, minZoom, maxZoom);
targetCamera.orthographicSize = baseOrthographicSize * currentZoomLevel;
}

pub void StoreBaseSize() {
if (targetCamera != null) {
baseOrthographicSize = targetCamera.orthographicSize;
}
}

pub void ResetZoom() {
currentZoomLevel = 1f;
targetCamera.orthographicSize = baseOrthographicSize;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\InitializationManager.cs

﻿using System.Collections;
using WegoSystem;

namespace WegoSystem {
pub cls InitializationManager : SingletonMonoBehaviour<InitializationManager> {
[SerializeField] GameEvent onCoreSystemsInitialized;
[SerializeField] GameEvent onGameManagersInitialized;
[SerializeField] GameEvent onGameplaySystemsInitialized;

IEnumerator Start() {
Debug.Log("[InitializationManager] Starting initialization sequence...");

Debug.Log("[InitializationManager] Phase 1: Initializing Core Systems...");
onCoreSystemsInitialized.Raise();
yield ret null;

Debug.Log("[InitializationManager] Phase 2: Initializing Game Managers...");
onGameManagersInitialized.Raise();
yield ret null;

if (UIManager.Instance != null) {
Debug.Log("[InitializationManager] Initializing UIManager...");
UIManager.Instance.Initialize();
}
else {
Debug.LogError("[InitializationManager] UIManager instance not found! UI will not be initialized.");
}

if (EnvironmentalStatusEffectSystem.Instance != null) {
Debug.Log("[InitializationManager] Initializing EnvironmentalStatusEffectSystem...");
EnvironmentalStatusEffectSystem.Instance.Initialize();
}
else {
Debug.LogWarning("[InitializationManager] EnvironmentalStatusEffectSystem instance not found. Tile-based status effects will not function.");
}

Debug.Log("[InitializationManager] Phase 3: Initializing Gameplay Systems & UI...");
onGameplaySystemsInitialized.Raise();
yield ret null;

Debug.Log("[InitializationManager] All systems initialized successfully.");
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\PixelGridSnapper.cs

﻿using UnityEngine;
using WegoSystem;

namespace WegoSystem {
pub stat cls PixelGridSnapper {
stat float cachedPixelSize;
stat bool pixelSizeIsCached = false;

pub stat Vector3 SnapToGrid(Vector3 position) {
if (ResolutionManager.HasInstance) {
if (!pixelSizeIsCached) // Cache it once for performance {
cachedPixelSize = 1f / ResolutionManager.Instance.CurrentPPU;
pixelSizeIsCached = true;
}

position.x = Mathf.Round(position.x / cachedPixelSize) * cachedPixelSize;
position.y = Mathf.Round(position.y / cachedPixelSize) * cachedPixelSize;
ret position;
}

ret position;
}

pub stat Vector2 SnapToGrid(Vector2 position) {
Vector3 snapped = SnapToGrid((Vector3)position);
ret new Vector2(snapped.x, snapped.y);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\RunManager.cs

﻿// Assets/Scripts/Core/RunManager.cs
using WegoSystem;

namespace WegoSystem {
pub enum RunState {
Planning,
GrowthAndThreat
}

pub enum GamePhase {
Planning,
Execution
}

pub cls RunManager : SingletonMonoBehaviour<RunManager> {

[SerializeField] RunState currentState = RunState.Planning;
[SerializeField] GamePhase currentPhase = GamePhase.Planning;
[SerializeField] int currentRoundNumber = 1;
[SerializeField] int currentPhaseTicks = 0;

pub RunState CurrentState => currentState;
pub GamePhase CurrentPhase => currentPhase;
pub int CurrentRoundNumber => currentRoundNumber;
pub int CurrentPhaseTicks => currentPhaseTicks;

pub event Action<RunState> OnRunStateChanged;
pub event Action<GamePhase, GamePhase> OnPhaseChanged;
pub event Action<int> OnRoundChanged;

prot ovr void OnAwake() {
SetState(RunState.Planning, true);
}

pub void Initialize() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(new PhaseTickHandler(this));
}
else {
Debug.LogError("[RunManager] Initialization failed: TickManager not found!");
}
}

void SetState(RunState newState, bool force = false) {
if (currentState == newState && !force) return;

currentState = newState;
Debug.Log($"[RunManager] State changed to: {currentState}");

switch (currentState) {
case RunState.Planning:
WeatherManager.Instance?.PauseCycleAtDay();
SetPhase(GamePhase.Planning);
break;

case RunState.GrowthAndThreat:
WeatherManager.Instance?.ResumeCycle();
WaveManager.Instance?.StartWaveForRound(currentRoundNumber);
SetPhase(GamePhase.Execution);
break;
}

OnRunStateChanged?.Invoke(currentState);
}

void SetPhase(GamePhase newPhase) {
if (currentPhase == newPhase) return;

GamePhase oldPhase = currentPhase;
currentPhase = newPhase;
currentPhaseTicks = 0;

Debug.Log($"[RunManager] Phase changed: {oldPhase} -> {newPhase}");
OnPhaseChanged?.Invoke(oldPhase, newPhase);
}

pub void StartGrowthAndThreatPhase() {
if (currentState == RunState.Planning) {
Debug.Log($"[RunManager] Starting Growth & Threat for Round {currentRoundNumber}");
SetState(RunState.GrowthAndThreat);
}
}

pub void EndPlanningPhase() {
if (currentState == RunState.Planning && currentPhase == GamePhase.Planning) {
SetPhase(GamePhase.Execution);
StartGrowthAndThreatPhase();
}
}

pub void StartNewPlanningPhase() {
Debug.Log("[RunManager] Starting new planning phase");

if (currentState != RunState.Planning) {
if (WaveManager.Instance != null && WaveManager.Instance.IsCurrentWaveDefeated()) {
StartNewRound();
}
else {
SetState(RunState.Planning);
}
}
}

void StartNewRound() {
currentRoundNumber++;
Debug.Log($"[RunManager] Starting new round: {currentRoundNumber}");

WaveManager.Instance?.ResetForNewRound();
SetState(RunState.Planning);

OnRoundChanged?.Invoke(currentRoundNumber);
}

cls PhaseTickHandler : ITickUpdateable {
RunManager manager;

pub PhaseTickHandler(RunManager manager) {
this.manager = manager;
}

pub void OnTickUpdate(int currentTick) {
manager.currentPhaseTicks++;
}
}

pub void ForcePhase(GamePhase phase) {
if (Application.isEditor || Debug.isDebugBuild) {
SetPhase(phase);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\SingletonMonoBehaviour.cs

﻿using UnityEngine;

namespace WegoSystem {
pub abs cls SingletonMonoBehaviour<T> : MonoBehaviour where T : MonoBehaviour {
stat T _instance;
stat ro object _lock = new object();
stat bool _applicationIsQuitting = false;

pub stat T Instance {
get {
if (_applicationIsQuitting) {
ret null;
}

lock (_lock) {
if (_instance == null) {
_instance = FindFirstObjectByType<T>();

if (_instance == null) {
Debug.LogError($"[Singleton] CRITICAL: An instance of '{typeof(T).Name}' is needed in the scene, but none was found. " +
"Ensure a GameObject with this component exists and is active in your scene.");
}
}
ret _instance;
}
}
}

pub stat bool HasInstance => _instance != null;

#if UNITY_EDITOR
stat void ResetStaticData() {
_applicationIsQuitting = false;
}
#endif

prot virt void Awake() {
if (_instance == null) {
_instance = this as T;

transform.SetParent(null);
DontDestroyOnLoad(gameObject);
}
else if (_instance != this) {
Debug.LogWarning($"[Singleton] Another instance of '{typeof(T).Name}' already exists. Destroying duplicate on '{gameObject.name}'.", gameObject);
Destroy(gameObject);
return;
}

OnAwake();
}

prot virt void OnAwake() { }

prot virt void OnApplicationQuit() {
_applicationIsQuitting = true;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\EnvironmentalStatusEffectSystem.cs

﻿using System.Collections.Generic;
using WegoSystem;

namespace WegoSystem {
pub cls EnvironmentalStatusEffectSystem : MonoBehaviour, ITickUpdateable {
pub stat EnvironmentalStatusEffectSystem Instance { get; set; }

pub cls TileStatusRule {
pub TileDefinition tile;
pub List<StatusEffect> statusEffectsToApply;
}

pub cls ToolStatusRule {
pub ToolDefinition tool;
pub List<StatusEffect> statusEffectsToApply;
}

pub List<TileStatusRule> tileRules = new List<TileStatusRule>();
pub List<ToolStatusRule> toolRules = new List<ToolStatusRule>();

ro Dictionary<TileDefinition, List<StatusEffect>> tileRuleLookup = new Dictionary<TileDefinition, List<StatusEffect>>();
ro Dictionary<ToolDefinition, List<StatusEffect>> toolRuleLookup = new Dictionary<ToolDefinition, List<StatusEffect>>();
ro List<IStatusEffectable> allEffectableEntities = new List<IStatusEffectable>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
BuildLookups();
}

pub void Initialize() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
if (PlayerActionManager.Instance != null) {
PlayerActionManager.Instance.OnActionExecuted += HandlePlayerAction;
}
}

void OnDestroy() {
if (Instance == this) Instance = null;

var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}

if (PlayerActionManager.Instance != null) {
PlayerActionManager.Instance.OnActionExecuted -= HandlePlayerAction;
}
}

void BuildLookups() {
tileRuleLookup.Clear();
foreach (var rule in tileRules) {
if (rule.tile != null && rule.statusEffectsToApply != null && rule.statusEffectsToApply.Count > 0) {
tileRuleLookup[rule.tile] = rule.statusEffectsToApply;
}
}

toolRuleLookup.Clear();
foreach (var rule in toolRules) {
if (rule.tool != null && rule.statusEffectsToApply != null && rule.statusEffectsToApply.Count > 0) {
toolRuleLookup[rule.tool] = rule.statusEffectsToApply;
}
}
}

pub void OnTickUpdate(int currentTick) {
RefreshAllEntityTileEffects();
}

void HandlePlayerAction(PlayerActionType actionType, object actionData) {
if (actionType != PlayerActionType.UseTool) return;

var toolData = actionData as PlayerActionManager.ToolActionData;
if (toolData == null) return;

if (toolRuleLookup.TryGetValue(toolData.Tool, out List<StatusEffect> effectsToApply)) {
if (GridPositionManager.Instance == null) return;
GridPosition gridPos = new GridPosition(toolData.GridPosition);
HashSet<GridEntity> entitiesOnTile = GridPositionManager.Instance.GetEntitiesAt(gridPos);

foreach(var entity in entitiesOnTile) {
IStatusEffectable effectable = entity.GetComponent<IStatusEffectable>();
if (effectable != null) {
foreach(var effect in effectsToApply) {
effectable.StatusManager.ApplyStatusEffect(effect);
}
}
}
}
}

void RefreshAllEntityTileEffects() {
var animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
var players = FindObjectsByType<GardenerController>(FindObjectsSortMode.None);

allEffectableEntities.Clear();
foreach (var animal in animals) allEffectableEntities.Add(animal);
foreach (var player in players) allEffectableEntities.Add(player);

foreach(var entity in allEffectableEntities) {
CheckAndApplyTileEffects(entity);
}
}

pub void CheckAndApplyTileEffects(IStatusEffectable entity) {
if (entity == null || entity.GridEntity == null || TileInteractionManager.Instance == null) return;

Component entityComponent = entity as Component;
if (entityComponent == null || !entityComponent.gameObject.activeInHierarchy) return;

GridPosition currentPos = entity.GridEntity.Position;

TileDefinition currentTile = TileInteractionManager.Instance.FindWhichTileDefinitionAt(currentPos.ToVector3Int());

if (currentTile == null) return;

if (tileRuleLookup.TryGetValue(currentTile, out List<StatusEffect> effectsToApply)) {
foreach (var effect in effectsToApply) {
if (effect != null) {
entity.StatusManager.ApplyStatusEffect(effect);
}
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\ProceduralGeneration\MapConfiguration.cs

﻿using UnityEngine;
using WegoSystem;

namespace WegoSystem {
pub cls MapConfiguration : ScriptableObject {
pub Vector2Int mapSize = new Vector2Int(100, 100);
pub Vector2Int gridOffset = Vector2Int.zero;

pub int gizmoDisplayRadius = 20;
pub bool autoScaleGizmos = true;

[Header("Camera Settings")] // Renamed header for clarity
pub Vector2Int referenceResolution = new Vector2Int(320, 180);
pub int pixelsPerUnit = 6;

pub GridPosition GetMapCenter() => new GridPosition(mapSize.x / 2, mapSize.y / 2);

pub int GetAdaptiveGizmoSize() {
if (!autoScaleGizmos) ret gizmoDisplayRadius;
ret Mathf.Min(gizmoDisplayRadius, Mathf.Max(mapSize.x, mapSize.y) / 5);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\ProceduralGeneration\ResolutionManager.cs

﻿using UnityEngine;
using URPPixelPerfectCamera = UnityEngine.Rendering.Universal.PixelPerfectCamera;
using WegoSystem;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
pub cls ResolutionManager : SingletonMonoBehaviour<ResolutionManager> {
pub cls ResolutionProfile {
pub string name;
pub Vector2Int resolution;
pub int pixelsPerUnit = 6;
pub float cameraZoomMultiplier = 1f;
}

[SerializeField] Camera mainCamera;
[SerializeField] MapConfiguration mapConfig;

[SerializeField] ResolutionProfile[] profiles = {
new ResolutionProfile {
name = "Pixel Perfect 320x180",
resolution = new Vector2Int(320, 180),
pixelsPerUnit = 16,
cameraZoomMultiplier = 1f
},
new ResolutionProfile {
name = "HD 640x360",
resolution = new Vector2Int(640, 360),
pixelsPerUnit = 16,
cameraZoomMultiplier = 1f
},
new ResolutionProfile {
name = "Full HD 1280x720",
resolution = new Vector2Int(1280, 720),
pixelsPerUnit = 16,
cameraZoomMultiplier = 1f
},
new ResolutionProfile {
name = "4K 2560x1440",
resolution = new Vector2Int(2560, 1440),
pixelsPerUnit = 16,
cameraZoomMultiplier = 1f
}
};

[SerializeField] int currentProfileIndex = 0;

pub int CurrentPPU { get; set; } = 6;

URPPixelPerfectCamera pixelPerfectCam;

prot ovr void OnAwake() {
base.OnAwake();
if (mainCamera == null) {
mainCamera = Camera.main;
}
if (mainCamera != null) {
pixelPerfectCam = mainCamera.GetComponent<URPPixelPerfectCamera>();
}
}

void Start() {
ApplyProfile(currentProfileIndex);
}

pub void ApplyProfileInEditor() {
Camera camToApply = mainCamera;
if (camToApply == null) {
camToApply = Camera.main;
}

if (camToApply == null) {
Debug.LogError("[ResolutionManager] Could not find Main Camera. Ensure it's tagged or assigned in the Inspector.");
return;
}

var ppCamComponent = camToApply.GetComponent("UnityEngine.Rendering.Universal.PixelPerfectCamera");

if (ppCamComponent == null) {
Debug.LogError($"[ResolutionManager] Failed to find URP PixelPerfectCamera component on '{camToApply.name}'. Please ensure the component exists.", camToApply.gameObject);
return;
}

URPPixelPerfectCamera ppCam = ppCamComponent as URPPixelPerfectCamera;

ApplyProfileLogic(currentProfileIndex, camToApply, ppCam);
}

pub void ApplyProfile(int index) {
if (mainCamera == null || pixelPerfectCam == null) {
Debug.LogError("[ResolutionManager] The 'Main Camera' reference is not set in the Inspector or was not found at startup! Disabling ResolutionManager.", this);
this.enabled = false;
return;
}

ApplyProfileLogic(index, mainCamera, pixelPerfectCam);
}

void ApplyProfileLogic(int index, Camera targetCam, URPPixelPerfectCamera targetPPCam) {
if (mapConfig == null) {
Debug.LogError("[ResolutionManager] MapConfiguration is not assigned! Cannot apply profile.", this);
return;
}

if (index < 0 || index >= profiles.Length) {
Debug.LogWarning($"[ResolutionManager] Invalid profile index {index}. Aborting.", this);
return;
}

var profile = profiles[index];
currentProfileIndex = index;

CurrentPPU = profile.pixelsPerUnit;
targetPPCam.assetsPPU = profile.pixelsPerUnit;
targetPPCam.refResolutionX = profile.resolution.x;
targetPPCam.refResolutionY = profile.resolution.y;

float baseOrthoSize = (float)profile.resolution.y / (2f * profile.pixelsPerUnit);
targetCam.orthographicSize = baseOrthoSize * profile.cameraZoomMultiplier;

#if UNITY_EDITOR
if (!Application.isPlaying) {
EditorUtility.SetDirty(targetCam);
EditorUtility.SetDirty(targetPPCam);
}
#endif

var cameraController = targetCam.GetComponent<CameraController>();
if (cameraController != null) {
cameraController.OnResolutionChanged();
}

Debug.Log($"[ResolutionManager] Applied profile: '{profile.name}' (PPU: {CurrentPPU}, Res: {profile.resolution}, Zoom: {targetCam.orthographicSize})");
}

pub void CycleResolution() {
int nextIndex = (currentProfileIndex + 1) % profiles.Length;
ApplyProfile(nextIndex);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\ProceduralGeneration\SceneSetupManager.cs

﻿using UnityEngine;
using WegoSystem;

namespace WegoSystem {
pub cls SceneSetupManager : MonoBehaviour {
[SerializeField] bool setupOnStart = true;

void Start() {
if (setupOnStart) {
SetupScene();
}
}

pub void SetupScene() {
Debug.Log("--- Starting Scene Setup ---");

GridPositionManager gridManager = GridPositionManager.Instance;

if (gridManager == null) {
gridManager = FindFirstObjectByType<GridPositionManager>();
if (gridManager != null) {
Debug.LogWarning("[SceneSetupManager] GridPositionManager.Instance was null (expected in Edit Mode). Found manager manually.", this);
}
}

if (gridManager == null) {
Debug.LogError("[SceneSetupManager] GridPositionManager could not be found in the scene. Aborting setup.", this);
return;
}

GardenerController player = FindFirstObjectByType<GardenerController>();
if (player != null) {
gridManager.SnapEntityToGrid(player.gameObject);

GridPosition centerPosition = gridManager.GetMapCenter();
player.GetComponent<GridEntity>().SetPosition(centerPosition, true);

Debug.Log($"Player '{player.name}' snapped, registered, and moved to map center: {centerPosition}", player);

SetupMainCamera(player.transform);
}
else {
Debug.LogWarning("[SceneSetupManager] No GardenerController found in the scene to position.", this);
}

Debug.Log("--- Scene Setup Complete ---");
}

void SetupMainCamera(Transform target) {
Camera mainCamera = Camera.main;
if (mainCamera != null) {
CameraController cameraController = mainCamera.GetComponent<CameraController>();
if (cameraController == null) {
Debug.LogWarning($"[SceneSetupManager] Main Camera does not have a CameraController. Adding one now.", mainCamera);
cameraController = mainCamera.gameObject.AddComponent<CameraController>();
}

cameraController.followTarget = target;
cameraController.SnapToTarget(); // Immediate snap on scene setup

Debug.Log($"Main Camera's CameraController set to follow '{target.name}' and snapped to position.", mainCamera);
}
else {
Debug.LogWarning("[SceneSetupManager] Could not find Main Camera to configure. Ensure it has the 'MainCamera' tag.", this);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridEntity.cs

﻿using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
pub cls GridEntity : MonoBehaviour {
pub bool isTileOccupant = true;

GridPosition gridPosition;

[SerializeField] Vector3 groundPointOffset = Vector3.zero;
[SerializeField] Vector3 visualOffset = Vector3.zero;
[SerializeField] float visualInterpolationSpeed = 5f;
[SerializeField] AnimationCurve movementCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

GridPosition previousGridPosition;
Vector3 visualStartPosition;
Vector3 visualTargetPosition;
float movementProgress = 1f;
bool isMoving = false;
float speedMultiplier = 1f;

bool isPositionLocked = false;

pub GridPosition Position {
get => gridPosition;
set {
if (gridPosition != value) {
previousGridPosition = gridPosition;
gridPosition = value;
}
}
}

pub GridPosition PreviousPosition => previousGridPosition;
pub bool IsMoving => isMoving;
pub float MovementProgress => movementProgress;
pub Vector3 GroundWorldPosition => transform.position + groundPointOffset;

pub event Action<GridPosition, GridPosition> OnPositionChanged;
pub event Action<GridPosition> OnMovementComplete;
pub event Action OnMovementStart;

prot virt void Start() {
if (gridPosition == GridPosition.Zero && movementProgress >= 1f) {
SnapToGrid();
}
}

prot virt void OnDestroy() {
var gridManager = GridPositionManager.Instance;
if (gridManager != null) {
gridManager.UnregisterEntity(this);
}
}

prot virt void Update() {
if (isPositionLocked || movementProgress >= 1f) {
return;
}

movementProgress += Time.deltaTime * visualInterpolationSpeed * speedMultiplier;
movementProgress = Mathf.Clamp01(movementProgress);

float curvedProgress = movementCurve.Evaluate(movementProgress);
transform.position = Vector3.Lerp(visualStartPosition, visualTargetPosition, curvedProgress);

if (movementProgress >= 1f) {
transform.position = visualTargetPosition;
isMoving = false;
OnMovementComplete?.Invoke(gridPosition);
}
}

#if UNITY_EDITOR
void OnDrawGizmosSelected() {
Vector3 groundWorldPosition = transform.position + groundPointOffset;
Gizmos.color = Color.green;
Gizmos.DrawLine(transform.position, groundWorldPosition);
Gizmos.DrawWireSphere(groundWorldPosition, 0.1f);
UnityEditor.Handles.Label(groundWorldPosition + Vector3.up * 0.2f, "Ground Point");

if (Application.isPlaying && GridPositionManager.Instance != null) {
Gizmos.color = Color.yellow;
Vector3 gridCenter = GridPositionManager.Instance.GetCellCenter(gridPosition);
Gizmos.DrawSphere(gridCenter, 0.08f);
}
}
#endif

pub void SetPosition(GridPosition newPosition, bool instant = false) {
if (GridPositionManager.Instance != null && !GridPositionManager.Instance.IsPositionValid(newPosition)) {
Debug.LogWarning($"[GridEntity] Blocked attempt to move '{gameObject.name}' to invalid position {newPosition}. Movement cancelled.");
return;
}

if (instant) {
isPositionLocked = true;
Position = newPosition;
visualStartPosition = transform.position;
visualTargetPosition = transform.position;
movementProgress = 1f;
isMoving = false;
OnPositionChanged?.Invoke(previousGridPosition, newPosition);
}
else {
isPositionLocked = false;
if (!isMoving) {
visualStartPosition = transform.position;
}

Position = newPosition; // This will update gridPosition and previousGridPosition

if (GridPositionManager.Instance != null) {
Vector3 groundTargetPosition = GridPositionManager.Instance.GridToWorld(gridPosition);
visualTargetPosition = groundTargetPosition - groundPointOffset + visualOffset;
}

movementProgress = 0f;
if (!isMoving) {
isMoving = true;
OnMovementStart?.Invoke();
}
OnPositionChanged?.Invoke(previousGridPosition, newPosition);
}
}

pub void SetSpeedMultiplier(float multiplier) {
this.speedMultiplier = multiplier;
}

pub void SnapToGrid() {
if (GridPositionManager.Instance == null) return;

Vector3 groundWorldPos = transform.position + groundPointOffset;
GridPosition currentGridPos = GridPositionManager.Instance.WorldToGrid(groundWorldPos);

isPositionLocked = false;
SetPosition(currentGridPos, true); // This will now use the instant path but we must move the transform.
transform.position = GridPositionManager.Instance.GridToWorld(currentGridPos) - groundPointOffset + visualOffset;
visualStartPosition = transform.position;
visualTargetPosition = transform.position;
}

pub void MoveInDirection(GridPosition direction) {
SetPosition(gridPosition + direction);
}

pub bool CanMoveTo(GridPosition targetPosition) {
ret GridPositionManager.Instance?.IsPositionValid(targetPosition) ?? false;
}

pub void CompleteMovement() {
if (isMoving) {
transform.position = visualTargetPosition;
movementProgress = 1f;
isMoving = false;
isPositionLocked = false;
OnMovementComplete?.Invoke(gridPosition);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridPosition.cs

﻿// Assets/Scripts/Ticks/GridPosition.cs

namespace WegoSystem {
pub struct GridPosition : IEquatable<GridPosition> {
pub int x;
pub int y;

pub GridPosition(int x, int y) {
this.x = x;
this.y = y;
}

pub GridPosition(Vector3Int vector3Int) {
this.x = vector3Int.x;
this.y = vector3Int.y;
}

pub GridPosition(Vector2Int vector2Int) {
this.x = vector2Int.x;
this.y = vector2Int.y;
}

pub stat GridPosition operator +(GridPosition a, GridPosition b) {
ret new GridPosition(a.x + b.x, a.y + b.y);
}

pub stat GridPosition operator -(GridPosition a, GridPosition b) {
ret new GridPosition(a.x - b.x, a.y - b.y);
}

pub stat bool operator ==(GridPosition a, GridPosition b) {
ret a.x == b.x && a.y == b.y;
}

pub stat bool operator !=(GridPosition a, GridPosition b) {
ret !(a == b);
}

pub Vector3Int ToVector3Int() => new Vector3Int(x, y, 0);
pub Vector2Int ToVector2Int() => new Vector2Int(x, y);
pub Vector3 ToWorldPosition(float cellSize = 1f) => new Vector3(x * cellSize, y * cellSize, 0);

pub stat ro GridPosition Up = new GridPosition(0, 1);
pub stat ro GridPosition Down = new GridPosition(0, -1);
pub stat ro GridPosition Left = new GridPosition(-1, 0);
pub stat ro GridPosition Right = new GridPosition(1, 0);
pub stat ro GridPosition UpLeft = new GridPosition(-1, 1);
pub stat ro GridPosition UpRight = new GridPosition(1, 1);
pub stat ro GridPosition DownLeft = new GridPosition(-1, -1);
pub stat ro GridPosition DownRight = new GridPosition(1, -1);
pub stat ro GridPosition Zero = new GridPosition(0, 0);

pub int ManhattanDistance(GridPosition other) {
ret Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y);
}

pub int ChebyshevDistance(GridPosition other) {
ret Mathf.Max(Mathf.Abs(x - other.x), Mathf.Abs(y - other.y));
}

pub float EuclideanDistance(GridPosition other) {
int dx = x - other.x;
int dy = y - other.y;
ret Mathf.Sqrt(dx * dx + dy * dy);
}

pub GridPosition[] GetNeighbors(bool includeDiagonals = false) {
if (includeDiagonals) {
ret new GridPosition[] {
this + Up, this + Down, this + Left, this + Right,
this + UpLeft, this + UpRight, this + DownLeft, this + DownRight
};
}
else {
ret new GridPosition[] {
this + Up, this + Down, this + Left, this + Right
};
}
}

pub bool Equals(GridPosition other) {
ret x == other.x && y == other.y;
}

pub ovr bool Equals(object obj) {
ret obj is GridPosition other && Equals(other);
}

pub ovr int GetHashCode() {
ret HashCode.Combine(x, y);
}

pub ovr string ToString() {
ret $"({x}, {y})";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridPositionManager.cs

﻿using System;
using UnityEngine.Tilemaps;
using WegoSystem;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
pub cls GridPositionManager : SingletonMonoBehaviour<GridPositionManager> {
[SerializeField] MapConfiguration mapConfig;

[SerializeField] TileInteractionManager tileInteractionManager;

Grid _tilemapGrid;
Grid TilemapGrid => _tilemapGrid;

[SerializeField] bool showGridGizmos = true;
[SerializeField] Color gridColor = new Color(0.5f, 0.5f, 0.5f, 0.3f);
[SerializeField] bool debugMode = false;

ro Dictionary<GridPosition, HashSet<GridEntity>> entitiesByPosition = new Dictionary<GridPosition, HashSet<GridEntity>>();
ro HashSet<GridEntity> allEntities = new HashSet<GridEntity>();

prot ovr void OnAwake() {
EnsureInitialized();
}

void EnsureInitialized() {
if (_tilemapGrid != null) return;

if (mapConfig == null) {
Debug.LogError("[GridPositionManager] CRITICAL: MapConfiguration is not assigned! Grid system will not fn correctly.", this);
}

if(debugMode) Debug.Log("[GridPositionManager] Grid reference is null. Initializing now.");
SyncWithTileGrid();
}

pub void Initialize() // This can still be called by other managers if needed. {
EnsureInitialized();
}

pub void SyncWithTileGrid() {
if (tileInteractionManager != null && tileInteractionManager.interactionGrid != null) {
this._tilemapGrid = tileInteractionManager.interactionGrid;
if (debugMode) Debug.Log($"[GridPositionManager] Synced with assigned TileInteractionManager's grid: '{this._tilemapGrid.name}'.");
return;
}

if (TileInteractionManager.Instance != null && TileInteractionManager.Instance.interactionGrid != null) {
this._tilemapGrid = TileInteractionManager.Instance.interactionGrid;
tileInteractionManager = TileInteractionManager.Instance;
if (debugMode) Debug.Log($"[GridPositionManager] Synced with singleton TileInteractionManager.Instance's grid: '{this._tilemapGrid.name}'.");
return;
}

if (_tilemapGrid == null) {
Debug.LogError("[GridPositionManager] Could not find TileInteractionManager or its grid to sync with! Grid system may be misaligned. Please assign the TileInteractionManager in the Inspector.");
}
}

pub GridPosition WorldToGrid(Vector3 worldPosition) {
EnsureInitialized(); // Make sure _tilemapGrid is set before using it.
if (TilemapGrid == null) ret GridPosition.Zero;
Vector3Int cellPos = TilemapGrid.WorldToCell(worldPosition);
ret new GridPosition(cellPos);
}

pub Vector3 GridToWorld(GridPosition gridPosition) {
EnsureInitialized(); // Make sure _tilemapGrid is set before using it.
if (TilemapGrid == null) ret Vector3.zero;
ret TilemapGrid.GetCellCenterWorld(gridPosition.ToVector3Int());
}

pub Vector3 GetCellCenter(GridPosition gridPosition) {
ret GridToWorld(gridPosition);
}

pub bool IsPositionValid(GridPosition position) {
if (mapConfig == null) {
Debug.LogError("[GridPositionManager] MapConfiguration not assigned!");
ret false;
}
ret position.x >= 0 && position.x < mapConfig.mapSize.x &&
position.y >= 0 && position.y < mapConfig.mapSize.y;
}

pub GridPosition GetMapCenter() {
if (mapConfig == null) {
Debug.LogError("[GridPositionManager] MapConfiguration not assigned! Returning fallback center.");
ret new GridPosition(50, 50); // Fallback
}
ret mapConfig.GetMapCenter();
}

pub Vector3 GetMapCenterWorld() {
ret GridToWorld(GetMapCenter());
}

pub bool IsPositionOccupied(GridPosition position) {
if (entitiesByPosition.TryGetValue(position, out var entities)) {
ret entities.Any(entity => entity.isTileOccupant);
}
ret false;
}

pub void RegisterEntity(GridEntity entity) {
if (entity == null || allEntities.Contains(entity)) return;

allEntities.Add(entity);
AddEntityToPosition(entity, entity.Position);

entity.OnPositionChanged += OnEntityPositionChanged;
}

pub void UnregisterEntity(GridEntity entity) {
if (entity == null || !allEntities.Contains(entity)) return;

allEntities.Remove(entity);
RemoveEntityFromPosition(entity, entity.Position);

entity.OnPositionChanged -= OnEntityPositionChanged;
}

void OnEntityPositionChanged(GridPosition oldPosition, GridPosition newPosition) {
var entity = allEntities.FirstOrDefault(e => e.Position == newPosition && e.PreviousPosition == oldPosition);
if (entity != null) {
RemoveEntityFromPosition(entity, oldPosition);
AddEntityToPosition(entity, newPosition);
}
}

void AddEntityToPosition(GridEntity entity, GridPosition position) {
if (!entitiesByPosition.ContainsKey(position)) {
entitiesByPosition[position] = new HashSet<GridEntity>();
}
entitiesByPosition[position].Add(entity);
}

void RemoveEntityFromPosition(GridEntity entity, GridPosition position) {
if (entitiesByPosition.ContainsKey(position)) {
entitiesByPosition[position].Remove(entity);
if (entitiesByPosition[position].Count == 0) {
entitiesByPosition.Remove(position);
}
}
}

pub HashSet<GridEntity> GetEntitiesAt(GridPosition position) {
ret entitiesByPosition.ContainsKey(position)
? new HashSet<GridEntity>(entitiesByPosition[position])
: new HashSet<GridEntity>();
}

pub List<GridEntity> GetEntitiesInRadius(GridPosition center, int radius, bool useCircle = true) {
var result = new List<GridEntity>();

if (useCircle) {
var tilesInRadius = GridRadiusUtility.GetTilesInCircle(center, radius);
foreach (var pos in tilesInRadius) {
if (entitiesByPosition.ContainsKey(pos)) {
result.AddRange(entitiesByPosition[pos]);
}
}
}
else {
for (int x = -radius; x <= radius; x++) {
for (int y = -radius; y <= radius; y++) {
var checkPos = new GridPosition(center.x + x, center.y + y);
if (checkPos.ManhattanDistance(center) <= radius && entitiesByPosition.ContainsKey(checkPos)) {
result.AddRange(entitiesByPosition[checkPos]);
}
}
}
}

ret result;
}

pub bool IsPositionWithinRadius(GridPosition position, GridPosition center, int radius, bool useCircle = true) {
if (useCircle) {
ret GridRadiusUtility.IsWithinCircleRadius(position, center, radius);
}
else {
ret position.ManhattanDistance(center) <= radius;
}
}

pub GridEntity GetNearestEntity(GridPosition position, System.Func<GridEntity, bool> predicate = null) {
GridEntity nearest = null;
float nearestDistance = float.MaxValue;

foreach (var entity in allEntities) {
if (predicate != null && !predicate(entity)) continue;

float distance = entity.Position.EuclideanDistance(position);
if (distance < nearestDistance) {
nearest = entity;
nearestDistance = distance;
}
}
ret nearest;
}

pub Grid GetTilemapGrid() {
EnsureInitialized();
ret TilemapGrid;
}

pub List<GridPosition> GetPath(GridPosition start, GridPosition end, bool allowDiagonal = false) {
var path = new List<GridPosition>();

if (!IsPositionValid(start) || !IsPositionValid(end)) {
ret path;
}

var openSet = new HashSet<GridPosition>();
var closedSet = new HashSet<GridPosition>();
var cameFrom = new Dictionary<GridPosition, GridPosition>();
var gScore = new Dictionary<GridPosition, float>();
var fScore = new Dictionary<GridPosition, float>();

openSet.Add(start);
gScore[start] = 0;
fScore[start] = HeuristicCost(start, end);

while (openSet.Count > 0) {
GridPosition current = GetLowestFScore(openSet, fScore);

if (current == end) {
while (cameFrom.ContainsKey(current)) {
path.Add(current);
current = cameFrom[current];
}
path.Reverse();
ret path;
}

openSet.Remove(current);
closedSet.Add(current);

foreach (var neighbor in current.GetNeighbors(allowDiagonal)) {
if (!IsPositionValid(neighbor) || closedSet.Contains(neighbor) || (neighbor != end && IsPositionOccupied(neighbor))) {
continue;
}

float tentativeGScore = gScore[current] + 1; // Assuming cost of 1 per tile

if (!openSet.Contains(neighbor)) {
openSet.Add(neighbor);
}
else if (gScore.ContainsKey(neighbor) && tentativeGScore >= gScore[neighbor]) {
continue; // This path is not better
}

cameFrom[neighbor] = current;
gScore[neighbor] = tentativeGScore;
fScore[neighbor] = gScore[neighbor] + HeuristicCost(neighbor, end);
}
}
ret path; // No path found
}

float HeuristicCost(GridPosition a, GridPosition b) {
ret a.ManhattanDistance(b);
}

GridPosition GetLowestFScore(HashSet<GridPosition> openSet, Dictionary<GridPosition, float> fScore) {
GridPosition lowest = openSet.First();
float lowestScore = fScore.ContainsKey(lowest) ? fScore[lowest] : float.MaxValue;

foreach (var pos in openSet) {
float score = fScore.ContainsKey(pos) ? fScore[pos] : float.MaxValue;
if (score < lowestScore) {
lowest = pos;
lowestScore = score;
}
}
ret lowest;
}

pub bool PathExists(GridPosition start, GridPosition end, bool allowDiagonal = false) {
var path = GetPath(start, end, allowDiagonal);
ret path.Count > 0;
}

pub void SnapEntityToGrid(GameObject entity) {
if (entity == null) return;

GridEntity gridEntity = entity.GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = entity.AddComponent<GridEntity>();
}

gridEntity.SnapToGrid();

RegisterEntity(gridEntity);

if (debugMode) {
Debug.Log($"[GridPositionManager] Snapped and Registered {entity.name} to grid {gridEntity.Position}");
}
}

pub void SnapAllEntitiesToGrid<T>() where T : Component {
T[] entities = FindObjectsByType<T>(FindObjectsSortMode.None);
foreach (var entity in entities) {
SnapEntityToGrid(entity.gameObject);
}
Debug.Log($"[GridPositionManager] Snapped {entities.Length} entities of type {typeof(T).Name} to grid");
}

pub stat List<GridPosition> GetTilesInRadius(GridPosition center, int radius, bool useManhattan = true) {
var result = new List<GridPosition>();

for (int x = -radius; x <= radius; x++) {
for (int y = -radius; y <= radius; y++) {
var checkPos = new GridPosition(center.x + x, center.y + y);

if (Instance != null && !Instance.IsPositionValid(checkPos)) continue;

int distance = useManhattan
? Mathf.Abs(x) + Mathf.Abs(y)
: Mathf.Max(Mathf.Abs(x), Mathf.Abs(y));

if (distance <= radius) {
result.Add(checkPos);
}
}
}

ret result;
}

void OnDrawGizmos() {
if (!showGridGizmos || mapConfig == null) return;

EnsureInitialized();
if(_tilemapGrid == null) return;

Gizmos.color = gridColor;

int displaySize = mapConfig.GetAdaptiveGizmoSize();
int displayWidth = Mathf.Min(displaySize, mapConfig.mapSize.x);
int displayHeight = Mathf.Min(displaySize, mapConfig.mapSize.y);

for (int x = 0; x <= displayWidth; x++) {
Vector3 start = GridToWorld(new GridPosition(x, 0));
Vector3 end = GridToWorld(new GridPosition(x, displayHeight));
Gizmos.DrawLine(start, end);
}

for (int y = 0; y <= displayHeight; y++) {
Vector3 start = GridToWorld(new GridPosition(0, y));
Vector3 end = GridToWorld(new GridPosition(displayWidth, y));
Gizmos.DrawLine(start, end);
}

Gizmos.color = Color.green;
Vector3 origin = GridToWorld(GridPosition.Zero);
Gizmos.DrawWireSphere(origin, _tilemapGrid.cellSize.x * 0.2f);

Gizmos.color = Color.red;
if (entitiesByPosition != null) {
foreach (var kvp in entitiesByPosition) {
if (kvp.Value.Count > 0) {
Vector3 cellCenter = GridToWorld(kvp.Key);
Gizmos.DrawWireCube(cellCenter, Vector3.one * _tilemapGrid.cellSize.x * 0.8f);
}
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridRadiusUtility.cs

﻿using UnityEngine;
using WegoSystem;

ns WegoSystem {
pub stat cls GridRadiusUtility {
pub stat List<GridPosition> GetTilesInCircle(GridPosition center, int radius, bool filled = true) {
var result = new List<GridPosition>();

if (radius <= 0) {
result.Add(center);
ret result;
}

for (int dx = -radius; dx <= radius; dx++) {
for (int dy = -radius; dy <= radius; dy++) {
float distance = Mathf.Sqrt(dx * dx + dy * dy);

if (filled) {
if (distance <= radius + 0.5f) {
result.Add(new GridPosition(center.x + dx, center.y + dy));
}
} else {
if (distance >= radius - 0.5f && distance <= radius + 0.5f) {
result.Add(new GridPosition(center.x + dx, center.y + dy));
}
}
}
}

ret result;
}

pub stat List<GridPosition> GetPerfectCircleTiles(GridPosition center, int radius) {
var result = new HashSet<GridPosition>();

if (radius == 0) {
result.Add(center);
ret new List<GridPosition>(result);
}

int x = 0;
int y = radius;
int d = 3 - 2 * radius;

while (x <= y) {
AddCirclePoints(result, center, x, y);

if (d < 0) {
d = d + 4 * x + 6;
} else {
d = d + 4 * (x - y) + 10;
y--;
}
x++;
}

var filledResult = new List<GridPosition>();
int minX = center.x - radius;
int maxX = center.x + radius;

for (int scanY = center.y - radius; scanY <= center.y + radius; scanY++) {
bool inside = false;
int startX = minX;

for (int scanX = minX; scanX <= maxX; scanX++) {
var pos = new GridPosition(scanX, scanY);
if (result.Contains(pos)) {
if (!inside) {
inside = true;
startX = scanX;
}
} else if (inside) {
for (int fillX = startX; fillX < scanX; fillX++) {
filledResult.Add(new GridPosition(fillX, scanY));
}
inside = false;
}
}

if (inside) {
for (int fillX = startX; fillX <= maxX; fillX++) {
var pos = new GridPosition(fillX, scanY);
if (result.Contains(pos) || fillX == maxX) {
for (int fill = startX; fill <= fillX; fill++) {
filledResult.Add(new GridPosition(fill, scanY));
}
break;
}
}
}
}

ret filledResult;
}

stat void AddCirclePoints(HashSet<GridPosition> result, GridPosition center, int x, int y) {
result.Add(new GridPosition(center.x + x, center.y + y));
result.Add(new GridPosition(center.x - x, center.y + y));
result.Add(new GridPosition(center.x + x, center.y - y));
result.Add(new GridPosition(center.x - x, center.y - y));
result.Add(new GridPosition(center.x + y, center.y + x));
result.Add(new GridPosition(center.x - y, center.y + x));
result.Add(new GridPosition(center.x + y, center.y - x));
result.Add(new GridPosition(center.x - y, center.y - x));
}

pub stat bool IsWithinCircleRadius(GridPosition position, GridPosition center, int radius) {
int dx = position.x - center.x;
int dy = position.y - center.y;
float distance = Mathf.Sqrt(dx * dx + dy * dy);
ret distance <= radius + 0.5f;
}

pub stat List<GridPosition> GetCircleOutline(GridPosition center, int radius) {
ret GetTilesInCircle(center, radius, false);
}

pub stat void DebugPrintRadius(GridPosition center, int radius) {
var tiles = GetTilesInCircle(center, radius);
var tileSet = new HashSet<GridPosition>(tiles);

Debug.Log($"Circle pattern for radius {radius}:");

for (int y = radius; y >= -radius; y--) {
string line = "";
for (int x = -radius; x <= radius; x++) {
var pos = new GridPosition(center.x + x, center.y + y);
if (pos.Equals(center)) {
line += "◉ "; // Center
} else if (tileSet.Contains(pos)) {
line += "● "; // Included tile
} else {
line += "· "; // Not included
}
}
Debug.Log(line);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\TickConfiguration.cs

﻿using UnityEngine;

namespace WegoSystem {
pub cls TickConfiguration : ScriptableObject {
[SerializeField] pub float ticksPerRealSecond = 2f;

pub int ticksPerDay = 100;
pub int dayPhaseTicks = 60;
pub int nightPhaseTicks = 40;
pub int transitionTicks = 10;

pub int animalHungerTickInterval = 3;
pub int animalThinkingInterval = 3;

pub int movementTicksPerTile = 1;
pub int movementCooldownTicks = 0;

pub float GetRealSecondsPerTick() {
ret ticksPerRealSecond > 0 ? 1f / ticksPerRealSecond : 0.5f;
}

pub int ConvertSecondsToTicks(float seconds) {
ret Mathf.RoundToInt(seconds * ticksPerRealSecond);
}

pub float ConvertTicksToSeconds(int ticks) {
ret ticks / ticksPerRealSecond;
}

pub int GetDayProgress(int currentTick) {
ret currentTick % ticksPerDay;
}

pub float GetDayProgressNormalized(int currentTick) {
ret (float)(currentTick % ticksPerDay) / ticksPerDay;
}

pub void SetTicksPerSecond(float newRate) {
ticksPerRealSecond = Mathf.Max(0.1f, newRate);
}

void OnValidate() {
ticksPerRealSecond = Mathf.Max(0.1f, ticksPerRealSecond);
ticksPerDay = Mathf.Max(10, ticksPerDay);
dayPhaseTicks = Mathf.Max(1, dayPhaseTicks);
nightPhaseTicks = Mathf.Max(1, nightPhaseTicks);
transitionTicks = Mathf.Max(1, transitionTicks);
animalHungerTickInterval = Mathf.Max(1, animalHungerTickInterval);
animalThinkingInterval = Mathf.Max(1, animalThinkingInterval);
}

void ApplySlowPacedPreset() {
ticksPerRealSecond = 1f;
ticksPerDay = 200;
dayPhaseTicks = 120;
nightPhaseTicks = 80;
transitionTicks = 20;
animalHungerTickInterval = 5;
}

void ApplyFastPacedPreset() {
ticksPerRealSecond = 4f;
ticksPerDay = 50;
dayPhaseTicks = 30;
nightPhaseTicks = 20;
transitionTicks = 5;
animalHungerTickInterval = 2;
}

void ApplyBalancedPreset() {
ticksPerRealSecond = 2f;
ticksPerDay = 100;
dayPhaseTicks = 60;
nightPhaseTicks = 40;
transitionTicks = 10;
animalHungerTickInterval = 3;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\TickManager.cs

﻿// Assets/Scripts/Ticks/TickManager.cs

namespace WegoSystem {
pub ifc ITickUpdateable {
void OnTickUpdate(int currentTick);
}

pub cls TickManager : SingletonMonoBehaviour<TickManager> {
[SerializeField] TickConfiguration tickConfig;
[SerializeField] bool debugMode = false;
[SerializeField] int currentTick = 0;

pub int CurrentTick => currentTick;
pub TickConfiguration Config => tickConfig;

pub event Action<int> OnTickAdvanced;
pub event Action<int> OnTickStarted;
pub event Action<int> OnTickCompleted;

ro List<ITickUpdateable> tickUpdateables = new List<ITickUpdateable>();
ro List<ITickUpdateable> pendingAdditions = new List<ITickUpdateable>();
ro List<ITickUpdateable> pendingRemovals = new List<ITickUpdateable>();
bool isProcessingTick = false;

prot ovr void OnAwake() {
if (tickConfig == null) {
Debug.LogError("[TickManager] No TickConfiguration assigned! Creating default config.");
tickConfig = ScriptableObject.CreateInstance<TickConfiguration>();
}
}

void OnDestroy() {
if (Instance == this) {
}
}

void Update() {
#if UNITY_EDITOR
if (debugMode && Input.GetKeyDown(KeyCode.T)) {
Debug.Log("[TickManager] Debug: Manual tick advance");
AdvanceTick();
}
#endif
}

pub void AdvanceTick() {
AdvanceMultipleTicks(1);
}

pub void AdvanceMultipleTicks(int tickCount) {
if (tickCount <= 0) return;

for (int i = 0; i < tickCount; i++) {
currentTick++;
ProcessTick();
}
}

void ProcessTick() {
if (debugMode) {
Debug.Log($"[TickManager] Processing tick {currentTick}");
}

OnTickStarted?.Invoke(currentTick);

ProcessPendingUpdates();

isProcessingTick = true;
foreach (var tickUpdateable in tickUpdateables) {
try {
tickUpdateable?.OnTickUpdate(currentTick);
}
catch (Exception e) {
Debug.LogError($"[TickManager] Error in tick update: {e.Message}");
}
}
isProcessingTick = false;

OnTickAdvanced?.Invoke(currentTick);
OnTickCompleted?.Invoke(currentTick);
}

pub void RegisterTickUpdateable(ITickUpdateable updateable) {
if (updateable == null) return;

if (isProcessingTick) {
if (!pendingAdditions.Contains(updateable))
pendingAdditions.Add(updateable);
}
else {
if (!tickUpdateables.Contains(updateable))
tickUpdateables.Add(updateable);
}
}

pub void UnregisterTickUpdateable(ITickUpdateable updateable) {
if (updateable == null) return;

if (isProcessingTick) {
if (!pendingRemovals.Contains(updateable))
pendingRemovals.Add(updateable);
}
else {
tickUpdateables.Remove(updateable);
}
}

void ProcessPendingUpdates() {
foreach (var updateable in pendingAdditions) {
if (!tickUpdateables.Contains(updateable))
tickUpdateables.Add(updateable);
}
pendingAdditions.Clear();

foreach (var updateable in pendingRemovals) {
tickUpdateables.Remove(updateable);
}
pendingRemovals.Clear();
}

pub void ResetTicks() {
currentTick = 0;
if (debugMode) Debug.Log("[TickManager] Reset tick counter");
}

pub int GetTicksSince(int pastTick) {
ret currentTick - pastTick;
}

pub bool HasTicksPassed(int lastTick, int tickInterval) {
ret GetTicksSince(lastTick) >= tickInterval;
}

pub int GetNextIntervalTick(int tickInterval) {
ret currentTick + tickInterval;
}

pub void DebugAdvanceTick() {
if (Application.isEditor || Debug.isDebugBuild) {
AdvanceTick();
}
}

pub int GetRegisteredUpdateableCount() {
ret tickUpdateables.Count;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\GardenerController.cs

﻿using System.Collections;
using WegoSystem;

namespace WegoSystem {
pub cls GardenerController : MonoBehaviour, IStatusEffectable, ITickUpdateable {
[SerializeField] float multiTickDelay = 0.5f;

[SerializeField] bool useAnimations = true;
[SerializeField] Animator animator;
[SerializeField] string runningParameterName = "isRunning";
[SerializeField] string plantingTriggerName = "plant";

[SerializeField] SpriteRenderer spriteRenderer;
[SerializeField] bool flipSpriteWhenMovingLeft = true;
[SerializeField] bool flipHorizontalDirection = true;

GridEntity gridEntity;
StatusEffectManager statusManager;
StatusEffectUIManager statusEffectUI;
PlayerHungerSystem hungerSystem;

GridPosition currentTargetPosition;
bool isProcessingMovement = false;

pub GridEntity GridEntity => gridEntity;
pub StatusEffectManager StatusManager => statusManager;
pub PlayerHungerSystem HungerSystem => hungerSystem;

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) gridEntity = gameObject.AddComponent<GridEntity>();
statusManager = GetComponent<StatusEffectManager>();
if (statusManager == null) statusManager = gameObject.AddComponent<StatusEffectManager>();
hungerSystem = GetComponent<PlayerHungerSystem>();
if (hungerSystem == null) hungerSystem = gameObject.AddComponent<PlayerHungerSystem>();

statusEffectUI = GetComponentInChildren<StatusEffectUIManager>(true);
if (statusEffectUI == null) Debug.LogWarning("[GardenerController] StatusEffectUIManager not found in children. Icons won't display.", this);
if (spriteRenderer == null) spriteRenderer = GetComponentInChildren<SpriteRenderer>();
if (spriteRenderer == null) Debug.LogWarning("[GardenerController] SpriteRenderer not found.", gameObject);
if (animator == null && useAnimations) Debug.LogWarning("[GardenerController] Animator not found.", gameObject);
}

void Start() {
statusManager.Initialize(this);

if (statusEffectUI != null) {
statusEffectUI.Initialize(statusManager);
}

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
if (gridEntity != null) {
gridEntity.OnPositionChanged += OnGridPositionChanged;
}

StartCoroutine(InitialTileEffectCheck());
}

IEnumerator InitialTileEffectCheck() {
yield ret null;
if (EnvironmentalStatusEffectSystem.Instance != null) {
EnvironmentalStatusEffectSystem.Instance.CheckAndApplyTileEffects(this);
}
}

void OnDestroy() {
var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}

if (gridEntity != null) {
gridEntity.OnPositionChanged -= OnGridPositionChanged;
}
}

pub void OnTickUpdate(int currentTick) {
statusManager?.OnTickUpdate(currentTick);
}

void Update() {
if (RunManager.Instance?.CurrentState == RunState.GrowthAndThreat) {
HandlePlayerInput();
}
if (gridEntity != null && statusManager != null) {
gridEntity.SetSpeedMultiplier(statusManager.VisualInterpolationSpeedMultiplier);
}
UpdateAnimations();
UpdateSpriteDirection();
}

void LateUpdate() {
transform.position = PixelGridSnapper.SnapToGrid(transform.position);
}

void OnGridPositionChanged(GridPosition oldPos, GridPosition newPos) {
EnvironmentalStatusEffectSystem.Instance?.CheckAndApplyTileEffects(this);
}

pub string GetDisplayName() { ret "Gardener"; }
pub void TakeDamage(float amount) { Debug.Log($"Gardener took {amount} damage!"); }
pub void Heal(float amount) { Debug.Log($"Gardener was healed for {amount}!"); }
pub void ModifyHunger(float amount) {
if (hungerSystem != null) {
hungerSystem.Eat(-amount);
}
}

void HandlePlayerInput() {
if (gridEntity == null || gridEntity.IsMoving || isProcessingMovement) return;

GridPosition moveDir = GridPosition.Zero;
if (Input.GetKeyDown(KeyCode.W) || Input.GetKeyDown(KeyCode.UpArrow)) moveDir = GridPosition.Up;
else if (Input.GetKeyDown(KeyCode.S) || Input.GetKeyDown(KeyCode.DownArrow)) moveDir = GridPosition.Down;
else if (Input.GetKeyDown(KeyCode.A) || Input.GetKeyDown(KeyCode.LeftArrow)) moveDir = GridPosition.Left;
else if (Input.GetKeyDown(KeyCode.D) || Input.GetKeyDown(KeyCode.RightArrow)) moveDir = GridPosition.Right;

if (moveDir != GridPosition.Zero) {
TryMove(moveDir);
return;
}
}

void TryMove(GridPosition direction) {
if (gridEntity == null) return;
GridPosition targetPos = gridEntity.Position + direction;
if (GridPositionManager.Instance != null && PlayerActionManager.Instance != null && TickManager.Instance != null &&
GridPositionManager.Instance.IsPositionValid(targetPos) &&
!GridPositionManager.Instance.IsPositionOccupied(targetPos)) {
Vector3 currentWorldPos = GridPositionManager.Instance.GridToWorld(gridEntity.Position);
int moveCost = PlayerActionManager.Instance.GetMovementTickCost(currentWorldPos, this);
if (moveCost > 1) {
StartCoroutine(ProcessMultiTickMovement(targetPos, moveCost));
}
else {
gridEntity.SetPosition(targetPos);
currentTargetPosition = targetPos;
TickManager.Instance.AdvanceTick();
}
}
}

IEnumerator ProcessMultiTickMovement(GridPosition targetPos, int tickCost) {
isProcessingMovement = true;
for (int i = 0; i < tickCost - 1; i++) {
TickManager.Instance.AdvanceTick();
yield ret new WaitForSeconds(multiTickDelay);
}
gridEntity.SetPosition(targetPos);
currentTargetPosition = targetPos;
TickManager.Instance.AdvanceTick();
isProcessingMovement = false;
}

void UpdateAnimations() {
if (!useAnimations || animator == null) return;
bool isMoving = gridEntity != null && gridEntity.IsMoving;
animator.SetBool(runningParameterName, isMoving);
}

void UpdateSpriteDirection() {
if (spriteRenderer == null || !flipSpriteWhenMovingLeft || gridEntity == null || !gridEntity.IsMoving) return;
Vector3 worldTarget = GridPositionManager.Instance.GridToWorld(currentTargetPosition);
Vector3 currentWorld = transform.position;
Vector2 directionToCheck = (worldTarget - currentWorld).normalized;
if (Mathf.Abs(directionToCheck.x) > 0.01f) {
bool shouldFlip = directionToCheck.x < 0;
spriteRenderer.flipX = flipHorizontalDirection ? shouldFlip : !shouldFlip;
}
}

pub void Plant() {
if (useAnimations && animator != null) {
animator.SetTrigger(plantingTriggerName);
}
}

pub GridPosition GetCurrentGridPosition() {
ret gridEntity?.Position ?? GridPosition.Zero;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileInteractionManager.cs

﻿using UnityEngine;
using Abracodabra.UI.Genes;
using UnityEngine.Tilemaps;
using skner.DualGrid;
using TMPro;
using WegoSystem;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
pub cls TileInteractionManager : SingletonMonoBehaviour<TileInteractionManager>, ITickUpdateable {
pub cls TileDefinitionMapping {
pub TileDefinition tileDef;
pub DualGridTilemapModule tilemapModule;
}

pub struct TimedTileState {
pub TileDefinition tileDef;
pub int ticksRemaining;
}

pub List<TileDefinitionMapping> tileDefinitionMappings;
pub TileInteractionLibrary interactionLibrary;
pub Grid interactionGrid;
pub Camera mainCamera;
pub Transform player;

pub float hoverRadius = 3f;

pub GameObject hoverHighlightObject;
pub TileHoverColorManager hoverColorManager;
pub int baseSortingOrder = 0;

pub bool debugLogs = false;
pub TextMeshProUGUI hoveredTileText;
pub TextMeshProUGUI currentToolText;

Dictionary<TileDefinition, DualGridTilemapModule> moduleByDefinition;
ro Dictionary<Vector3Int, TimedTileState> timedCells = new Dictionary<Vector3Int, TimedTileState>();
Vector3Int? currentlyHoveredCell;
TileDefinition hoveredTileDef;
SpriteRenderer hoverSpriteRenderer;
bool isWithinInteractionRange = false;

prot ovr void OnAwake() {
EnsureInitialized();
CacheHoverSpriteRenderer();
}

void EnsureInitialized() {
if (moduleByDefinition == null) {
if (debugLogs) Debug.Log("[TileInteractionManager] Dictionaries are null. Initializing now.");
SetupTilemaps();
}
}

void Start() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

pub void OnTickUpdate(int currentTick) {
UpdateReversionTicks();
}

void Update() {
HandleTileHover();
UpdateDebugUI();
}

pub TileDefinition FindWhichTileDefinitionAt(Vector3Int cellPos) {
EnsureInitialized();
if (tileDefinitionMappings == null) ret null;

foreach (var mapping in tileDefinitionMappings) {
if (mapping?.tileDef != null && mapping.tilemapModule != null) {
if (TileExistsInModule(mapping.tilemapModule, cellPos)) {
ret mapping.tileDef;
}
}
}

ret null;
}

bool TileExistsInModule(DualGridTilemapModule module, Vector3Int cellPos) {
ret module.DataTilemap != null && module.DataTilemap.HasTile(cellPos);
}

pub void ApplyToolAction(ToolDefinition toolDef) {
if (toolDef == null || !currentlyHoveredCell.HasValue) return;

Vector3Int targetCell = currentlyHoveredCell.Value;
TileDefinition currentTileDef = FindWhichTileDefinitionAt(targetCell);
if (currentTileDef == null) return;

TileInteractionRule rule = interactionLibrary?.rules.FirstOrDefault(r => r != null && r.tool == toolDef && r.fromTile == currentTileDef);

if (rule != null) {
TileDefinition fromTile = currentTileDef;
TileDefinition toTile = rule.toTile;

if (debugLogs) Debug.Log($"[TileInteractionManager] Rule found! From: '{fromTile.displayName}', To: '{(toTile != null ? toTile.displayName : "NULL")}'.");

if (toTile == null) {
RemoveTile(fromTile, targetCell);
return;
}

if (!toTile.keepBottomTile) {
RemoveTile(fromTile, targetCell);
}

PlaceTile(toTile, targetCell);
}
else if (debugLogs) {
Debug.Log($"[TileInteractionManager] No transformation rule found for Tool='{toolDef.displayName}' on Tile='{currentTileDef.displayName}'.");
}
}

void UpdateReversionTicks() {
if (timedCells.Count == 0) return;
List<Vector3Int> cellsToProcess = timedCells.Keys.ToList();

foreach (Vector3Int cellPos in cellsToProcess) {
if (timedCells.TryGetValue(cellPos, out TimedTileState state)) {
state.ticksRemaining--;
if (state.ticksRemaining <= 0) {
TileDefinition actualTile = FindWhichTileDefinitionAt(cellPos);
if (actualTile == state.tileDef) {
if (debugLogs) Debug.Log($"[TileInteractionManager] Reverting tile '{state.tileDef.displayName}' at {cellPos}.");
RemoveTile(state.tileDef, cellPos);
if (state.tileDef.revertToTile != null) {
PlaceTile(state.tileDef.revertToTile, cellPos);
}
}
else {
if (debugLogs) Debug.LogWarning($"[TileInteractionManager] State desync detected at {cellPos}. Expected '{state.tileDef.displayName}' for reversion, but found '{(actualTile != null ? actualTile.displayName : "NULL")}'. Removing stale timer.");
}
timedCells.Remove(cellPos);
}
else {
timedCells[cellPos] = state;
}
}
}
}

pub void PlaceTile(TileDefinition tileDef, Vector3Int cellPos) {
EnsureInitialized();
if (tileDef == null) return;
if (moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module) && module?.DataTilemap != null) {
module.DataTilemap.SetTile(cellPos, ScriptableObject.CreateInstance<Tile>());
if (tileDef.revertAfterTicks > 0) {
timedCells[cellPos] = new TimedTileState { tileDef = tileDef, ticksRemaining = tileDef.revertAfterTicks };
}
}
}

pub void RemoveTile(TileDefinition tileDef, Vector3Int cellPos) {
EnsureInitialized();
if (tileDef == null) return;
if (moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module) && module?.DataTilemap != null) {
module.DataTilemap.SetTile(cellPos, null);
}

if (timedCells.TryGetValue(cellPos, out TimedTileState timedState) && timedState.tileDef == tileDef) {
timedCells.Remove(cellPos);
}
}

void CacheHoverSpriteRenderer() {
if (hoverHighlightObject != null) {
hoverSpriteRenderer = hoverHighlightObject.GetComponent<SpriteRenderer>();
}
}

void SetupTilemaps() {
moduleByDefinition = new Dictionary<TileDefinition, DualGridTilemapModule>();
if (tileDefinitionMappings == null) return;
foreach (var mapping in tileDefinitionMappings) {
if (mapping?.tileDef != null && mapping.tilemapModule != null) {
if (!moduleByDefinition.ContainsKey(mapping.tileDef)) {
moduleByDefinition[mapping.tileDef] = mapping.tilemapModule;
}
else {
Debug.LogWarning($"[TileInteractionManager] Duplicate TileDefinition '{mapping.tileDef.displayName}' found in mappings.", mapping.tileDef);
}
}
}
}

pub void UpdateSortingOrder() {
if (tileDefinitionMappings == null) return;
for (int i = 0; i < tileDefinitionMappings.Count; i++) {
var mapping = tileDefinitionMappings[i];
if (mapping?.tilemapModule != null) {
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
if (renderTilemapTransform.GetComponent<TilemapRenderer>() is TilemapRenderer renderer) {
renderer.sortingOrder = baseSortingOrder - i;
#if UNITY_EDITOR
if (!Application.isPlaying) EditorUtility.SetDirty(renderer);
#endif
}
}
}
}
}

pub void UpdateAllColors() {
if (tileDefinitionMappings == null) return;
foreach (var mapping in tileDefinitionMappings) {
if (mapping?.tileDef != null && mapping.tilemapModule != null) {
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
if (renderTilemapTransform.GetComponent<Tilemap>() is Tilemap renderTilemap) {
renderTilemap.color = mapping.tileDef.tintColor;
#if UNITY_EDITOR
if (!Application.isPlaying) EditorUtility.SetDirty(renderTilemap);
#endif
}
}
}
}
}

void HandleTileHover() {
if (mainCamera == null || player == null) return;
Vector3 mouseWorldPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
mouseWorldPos.z = 0f;
Vector3Int cellPos = WorldToCell(mouseWorldPos);

if (player.GetComponent<GridEntity>() is GridEntity playerGrid) {
int gridRadius = Mathf.CeilToInt(hoverRadius);
GridPosition playerGridPos = playerGrid.Position;
GridPosition hoveredGridPos = new GridPosition(cellPos);
isWithinInteractionRange = GridRadiusUtility.IsWithinCircleRadius(hoveredGridPos, playerGridPos, gridRadius);
}

hoveredTileDef = FindWhichTileDefinitionAt(cellPos);
currentlyHoveredCell = cellPos;

if (hoverHighlightObject != null) {
hoverHighlightObject.SetActive(true);

hoverHighlightObject.transform.position = CellCenterWorld(cellPos);

hoverHighlightObject.transform.position = PixelGridSnapper.SnapToGrid(hoverHighlightObject.transform.position);

UpdateHoverHighlightColor(isWithinInteractionRange);
}
}

void UpdateHoverHighlightColor(bool withinRange) {
if (hoverSpriteRenderer != null && hoverColorManager != null) {
hoverSpriteRenderer.color = hoverColorManager.GetColorForRange(withinRange);
}
}

void UpdateDebugUI() {
if (hoveredTileText != null) {
string tileName = hoveredTileDef != null ? hoveredTileDef.displayName : "None";
if (currentlyHoveredCell.HasValue && timedCells.TryGetValue(currentlyHoveredCell.Value, out TimedTileState timedState)) {
tileName += $" [{timedState.ticksRemaining}t]";
}
string rangeIndicator = isWithinInteractionRange ? " [IN RANGE]" : " [OUT OF RANGE]";
hoveredTileText.text = $"Hover: {tileName}{rangeIndicator}";
}
if (currentToolText != null) {
if (InventoryBarController.Instance?.SelectedItem != null) {
currentToolText.text = $"Selected: {InventoryBarController.Instance.SelectedItem.GetDisplayName()}";
}
else {
currentToolText.text = "Nothing Selected";
}
}
}

pub Vector3Int WorldToCell(Vector3 worldPos) {
ret interactionGrid != null ? interactionGrid.WorldToCell(worldPos) : Vector3Int.zero;
}

Vector3 CellCenterWorld(Vector3Int cellPos) {
ret interactionGrid != null ? interactionGrid.GetCellCenterWorld(cellPos) : Vector3.zero;
}

pub bool IsWithinInteractionRange => isWithinInteractionRange;
pub Vector3Int? CurrentlyHoveredCell => currentlyHoveredCell;
pub TileDefinition HoveredTileDef => hoveredTileDef;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\ProceduralGeneration\Editor\ResolutionManagerEditor.cs

﻿using UnityEngine;
using UnityEditor;
using WegoSystem;

namespace WegoSystem.Editor {
pub cls ResolutionManagerEditor : UnityEditor.Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

ResolutionManager manager = (ResolutionManager)target;

EditorGUILayout.Space(10);

GUIStyle buttonStyle = new GUIStyle(GUI.skin.button);
buttonStyle.padding = new RectOffset(10, 10, 8, 8);
buttonStyle.fontSize = 12;

if (GUILayout.Button("Apply Current Profile in Editor", buttonStyle)) {
if (manager != null) {
manager.ApplyProfileInEditor();
Debug.Log("Applied resolution profile settings in the editor.");
}
}

EditorGUILayout.HelpBox("Press this button to apply the 'Current Profile Index' settings to the Main Camera. This is useful for previewing changes without entering Play mode.", MessageType.Info);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\TileInteractionManagerEditor.cs

﻿using UnityEngine;
using UnityEditor;
using WegoSystem;

pub cls TileInteractionManagerEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

TileInteractionManager manager = (TileInteractionManager)target;

EditorGUILayout.Space();
EditorGUILayout.BeginHorizontal();

if (GUILayout.Button("UPDATE SORTING ORDER", GUILayout.Height(30))) {
if (manager != null) {
manager.UpdateSortingOrder();
EditorUtility.SetDirty(manager);
}
}

if (GUILayout.Button("UPDATE ALL COLORS", GUILayout.Height(30))) {
if (manager != null) {
manager.UpdateAllColors();
EditorUtility.SetDirty(manager);
}
}

EditorGUILayout.EndHorizontal();

if (manager != null) {
EditorGUILayout.HelpBox("Order: First item in list gets highest sorting order value (" +
manager.baseSortingOrder + "). Each subsequent item is " +
(manager.baseSortingOrder - 1) + ", " +
(manager.baseSortingOrder - 2) + ", etc.", MessageType.Info);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\ProceduralGeneration\MapBoundsVisualizer.cs

﻿using UnityEngine;
using WegoSystem;

namespace WegoSystem.EditorTools {
pub cls MapBoundsVisualizer : MonoBehaviour {
[SerializeField] MapConfiguration mapConfig;

[SerializeField] Color boundsColor = Color.green;
[SerializeField] Color safeAreaColor = Color.yellow;
[SerializeField] bool showCameraArea = true;

void OnDrawGizmos() {
if (mapConfig == null) return;

var gridManager = GridPositionManager.Instance;
if (gridManager == null) {
gridManager = FindFirstObjectByType<GridPositionManager>();
if (gridManager == null) return; // If still not found, we cannot proceed.
}

var grid = gridManager.GetTilemapGrid();
if (grid == null) return;

Vector3 firstCellCenter = grid.GetCellCenterWorld(new Vector3Int(0, 0, 0));
Vector3 lastCellCenter = grid.GetCellCenterWorld(new Vector3Int(mapConfig.mapSize.x - 1, mapConfig.mapSize.y - 1, 0));

Vector3 mapWorldCenter = (firstCellCenter + lastCellCenter) / 2f;

Vector3 mapWorldSize = (lastCellCenter - firstCellCenter) + grid.cellSize;
mapWorldSize.x = Mathf.Abs(mapWorldSize.x);
mapWorldSize.y = Mathf.Abs(mapWorldSize.y);

Gizmos.color = boundsColor;
Gizmos.DrawWireCube(mapWorldCenter, mapWorldSize);

Gizmos.color = safeAreaColor;
float padding = grid.cellSize.x * 2; // 2 tiles padding
Vector3 safeSize = mapWorldSize - new Vector3(padding * 2, padding * 2, 0);
if (safeSize.x > 0 && safeSize.y > 0) {
Gizmos.DrawWireCube(mapWorldCenter, safeSize);
}

if (showCameraArea && Camera.main != null) {
Gizmos.color = Color.blue;
Camera cam = Camera.main;
float height = cam.orthographicSize * 2;
float width = height * cam.aspect;
Gizmos.DrawWireCube(cam.transform.position, new Vector3(width, height, 0));
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\ProceduralGeneration\MapGenerationProfile.cs

﻿// FILE: Assets/Scripts/ProceduralGeneration/MapGenerationProfile.cs
using WegoSystem.ProceduralGeneration;

pub cls BiomeLayer {
pub TileDefinition tile;

pub float noiseThreshold;

pub bool placeUnderlayTile = false;

pub TileDefinition underlayTile;

}

namespace WegoSystem.ProceduralGeneration {
pub cls MapGenerationProfile : ScriptableObject {

pub int worldSeed = 12345;
pub bool useRandomSeed = true;

pub NoiseParameters noiseParameters = new NoiseParameters {
scale = 0.1f,
octaves = 4,
persistence = 0.5f,
lacunarity = 2f
};

pub List<BiomeLayer> biomeLayers;

pub void InitializeSeed() {
if (useRandomSeed) {
worldSeed = Random.Range(0, int.MaxValue);
}
noiseParameters.seed = worldSeed;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\ProceduralGeneration\ProceduralMapGenerator.cs

﻿using System.Collections.Generic;
using WegoSystem;

namespace WegoSystem.ProceduralGeneration {
pub cls ProceduralMapGenerator : MonoBehaviour {
[SerializeField] MapConfiguration mapConfig;

[SerializeField] MapGenerationProfile profile;

[SerializeField] TileInteractionManager tileManager;

ro Dictionary<Vector2Int, TileDefinition> tileMap = new Dictionary<Vector2Int, TileDefinition>();

pub void GenerateMap() {
if (!ValidateConfiguration()) {
return;
}

profile.InitializeSeed();
Debug.Log($"Starting map generation with seed: {profile.worldSeed}...");

ClearMap();

var sortedLayers = profile.biomeLayers.OrderBy(layer => layer.noiseThreshold).ToList();

float halfWidth = mapConfig.mapSize.x / 2f;
float halfHeight = mapConfig.mapSize.y / 2f;

for (int x = 0; x < mapConfig.mapSize.x; x++) {
for (int y = 0; y < mapConfig.mapSize.y; y++) {
float sampleX = x - halfWidth;
float sampleY = y - halfHeight;
float noiseValue = profile.noiseParameters.Sample(sampleX, sampleY);

float normalizedNoise = SimplexNoise.Remap(noiseValue, -1f, 1f, 0f, 1f);

BiomeLayer chosenLayer = null;
foreach (var layer in sortedLayers) {
if (normalizedNoise <= layer.noiseThreshold) {
chosenLayer = layer;
break;
}
}

if (chosenLayer != null) {
var cellPos = new Vector3Int(x, y, 0);

if (chosenLayer.placeUnderlayTile && chosenLayer.underlayTile != null) {
tileManager.PlaceTile(chosenLayer.underlayTile, cellPos);
}

if (chosenLayer.tile != null) {
tileManager.PlaceTile(chosenLayer.tile, cellPos);
tileMap[new Vector2Int(x, y)] = chosenLayer.tile;
}
}
}
}

Debug.Log("Map generation complete.");
}

pub void ClearMap() {
if (!ValidateConfiguration(checkMappings: false)) {
return;
}

Debug.Log("Clearing existing map by checking every cell...");

for (int x = 0; x < mapConfig.mapSize.x; x++) {
for (int y = 0; y < mapConfig.mapSize.y; y++) {
var cellPos = new Vector3Int(x, y, 0);

TileDefinition tileOnTop;
while ((tileOnTop = tileManager.FindWhichTileDefinitionAt(cellPos)) != null) {
tileManager.RemoveTile(tileOnTop, cellPos);
}
}
}

ClearCaches();
Debug.Log("[ProceduralMapGenerator] Map clear complete.");
}

void ClearCaches() {
tileMap.Clear();
}

bool ValidateConfiguration(bool checkMappings = true) {
if (mapConfig == null) {
Debug.LogError("[ProceduralMapGenerator] Map Configuration is not assigned!", this);
ret false;
}
if (profile == null) {
Debug.LogError("[ProceduralMapGenerator] Map Generation Profile is not assigned!", this);
ret false;
}

if (tileManager == null) {
tileManager = TileInteractionManager.Instance;
if (tileManager == null) {
Debug.LogError("[ProceduralMapGenerator] Tile Interaction Manager is not assigned in the Inspector and could not be found in the scene! Please assign it.", this);
ret false;
}
}

if (checkMappings && (profile.biomeLayers == null || profile.biomeLayers.Count == 0)) {
Debug.LogError("[ProceduralMapGenerator] The assigned Profile has no Biome Layers defined!", this);
ret false;
}
ret true;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\ProceduralGeneration\SimplexNoise.cs

﻿// FILE: Assets/Scripts/ProceduralGeneration/SimplexNoise.cs

namespace WegoSystem.ProceduralGeneration {
pub stat cls SimplexNoise {
stat ro int[] perm = new int[512];
stat ro float F2 = 0.5f * (Mathf.Sqrt(3f) - 1f);
stat ro float G2 = (3f - Mathf.Sqrt(3f)) / 6f;

stat ro Vector2[] grad2 = {
new Vector2(1, 1), new Vector2(-1, 1), new Vector2(1, -1), new Vector2(-1, -1),
new Vector2(1, 0), new Vector2(-1, 0), new Vector2(0, 1), new Vector2(0, -1)
};

pub stat void Initialize(int seed) {
System.Random rand = new System.Random(seed);
int[] p = new int[256];

for (int i = 0; i < 256; i++) {
p[i] = i;
}

for (int i = 255; i > 0; i--) {
int j = rand.Next(i + 1);
int temp = p[i];
p[i] = p[j];
p[j] = temp;
}

for (int i = 0; i < 512; i++) {
perm[i] = p[i & 255];
}
}

pub stat float Generate2D(float x, float y) {
float s = (x + y) * F2;
int i = Mathf.FloorToInt(x + s);
int j = Mathf.FloorToInt(y + s);

float t = (i + j) * G2;
float X0 = i - t;
float Y0 = j - t;
float x0 = x - X0;
float y0 = y - Y0;

int i1, j1;
if (x0 > y0) {
i1 = 1; j1 = 0;
}
else {
i1 = 0; j1 = 1;
}

float x1 = x0 - i1 + G2;
float y1 = y0 - j1 + G2;
float x2 = x0 - 1f + 2f * G2;
float y2 = y0 - 1f + 2f * G2;

int ii = i & 255;
int jj = j & 255;
int gi0 = perm[ii + perm[jj]] % 8;
int gi1 = perm[ii + i1 + perm[jj + j1]] % 8;
int gi2 = perm[ii + 1 + perm[jj + 1]] % 8;

float n0 = 0f, n1 = 0f, n2 = 0f;

float t0 = 0.5f - x0 * x0 - y0 * y0;
if (t0 >= 0) {
t0 *= t0;
n0 = t0 * t0 * Dot(grad2[gi0], x0, y0);
}

float t1 = 0.5f - x1 * x1 - y1 * y1;
if (t1 >= 0) {
t1 *= t1;
n1 = t1 * t1 * Dot(grad2[gi1], x1, y1);
}

float t2 = 0.5f - x2 * x2 - y2 * y2;
if (t2 >= 0) {
t2 *= t2;
n2 = t2 * t2 * Dot(grad2[gi2], x2, y2);
}

ret 70f * (n0 + n1 + n2);
}

pub stat float GenerateOctaves(float x, float y, NoiseParameters parameters) {
if (parameters.octaves <= 0) ret 0f;

float amplitude = 1f;
float frequency = 1f;
float noiseValue = 0f;
float maxValue = 0f;

for (int i = 0; i < parameters.octaves; i++) {
float sampleX = (x + parameters.offset.x) * parameters.scale * frequency;
float sampleY = (y + parameters.offset.y) * parameters.scale * frequency;

float octaveValue = Generate2D(sampleX, sampleY);
noiseValue += octaveValue * amplitude;
maxValue += amplitude;

amplitude *= parameters.persistence;
frequency *= parameters.lacunarity;
}

if (maxValue > 0) {
ret noiseValue / maxValue;
}
ret 0f;
}

stat float Dot(Vector2 g, float x, float y) {
ret g.x * x + g.y * y;
}

pub stat float Remap(float value, float from1, float to1, float from2, float to2) {
ret from2 + (value - from1) * (to2 - from2) / (to1 - from1);
}
}

pub cls NoiseParameters {
pub float scale = 0.1f;

pub int seed = 42;

pub int octaves = 4;

pub float persistence = 0.5f;

pub float lacunarity = 2f;

pub Vector2 offset = Vector2.zero;

pub NoiseParameters() { }

pub NoiseParameters(float scale, int octaves, int seed) {
this.scale = scale;
this.octaves = octaves;
this.seed = seed;
}

pub float Sample(float x, float y) {
SimplexNoise.Initialize(seed);
ret SimplexNoise.GenerateOctaves(x, y, this);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\ProceduralGeneration\Editor\SceneSetupManagerEditor.cs

﻿using UnityEngine;
using UnityEditor;
using WegoSystem; // <-- ADDED THIS LINE to resolve the ns issue.

pub cls SceneSetupManagerEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

SceneSetupManager setupManager = (SceneSetupManager)target;

EditorGUILayout.Space(10);

GUIStyle buttonStyle = new GUIStyle(GUI.skin.button);
buttonStyle.padding = new RectOffset(10, 10, 10, 10);
buttonStyle.fontSize = 13;

if (GUILayout.Button("Setup Scene Now (Move Player & Camera)", buttonStyle)) {
if (setupManager != null) {
setupManager.SetupScene();
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Placement\PlantPlacementManager.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;
using WegoSystem; // <-- FIX: Added this line to resolve the ns issue.

namespace Abracodabra.UI.Genes {
pub cls PlantPlacementManager : MonoBehaviour {
pub stat PlantPlacementManager Instance { get; set; }

[SerializeField] Transform plantParent;
[SerializeField] TileInteractionManager tileInteractionManager;
[SerializeField] NodeExecutor nodeExecutor;
[SerializeField] float spawnRadius = 0.25f;
[SerializeField] List<TileDefinition> invalidPlantingTiles = new List<TileDefinition>();

ro HashSet<TileDefinition> invalidTilesSet = new HashSet<TileDefinition>();
ro Dictionary<Vector3Int, GameObject> plantsByGridPosition = new Dictionary<Vector3Int, GameObject>();

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;
RebuildInvalidTilesSet();
}

pub void Initialize() {
if (plantParent == null && EcosystemManager.Instance != null) plantParent = EcosystemManager.Instance.plantParent;
if (tileInteractionManager == null) tileInteractionManager = TileInteractionManager.Instance;
if (nodeExecutor == null) nodeExecutor = FindFirstObjectByType<NodeExecutor>();
}

void RebuildInvalidTilesSet() {
invalidTilesSet.Clear();
foreach (var tile in invalidPlantingTiles) {
if (tile != null) {
invalidTilesSet.Add(tile);
}
}
}

pub bool IsPositionOccupied(Vector3Int gridPosition) {
CleanupDestroyedPlants();
ret plantsByGridPosition.ContainsKey(gridPosition);
}

pub bool IsTileValidForPlanting(TileDefinition tileDef) {
ret tileDef != null && !invalidTilesSet.Contains(tileDef);
}

void CleanupDestroyedPlants() {
var keysToRemove = plantsByGridPosition.Where(kvp => kvp.Value == null).Select(kvp => kvp.Key).ToList();
foreach (var key in keysToRemove) {
plantsByGridPosition.Remove(key);
}
}

pub bool TryPlantSeedFromInventory(PlantGeneRuntimeState runtimeState, Vector3Int gridPosition, Vector3 worldPosition) {
if (runtimeState == null || runtimeState.template == null) {
Debug.LogError("[PlantPlacementManager] Failed: RuntimeState or its template was null.");
ret false;
}

if (!runtimeState.template.IsValid()) {
Debug.LogError($"[PlantPlacementManager] Failed: Seed template '{runtimeState.template.templateName}' configuration is invalid.", runtimeState.template);
ret false;
}

if (IsPositionOccupied(gridPosition)) {
Debug.LogWarning($"[PlantPlacementManager] Failed: Position {gridPosition} is already occupied by another plant in the dictionary.", this);
ret false;
}

TileDefinition tileDef = tileInteractionManager?.FindWhichTileDefinitionAt(gridPosition);
if (!IsTileValidForPlanting(tileDef)) {
string tileName = tileDef != null ? tileDef.displayName : "NULL";
Debug.LogWarning($"[PlantPlacementManager] Failed: Tile '{tileName}' at {gridPosition} is not a valid planting tile.", this);
ret false;
}

if (nodeExecutor == null) {
nodeExecutor = FindFirstObjectByType<NodeExecutor>();
if (nodeExecutor == null) {
Debug.LogError("[PlantPlacementManager] Failed: NodeExecutor reference is missing and could not be found in the scene!");
ret false;
}
}

Vector3 finalPlantingPosition = GetRandomizedPlantingPosition(worldPosition);
GameObject plantGO = nodeExecutor.SpawnPlantFromState(runtimeState, finalPlantingPosition, plantParent);

if (plantGO == null) {
Debug.LogError("[PlantPlacementManager] Failed: NodeExecutor returned a null plant GameObject. Check NodeExecutor's logs (is its Plant Prefab assigned?).", this);
ret false;
}

WegoSystem.GridPositionManager.Instance.SnapEntityToGrid(plantGO);
var finalGridEntity = plantGO.GetComponent<WegoSystem.GridEntity>();
Vector3Int finalGridPosition = finalGridEntity.Position.ToVector3Int();

plantsByGridPosition[finalGridPosition] = plantGO;
Debug.Log($"[PlantPlacementManager] Successfully planted '{runtimeState.template.templateName}' and registered it at final grid position {finalGridPosition}.");
ret true;
}

Vector3 GetRandomizedPlantingPosition(Vector3 centerPosition) {
if (spawnRadius <= 0f) ret centerPosition;
Vector2 randomOffset = Random.insideUnitCircle * spawnRadius;
ret centerPosition + new Vector3(randomOffset.x, randomOffset.y, 0);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\HungerUI.cs

﻿using UnityEngine;
using TMPro;
using WegoSystem; // <-- ADDED THIS LINE to resolve the ns issue.

pub cls HungerUI : MonoBehaviour {
[SerializeField] PlayerHungerSystem playerHungerSystem;
[SerializeField] Slider hungerSlider;
[SerializeField] TextMeshProUGUI hungerText;

void Start() {
if (playerHungerSystem == null) {
GardenerController player = FindAnyObjectByType<GardenerController>();
if (player != null) {
playerHungerSystem = player.GetComponent<PlayerHungerSystem>();
}
}

if (playerHungerSystem != null) {
playerHungerSystem.OnHungerChanged += UpdateUI;
UpdateUI(playerHungerSystem.CurrentHunger, playerHungerSystem.MaxHunger);
}
else {
Debug.LogError("[HungerUI] PlayerHungerSystem reference not found! UI will not update.", this);
gameObject.SetActive(false);
}
}

void OnDestroy() {
if (playerHungerSystem != null) {
playerHungerSystem.OnHungerChanged -= UpdateUI;
}
}

void UpdateUI(float currentHunger, float maxHunger) {
if (hungerSlider != null) {
hungerSlider.maxValue = maxHunger;
hungerSlider.value = currentHunger;
}

if (hungerText != null) {
hungerText.text = $"{Mathf.CeilToInt(currentHunger)} / {Mathf.CeilToInt(maxHunger)}";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileDefinition.cs

﻿using UnityEngine;
using UnityEngine.Tilemaps;
using WegoSystem; // <-- FIX: Added this line to resolve the ns issue.

pub cls TileDefinition : ScriptableObject {
pub string displayName;    // e.g. "Grass", "Dirt", "Wet Dirt"

pub Color tintColor = Color.white;

pub int revertAfterTicks = 0;  // Changed from float revertAfterSeconds

pub TileDefinition revertToTile;

pub bool keepBottomTile = false;

pub bool isWaterTile = false;

#if UNITY_EDITOR
pub void UpdateColor() {
var manager = UnityEngine.Object.FindAnyObjectByType<TileInteractionManager>();
if (manager == null) return;

foreach (var mapping in manager.tileDefinitionMappings) {
if (mapping.tileDef == this && mapping.tilemapModule != null) {
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
if (renderTilemap != null) {
renderTilemap.color = tintColor;
UnityEditor.EditorUtility.SetDirty(renderTilemap);
}
}
}
}
}
#endif
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Services\GeneEventBus.cs

﻿// File: Assets/Scripts/Genes/Services/GeneEventBus.cs
using Abracodabra.Genes.Core; // Assuming Gene classes will be in this namespace

namespace Abracodabra.Genes.Services {
pub cls GeneEventBus : IGeneEventBus {
Dictionary<Type, List<Delegate>> handlers = new Dictionary<Type, List<Delegate>>();

pub void Subscribe<T>(Action<T> handler) where T : class {
var type = typeof(T);
if (!handlers.ContainsKey(type))
handlers[type] = new List<Delegate>();
handlers[type].Add(handler);
}

pub void Unsubscribe<T>(Action<T> handler) where T : class {
var type = typeof(T);
if (handlers.ContainsKey(type))
handlers[type].Remove(handler);
}

pub void Publish<T>(T message) where T : class {
var type = typeof(T);
if (handlers.TryGetValue(type, out var list)) {
var handlersToInvoke = new List<Delegate>(list);
foreach (Action<T> handler in handlersToInvoke)
handler?.Invoke(message);
}
}
}

pub cls GeneExecutedEvent {
pub ActiveGene Gene { get; set; }
pub int SequencePosition { get; set; }
pub bool Success { get; set; }
pub float EnergyCost { get; set; }
}

pub cls SequenceCompletedEvent {
pub int TotalSlotsExecuted { get; set; }
pub float TotalEnergyUsed { get; set; }
}

pub cls GeneValidationFailedEvent {
pub string GeneId { get; set; }
pub string Reason { get; set; }
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\ProceduralGeneration\Editor\ProceduralMapGeneratorEditor.cs

﻿// FILE: Assets/Scripts/Editor/ProceduralMapGeneratorEditor.cs
using UnityEditor;
using WegoSystem.ProceduralGeneration;

namespace WegoSystem.ProceduralGeneration.Editor {
pub cls ProceduralMapGeneratorEditor : UnityEditor.Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

ProceduralMapGenerator generator = (ProceduralMapGenerator)target;

EditorGUILayout.Space(10);
EditorGUILayout.LabelField("Controls", EditorStyles.boldLabel);

if (GUILayout.Button("Generate Map")) {
generator.GenerateMap();
}

if (GUILayout.Button("Clear Map")) {
generator.ClearMap();
}
}
}
}
