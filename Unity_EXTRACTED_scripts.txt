UNITY PROJECT SCRIPTS - COMPRESSED FORMAT
Compression Stats: 733,786 -> 533,942 chars (27.2% reduction)
Estimated tokens saved: ~49,961

This document contains extracted Unity 6 C# scripts optimized for AI/LLM context.

When editing: return each changed method in full. If edits touch <=3 methods, list those blocks only; otherwise output the entire script. Always copy-paste ready.

COMPRESSION APPLIED:
- Removed: empty lines, common usings, XML docs, most attributes, regions
- Preserved: code structure, logic flow, important comments (TODO/FIXME/NOTE)

WHEN CREATING/EDITING SCRIPTS:
1. Re-add standard Unity using statements (listed below + any project-specific ones)
2. Format with proper indentation and spacing
3. Add [SerializeField] attributes where needed
4. Ensure proper C# code style

COMMON USING STATEMENTS:
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using System.Linq;

[Global Scope]
  GameEvent (Assets\Scripts\Core\Events/) L34
  GameEventListener (Assets\Scripts\Core\Events/) L61
  IGameEventListener (Assets\Scripts\Core\Events/) L90
  GameInitializer (Assets\Scripts\Core/) L98
  GeneSystemInitializer (Assets\Scripts\Core/) L122
  SortableEntity (Assets\Scripts\Core/) L136
  WeatherManager (Assets\Scripts\Core/) L207
  AnimalBehavior (Assets\Scripts\Ecosystem\Animals/) L409
  AnimalController (Assets\Scripts\Ecosystem\Animals/) L470
  AnimalDefinition (Assets\Scripts\Ecosystem\Animals/) L756
  AnimalLibrary (Assets\Scripts\Ecosystem\Animals/) L827
  AnimalMovement (Assets\Scripts\Ecosystem\Animals/) L836
  AnimalNeeds (Assets\Scripts\Ecosystem\Animals/) L1249
  AnimalSpawnData (Assets\Scripts\Ecosystem\Animals/) L1413
  AnimalThoughtLibrary (Assets\Scripts\Ecosystem\Animals/) L1429
  FireflyController (Assets\Scripts\Ecosystem\Effects/) L1467
  FireflyDefinition (Assets\Scripts\Ecosystem\Effects/) L1777
  FireflyManager (Assets\Scripts\Ecosystem\Effects/) L1813
  PoopController (Assets\Scripts\Ecosystem\Environment/) L2093
  ScentDefinition (Assets\Scripts\Ecosystem\Environment/) L2186
  ScentLibrary (Assets\Scripts\Ecosystem\Environment/) L2208
  ScentSource (Assets\Scripts\Ecosystem\Environment/) L2227
  DietPreferenceSimplified (Assets\Scripts\Ecosystem\Food/) L2311
  FoodItem (Assets\Scripts\Ecosystem\Food/) L2392
  FoodType (Assets\Scripts\Ecosystem\Food/) L2464
  EcosystemManager (Assets\Scripts\Ecosystem\Management/) L2480
  FaunaManager (Assets\Scripts\Ecosystem\Management/) L2502
  FloraManager (Assets\Scripts\Ecosystem\Management/) L2751
  WaveState (Assets\Scripts\Ecosystem\Management/) L2771
  WaveSpawnLocationType (Assets\Scripts\Ecosystem\Spawning/) L3076
  IStatusEffectable (Assets\Scripts\Ecosystem\Status Effects/) L3119
  StatusEffect (Assets\Scripts\Ecosystem\Status Effects/) L3138
  StatusEffectIconUI (Assets\Scripts\Ecosystem\Status Effects/) L3177
  StatusEffectInstance (Assets\Scripts\Ecosystem\Status Effects/) L3225
  StatusEffectManager (Assets\Scripts\Ecosystem\Status Effects/) L3243
  StatusEffectUIManager (Assets\Scripts\Ecosystem\Status Effects/) L3394
  ThoughtBubbleController (Assets\Scripts\Ecosystem\UI/) L3505
  ThoughtTrigger (Assets\Scripts\Ecosystem\UI/) L3552
  RadiusPatternTesterEditor (Assets\Scripts\Editor/) L3565
  TileDefinitionEditor (Assets\Scripts\Editor/) L3627
  TileInteractionManagerEditor (Assets\Scripts\Editor/) L3647
  WaveDefinitionEditor (Assets\Scripts\Editor/) L3688
  WaveManagerEditor (Assets\Scripts\Editor/) L3825
  GeneLibraryLoader (Assets\Scripts\Genes\Core/) L4002
  ItemEffect (Assets\Scripts\Items/) L4028
  ItemInstance (Assets\Scripts\Items/) L4062
  ITriggerTarget (Assets\Scripts\PlantSystem\Data/) L4097
  LeafData (Assets\Scripts\PlantSystem\Data/) L4105
  NodeExecutor (Assets\Scripts\PlantSystem\Execution/) L4120
  PlantCellType (Assets\Scripts\PlantSystem\Growth/) L4159
  PlantCellManager (Assets\Scripts\PlantSystem\Growth/) L4180
  PlantEnergySystem (Assets\Scripts\PlantSystem\Growth/) L4317
  PlantGrowthLogic (Assets\Scripts\PlantSystem\Growth/) L4379
  PlantVisualManager (Assets\Scripts\PlantSystem\Growth/) L4474
  StartingInventory (Assets\Scripts\PlantSystem\UI/) L4574
  OutlinePartController (Assets\Scripts\PlantSystem\Visual/) L4596
  PlantOutlineController (Assets\Scripts\PlantSystem\Visual/) L4711
  PlantShadowController (Assets\Scripts\PlantSystem\Visual/) L4867
  ShadowPartController (Assets\Scripts\PlantSystem\Visual/) L4977
  SceneSetupManagerEditor (Assets\Scripts\ProceduralGeneration\Editor/) L5078
  GridDebugVisualizer (Assets\Scripts\Ticks/) L5105
  GridSnapStartup (Assets\Scripts\Ticks/) L5347
  TickDebugMonitor (Assets\Scripts\Ticks/) L5414
  ColorExtensions (Assets\Scripts\UI\Utilities/) L5450
  PrefabOrigin (Assets\Scripts\UI\Utilities/) L5461
  InventoryBarItem (Assets\Scripts\UI\_UGUI_Legacy/) L5491
  InventoryColorManager (Assets\Scripts\UI\_UGUI_Legacy/) L5592
  InventoryGridController (Assets\Scripts\UI\_UGUI_Legacy/) L5659
  TooltipTrigger (Assets\Scripts\UI\_UGUI_Legacy/) L5804
  UIManager (Assets\Scripts\UI\_UGUI_Legacy/) L5862
  ITooltipDataProvider (Assets\Scripts\UI\_UGUI_Legacy/) L6079
  NightColorPostProcess (Assets\Scripts\Visual\Effects/) L6313
  RuntimeCircleDrawer (Assets\Scripts\Visual\Effects/) L6421
  WaterReflection (Assets\Scripts\Visual\Effects/) L6528
  WaterReflectionManager (Assets\Scripts\Visual\Effects/) L6953
  PlantGrowthModifierManager (Assets\Scripts\WorldInteraction\Placement/) L6999
  PlayerTileInteractor (Assets\Scripts\WorldInteraction\Placement/) L7170
  HarvestableTag (Assets\Scripts\WorldInteraction\Player/) L7431
  HarvestedItem (Assets\Scripts\WorldInteraction\Player/) L7439
  HungerUI (Assets\Scripts\WorldInteraction\Player/) L7465
  PlayerActionType (Assets\Scripts\WorldInteraction\Player/) L7513
  PlayerHungerSystem (Assets\Scripts\WorldInteraction\Player/) L7712
  TileDefinition (Assets\Scripts\WorldInteraction\Tiles/) L7789
  TileHoverColorManager (Assets\Scripts\WorldInteraction\Tiles/) L7843
  ToolRefillRule (Assets\Scripts\WorldInteraction\Tiles/) L7870
  TileInteractionRule (Assets\Scripts\WorldInteraction\Tiles/) L7895
  ToolDefinition (Assets\Scripts\WorldInteraction\Tools/) L7912
  ToolSwitcher (Assets\Scripts\WorldInteraction\Tools/) L7952
  ToolType (Assets\Scripts\WorldInteraction\Tools/) L8087

[Abracodabra.Genes]
  TemporaryFruitSpawnMarker (Assets\Scripts\Genes\Components/) L8098
  GeneLibrary (Assets\Scripts\Genes/) L8108
  PlantSequenceExecutor (Assets\Scripts\Genes/) L8263
  PlantState (Assets\Scripts\PlantSystem\Growth/) L8443

[Abracodabra.Genes.Components]
  Creature (Assets\Scripts\Genes\Components/) L8835
  Fruit (Assets\Scripts\Genes\Components/) L8860
  NutritionComponent (Assets\Scripts\Genes\Components/) L8898

[Abracodabra.Genes.Core]
  ActiveGene (Assets\Scripts\Genes\Core/) L8910
  ActiveGeneContext (Assets\Scripts\Genes\Core/) L8956
  ActiveGeneSlotConfig (Assets\Scripts\Genes\Core/) L8975
  ModifierGene (Assets\Scripts\Genes\Core/) L8987
  PassiveStatType (Assets\Scripts\Genes\Core/) L9019
  PayloadGene (Assets\Scripts\Genes\Core/) L9061
  PlaceholderGene (Assets\Scripts\Genes\Core/) L9107
  SafeGeneLoader (Assets\Scripts\Genes\Core/) L9128
  GeneBase (Assets\Scripts\Genes/) L9161
  TerrainAffinityGene (Assets\Scripts\Genes\Implementations\Passive/) L9239

[Abracodabra.Genes.Implementations]
  BasicFruitGene (Assets\Scripts\Genes\Implementations\Active/) L9342
  CostReductionGene (Assets\Scripts\Genes\Implementations\Modifier/) L9460
  GrowthSpeedGene (Assets\Scripts\Genes\Implementations\Passive/) L9490
  NutritiousPayload (Assets\Scripts\Genes\Implementations\Payload/) L9533

[Abracodabra.Genes.Runtime]
  PlantGeneRuntimeState (Assets\Scripts\Genes\Runtime/) L9584
  RuntimeGeneInstance (Assets\Scripts\Genes\Runtime/) L9640
  RuntimeSequenceSlot (Assets\Scripts\Genes\Runtime/) L9772

[Abracodabra.Genes.Services]
  DeterministicRandom (Assets\Scripts\Genes\Services/) L9827
  GeneEffectPool (Assets\Scripts\Genes\Services/) L9860
  GeneEventBus (Assets\Scripts\Genes\Services/) L9958
  IGeneLibrary (Assets\Scripts\Genes\Services/) L10010

[Abracodabra.Genes.Templates]
  SeedTemplate (Assets\Scripts\Genes\Templates/) L10097

[Abracodabra.UI.Genes]
  HotbarSelectionService (Assets\Scripts\A_ToolkitUI/) L10190
  InventoryService (Assets\Scripts\A_ToolkitUI/) L10301
  GeneSequenceUI (Assets\Scripts\UI\_UGUI_Legacy/) L10471
  GeneSlotUI (Assets\Scripts\UI\_UGUI_Legacy/) L10711
  InventoryBarController (Assets\Scripts\UI\_UGUI_Legacy/) L10940
  ItemView (Assets\Scripts\UI\_UGUI_Legacy/) L11116
  SequenceRowUI (Assets\Scripts\UI\_UGUI_Legacy/) L11234
  PlantPlacementManager (Assets\Scripts\WorldInteraction\Placement/) L11305

[Abracodabra.UI.Toolkit]
  GameUIManager (Assets\Scripts\A_ToolkitUI/) L11576
  UIDragDropController (Assets\Scripts\A_ToolkitUI/) L12322
  UIHotbarController (Assets\Scripts\A_ToolkitUI/) L12611
  UIInventoryGridController (Assets\Scripts\A_ToolkitUI/) L12822
  UIInventoryItem (Assets\Scripts\A_ToolkitUI/) L13008
  UISeedEditorController (Assets\Scripts\A_ToolkitUI/) L13151
  UISpecSheetController (Assets\Scripts\A_ToolkitUI/) L13795

[Abracodabra.UI.Tooltips]
  EnhancedTooltipTrigger (Assets\Scripts\UI\_UGUI_Legacy/) L13989
  InventoryTooltipPanel (Assets\Scripts\UI\_UGUI_Legacy/) L14042
  SeedEditorTooltipPanel (Assets\Scripts\UI\_UGUI_Legacy/) L14144
  SeedTooltipData (Assets\Scripts\UI\_UGUI_Legacy/) L14287
  SeedRarity (Assets\Scripts\UI\_UGUI_Legacy/) L14457
  TooltipSystemManager (Assets\Scripts\UI\_UGUI_Legacy/) L14479
  QualityTier (Assets\Scripts\UI\_UGUI_Legacy/) L14505

[WegoSystem]
  CameraController (Assets\Scripts\Core/) L14618
  CameraZoomController (Assets\Scripts\Core/) L14731
  InitializationManager (Assets\Scripts\Core/) L14780
  PixelGridSnapper (Assets\Scripts\Core/) L14820
  RunState (Assets\Scripts\Core/) L14853
  SingletonMonoBehaviour (Assets\Scripts\Core/) L15021
  EnvironmentalStatusEffectSystem (Assets\Scripts\Ecosystem\Status Effects/) L15084
  MapConfiguration (Assets\Scripts\ProceduralGeneration/) L15220
  ResolutionManager (Assets\Scripts\ProceduralGeneration/) L15249
  SceneSetupManager (Assets\Scripts\ProceduralGeneration/) L15400
  GridEntity (Assets\Scripts\Ticks/) L15472
  GridPosition (Assets\Scripts\Ticks/) L15642
  GridPositionManager (Assets\Scripts\Ticks/) L15743
  GridRadiusUtility (Assets\Scripts\Ticks/) L16123
  TickConfiguration (Assets\Scripts\Ticks/) L16267
  ITickUpdateable (Assets\Scripts\Ticks/) L16353
  GardenerController (Assets\Scripts\WorldInteraction\Player/) L16505
  TileInteractionManager (Assets\Scripts\WorldInteraction\Tiles/) L16696

[WegoSystem.Editor]
  ResolutionManagerEditor (Assets\Scripts\ProceduralGeneration\Editor/) L17107

[WegoSystem.EditorTools]
  MapBoundsVisualizer (Assets\Scripts\ProceduralGeneration/) L17139

[WegoSystem.ProceduralGeneration]
  BiomeLayer (Assets\Scripts\ProceduralGeneration/) L17197
  ProceduralMapGenerator (Assets\Scripts\ProceduralGeneration/) L17243
  SimplexNoise (Assets\Scripts\ProceduralGeneration/) L17366

[WegoSystem.ProceduralGeneration.Editor]
  ProceduralMapGeneratorEditor (Assets\Scripts\ProceduralGeneration\Editor/) L17531


================================================================================
FILES
================================================================================

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\Events\GameEvent.cs

﻿// Assets/Scripts/Core/Events/GameEvent.cs

pub class GameEvent : ScriptableObject {
 ro List<IGameEventListener> _listeners = new List<IGameEventListener>();

 pub void Raise() {
  for (int i = _listeners.Count - 1; i >= 0; i--) {
   _listeners[i].OnEventRaised();
  }
 }

 pub void RegisterListener(IGameEventListener listener) {
  if (!_listeners.Contains(listener)) {
   _listeners.Add(listener);
  }
 }

 pub void UnregisterListener(IGameEventListener listener) {
  if (_listeners.Contains(listener)) {
   _listeners.Remove(listener);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\Events\GameEventListener.cs

﻿// Assets/Scripts/Core/Events/GameEventListener.cs

pub class GameEventListener : MonoBehaviour, IGameEventListener {
 [Tooltip("The event to register with.")]
 [SerializeField] GameEvent gameEvent;

 [Tooltip("The response to invoke when the event is raised.")]
 [SerializeField] UnityEvent response;

 void OnEnable() {
  if (gameEvent != null) {
   gameEvent.RegisterListener(this);
  }
 }

 void OnDisable() {
  if (gameEvent != null) {
   gameEvent.UnregisterListener(this);
  }
 }

 pub void OnEventRaised() {
  response.Invoke();
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\Events\IGameEventListener.cs

﻿// Assets/Scripts/Core/Events/IGameEventListener.cs
pub interface IGameEventListener {
 void OnEventRaised();
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\GameInitializer.cs

﻿using UnityEngine;
using Abracodabra.Genes.Services;
using WegoSystem;

pub class GameInitializer : MonoBehaviour {
 void Awake() {
  InitializeServices();

  if (GeneEffectPool.Instance != null) {
   GeneServices.Register<IGeneEffectPool>(GeneEffectPool.Instance);
  }
  else {
   Debug.LogError("[GameInitializer] GeneEffectPool instance could not be created or found.");
  }
 }

 stat void InitializeServices() {
  GeneServices.Initialize();
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\GeneSystemInitializer.cs

﻿using UnityEngine;
using Abracodabra.Genes.Services;

pub class GeneSystemInitializer : MonoBehaviour {
 void Awake() {
  if (!GeneServices.IsInitialized) {
   GeneServices.Initialize();
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\SortableEntity.cs

﻿using UnityEngine;

pub class SortableEntity : MonoBehaviour {
 [Header("Sorting Configuration")]
 [Tooltip("Offset added to Y position for sorting calculation")]
 [SerializeField] float sortingLayerYOffset = 0f;

 [Tooltip("Use parent's Y coordinate for sorting")]
 [SerializeField] bool useParentYCoordinate = false;

 [Tooltip("Debug logging for sorting")]
 pub bool debugSorting = false;

 SpriteRenderer spriteRenderer;

 void Awake() {
  spriteRenderer = GetComponent<SpriteRenderer>();

  if (spriteRenderer == null)
   spriteRenderer = GetComponentInChildren<SpriteRenderer>();

  if (spriteRenderer == null) {
   Debug.LogWarning($"[SortableEntity] No SpriteRenderer found on {gameObject.name}");
  }
 }

 void Start() {
  UpdateSortingOrder();
 }

 void LateUpdate() {
  UpdateSortingOrder();
 }

 pub void UpdateSortingOrder() {
  if (spriteRenderer == null) return;

  float yPositionForSorting = useParentYCoordinate && transform.parent != null
   ? transform.parent.position.y
   : transform.position.y;

  int sortOrder = CalculateSortOrder(yPositionForSorting);
  spriteRenderer.sortingOrder = sortOrder;

  if (debugSorting) {
   Debug.Log($"[SortableEntity] {gameObject.name} - Y: {yPositionForSorting}, Offset: {sortingLayerYOffset}, Sort Order: {sortOrder}");
  }
 }

 int CalculateSortOrder(float yPosition) {
  return Mathf.RoundToInt(-(yPosition + sortingLayerYOffset) * 1000f);
 }

 pub int GetCurrentSortOrder() {
  if (spriteRenderer == null) return 0;
  return spriteRenderer.sortingOrder;
 }

 pub void SetSortingOrder(int order) {
  if (spriteRenderer != null)
   spriteRenderer.sortingOrder = order;
 }

 pub void SetUseParentYCoordinate(bool value) {
  useParentYCoordinate = value;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\WeatherManager.cs

﻿// Assets/Scripts/Core/WeatherManager.cs
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using WegoSystem;

pub class WeatherManager : MonoBehaviour, ITickUpdateable {
 pub stat WeatherManager Instance { get; set; }

 pub enum CyclePhase { Day, TransitionToNight, Night, TransitionToDay }

 [Header("Cycle Control")]
 pub bool dayNightCycleEnabled = true;
 pub AnimationCurve transitionCurve = AnimationCurve.Linear(0, 0, 1, 1);
 pub float sunIntensity = 1f;

 [Header("Visuals")]
 pub float fixedSunIntensity = 1f;
 pub SpriteRenderer fadeSprite;
 pub float minAlpha = 0f;
 pub float maxAlpha = 1f;

 pub bool IsPaused { get; set; } = false;

 int currentPhaseTicks = 0;
 int totalPhaseTicksTarget = 0;

 pub CyclePhase CurrentPhase => currentPhase;
 pub event Action<CyclePhase> OnPhaseChanged;

 CyclePhase currentPhase = CyclePhase.Day;

 pub float CurrentTotalPhaseTime => totalPhaseTicksTarget * (TickManager.Instance?.Config?.GetRealSecondsPerTick() ?? 0.5f);
 pub float CurrentPhaseTimer => (totalPhaseTicksTarget - currentPhaseTicks) * (TickManager.Instance?.Config?.GetRealSecondsPerTick() ?? 0.5f);

 pub float GetPhaseProgress() {
  if (totalPhaseTicksTarget <= 0) return 0f;
  return (float)currentPhaseTicks / totalPhaseTicksTarget;
 }

 void Awake() {
  if (Instance != null && Instance != this) {
   Destroy(gameObject);
   return;
  }
  Instance = this;

  if (TickManager.Instance != null) {
   TickManager.Instance.RegisterTickUpdateable(this);
  }
 }

 pub void Initialize() {
  if (TickManager.Instance != null) {
   TickManager.Instance.RegisterTickUpdateable(this);
  }

  EnterPhase(CyclePhase.Day, true);
 }

 void OnDestroy() {
  var tickManager = TickManager.Instance;
  if (tickManager != null) {
   tickManager.UnregisterTickUpdateable(this);
  }
 }

 pub void OnTickUpdate(int currentTick) {
  if (!dayNightCycleEnabled || IsPaused) return;

  currentPhaseTicks++;

  if (currentPhaseTicks >= totalPhaseTicksTarget) {
   AdvanceToNextPhase();
  }

  UpdateSunIntensity();
 }

 void Update() {
  UpdateFadeSprite();
 }

 void UpdateSunIntensity() {
  if (TickManager.Instance?.Config != null) {
   float dayProgress = TickManager.Instance.Config.GetDayProgressNormalized(TickManager.Instance.CurrentTick);

   CyclePhase newPhase = currentPhase;

   if (dayProgress < 0.4f) {
    newPhase = CyclePhase.Day;
    sunIntensity = 1f;
   }
   else if (dayProgress < 0.5f) {
    newPhase = CyclePhase.TransitionToNight;
    float transitionProgress = (dayProgress - 0.4f) / 0.1f;
    sunIntensity = Mathf.Lerp(1f, 0f, transitionCurve.Evaluate(transitionProgress));
   }
   else if (dayProgress < 0.9f) {
    newPhase = CyclePhase.Night;
    sunIntensity = 0f;
   }
   else {
    newPhase = CyclePhase.TransitionToDay;
    float transitionProgress = (dayProgress - 0.9f) / 0.1f;
    sunIntensity = Mathf.Lerp(0f, 1f, transitionCurve.Evaluate(transitionProgress));
   }

   if (newPhase != currentPhase) {
    EnterPhase(newPhase, true);
   }
  }
 }

 void AdvanceToNextPhase() {
  CyclePhase nextPhase = currentPhase;
  switch (currentPhase) {
   case CyclePhase.Day: nextPhase = CyclePhase.TransitionToNight; break;
   case CyclePhase.TransitionToNight: nextPhase = CyclePhase.Night; break;
   case CyclePhase.Night: nextPhase = CyclePhase.TransitionToDay; break;
   case CyclePhase.TransitionToDay: nextPhase = CyclePhase.Day; break;
  }
  EnterPhase(nextPhase);
 }

 void EnterPhase(CyclePhase nextPhase, bool forceEvent = false) {
  CyclePhase previousPhase = currentPhase;
  currentPhase = nextPhase;

  if (TickManager.Instance?.Config != null) {
   var config = TickManager.Instance.Config;
   switch (nextPhase) {
    case CyclePhase.Day:
     totalPhaseTicksTarget = config.dayPhaseTicks;
     break;
    case CyclePhase.Night:
     totalPhaseTicksTarget = config.nightPhaseTicks;
     break;
    case CyclePhase.TransitionToNight:
    case CyclePhase.TransitionToDay:
     totalPhaseTicksTarget = config.transitionTicks;
     break;
   }
   currentPhaseTicks = 0;
  }

  if (previousPhase != currentPhase || forceEvent) {
   if (Debug.isDebugBuild) Debug.Log($"[WeatherManager] Phase Changed To: {currentPhase}");
   OnPhaseChanged?.Invoke(currentPhase);
  }
 }

 void UpdateFadeSprite() {
  if (fadeSprite != null) {
   float alpha = Mathf.Lerp(maxAlpha, minAlpha, sunIntensity);
   Color c = fadeSprite.color;
   c.a = alpha;
   fadeSprite.color = c;
  }
 }

 pub void PauseCycleAtDay() {
  Debug.Log("[WeatherManager] PauseCycleAtDay called.");
  IsPaused = true;
  currentPhase = CyclePhase.Day;
  currentPhaseTicks = 0;
  totalPhaseTicksTarget = TickManager.Instance?.Config?.dayPhaseTicks ?? 60;
  sunIntensity = 1.0f;
  UpdateFadeSprite();
  OnPhaseChanged?.Invoke(CyclePhase.Day);
 }

 pub void ResumeCycle() {
  Debug.Log("[WeatherManager] ResumeCycle called.");
  IsPaused = false;

  currentPhaseTicks = 0;
  EnterPhase(CyclePhase.Day, true);
 }

 pub void PauseCycle() {
  Debug.Log("[WeatherManager] PauseCycle called.");
  IsPaused = true;
 }

 pub int GetCurrentPhaseTicks() {
  return currentPhaseTicks;
 }

 pub int GetTotalPhaseTicksTarget() {
  return totalPhaseTicksTarget;
 }

 pub void ForcePhase(CyclePhase phase) {
  if (Application.isEditor || Debug.isDebugBuild) {
   EnterPhase(phase, true);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalBehavior.cs

﻿// REWORKED FILE: Assets/Scripts/Ecosystem/Animals/AnimalBehavior.cs
using WegoSystem;

pub class AnimalBehavior : MonoBehaviour {
 [SerializeField] Transform poopSpawnPoint;
 [SerializeField] List<GameObject> poopPrefabs;
 AnimalController controller;
 AnimalDefinition definition;
 bool isEating = false;
 bool isPooping = false;
 bool hasPooped = true;
 GameObject currentEatingTarget = null;
 int eatRemainingTicks = 0;
 int poopDelayTick = 0;
 int currentPoopCooldownTick = 0;
 pub bool IsEating => isEating;
 pub bool IsPooping => isPooping;
 pub bool CanAct => !isEating && !isPooping && !controller.IsDying;

 pub void Initialize(AnimalController controller, AnimalDefinition definition) { this.controller = controller; this.definition = definition; hasPooped = true; }
 pub void OnTickUpdate(int currentTick) { if (isEating) { eatRemainingTicks--; if (eatRemainingTicks <= 0) { FinishEating(); } } if (poopDelayTick > 0) { poopDelayTick--; } if (currentPoopCooldownTick > 0) { currentPoopCooldownTick--; } if (!hasPooped && poopDelayTick <= 0 && currentPoopCooldownTick <= 0 && CanAct) { TryPoop(); } }
 pub void StartEating(GameObject food) { if (food == null || !CanAct) return; FoodItem foodItem = food.GetComponent<FoodItem>(); if (foodItem == null || foodItem.foodType == null || !definition.diet.CanEat(foodItem.foodType)) { return; } controller.Movement.ClearMovementPlan(); isEating = true; currentEatingTarget = food; eatRemainingTicks = definition.eatDurationTicks; if (controller.CanShowThought()) { controller.ShowThought(ThoughtTrigger.Eating); } }

 void FinishEating() {
  isEating = false;

  if (currentEatingTarget == null) {
   return;
  }

  if (!currentEatingTarget.activeInHierarchy) {
   currentEatingTarget = null;
   return;
  }

  FoodItem foodItem = currentEatingTarget.GetComponent<FoodItem>();
  if (foodItem != null) {
   controller.Needs.Eat(foodItem);

   var plantCell = currentEatingTarget.GetComponent<PlantCell>();
   if (plantCell != null && plantCell.ParentPlantGrowth != null) {
    plantCell.ParentPlantGrowth.HandleBeingEaten(this.controller, plantCell);
   }

   Destroy(currentEatingTarget);

   hasPooped = false;
   poopDelayTick = Random.Range(definition.minPoopDelayTicks, definition.maxPoopDelayTicks);
  }

  currentEatingTarget = null;
 }

 void TryPoop() { if (!CanAct) return; isPooping = true; currentPoopCooldownTick = definition.poopCooldownTicks; SpawnPoop(); hasPooped = true; isPooping = false; if (controller.CanShowThought()) { controller.ShowThought(ThoughtTrigger.Pooping); } }
 void SpawnPoop() { if (poopPrefabs == null || poopPrefabs.Count == 0) return; int index = Random.Range(0, poopPrefabs.Count); GameObject prefab = poopPrefabs[index]; if (prefab == null) return; Transform spawnTransform = poopSpawnPoint != null ? poopSpawnPoint : transform; GameObject poopObj = Instantiate(prefab, spawnTransform.position, Quaternion.identity); if (GridPositionManager.Instance != null) { GridPositionManager.Instance.SnapEntityToGrid(poopObj); } }
 pub void CancelCurrentAction() { isEating = false; eatRemainingTicks = 0; currentEatingTarget = null; isPooping = false; }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalController.cs

﻿// Assets/Scripts/Ecosystem/Animals/AnimalController.cs
using TMPro;
using WegoSystem;

pub class AnimalController : MonoBehaviour, ITickUpdateable, IStatusEffectable, ITriggerTarget {
 [Header("Configuration")]
 [SerializeField] pub AnimalDefinition definition;

 [Header("UI & Visuals")]
 [SerializeField] GameObject thoughtBubblePrefab;
 [SerializeField] Transform bubbleSpawnTransform;
 [SerializeField] Animator animator;

 [Header("Debug")]
 [SerializeField] TextMeshProUGUI hpText;
 [SerializeField] TextMeshProUGUI hungerText;
 [SerializeField] KeyCode showStatsKey = KeyCode.LeftAlt;

 AnimalMovement movement;
 AnimalNeeds needs;
 AnimalBehavior behavior;
 GridEntity gridEntity;
 SpriteRenderer spriteRenderer;
 StatusEffectManager statusManager;
 StatusEffectUIManager statusEffectUI;

 bool isDying = false;
 float deathFadeTimer = 0f;
 float deathFadeDuration = 1f;
 int thoughtCooldownTick = 0;

 pub GridEntity GridEntity => gridEntity;
 pub StatusEffectManager StatusManager => statusManager;
 pub AnimalDefinition Definition => definition;
 pub AnimalMovement Movement => movement;
 pub AnimalNeeds Needs => needs;
 pub AnimalBehavior Behavior => behavior;
 pub bool IsDying => isDying;
 pub string SpeciesName => definition != null ? definition.animalName : "Uninitialized";

 void Awake() {
  CacheComponents();
  ValidateComponents();
 }

 void Start() {
  InitializeAnimal();

  if (TickManager.Instance == null) {
   Debug.LogError($"[{GetType().Name}] TickManager not found! Disabling component.", this);
   enabled = false;
   return;
  }

  TickManager.Instance.RegisterTickUpdateable(this);

  if (gridEntity != null) {
   gridEntity.OnPositionChanged += OnGridPositionChanged;
  }
 }

 void OnDestroy() {
  if (TickManager.Instance != null) {
   TickManager.Instance.UnregisterTickUpdateable(this);
  }
  if (GridDebugVisualizer.Instance != null) {
   GridDebugVisualizer.Instance.HideContinuousRadius(this);
  }
  if (gridEntity != null) {
   gridEntity.OnPositionChanged -= OnGridPositionChanged;
  }
 }

 void Update() {
  if (!enabled) return;
  if (isDying && deathFadeTimer > 0) {
   deathFadeTimer -= Time.deltaTime;
   UpdateDeathFade();
   if (deathFadeTimer <= 0) Destroy(gameObject);
   return;
  }
  bool showStats = Input.GetKey(showStatsKey);
  SetStatsTextVisibility(showStats);
  UpdateSpriteFlipping();
  movement.UpdateVisuals();
 }

 void LateUpdate() {
  transform.position = PixelGridSnapper.SnapToGrid(transform.position);
 }

 pub void OnTickUpdate(int currentTick) {
  if (!enabled || definition == null) return;
  if (!isDying && needs != null && needs.CurrentHealth <= 0) {
   StartDying();
   return;
  }
  if (isDying) return;

  needs.OnTickUpdate(currentTick);
  behavior.OnTickUpdate(currentTick);
  movement.OnTickUpdate(currentTick);
  statusManager.OnTickUpdate(currentTick);

  if (gridEntity != null && statusManager != null) {
   gridEntity.SetSpeedMultiplier(statusManager.VisualInterpolationSpeedMultiplier);
  }

  if (thoughtCooldownTick > 0) thoughtCooldownTick--;
  UpdateAnimations();
 }

 void OnGridPositionChanged(GridPosition oldPos, GridPosition newPos) {
 }

 pub string GetDisplayName() { return SpeciesName; }
 pub void Heal(float amount) { if (needs != null) needs.Heal(amount); }
 pub void ModifyHunger(float amount) { if (needs != null) needs.ModifyHunger(amount); }

 pub void TakeDamage(float amount) {
  if (isDying) return;
  float finalDamage = amount;
  if (statusManager != null) {
   finalDamage *= statusManager.DamageResistanceMultiplier;
  }
  needs.TakeDamage(finalDamage);
 }

 void CacheComponents() {
  gridEntity = GetComponent<GridEntity>();
  if (gridEntity == null) gridEntity = gameObject.AddComponent<GridEntity>();
  movement = GetComponent<AnimalMovement>();
  if (movement == null) movement = gameObject.AddComponent<AnimalMovement>();
  needs = GetComponent<AnimalNeeds>();
  if (needs == null) needs = gameObject.AddComponent<AnimalNeeds>();
  behavior = GetComponent<AnimalBehavior>();
  if (behavior == null) behavior = gameObject.AddComponent<AnimalBehavior>();
  spriteRenderer = GetComponentInChildren<SpriteRenderer>();
  statusManager = GetComponent<StatusEffectManager>();
  if (statusManager == null) statusManager = gameObject.AddComponent<StatusEffectManager>();
  statusEffectUI = GetComponentInChildren<StatusEffectUIManager>(true);
  if (statusEffectUI == null) Debug.LogWarning($"StatusEffectUIManager not found on a child of {gameObject.name}. Icons will not display.", this);
 }

 void ValidateComponents() {
  if (definition == null) { Debug.LogError($"[{gameObject.name}] Missing AnimalDefinition!", this); enabled = false; return; }
  if (definition.diet == null) { Debug.LogError($"[{gameObject.name}] AnimalDefinition missing diet!", this); enabled = false; return; }
 }

 void InitializeAnimal() {
  movement.Initialize(this, definition);
  needs.Initialize(this, definition);
  behavior.Initialize(this, definition);
  statusManager.Initialize(this);

  if (statusEffectUI != null) {
   statusEffectUI.Initialize(statusManager);
  }

  if (GridPositionManager.Instance != null) {
   GridPositionManager.Instance.SnapEntityToGrid(gameObject);
   Debug.Log($"[AnimalController] {gameObject.name} snapped to grid position {gridEntity.Position}");
  }
 }

 void StartDying() {
  if (isDying) return;
  isDying = true;

  if (TickManager.Instance?.Config != null) {
   deathFadeDuration = definition.deathFadeTicks / TickManager.Instance.Config.ticksPerRealSecond;
  }
  else {
   deathFadeDuration = definition.deathFadeTicks * 0.5f;
  }
  deathFadeTimer = deathFadeDuration;

  Debug.Log($"[AnimalController] {SpeciesName} is dying! Duration: {deathFadeDuration}s");

  if (GridDebugVisualizer.Instance != null) {
   GridDebugVisualizer.Instance.HideContinuousRadius(this);
  }
  movement.StopAllMovement();
  behavior.CancelCurrentAction();

  if (movement != null) movement.enabled = false;
  if (behavior != null) behavior.enabled = false;
  if (needs != null) needs.enabled = false;
 }

 void UpdateDeathFade() {
  if (spriteRenderer == null) return;

  float fadeProgress = 1f - (deathFadeTimer / deathFadeDuration);
  Color color = spriteRenderer.color;
  color.a = Mathf.Lerp(1f, 0f, fadeProgress);
  spriteRenderer.color = color;
 }

 pub void ShowThought(ThoughtTrigger trigger) {
  if (!CanShowThought()) return;

  thoughtCooldownTick = definition.thoughtCooldownTicks;
  if (definition.thoughtLibrary == null || thoughtBubblePrefab == null) return;

  string message = "";
  switch (trigger) {
   case ThoughtTrigger.Hungry:
    message = definition.thoughtLibrary?.hungryThoughts?.Length > 0 ? definition.thoughtLibrary.hungryThoughts[Random.Range(0, definition.thoughtLibrary.hungryThoughts.Length)] : "";
    break;
   case ThoughtTrigger.Eating:
    message = definition.thoughtLibrary?.eatingThoughts?.Length > 0 ? definition.thoughtLibrary.eatingThoughts[Random.Range(0, definition.thoughtLibrary.eatingThoughts.Length)] : "";
    break;
   case ThoughtTrigger.HealthLow:
    message = definition.thoughtLibrary?.healthLowThoughts?.Length > 0 ? definition.thoughtLibrary.healthLowThoughts[Random.Range(0, definition.thoughtLibrary.healthLowThoughts.Length)] : "";
    break;
   case ThoughtTrigger.Fleeing:
    message = definition.thoughtLibrary?.fleeingThoughts?.Length > 0 ? definition.thoughtLibrary.fleeingThoughts[Random.Range(0, definition.thoughtLibrary.fleeingThoughts.Length)] : "";
    break;
   case ThoughtTrigger.Pooping:
    message = definition.thoughtLibrary?.poopingThoughts?.Length > 0 ? definition.thoughtLibrary.poopingThoughts[Random.Range(0, definition.thoughtLibrary.poopingThoughts.Length)] : "";
    break;
  }

  if (!string.IsNullOrEmpty(message)) {
   Transform spawnT = bubbleSpawnTransform != null ? bubbleSpawnTransform : transform;
   GameObject bubble = Instantiate(thoughtBubblePrefab, spawnT.position, Quaternion.identity);
   ThoughtBubbleController controller = bubble.GetComponent<ThoughtBubbleController>();
   if (controller != null) {
    controller.Initialize(message, spawnT, 3f);
   }
  }
 }

 pub bool CanShowThought() {
  return thoughtCooldownTick <= 0 && !isDying;
 }

 void UpdateAnimations() {
  if (animator == null) return;

  bool isMoving = gridEntity != null && gridEntity.IsMoving;
  bool isEating = behavior != null && behavior.IsEating;

  animator.SetBool("isMoving", isMoving);
  animator.SetBool("isEating", isEating);
  animator.SetBool("isDying", isDying);
 }

 void UpdateSpriteFlipping() {
  if (spriteRenderer == null || movement == null) return;

  Vector2 moveDirection = movement.GetLastMoveDirection();
  if (Mathf.Abs(moveDirection.x) > 0.01f) {
   spriteRenderer.flipX = moveDirection.x < 0;
  }
 }

 void SetStatsTextVisibility(bool visible) {
  if (hpText != null) hpText.gameObject.SetActive(visible);
  if (hungerText != null) hungerText.gameObject.SetActive(visible);

  if (visible) {
   UpdateUI();
  }
 }

 pub void UpdateUI() {
  if (needs == null) return;

  if (hpText != null) {
   hpText.text = $"{Mathf.CeilToInt(needs.CurrentHealth)}/{Mathf.CeilToInt(definition.maxHealth)}";
  }
  if (hungerText != null) {
   hungerText.text = $"{Mathf.CeilToInt(needs.CurrentHunger)}/{Mathf.CeilToInt(definition.diet.maxHunger)}";
  }
 }

 pub void SetSeekingScreenCenter(Vector2 target, Vector2 minBounds, Vector2 maxBounds) {
  movement.SetSeekingScreenCenter(target, minBounds, maxBounds);
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalDefinition.cs

﻿using UnityEngine;

pub class AnimalDefinition : ScriptableObject {
 pub string animalName = "DefaultAnimal";
 pub GameObject prefab;

 [Header("Health & Stats")]
 pub float maxHealth = 10f;

 [Header("Movement")]
 pub float movementSpeed = 2f;
 pub int searchRadiusTiles = 5;
 pub int eatDistanceTiles = 1;

 [Header("Behavior")]
 pub AnimalDiet diet;
 pub int thinkingTickInterval = 3;
 pub int eatDurationTicks = 3;

 [Header("Wandering")]
 pub int wanderPauseTickChance = 30;
 pub int minWanderPauseTicks = 1;
 pub int maxWanderPauseTicks = 4;

 [Header("Needs & Damage")]
 pub int starvationDamageTickInterval = 4;
 pub float damagePerStarvationTick = 2f;
 pub Color damageFlashColor = Color.red;
 pub int damageFlashTicks = 1;
 pub int deathFadeTicks = 3;

 [Header("Digestion")]
 pub int minPoopDelayTicks = 10;
 pub int maxPoopDelayTicks = 20;
 pub int poopCooldownTicks = 2;
 pub float poopColorVariation = 0.1f;

 [Header("UI & Effects")]
 pub AnimalThoughtLibrary thoughtLibrary;
 pub int thoughtCooldownTicks = 10;
 pub List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();
 pub List<ScentDefinition> repellentScentDefinitions = new List<ScentDefinition>();

 void OnValidate() {
  maxHealth = Mathf.Max(1f, maxHealth);
  movementSpeed = Mathf.Max(0.1f, movementSpeed);

  thinkingTickInterval = Mathf.Max(1, thinkingTickInterval);
  searchRadiusTiles = Mathf.Max(1, searchRadiusTiles);
  eatDistanceTiles = Mathf.Max(1, eatDistanceTiles);
  eatDurationTicks = Mathf.Max(1, eatDurationTicks);

  minWanderPauseTicks = Mathf.Max(1, minWanderPauseTicks);
  maxWanderPauseTicks = Mathf.Max(minWanderPauseTicks, maxWanderPauseTicks);

  starvationDamageTickInterval = Mathf.Max(1, starvationDamageTickInterval);
  damagePerStarvationTick = Mathf.Max(0.1f, damagePerStarvationTick);
  deathFadeTicks = Mathf.Max(1, deathFadeTicks);
  damageFlashTicks = Mathf.Max(1, damageFlashTicks);

  minPoopDelayTicks = Mathf.Max(1, minPoopDelayTicks);
  maxPoopDelayTicks = Mathf.Max(minPoopDelayTicks, maxPoopDelayTicks);
  poopCooldownTicks = Mathf.Max(1, poopCooldownTicks);

  thoughtCooldownTicks = Mathf.Max(1, thoughtCooldownTicks);
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalLibrary.cs

﻿using UnityEngine;

pub class AnimalLibrary : ScriptableObject {
 pub List<AnimalDefinition> animals;
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalMovement.cs

﻿using UnityEngine;
using WegoSystem;
using Abracodabra.Genes; // Required for PlantCell

pub class AnimalMovement : MonoBehaviour {
 [SerializeField] bool showPathfindingDebugLine = false;

 AnimalController controller;
 AnimalDefinition definition;
 GridEntity gridEntity;
 LineRenderer pathDebugLine;

 List<GridPosition> currentPath = new List<GridPosition>();
 int currentPathIndex = 0;
 GameObject currentTargetFood = null;
 bool hasPlannedAction = false;
 int wanderPauseTicks = 0;
 int lastThinkTick = 0;

 bool isSeekingScreenCenter = false;
 Vector2 screenCenterTarget;
 Vector2 minBounds;
 Vector2 maxBounds;

 Vector2 lastMoveDirection;
 float _speedAccumulator = 0f;

 pub bool HasTarget => currentTargetFood != null || hasPlannedAction;
 pub GameObject CurrentTargetFood => currentTargetFood;

 pub void Initialize(AnimalController controller, AnimalDefinition definition) {
  this.controller = controller;
  this.definition = definition;
  this.gridEntity = controller.GridEntity;

  SetupDebugLineRenderer();
 }

 pub void OnTickUpdate(int currentTick) {
  if (!enabled || controller.IsDying || controller.Behavior.IsEating || controller.Behavior.IsPooping) {
   _speedAccumulator = 0f; // Reset speed if action is interrupted
   return;
  }

  if (wanderPauseTicks > 0) {
   wanderPauseTicks--;
   return;
  }

  _speedAccumulator += definition.movementSpeed;

  if (currentTick - lastThinkTick >= definition.thinkingTickInterval) {
   MakeMovementDecision();
   lastThinkTick = currentTick;
  }

  if (hasPlannedAction && !gridEntity.IsMoving) {
   ExecutePlannedMovement();
  }
 }

 pub void UpdateVisuals() {
  UpdatePathDebugLine();
 }

 void MakeMovementDecision() {
  if (gridEntity.IsMoving) return;

  if (isSeekingScreenCenter) {
   HandleScreenCenterSeeking();
   return;
  }

  if (controller.Needs.IsHungry) {
   PlanFoodSeeking();
  }
  else {
   PlanWandering();
  }
 }

 void PlanFoodSeeking() {
  if (GridDebugVisualizer.Instance != null && Debug.isDebugBuild) {
   GridDebugVisualizer.Instance.VisualizeAnimalSearchRadius(controller, gridEntity.Position, definition.searchRadiusTiles);
  }

  if (controller.CanShowThought()) {
   controller.ShowThought(ThoughtTrigger.Hungry);
  }

  GameObject nearestFood = FindNearestFood();
  if (nearestFood != null) {
   SetTargetFood(nearestFood);
  }
  else {
   PlanWandering();
  }
 }

 GameObject FindNearestFood() {
  if (definition.diet == null) return null;

  var entitiesInRadius = GridPositionManager.Instance.GetEntitiesInRadius(
   gridEntity.Position,
   definition.searchRadiusTiles,
   true // Use circle radius
  );

  GameObject bestFood = null;
  float bestScore = -1f;

  var foodItems = entitiesInRadius
   .Select(entity => entity.GetComponent<FoodItem>())
   .Where(foodItem => foodItem != null && foodItem.foodType != null && definition.diet.CanEat(foodItem.foodType));

  foreach (var foodItem in foodItems) {
   var pref = definition.diet.GetPreference(foodItem.foodType);
   if (pref == null) continue;

   GridEntity foodEntity = foodItem.GetComponent<GridEntity>();
   if (foodEntity == null) continue;

   float distance = gridEntity.Position.ManhattanDistance(foodEntity.Position);
   float score = pref.preferencePriority / (1f + distance);

   if (score > bestScore) {
    bestScore = score;
    bestFood = foodItem.gameObject;
   }
  }

  return bestFood;
 }

 GridPosition GetFoodGroundPosition(GameObject food) {
  GridEntity foodEntity = food.GetComponent<GridEntity>();
  if (foodEntity != null && foodEntity.enabled) {
   return foodEntity.Position;
  }

  Debug.LogWarning($"[AnimalMovement] Food item '{food.name}' did not have an enabled GridEntity. Using world position as fallback.", food);
  return GridPositionManager.Instance.WorldToGrid(food.transform.position);
 }

 void SetTargetFood(GameObject food) {
  currentTargetFood = food;
  GridPosition foodGroundPos = GetFoodGroundPosition(food);

  List<GridPosition> validEatingPositions = GetValidEatingPositions(foodGroundPos);

  GridPosition bestTarget = GridPosition.Zero;
  float shortestDistance = float.MaxValue;
  List<GridPosition> shortestPath = null;

  foreach (var pos in validEatingPositions) {
   if (!IsValidMove(pos)) continue;

   var path = GridPositionManager.Instance.GetPath(gridEntity.Position, pos, false);
   if (path != null && path.Count > 0) {
    float distance = path.Count;
    if (distance < shortestDistance) {
     shortestDistance = distance;
     bestTarget = pos;
     shortestPath = path;
    }
   }
  }

  if (shortestPath != null) {
   currentPath = shortestPath;
   currentPathIndex = 0;
   hasPlannedAction = true;
  }
  else {
   currentTargetFood = null;
  }
 }

 List<GridPosition> GetValidEatingPositions(GridPosition foodPos) {
  var positions = new List<GridPosition>();
  for (int x = -definition.eatDistanceTiles; x <= definition.eatDistanceTiles; x++) {
   for (int y = -definition.eatDistanceTiles; y <= definition.eatDistanceTiles; y++) {
    if (x == 0 && y == 0) continue; // Skip the food's own position

    int distance = Mathf.Abs(x) + Mathf.Abs(y);
    if (distance == definition.eatDistanceTiles) {
     positions.Add(foodPos + new GridPosition(x, y));
    }
   }
  }
  return positions;
 }

 void PlanWandering() {
  if (GridDebugVisualizer.Instance != null) {
   GridDebugVisualizer.Instance.HideContinuousRadius(controller);
  }
  ClearPathDebugLine();

  currentPath.Clear();
  currentTargetFood = null;

  if (Random.Range(0, 100) < definition.wanderPauseTickChance) {
   wanderPauseTicks = Random.Range(definition.minWanderPauseTicks, definition.maxWanderPauseTicks);
   hasPlannedAction = false;
   return;
  }

  GridPosition currentPos = gridEntity.Position;
  GridPosition[] directions = {
   GridPosition.Up, GridPosition.Down,
   GridPosition.Left, GridPosition.Right
  };

  for (int i = 0; i < directions.Length; i++) {
   int randomIndex = Random.Range(i, directions.Length);
   GridPosition temp = directions[i];
   directions[i] = directions[randomIndex];
   directions[randomIndex] = temp;
  }

  foreach (var dir in directions) {
   GridPosition targetPos = currentPos + dir;
   if (IsValidMove(targetPos)) {
    currentPath.Clear();
    currentPath.Add(targetPos);
    currentPathIndex = 0;
    hasPlannedAction = true;
    return;
   }
  }

  hasPlannedAction = false;
 }

 void ExecutePlannedMovement() {
  if (!hasPlannedAction || gridEntity.IsMoving) return;

  if (currentTargetFood != null) {
   if (currentTargetFood == null || !currentTargetFood.activeInHierarchy) {
    ClearMovementPlan();
    return;
   }

   GridPosition foodPos = GetFoodGroundPosition(currentTargetFood);
   int distance = gridEntity.Position.ManhattanDistance(foodPos);

   if (distance == definition.eatDistanceTiles) {
    controller.Behavior.StartEating(currentTargetFood);
    ClearMovementPlan();
    return;
   }
  }

  int tilesToMove = Mathf.FloorToInt(_speedAccumulator);
  if (tilesToMove <= 0) return;

  int tilesMovedSuccessfully = 0;
  for (int i = 0; i < tilesToMove; i++) {
   if (currentPath == null || currentPathIndex >= currentPath.Count) {
    ClearMovementPlan();
    break;
   }

   GridPosition nextPosition = currentPath[currentPathIndex];
   if (TryMoveTo(nextPosition)) {
    currentPathIndex++;
    tilesMovedSuccessfully++;
   }
   else {
    if (currentTargetFood != null) {
     SetTargetFood(currentTargetFood);
    }
    else {
     ClearMovementPlan();
    }
    break;
   }
  }

  _speedAccumulator -= tilesMovedSuccessfully;

  if (currentPath != null && currentPathIndex >= currentPath.Count) {
   ClearMovementPlan();
  }
 }

 bool TryMoveTo(GridPosition targetPos) {
  if (!IsValidMove(targetPos))
   return false;

  Vector3 currentWorld = transform.position;
  Vector3 targetWorld = GridPositionManager.Instance.GridToWorld(targetPos);
  lastMoveDirection = (targetWorld - currentWorld).normalized;

  gridEntity.SetPosition(targetPos);
  return true;
 }

 bool IsValidMove(GridPosition pos) {
  if (GridPositionManager.Instance == null) return false;

  if (!GridPositionManager.Instance.IsPositionValid(pos)) return false;

  var entitiesAtPos = GridPositionManager.Instance.GetEntitiesAt(pos);
  foreach (var entity in entitiesAtPos) {
   if (entity.GetComponent<PlantCell>() != null) {
    return false;
   }
  }

  if (GridPositionManager.Instance.IsPositionOccupied(pos)) {
   if (currentTargetFood != null) {
    GridPosition foodPos = GetFoodGroundPosition(currentTargetFood);
    if (pos == foodPos) return false;
   }
   return false;
  }

  return true;
 }

 void HandleScreenCenterSeeking() {
  Vector2 currentPos = transform.position;
  bool centerWithinBounds = currentPos.x >= minBounds.x && currentPos.x <= maxBounds.x &&
        currentPos.y >= minBounds.y && currentPos.y <= maxBounds.y;

  if (centerWithinBounds) {
   isSeekingScreenCenter = false;
   hasPlannedAction = false;
  }
  else {
   GridPosition targetGridPos = GridPositionManager.Instance.WorldToGrid(screenCenterTarget);
   currentPath = GridPositionManager.Instance.GetPath(gridEntity.Position, targetGridPos, false);
   currentPathIndex = 0;
   hasPlannedAction = currentPath.Count > 0;
  }
 }

 pub void SetSeekingScreenCenter(Vector2 target, Vector2 minBounds, Vector2 maxBounds) {
  isSeekingScreenCenter = true;
  screenCenterTarget = target;
  this.minBounds = minBounds;
  this.maxBounds = maxBounds;
 }

 pub void StopAllMovement() {
  ClearMovementPlan();
  wanderPauseTicks = 0;
  isSeekingScreenCenter = false;
 }

 pub void ClearMovementPlan() {
  currentPath.Clear();
  currentPathIndex = 0;
  currentTargetFood = null;
  hasPlannedAction = false;
  _speedAccumulator = 0f;
  ClearPathDebugLine();

  if (GridDebugVisualizer.Instance != null) {
   GridDebugVisualizer.Instance.HideContinuousRadius(controller);
  }
 }

 pub Vector2 GetLastMoveDirection() {
  return lastMoveDirection;
 }

 void SetupDebugLineRenderer() {
  if (!showPathfindingDebugLine) return;

  GameObject lineObj = new GameObject("PathDebugLine");
  lineObj.transform.SetParent(transform);
  pathDebugLine = lineObj.AddComponent<LineRenderer>();
  pathDebugLine.startWidth = 0.05f;
  pathDebugLine.endWidth = 0.05f;
  pathDebugLine.material = new Material(Shader.Find("Sprites/Default"));
  pathDebugLine.startColor = Color.yellow;
  pathDebugLine.endColor = Color.red;
  pathDebugLine.sortingOrder = 100;
 }

 void UpdatePathDebugLine() {
  if (!showPathfindingDebugLine || pathDebugLine == null || currentPath == null || currentPath.Count == 0) {
   if (pathDebugLine != null) pathDebugLine.positionCount = 0;
   return;
  }

  List<Vector3> positions = new List<Vector3>();

  Vector3 groundPosition = GridPositionManager.Instance.GridToWorld(gridEntity.Position);
  positions.Add(groundPosition);

  for (int i = currentPathIndex; i < currentPath.Count; i++) {
   Vector3 worldPos = GridPositionManager.Instance.GridToWorld(currentPath[i]);
   positions.Add(worldPos);
  }

  pathDebugLine.positionCount = positions.Count;
  pathDebugLine.SetPositions(positions.ToArray());
 }

 void ClearPathDebugLine() {
  if (pathDebugLine != null) {
   pathDebugLine.positionCount = 0;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalNeeds.cs

﻿using UnityEngine;
using WegoSystem;
using Abracodabra.Genes.Components;

pub class AnimalNeeds : MonoBehaviour {
 AnimalController controller;
 AnimalDefinition definition;
 AnimalDiet diet;
 SpriteRenderer spriteRenderer;

 float currentHealth;
 float currentHunger;

 int hungerTick = 0;
 int starvationTick = 0;

 float flashRemainingTime = 0f;
 float flashDurationSeconds = 0.2f;
 bool isFlashing = false;
 Color originalColor;

 pub float CurrentHealth => currentHealth;
 pub float CurrentHunger => currentHunger;
 pub bool IsHungry => currentHunger >= diet.hungerThreshold;
 pub bool IsStarving => currentHunger >= diet.maxHunger;

 pub void Initialize(AnimalController controller, AnimalDefinition definition) {
  this.controller = controller;
  this.definition = definition;
  this.diet = definition.diet;

  spriteRenderer = GetComponentInChildren<SpriteRenderer>();
  if (spriteRenderer != null) {
   originalColor = spriteRenderer.color;
  }

  if (TickManager.Instance?.Config != null) {
   flashDurationSeconds = definition.damageFlashTicks / TickManager.Instance.Config.ticksPerRealSecond;
  }

  currentHealth = definition.maxHealth;
  currentHunger = 0f;
 }

 pub void OnTickUpdate(int currentTick) {
  UpdateHunger();
  UpdateStarvation();
 }

 void UpdateHunger() {
  if (TickManager.Instance?.Config == null || diet == null) return;

  hungerTick++;
  if (hungerTick >= TickManager.Instance.Config.animalHungerTickInterval) {
   hungerTick = 0;

   currentHunger += diet.hungerIncreaseRate;
   currentHunger = Mathf.Min(currentHunger, diet.maxHunger);

   controller.UpdateUI();
  }
 }

 void UpdateStarvation() {
  if (!IsStarving) {
   starvationTick = 0;
   return;
  }

  starvationTick++;
  if (starvationTick >= definition.starvationDamageTickInterval) {
   starvationTick = 0;
   ApplyStarvationDamage();
  }
 }

 void Update() {
  if (!isFlashing || spriteRenderer == null) return;

  flashRemainingTime -= Time.deltaTime;

  if (flashRemainingTime <= 0) {
   spriteRenderer.color = originalColor;
   isFlashing = false;
  }
  else {
   float t = (flashRemainingTime / flashDurationSeconds);
   spriteRenderer.color = Color.Lerp(originalColor, definition.damageFlashColor, t);
  }
 }

 pub void TakeDamage(float amount) {
  currentHealth -= amount;
  currentHealth = Mathf.Clamp(currentHealth, 0f, definition.maxHealth);

  StartDamageFlash();
  controller.UpdateUI();

  if (currentHealth <= definition.maxHealth * 0.3f && controller.CanShowThought()) {
   controller.ShowThought(ThoughtTrigger.HealthLow);
  }
 }

 void ApplyStarvationDamage() {
  currentHealth -= definition.damagePerStarvationTick;
  currentHealth = Mathf.Clamp(currentHealth, 0f, definition.maxHealth);

  StartDamageFlash();
  controller.UpdateUI();

  Debug.Log($"[AnimalNeeds] {controller.SpeciesName} taking starvation damage. Health: {currentHealth}");
 }

 pub void Eat(FoodItem foodItem) {
  if (foodItem == null || foodItem.foodType == null || diet == null) return;

  float satiationGain = 0f;
  string foodName = foodItem.foodType.foodName; // Get a default name

  Fruit fruitComponent = foodItem.GetComponent<Fruit>();
  if (fruitComponent != null && fruitComponent.RepresentingItemDefinition != null) {
   var itemDef = fruitComponent.RepresentingItemDefinition;
   foodName = itemDef.itemName; // Get the more specific item name

   satiationGain = itemDef.baseNutrition; // Start with the base value
   if (fruitComponent.DynamicProperties.TryGetValue("nutrition_multiplier", out float multiplier)) {
    satiationGain *= multiplier; // Apply the gene-calculated multiplier
   }
  }
  else {
   satiationGain = diet.GetSatiationValue(foodItem.foodType);
  }

  currentHunger -= satiationGain;
  currentHunger = Mathf.Max(0f, currentHunger);

  controller.UpdateUI();

  Debug.Log($"[AnimalNeeds] {controller.SpeciesName} ate {foodName} for {satiationGain:F1} satiation. Hunger: {currentHunger:F1}/{diet.maxHunger}");
 }

 pub void Heal(float amount) {
  currentHealth += amount;
  currentHealth = Mathf.Clamp(currentHealth, 0f, definition.maxHealth);
  controller.UpdateUI();
 }

 pub void ModifyHunger(float amount) {
  currentHunger += amount;
  currentHunger = Mathf.Clamp(currentHunger, 0f, diet.maxHunger);
  controller.UpdateUI();
 }

 void StartDamageFlash() {
  if (spriteRenderer == null) return;

  isFlashing = true;
  flashRemainingTime = flashDurationSeconds;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalSpawnData.cs

﻿using UnityEngine;

pub class AnimalSpawnData {
 pub AnimalDefinition animalDefinition;
 [Range(0f, 1f)]
 [Tooltip("Spawn rate multiplier (0 = no spawn; lower values = less frequent spawns).")]
 pub float spawnRateMultiplier = 1f;
 [Tooltip("Maximum number of this animal type allowed to be spawned (0 = no limit).")]
 pub int maximumSpawned = 0;

 pub float spawnTimer = 0f;
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Animals\AnimalThoughtLibrary.cs

﻿using UnityEngine;

pub class AnimalThoughtLibrary : ScriptableObject {
 [Header("Thought Messages")]
 pub string[] hungryThoughts = new string[] {
  "I'm hungry!",
  "Need food...",
  "Where's the food?"
 };

 pub string[] eatingThoughts = new string[] {
  "Yum!",
  "Delicious!",
  "Nom nom nom"
 };

 pub string[] healthLowThoughts = new string[] {
  "I don't feel good...",
  "Help me!",
  "Ouch!"
 };

 pub string[] fleeingThoughts = new string[] {
  "Run away!",
  "Scary!",
  "Help!"
 };

 pub string[] poopingThoughts = new string[] {
  "Nature calls!",
  "Gotta go!",
  "..."
 };
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Effects\FireflyController.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes;
using UnityEngine.Rendering.Universal;
using WegoSystem;

pub class FireflyController : MonoBehaviour, ITickUpdateable {
 [SerializeField] FireflyDefinition definition;

 [SerializeField] Light2D glowLight;
 [SerializeField] Light2D groundLight;
 [SerializeField] SpriteRenderer spriteRenderer;
 [SerializeField] TrailRenderer trailRenderer;
 [SerializeField] ParticleSystem glowParticles;

 [SerializeField] float groundLightRadiusMultiplier = 2.5f;

 GridEntity gridEntity;

 int lifetimeTicks;
 int lastMovementTick = 0;

 float currentLifetimeSeconds = 0f;
 float maxLifetimeSeconds = 0f;

 Vector3 currentTileCenter;
 Vector3 localTargetPosition;
 float currentLocalSpeed;

 float baseGlowIntensity;
 float currentGlowIntensity;
 float baseGroundLightIntensity;
 float baseGroundLightOuterRadius;
 float glowFlickerTime;
 Color originalColor;

 pub bool IsAlive { get; set; } = true;
 pub Transform AttractionTarget { get; set; }

 void Awake() {
  gridEntity = GetComponent<GridEntity>();
  if (gridEntity == null) {
   Debug.LogError($"[FireflyController] Firefly prefab is missing the required GridEntity component!", this);
   enabled = false;
   return;
  }

  if (glowLight != null) {
   baseGlowIntensity = glowLight.intensity;
   currentGlowIntensity = glowLight.intensity;
  }

  if (spriteRenderer != null) {
   originalColor = spriteRenderer.color;
  }

  if (groundLight != null) {
   baseGroundLightIntensity = groundLight.intensity;
   baseGroundLightOuterRadius = groundLight.pointLightOuterRadius;
  }
 }

 void Start() {
  if (TickManager.Instance != null) {
   TickManager.Instance.RegisterTickUpdateable(this);
  }
 }

 void OnDestroy() {
  var tickManager = TickManager.Instance;
  if (tickManager != null) {
   TickManager.Instance.UnregisterTickUpdateable(this);
  }

  if (GridDebugVisualizer.Instance != null) {
   GridDebugVisualizer.Instance.HideContinuousRadius(this);
  }
 }

 pub void Initialize() {
  if (FireflyManager.Instance?.defaultFireflyDefinition == null || gridEntity == null) {
   Debug.LogError("[FireflyController] Initialization failed: Missing definition or GridEntity!", this);
   enabled = false;
   return;
  }

  definition = FireflyManager.Instance.defaultFireflyDefinition;

  if (GridPositionManager.Instance != null) {
   GridPositionManager.Instance.SnapEntityToGrid(gameObject);
   currentTileCenter = GridPositionManager.Instance.GridToWorld(gridEntity.Position);
  }

  lifetimeTicks = Random.Range(definition.minLifetimeTicks, definition.maxLifetimeTicks + 1);
  currentLocalSpeed = Random.Range(definition.minLocalSpeed, definition.maxLocalSpeed);

  SetRandomLocalTarget();

  if (glowParticles != null) {
   glowParticles.Play();
  }

  if (TickManager.Instance?.Config != null) {
   maxLifetimeSeconds = lifetimeTicks / TickManager.Instance.Config.ticksPerRealSecond;
  }
  else {
   maxLifetimeSeconds = lifetimeTicks * 0.5f;
  }
 }

 pub void OnTickUpdate(int currentTick) {
  if (!IsAlive) return;

  currentLifetimeSeconds += Time.deltaTime;
  if (currentLifetimeSeconds >= maxLifetimeSeconds) {
   Die();
   return;
  }

  if (currentTick - lastMovementTick >= definition.movementTickInterval) {
   UpdateMovement();
   lastMovementTick = currentTick;
  }

  UpdatePhotosynthesisVisualization();
 }

 void Update() {
  if (!IsAlive) return;

  UpdateLocalMovement();
  UpdateGlowEffect();
  UpdateGroundLight();
 }

 void UpdateMovement() {
  FindAttractionTarget();

  if (AttractionTarget != null) {
   Vector3 attractionDirection = (AttractionTarget.position - currentTileCenter).normalized;
   localTargetPosition = currentTileCenter + attractionDirection * Random.Range(0.1f, 0.3f);
  }
  else {
   SetRandomLocalTarget();
  }
 }

 void UpdatePhotosynthesisVisualization() {
  if (GridDebugVisualizer.Instance != null && FireflyManager.Instance != null && gridEntity != null) {
   int photosynthesisRadius = Mathf.RoundToInt(FireflyManager.Instance.photosynthesisRadius);
   if (photosynthesisRadius > 0) {
    GridDebugVisualizer.Instance.VisualizeFireflyPhotosynthesisRadius(this, gridEntity.Position, photosynthesisRadius);
   }
  }
 }

 void FindAttractionTarget() {
  if (definition == null || gridEntity == null) return;

  float bestScore = 0f;
  Transform bestTarget = null;

  GridPosition currentPos = gridEntity.Position;
  int searchRadius = definition.tileSearchRadius;

  for (int x = currentPos.x - searchRadius; x <= currentPos.x + searchRadius; x++) {
   for (int y = currentPos.y - searchRadius; y <= currentPos.y + searchRadius; y++) {
    GridPosition checkPos = new GridPosition(x, y);
    if (!GridPositionManager.Instance.IsPositionValid(checkPos)) continue;

    float distance = Vector2.Distance(currentPos.ToVector2Int(), checkPos.ToVector2Int());
    if (distance > searchRadius) continue;

    var entitiesAtPosition = GridPositionManager.Instance.GetEntitiesAt(checkPos);
    foreach (var entity in entitiesAtPosition) {
     var scentSources = entity.GetComponentsInChildren<ScentSource>();
     foreach (var source in scentSources) {
      if (definition.attractiveScentDefinitions.Contains(source.Definition)) {
       float score = definition.scentAttractionWeight / (distance + 1f);
       if (score > bestScore) {
        bestScore = score;
        bestTarget = entity.transform;
       }
      }
     }

     var plantGrowth = entity.GetComponent<PlantGrowth>();
     if (plantGrowth != null && plantGrowth.CurrentState == PlantState.Growing) {
      float score = definition.growingPlantAttraction / (distance + 1f);
      if (score > bestScore) {
       bestScore = score;
       bestTarget = entity.transform;
      }
     }
    }
   }
  }

  AttractionTarget = bestTarget;
 }

 void SetRandomLocalTarget() {
  if (definition == null) return;

  Vector2 randomOffset = new Vector2(
   Random.Range(-definition.flightBounds.x * 0.5f, definition.flightBounds.x * 0.5f),
   Random.Range(definition.flightHeightOffset, definition.flightHeightOffset + definition.flightBounds.y)
  );

  localTargetPosition = currentTileCenter + (Vector3)randomOffset;
 }

 void UpdateLocalMovement() {
  if (definition == null) return;

  transform.position = Vector3.MoveTowards(transform.position, localTargetPosition, currentLocalSpeed * Time.deltaTime);

  Vector3 direction = (localTargetPosition - transform.position).normalized;
  if (direction.magnitude > 0.1f) {
   float targetAngle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
   float currentAngle = transform.eulerAngles.z;
   float newAngle = Mathf.MoveTowardsAngle(currentAngle, targetAngle, definition.localMovementTurnSpeed * Time.deltaTime);
   transform.rotation = Quaternion.AngleAxis(newAngle, Vector3.forward);
  }
 }

 void UpdateGlowEffect() {
  if (glowParticles == null) return;

  glowFlickerTime += Time.deltaTime * definition.glowFlickerSpeed;
  float flicker = Mathf.Sin(glowFlickerTime) * definition.glowFlickerAmount;
  currentGlowIntensity = Mathf.Clamp01(baseGlowIntensity + flicker);

  var emission = glowParticles.emission;
  emission.rateOverTime = currentGlowIntensity * 10f;
 }

 void UpdateGroundLight() {
  if (groundLight == null) return;

  groundLight.transform.position = currentTileCenter;

  float height = Mathf.Max(0, transform.position.y - currentTileCenter.y);
  float maxFlightHeight = definition.flightBounds.y + definition.flightHeightOffset;
  float heightT = (maxFlightHeight > 0) ? Mathf.Clamp01(height / maxFlightHeight) : 0f;

  float heightBasedIntensity = Mathf.Lerp(baseGroundLightIntensity, baseGroundLightIntensity * 0.5f, heightT); // Dims to 50% at max height
  float heightBasedRadiusMultiplier = Mathf.Lerp(1f, groundLightRadiusMultiplier, heightT); // Scales from 1x to the max multiplier
  float finalRadius = baseGroundLightOuterRadius * heightBasedRadiusMultiplier;

  glowFlickerTime += Time.deltaTime * definition.glowFlickerSpeed;
  float flicker = Mathf.Sin(glowFlickerTime) * definition.glowFlickerAmount;

  groundLight.intensity = Mathf.Clamp(heightBasedIntensity + flicker, definition.groundLightMinIntensity, 1f);
  groundLight.pointLightOuterRadius = finalRadius;
 }

 void Die() {
  IsAlive = false;

  if (GridDebugVisualizer.Instance != null) {
   GridDebugVisualizer.Instance.HideContinuousRadius(this);
  }

  if (FireflyManager.Instance != null) {
   FireflyManager.Instance.ReportFireflyDespawned(this);
  }

  if (TickManager.Instance != null) {
   TickManager.Instance.UnregisterTickUpdateable(this);
  }

  if (glowParticles != null) {
   glowParticles.Stop();
   Destroy(gameObject, glowParticles.main.duration);
  }
  else {
   Destroy(gameObject);
  }
 }

 void OnDrawGizmosSelected() {
  if (definition == null) return;

  float tileSize = 1f;
  if (Application.isPlaying && GridPositionManager.Instance?.GetTilemapGrid() != null) {
   tileSize = GridPositionManager.Instance.GetTilemapGrid().cellSize.x;
  }

  Gizmos.color = new Color(1f, 1f, 0f, 0.3f);
  Gizmos.DrawWireSphere(transform.position, definition.tileSearchRadius * tileSize);

  if (Application.isPlaying && FireflyManager.Instance != null) {
   Gizmos.color = new Color(0f, 1f, 0.5f, 0.3f);
   Gizmos.DrawWireSphere(transform.position, FireflyManager.Instance.photosynthesisRadius * tileSize);
  }

  if (Application.isPlaying) {
   Vector3 flightBoxCenter = currentTileCenter + new Vector3(0, definition.flightHeightOffset + definition.flightBounds.y / 2f, 0);
   Gizmos.color = new Color(0f, 1f, 1f, 0.5f);
   Gizmos.DrawWireCube(flightBoxCenter, new Vector3(definition.flightBounds.x, definition.flightBounds.y, 0.1f));

   Gizmos.color = Color.yellow;
   Gizmos.DrawLine(transform.position, localTargetPosition);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Effects\FireflyDefinition.cs

﻿using System.Collections.Generic;

pub class FireflyDefinition : ScriptableObject {
 [Header("Behavior")]
 pub int movementTickInterval = 5;
 pub int tileSearchRadius = 3;

 [Header("Local Movement")]
 pub Vector2 flightBounds = new Vector2(0.4f, 0.4f);
 pub float flightHeightOffset = 0.2f;
 pub float localMovementTurnSpeed = 90f;
 pub float minLocalSpeed = 0.5f;
 pub float maxLocalSpeed = 1.0f;

 [Header("Lifetime & Visuals")]
 pub int minLifetimeTicks = 40;
 pub int maxLifetimeTicks = 90;
 pub float fadeInSeconds = 1.5f;
 pub float fadeOutSeconds = 2.5f;
 pub float glowFlickerAmount = 0.2f;
 pub float glowFlickerSpeed = 5.0f;
 [Range(0f, 1f)] pub float groundLightMinIntensity = 0.1f;

 [Header("Attractions")]
 pub List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();
 pub float scentAttractionWeight = 2.0f;
 pub float growingPlantAttraction = 1.0f;

 // Note: useSpawnEffect and spawnEffectTicks are now obsolete and replaced by fadeInSeconds
 [HideInInspector] pub bool useSpawnEffect = true;
 [HideInInspector] pub int spawnEffectTicks = 3;
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Effects\FireflyManager.cs

﻿// FILE: Assets/Scripts/Ecosystem/Effects/FireflyManager.cs
using WegoSystem;

pub class FireflyManager : MonoBehaviour, ITickUpdateable {
 pub stat FireflyManager Instance { get; set; }

 [Header("System References")]
 [SerializeField] WeatherManager weatherManager;
 [SerializeField] GameObject fireflyPrefab;
 [SerializeField] pub FireflyDefinition defaultFireflyDefinition;
 [SerializeField] Transform fireflyParent;

 [Header("Spawning Logic")]
 [SerializeField] int maxFireflies = 50;
 [SerializeField] int spawnIntervalTicks = 3;
 [SerializeField] [Range(0f, 1f)] float nightThreshold = 0.25f;

 [Header("Spawning Area")]
 [Tooltip("If true, the spawn area will be centered on the middle of the grid. If false, it will use the Custom Spawn Center.")]
 [SerializeField] bool useMapCenterAsSpawnArea = true;
 [Tooltip("A custom world-space coordinate for the spawn area center. Only used if 'Use Map Center' is false.")]
 [SerializeField] Vector2 customSpawnCenter = Vector2.zero;
 [SerializeField] Vector2 spawnAreaSize = new Vector2(20f, 10f);

 [Header("Gameplay Effects")]
 pub float photosynthesisRadius = 3f;
 pub float photosynthesisIntensityPerFly = 0.05f;
 pub float maxPhotosynthesisBonus = 0.5f;

 [Header("Debug")]
 [SerializeField] bool showAttractionLinesRuntime = false;
 [SerializeField] Color attractionLineColorRuntime = Color.magenta;
 [SerializeField] GameObject lineVisualizerPrefab;
 [SerializeField] Transform lineContainer;

 List<FireflyController> activeFireflies = new List<FireflyController>();
 Dictionary<FireflyController, LineRenderer> activeLineVisualizers = new Dictionary<FireflyController, LineRenderer>();
 int spawnTickCounter = 0;
 bool isNight = false;

 pub bool ShowAttractionLinesRuntime => showAttractionLinesRuntime;

 void Awake() {
  if (Instance != null && Instance != this) {
   Destroy(gameObject);
   return;
  }
  Instance = this;

  ValidateReferences();
 }

 pub void Initialize() {
  if (TickManager.Instance != null) {
   TickManager.Instance.RegisterTickUpdateable(this);
  }
 }

 void OnDestroy() {
  if (Instance == this) Instance = null;

  var tickManager = TickManager.Instance;
  if (tickManager != null) {
   tickManager.UnregisterTickUpdateable(this);
  }

  CleanupVisualizers();
 }

 void ValidateReferences() {
  if (weatherManager == null) {
   Debug.LogError($"[{nameof(FireflyManager)}] WeatherManager not assigned!", this);
   enabled = false;
   return;
  }

  if (fireflyPrefab == null) {
   Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab not assigned!", this);
   enabled = false;
   return;
  }

  if (defaultFireflyDefinition == null) {
   Debug.LogError($"[{nameof(FireflyManager)}] Default Firefly Definition not assigned!", this);
   enabled = false;
   return;
  }

  FireflyController controller = fireflyPrefab.GetComponent<FireflyController>();
  if (controller == null) {
   Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab missing FireflyController script!", this);
   enabled = false;
   return;
  }

  if (fireflyParent == null) {
   fireflyParent = transform;
  }
 }

 pub void OnTickUpdate(int currentTick) {
  isNight = weatherManager.sunIntensity <= nightThreshold;

  if (isNight) {
   spawnTickCounter++;
   if (spawnTickCounter >= spawnIntervalTicks) {
    TrySpawnFirefly();
    spawnTickCounter = 0;
   }
  }
  else {
   spawnTickCounter = 0;
  }

  activeFireflies.RemoveAll(f => f == null || !f.IsAlive);
 }

 void Update() {
  UpdateRuntimeLineVisualizers();
 }

 Vector2 GetEffectiveSpawnCenter() {
  if (useMapCenterAsSpawnArea && GridPositionManager.Instance != null) {
   return GridPositionManager.Instance.GetMapCenterWorld();
  }
  return customSpawnCenter;
 }

 void TrySpawnFirefly() {
  if (activeFireflies.Count >= maxFireflies) return;

  GridPosition spawnGridPos = FindValidSpawnPosition();
  if (spawnGridPos == GridPosition.Zero) return;

  Vector3 spawnWorldPos = GridPositionManager.Instance.GridToWorld(spawnGridPos);

  GameObject fireflyGO = Instantiate(fireflyPrefab, spawnWorldPos, Quaternion.identity, fireflyParent);
  FireflyController controller = fireflyGO.GetComponent<FireflyController>();

  if (controller != null) {
   controller.Initialize();
   activeFireflies.Add(controller);
  }
 }

 GridPosition FindValidSpawnPosition() {
  Vector2 center = GetEffectiveSpawnCenter();
  Vector2 minBounds = center - spawnAreaSize * 0.5f;
  Vector2 maxBounds = center + spawnAreaSize * 0.5f;

  GridPosition minGrid = GridPositionManager.Instance.WorldToGrid(minBounds);
  GridPosition maxGrid = GridPositionManager.Instance.WorldToGrid(maxBounds);

  for (int i = 0; i < 10; i++) {
   int x = Random.Range(minGrid.x, maxGrid.x + 1);
   int y = Random.Range(minGrid.y, maxGrid.y + 1);
   GridPosition pos = new GridPosition(x, y);

   if (GridPositionManager.Instance.IsPositionValid(pos) &&
    !GridPositionManager.Instance.IsPositionOccupied(pos)) {
    return pos;
   }
  }

  return GridPosition.Zero;
 }

 pub void ReportFireflyDespawned(FireflyController firefly) {
  activeFireflies.Remove(firefly);

  if (activeLineVisualizers.TryGetValue(firefly, out LineRenderer line)) {
   if (line != null) Destroy(line.gameObject);
   activeLineVisualizers.Remove(firefly);
  }
 }

 pub int GetNearbyFireflyCount(Vector3 position, float radius) {
  int count = 0;
  float radiusSq = radius * radius;

  for (int i = activeFireflies.Count - 1; i >= 0; i--) {
   if (activeFireflies[i] == null) {
    activeFireflies.RemoveAt(i);
    continue;
   }

   if ((activeFireflies[i].transform.position - position).sqrMagnitude <= radiusSq) {
    count++;
   }
  }

  return count;
 }

 void UpdateRuntimeLineVisualizers() {
  if (!Application.isPlaying || !showAttractionLinesRuntime) {
   CleanupVisualizers();
   return;
  }

  var toRemove = new List<FireflyController>();
  foreach (var kvp in activeLineVisualizers) {
   if (kvp.Key == null || kvp.Value == null) {
    toRemove.Add(kvp.Key);
    continue;
   }

   Transform target = kvp.Key.AttractionTarget;
   if (target != null) {
    kvp.Value.enabled = true;
    kvp.Value.SetPosition(0, kvp.Key.transform.position);
    kvp.Value.SetPosition(1, target.position);
    kvp.Value.startColor = attractionLineColorRuntime;
    kvp.Value.endColor = attractionLineColorRuntime;
   }
   else {
    kvp.Value.enabled = false;
   }
  }

  foreach (var firefly in toRemove) {
   if (activeLineVisualizers.TryGetValue(firefly, out var line) && line != null) {
    Destroy(line.gameObject);
   }
   activeLineVisualizers.Remove(firefly);
  }

  if (lineVisualizerPrefab != null && lineContainer != null) {
   foreach (var firefly in activeFireflies) {
    if (firefly == null || activeLineVisualizers.ContainsKey(firefly)) continue;

    if (firefly.AttractionTarget != null) {
     GameObject lineGO = Instantiate(lineVisualizerPrefab, lineContainer);
     LineRenderer newLine = lineGO.GetComponent<LineRenderer>();

     if (newLine != null) {
      newLine.SetPosition(0, firefly.transform.position);
      newLine.SetPosition(1, firefly.AttractionTarget.position);
      newLine.startColor = attractionLineColorRuntime;
      newLine.endColor = attractionLineColorRuntime;
      newLine.enabled = true;
      activeLineVisualizers.Add(firefly, newLine);
     }
     else {
      Debug.LogError($"Line Visualizer Prefab missing LineRenderer!", lineVisualizerPrefab);
      Destroy(lineGO);
     }
    }
   }
  }
 }

 void CleanupVisualizers() {
  foreach (var kvp in activeLineVisualizers) {
   if (kvp.Value != null) {
    Destroy(kvp.Value.gameObject);
   }
  }
  activeLineVisualizers.Clear();
 }

 void OnDrawGizmosSelected() {
  Vector2 center = GetEffectiveSpawnCenter();
  Gizmos.color = new Color(1f, 1f, 0f, 0.3f);
  Gizmos.DrawWireCube(center, spawnAreaSize);

  if (Application.isPlaying) {
   Gizmos.color = new Color(0f, 1f, 0.5f, 0.2f);
   foreach (var firefly in activeFireflies) {
    if (firefly != null) {
     Gizmos.DrawWireSphere(firefly.transform.position, photosynthesisRadius);
    }
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Environment\PoopController.cs

﻿using UnityEngine;
using WegoSystem;

pub class PoopController : MonoBehaviour, ITickUpdateable {
 [SerializeField] int lifetimeTicks = 20;

 [SerializeField] float fadeRealTimeDuration = 1f;

 GridEntity gridEntity;
 SpriteRenderer spriteRenderer;
 int currentLifetimeTicks;
 bool isFading = false;
 float fadeTimer = 0f;
 Color originalColor;

 void Awake() {
  gridEntity = GetComponent<GridEntity>();
  if (gridEntity == null) {
   gridEntity = gameObject.AddComponent<GridEntity>();
  }
  gridEntity.isTileOccupant = false;

  spriteRenderer = GetComponent<SpriteRenderer>();
  if (spriteRenderer != null) {
   originalColor = spriteRenderer.color;
  }

  if (GridPositionManager.Instance != null) {
   GridPositionManager.Instance.SnapEntityToGrid(gameObject);
  }
  else {
   Debug.LogError($"[{gameObject.name}] GridPositionManager not found on Awake! Poop will not be registered correctly.");
  }
 }

 void Start() {
  currentLifetimeTicks = lifetimeTicks;

  if (TickManager.Instance != null) {
   TickManager.Instance.RegisterTickUpdateable(this);
  }

 }

 void OnDestroy() {
  if (TickManager.Instance != null) {
   TickManager.Instance.UnregisterTickUpdateable(this);
  }
 }

 void Update() {
  if (isFading && fadeTimer > 0) {
   fadeTimer -= Time.deltaTime;
   UpdateFade();

   if (fadeTimer <= 0) {
    Destroy(gameObject);
   }
  }
 }

 pub void OnTickUpdate(int currentTick) {
  if (isFading) return;

  currentLifetimeTicks--;

  if (currentLifetimeTicks <= 0) {
   StartFading();
  }
 }

 void StartFading() {
  isFading = true;
  fadeTimer = fadeRealTimeDuration;

  if (TickManager.Instance != null) {
   TickManager.Instance.UnregisterTickUpdateable(this);
  }
 }

 void UpdateFade() {
  if (spriteRenderer == null) return;

  float fadeProgress = 1f - (fadeTimer / fadeRealTimeDuration);
  Color color = originalColor;
  color.a = Mathf.Lerp(1f, 0f, fadeProgress);
  spriteRenderer.color = color;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Environment\ScentDefinition.cs

﻿using UnityEngine;

pub class ScentDefinition : ScriptableObject {
 [Header("Identification")]
 [Tooltip("Unique identifier used internally and potentially for node effects.")]
 pub string scentID = "default_scent"; // Still useful for debugging/lookup
 [Tooltip("Display name for UI or debugging.")]
 pub string displayName = "Default Scent";

 [Tooltip("Base radius for this scent type if not modified by nodes.")]
 pub float baseRadius = 1f;
 [Tooltip("Base strength for this scent type if not modified by nodes.")]
 pub float baseStrength = 1f;

 [Header("Visuals (Optional)")]
 [Tooltip("Particle effect prefab to instantiate when this scent is active.")]
 pub GameObject particleEffectPrefab;
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Environment\ScentLibrary.cs

﻿using UnityEngine;

pub class ScentLibrary : ScriptableObject {
 pub List<ScentDefinition> scents;

 pub ScentDefinition GetScentByID(string id) {
  if (string.IsNullOrEmpty(id) || scents == null) return null;
  return scents.FirstOrDefault(s => s != null && s.scentID == id);
 }

 pub List<ScentDefinition> GetAllDefinitions() {
  return scents?.Where(s => s != null).ToList() ?? new List<ScentDefinition>();
 }

}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Environment\ScentSource.cs

﻿using Abracodabra.Genes;
using WegoSystem;

pub class ScentSource : MonoBehaviour {
 [SerializeField] ScentDefinition definition;
 [SerializeField] float radiusModifier = 0f;
 [SerializeField] float strengthModifier = 0f;

 pub ScentDefinition Definition => definition;
 pub float EffectiveRadius => definition != null ? Mathf.Max(0f, definition.baseRadius + radiusModifier) : 0f;
 pub float EffectiveStrength => definition != null ? Mathf.Max(0f, definition.baseStrength + strengthModifier) : 0f;

 GridEntity gridEntity;

 void Awake() {
  gridEntity = GetComponent<GridEntity>();
  if (gridEntity == null) {
   gridEntity = gameObject.AddComponent<GridEntity>();
  }
 }

 void Start() {
  if (GetComponentInParent<PlantGrowth>() == null) {
   if (GridPositionManager.Instance != null) {
    GridPositionManager.Instance.SnapEntityToGrid(gameObject);
   }
  }
 }

 void Update() {
  UpdateRadiusVisualization();
 }

 void UpdateRadiusVisualization() {
  if (GridDebugVisualizer.Instance != null && definition != null && gridEntity != null) {
   float effectiveRadius = EffectiveRadius;
   if (effectiveRadius > 0.01f) {
    int radiusTiles = Mathf.RoundToInt(effectiveRadius);
    GridDebugVisualizer.Instance.VisualizeScentRadius(this, gridEntity.Position, radiusTiles);
   }
   else {
    GridDebugVisualizer.Instance.HideContinuousRadius(this);
   }
  }
 }

 pub void SetDefinition(ScentDefinition newDefinition) {
  definition = newDefinition;
  UpdateRadiusVisualization(); // Update visualization when definition changes
 }

 pub void SetRadiusModifier(float modifier) {
  radiusModifier = modifier;
 }

 pub void SetStrengthModifier(float modifier) {
  strengthModifier = modifier;
 }

 pub void ApplyModifiers(float radiusMod, float strengthMod) {
  radiusModifier += radiusMod;
  strengthModifier += strengthMod;
 }

 void OnDestroy() {
  if (GridDebugVisualizer.Instance != null) {
   GridDebugVisualizer.Instance.HideContinuousRadius(this);
  }
 }

 void OnDisable() {
  if (GridDebugVisualizer.Instance != null) {
   GridDebugVisualizer.Instance.HideContinuousRadius(this);
  }
 }

 void OnEnable() {
  UpdateRadiusVisualization();
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\AnimalDiet.cs

﻿using UnityEngine;

pub class DietPreferenceSimplified {
 pub FoodType foodType;
 // Note: satiationAmount has been removed from here.
 [Tooltip("How much the animal prefers this food. Higher values are prioritized from further away.")]
 pub float preferencePriority = 1f;
}

pub class AnimalDiet : ScriptableObject {
 pub List<DietPreferenceSimplified> acceptableFoods = new List<DietPreferenceSimplified>();

 [Tooltip("The maximum hunger an animal can have before it starts starving.")]
 pub float maxHunger = 20f;

 [Tooltip("How much hunger the animal gains per hunger tick interval.")]
 pub float hungerIncreaseRate = 0.5f;

 [Tooltip("The hunger level at which the animal will start actively seeking food.")]
 pub float hungerThreshold = 10f;

 pub bool CanEat(FoodType food) {
  if (food == null) return false;
  return acceptableFoods.Any(pref => pref.foodType == food);
 }

 pub DietPreferenceSimplified GetPreference(FoodType food) {
  if (food == null) return null;
  return acceptableFoods.FirstOrDefault(p => p.foodType == food);
 }

 pub float GetSatiationValue(FoodType food) {
  if (food != null && CanEat(food)) {
   return food.baseSatiationValue;
  }
  return 0f;
 }

 pub GameObject FindBestFood(Collider2D[] nearbyColliders, Vector3 animalPosition) {
  GameObject bestTarget = null;
  float highestScore = -1f;

  foreach (var collider in nearbyColliders) {
   if (collider == null) continue;

   PoopController poopController = collider.GetComponent<PoopController>();
   if (poopController != null) continue;

   FoodItem foodItem = collider.GetComponent<FoodItem>();
   if (foodItem != null && foodItem.foodType != null && CanEat(foodItem.foodType)) {
    DietPreferenceSimplified pref = GetPreference(foodItem.foodType);
    if (pref == null) continue;

    float distance = Vector3.Distance(animalPosition, collider.transform.position);
    float score = pref.preferencePriority / (1f + distance); // Inverse distance weighting

    if (score > highestScore) {
     highestScore = score;
     bestTarget = collider.gameObject;
    }
   }
  }
  return bestTarget;
 }

 void OnValidate() {
  maxHunger = Mathf.Max(1f, maxHunger);
  hungerIncreaseRate = Mathf.Max(0.1f, hungerIncreaseRate);
  hungerThreshold = Mathf.Clamp(hungerThreshold, 0f, maxHunger);

  foreach (var pref in acceptableFoods) {
   if (pref != null) {
    pref.preferencePriority = Mathf.Max(0.1f, pref.preferencePriority);
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\FoodItem.cs

﻿using UnityEngine;
using Abracodabra.Genes;
using WegoSystem;

pub class FoodItem : MonoBehaviour {
 pub FoodType foodType;

 GridEntity gridEntity;
 bool isInitialized = false; // Prevents Start() from running if manually initialized

 void Awake() {
  gridEntity = GetComponent<GridEntity>();
  if (gridEntity == null) {
   gridEntity = gameObject.AddComponent<GridEntity>();
  }
 }

 void Start() {
  if (isInitialized) return; // If initialized by PlantCellManager, do nothing.

  if (foodType == null) {
   Debug.LogWarning($"FoodItem on GameObject '{gameObject.name}' is missing its FoodType reference!", gameObject);
   enabled = false;
   return;
  }

  gridEntity.isTileOccupant = false;
  gridEntity.enabled = true;

  if (GridPositionManager.Instance != null) {
   GridPositionManager.Instance.SnapEntityToGrid(gameObject);
   Debug.Log($"[FoodItem] Registered STANDALONE food '{foodType.foodName}' at grid position {gridEntity.Position}");
  }

  isInitialized = true;
 }

 pub void InitializeAsPlantPart(FoodType type, GridPosition gridPosition) {
  if (isInitialized) return;

  this.foodType = type;

  gridEntity.isTileOccupant = false;
  gridEntity.enabled = true;

  if (GridPositionManager.Instance != null) {
   gridEntity.SetPosition(gridPosition, true); // Instantly set logical state
   GridPositionManager.Instance.RegisterEntity(gridEntity); // Manually register
   Debug.Log($"[FoodItem] Registered PLANT food '{foodType.name}' at grid position {gridPosition}");
  }

  isInitialized = true;
 }

 pub bool CanBeEatenBy(AnimalController animal) {
  if (animal == null || animal.Definition == null || animal.Definition.diet == null)
   return false;

  return animal.Definition.diet.CanEat(foodType);
 }

 pub float GetSatiationValueFor(AnimalController animal) {
  if (animal == null || animal.Definition == null || animal.Definition.diet == null)
   return 0f;

  return animal.Definition.diet.GetSatiationValue(foodType);
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Food\FoodType.cs

﻿using UnityEngine;

pub class FoodType : ScriptableObject {
 pub string foodName = "Default Food";
 pub Sprite icon;

 pub enum FoodCategory { Plant_Leaf, Plant_Fruit, Plant_Stem, Plant_Seed, Other }
 pub FoodCategory category = FoodCategory.Other;

 [Tooltip("The base nutritional value this food provides when eaten.")]
 pub float baseSatiationValue = 5f;
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Management\EcosystemManager.cs

﻿// Assets/Scripts/Ecosystem/Management/EcosystemManager.cs
using WegoSystem;

pub class EcosystemManager : SingletonMonoBehaviour<EcosystemManager> {
 pub Transform animalParent;
 pub Transform plantParent;

 pub ScentLibrary scentLibrary;

 pub bool sortAnimalsBySpecies = true;
 pub bool sortPlantsBySpecies = true;

 prot ovr void OnAwake() {
  if (scentLibrary == null) {
   Debug.LogWarning($"[{nameof(EcosystemManager)}] Scent Library not assigned! Scent effects will not work.", this);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Management\FaunaManager.cs

﻿// FILE: Assets/Scripts/Ecosystem/Management/FaunaManager.cs
using WegoSystem;

pub class FaunaManager : MonoBehaviour {
 [Header("Spawning Area")]
 [Tooltip("If true, the spawn area will be centered on the middle of the grid. If false, it will use the Custom Spawn Center.")]
 [SerializeField] bool useMapCenterAsSpawnArea = true;
 [Tooltip("A custom world-space coordinate for the spawn area center. Only used if 'Use Map Center' is false.")]
 [SerializeField] Vector2 customSpawnCenter = Vector2.zero;
 [SerializeField] Vector2 spawnAreaSize = new Vector2(20f, 10f);

 [Header("System References")]
 [SerializeField] Transform ecosystemParent;

 [Header("Screen Spawning Settings")]
 [SerializeField] [Min(0f)] float screenBoundsPadding = 0.5f;
 [SerializeField] [Min(0f)] float offscreenSpawnMargin = 2.0f;
 [SerializeField] [Range(-10f, 10f)] float boundsOffsetX = 0f;
 [SerializeField] [Range(-10f, 10f)] float boundsOffsetY = 0f;

 [Header("Debug")]
 [SerializeField] bool showBoundsGizmos = false;

 List<Coroutine> activeSpawnCoroutines = new List<Coroutine>();
 Camera mainCamera;

 pub void Initialize() {
  InitializeManager();
 }

 void InitializeManager() {
  activeSpawnCoroutines.Clear();
  if (WaveManager.Instance != null) mainCamera = WaveManager.Instance.GetMainCamera();
  if (mainCamera == null) mainCamera = Camera.main;
  if (mainCamera == null) Debug.LogError("[FaunaManager] Cannot find Main Camera!", this);

  if (ecosystemParent == null) {
   if (EcosystemManager.Instance != null && EcosystemManager.Instance.animalParent != null) {
    ecosystemParent = EcosystemManager.Instance.animalParent;
    Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned from EcosystemManager.animalParent.", this);
   }
   else {
    ecosystemParent = transform;
    Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned to self as fallback.", this);
   }
  }
 }

 Vector2 GetEffectiveSpawnCenter() {
  if (useMapCenterAsSpawnArea && GridPositionManager.Instance != null) {
   return GridPositionManager.Instance.GetMapCenterWorld();
  }
  return customSpawnCenter;
 }

 pub void ExecuteSpawnWave(WaveDefinition waveDef) {
  if (waveDef == null) { Debug.LogError("[FaunaManager] ExecuteSpawnWave called with null WaveDefinition!", this); return; }
  if (waveDef.spawnEntries == null || waveDef.spawnEntries.Count == 0) { Debug.LogWarning($"[FaunaManager] Wave '{waveDef.waveName}' has no spawn entries.", this); return; }

  Debug.Log($"[FaunaManager] Executing spawn for Wave: '{waveDef.waveName}'");
  StopAllSpawnCoroutines();

  foreach (WaveSpawnEntry entry in waveDef.spawnEntries) {
   if (entry.animalDefinition == null) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', null AnimalDefinition for wave '{waveDef.waveName}'."); continue; }
   if (entry.spawnCount <= 0) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', Spawn Count <= 0 for wave '{waveDef.waveName}'."); continue; }

   if (RunManager.Instance != null && RunManager.Instance.CurrentState != RunState.GrowthAndThreat) {
    Debug.Log($"[FaunaManager] Halting further spawn entry processing for wave '{waveDef.waveName}', RunManager not in GrowthAndThreat state.");
    break;
   }

   WaveSpawnEntry currentEntry = entry;
   Coroutine spawnCoroutine = StartCoroutine(SpawnWaveEntryCoroutine(currentEntry, waveDef.waveName));
   activeSpawnCoroutines.Add(spawnCoroutine);
  }
  Debug.Log($"[FaunaManager] Started {activeSpawnCoroutines.Count} spawn entry coroutine(s) for '{waveDef.waveName}'.");
 }

 pub void StopAllSpawnCoroutines() {
  if (activeSpawnCoroutines.Count > 0) {
   Debug.Log($"[FaunaManager] Stopping all ({activeSpawnCoroutines.Count}) active spawn coroutines.");
   foreach (Coroutine co in activeSpawnCoroutines) {
    if (co != null) StopCoroutine(co);
   }
   activeSpawnCoroutines.Clear();
  }
 }

 IEnumerator SpawnWaveEntryCoroutine(WaveSpawnEntry entry, string waveNameForDebug) {
  if (entry.delayAfterSpawnTime > 0) {
   yield return new WaitForSeconds(entry.delayAfterSpawnTime);
  }

  for (int i = 0; i < entry.spawnCount; i++) {
   if (RunManager.Instance != null && RunManager.Instance.CurrentState != RunState.GrowthAndThreat) {
    Debug.Log($"[FaunaManager] Halting spawn for entry '{entry.description}' in wave '{waveNameForDebug}', RunManager no longer in GrowthAndThreat state.");
    break;
   }

   Vector2 spawnPos = CalculateSpawnPosition(entry.spawnLocationType, entry.spawnRadius);
   bool isOffscreen = entry.spawnLocationType == WaveSpawnLocationType.Offscreen;
   GameObject spawnedAnimal = SpawnAnimal(entry.animalDefinition, spawnPos, isOffscreen);

   if (entry.spawnInterval > 0 && i < entry.spawnCount - 1) {
    yield return new WaitForSeconds(entry.spawnInterval);
   }
  }
 }

 Vector2 CalculateSpawnPosition(WaveSpawnLocationType locationType, float radius) {
  if (mainCamera == null) {
   Debug.LogError("[FaunaManager] Missing Main Camera for CalculateSpawnPosition!");
   return GetEffectiveSpawnCenter();
  }

  Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
  Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

  Vector2 spawnPos;
  float camHeight = mainCamera.orthographicSize * 2f;
  float camWidth = camHeight * mainCamera.aspect;

  switch (locationType) {
   case WaveSpawnLocationType.Offscreen:
    float marginMinX = effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin;
    float marginMaxX = effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin;
    float marginMinY = effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin;
    float marginMaxY = effectiveCamPos.y + camHeight / 2f - offscreenSpawnMargin;
    float extraOffset = 0.1f;
    int edge = Random.Range(0, 4);
    if (edge == 0) { spawnPos.x = marginMinX - extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
    else if (edge == 1) { spawnPos.x = marginMaxX + extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
    else if (edge == 2) { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMinY - extraOffset; }
    else { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMaxY + extraOffset; }
    break;

   case WaveSpawnLocationType.RandomNearPlayer:
    Transform playerT = FindPlayerTransform();
    if (playerT != null) {
     spawnPos = (Vector2)playerT.position + Random.insideUnitCircle * radius;
    }
    else {
     Debug.LogWarning("[FaunaManager] Player not found for RandomNearPlayer. Falling back to Global.");
     goto case WaveSpawnLocationType.GlobalSpawnArea;
    }
    break;

   case WaveSpawnLocationType.GlobalSpawnArea:
   default:
    Vector2 center = GetEffectiveSpawnCenter();
    spawnPos.x = center.x + Random.Range(-spawnAreaSize.x / 2f, spawnAreaSize.x / 2f);
    spawnPos.y = center.y + Random.Range(-spawnAreaSize.y / 2f, spawnAreaSize.y / 2f);
    break;
  }
  return spawnPos;
 }

 Transform FindPlayerTransform() {
  GameObject playerGO = GameObject.FindGameObjectWithTag("Player");
  if (playerGO != null) return playerGO.transform;

  PlayerTileInteractor pti = FindAnyObjectByType<PlayerTileInteractor>();
  if (pti != null) return pti.transform;

  GardenerController gc = FindAnyObjectByType<GardenerController>();
  if (gc != null) return gc.transform;

  return null;
 }

 GameObject SpawnAnimal(AnimalDefinition definition, Vector2 position, bool isOffscreenSpawn) {
  if (definition == null || definition.prefab == null) {
   Debug.LogError("[FaunaManager] Cannot spawn animal: null definition or prefab.");
   return null;
  }

  if (mainCamera == null) {
   Debug.LogError("[FaunaManager] Missing Main Camera for SpawnAnimal bounds calculation!");
   return null;
  }

  Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
  Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

  Vector2 minPaddedBounds, maxPaddedBounds;
  float camHeight = mainCamera.orthographicSize * 2f;
  float camWidth = camHeight * mainCamera.aspect;

  minPaddedBounds.x = effectiveCamPos.x - camWidth / 2f + screenBoundsPadding;
  maxPaddedBounds.x = effectiveCamPos.x + camWidth / 2f - screenBoundsPadding;
  minPaddedBounds.y = effectiveCamPos.y - camHeight / 2f + screenBoundsPadding;
  maxPaddedBounds.y = effectiveCamPos.y + camHeight / 2f - screenBoundsPadding;

  GameObject animalObj = Instantiate(definition.prefab, position, Quaternion.identity);

  if (ecosystemParent != null) {
   Transform speciesParent = ecosystemParent;
   if (EcosystemManager.Instance != null && EcosystemManager.Instance.sortAnimalsBySpecies && !string.IsNullOrEmpty(definition.animalName)) {
    speciesParent = ecosystemParent.Find(definition.animalName);
    if (speciesParent == null) {
     GameObject subParentGO = new GameObject(definition.animalName);
     subParentGO.transform.SetParent(ecosystemParent);
     speciesParent = subParentGO.transform;
    }
   }
   animalObj.transform.SetParent(speciesParent);
  }

  AnimalController controller = animalObj.GetComponent<AnimalController>();
  if (controller != null) {
   if (isOffscreenSpawn) {
    Vector2 screenCenter = (minPaddedBounds + maxPaddedBounds) / 2f;
    controller.SetSeekingScreenCenter(screenCenter, minPaddedBounds, maxPaddedBounds);
   }
  }
  else {
   Debug.LogError($"[FaunaManager] Spawned animal prefab '{definition.prefab.name}' missing AnimalController script!", animalObj);
  }

  return animalObj;
 }

 void OnDrawGizmos() {
  if (!showBoundsGizmos) return;

  Vector2 center = GetEffectiveSpawnCenter();
  Gizmos.color = new Color(0f, 0.5f, 1f, 0.5f); // Blue for spawn area
  Gizmos.DrawWireCube(center, spawnAreaSize);

  if (mainCamera == null) return;

  Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
  Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;
  float camHeight = mainCamera.orthographicSize * 2f;
  float camWidth = camHeight * mainCamera.aspect;
  Vector2 paddedMin = new Vector2(effectiveCamPos.x - camWidth / 2f + screenBoundsPadding, effectiveCamPos.y - camHeight / 2f + screenBoundsPadding);
  Vector2 paddedMax = new Vector2(effectiveCamPos.x + camWidth / 2f - screenBoundsPadding, effectiveCamPos.y + camHeight / 2f - screenBoundsPadding);
  DrawWireRectangleGizmo(paddedMin, paddedMax, Color.green);
  Vector2 marginMin = new Vector2(effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin, effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin);
  Vector2 marginMax = new Vector2(effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin, effectiveCamPos.y + camHeight / 2f - offscreenSpawnMargin);
  DrawWireRectangleGizmo(marginMin, marginMax, Color.red);
 }

 void DrawWireRectangleGizmo(Vector2 min, Vector2 max, Color color) { Gizmos.color = color; Gizmos.DrawLine(new Vector3(min.x, min.y, 0), new Vector3(max.x, min.y, 0)); Gizmos.DrawLine(new Vector3(max.x, min.y, 0), new Vector3(max.x, max.y, 0)); Gizmos.DrawLine(new Vector3(max.x, max.y, 0), new Vector3(min.x, max.y, 0)); Gizmos.DrawLine(new Vector3(min.x, max.y, 0), new Vector3(min.x, min.y, 0)); }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Management\FloraManager.cs

﻿// REWORKED FILE: Assets/Scripts/Ecosystem/Management/FloraManager.cs

pub class FloraManager : MonoBehaviour {
 pub stat FloraManager Instance { get; set; }

 [Tooltip("The base rate of energy generation per leaf per tick, before sunlight, genes, or other modifiers.")]
 [SerializeField] pub float basePhotosynthesisRatePerLeaf = 0.1f;

 void Awake() {
  if (Instance != null && Instance != this) {
   Destroy(gameObject);
   return;
  }
  Instance = this;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Management\WaveManager.cs

﻿// Assets/Scripts/Ecosystem/Management/WaveManager.cs
using TMPro;
using WegoSystem;

pub enum WaveState {
 Idle,           // No wave active
 Active,         // Wave is currently running
 Spawning        // Currently spawning enemies
}

pub class WaveManager : MonoBehaviour {
 pub stat WaveManager Instance { get; set; }

 [SerializeField] Camera mainCamera;
 [SerializeField] FaunaManager faunaManager;
 [SerializeField] List<WaveDefinition> wavesSequence;

 [SerializeField] int waveDurationInDays = 1;
 [SerializeField] float spawnTimeNormalized = 0.1f;
 [SerializeField] bool continuousSpawning = false;

 [SerializeField] bool deletePreviousWaveAnimals = true;

 [SerializeField] TextMeshProUGUI waveStatusText;
 [SerializeField] TextMeshProUGUI timeTrackerText;

 WaveState currentState = WaveState.Idle;
 WaveDefinition currentWaveDef = null;
 int currentWaveIndex = -1;

 int waveStartTick = 0;
 int waveEndTick = 0;
 int waveSpawnTick = 0;
 bool hasSpawnedThisWave = false;

 Coroutine activeSpawnCoroutine = null;

 pub bool IsWaveActive => currentState != WaveState.Idle;
 pub bool IsCurrentWaveDefeated() => currentState == WaveState.Idle && currentWaveIndex >= 0;

 void Awake() {
  if (Instance != null && Instance != this) {
   Destroy(gameObject);
   return;
  }
  Instance = this;

  ValidateReferences();
 }

 pub void Initialize() {
  if (TickManager.Instance != null) {
   TickManager.Instance.OnTickAdvanced += OnTickAdvanced;
   Debug.Log("[WaveManager] Initialized and subscribed to TickManager events.");
  }
  else {
   Debug.LogError("[WaveManager] Initialization failed: TickManager not found!");
  }
 }

 void OnDestroy() {
  var tickManager = TickManager.Instance;
  if (tickManager != null) {
   tickManager.OnTickAdvanced -= OnTickAdvanced;
  }
  StopAllCoroutines();
 }

 void ValidateReferences() {
  if (faunaManager == null) {
   faunaManager = FindAnyObjectByType<FaunaManager>();
   if (faunaManager != null) {
    Debug.LogWarning("[WaveManager] FaunaManager was not assigned in the Inspector. Found it automatically.", this);
   }
  }

  if (faunaManager == null) {
   Debug.LogError("[WaveManager] CRITICAL: FaunaManager is missing and could not be found in the scene! Waves will not spawn.", this);
  }

  if (wavesSequence == null || wavesSequence.Count == 0)
   Debug.LogWarning("[WaveManager] Wave Sequence empty. No waves will spawn.", this);
 }

 void OnTickAdvanced(int currentTick) {
  if (currentState == WaveState.Active) {
   if (currentTick >= waveEndTick) {
    EndCurrentWave();
   }
   else if (!hasSpawnedThisWave && currentTick >= waveSpawnTick) {
    StartSpawning();
   }
   else if (continuousSpawning && hasSpawnedThisWave) {
   }
  }
 }

 pub void StartWaveForRound(int roundNumber) {
  if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat) {
   Debug.LogWarning("[WaveManager] Cannot start wave - not in GrowthAndThreat state.");
   return;
  }

  currentWaveIndex = roundNumber - 1;

  if (!IsValidWaveIndex(currentWaveIndex)) {
   Debug.LogWarning($"[WaveManager] No wave definition for round {roundNumber}");
   currentState = WaveState.Idle;
   return;
  }

  currentWaveDef = wavesSequence[currentWaveIndex];
  if (currentWaveDef == null) {
   Debug.LogError($"[WaveManager] Wave definition at index {currentWaveIndex} is null!");
   currentState = WaveState.Idle;
   return;
  }

  StartWave();
 }

 void StartWave() {
  if (deletePreviousWaveAnimals) {
   ClearAllActiveAnimals();
  }

  var config = TickManager.Instance?.Config;
  if (config == null) {
   Debug.LogError("[WaveManager] No TickConfiguration found!");
   return;
  }

  waveStartTick = TickManager.Instance.CurrentTick;
  int waveDurationTicks = config.ticksPerDay * waveDurationInDays;
  waveEndTick = waveStartTick + waveDurationTicks;

  waveSpawnTick = waveStartTick + Mathf.RoundToInt(waveDurationTicks * spawnTimeNormalized);

  hasSpawnedThisWave = false;
  currentState = WaveState.Active;

  Debug.Log($"[WaveManager] Starting wave '{currentWaveDef.waveName}' " +
    $"Duration: {waveDurationTicks} ticks ({waveDurationInDays} days) " +
    $"Spawn at tick: {waveSpawnTick}");
 }

 void StartSpawning() {
  if (currentWaveDef == null || faunaManager == null) return;

  hasSpawnedThisWave = true;
  currentState = WaveState.Spawning;

  Debug.Log($"[WaveManager] Beginning spawn for wave '{currentWaveDef.waveName}'");

  if (activeSpawnCoroutine != null) {
   StopCoroutine(activeSpawnCoroutine);
  }

  activeSpawnCoroutine = StartCoroutine(ExecuteWaveSpawn());
 }

 IEnumerator ExecuteWaveSpawn() {
  faunaManager.ExecuteSpawnWave(currentWaveDef);

  yield return new WaitForSeconds(1f);

  if (currentState == WaveState.Spawning) {
   currentState = WaveState.Active;
  }

  activeSpawnCoroutine = null;
 }

 void EndCurrentWave() {
  Debug.Log($"[WaveManager] Ending wave '{currentWaveDef?.waveName}'");

  StopCurrentWaveSpawning();
  currentWaveDef = null;
  currentState = WaveState.Idle;

  if (RunManager.Instance != null) {
   RunManager.Instance.StartNewPlanningPhase();
  }
 }

 pub void StopCurrentWaveSpawning() {
  if (activeSpawnCoroutine != null) {
   StopCoroutine(activeSpawnCoroutine);
   activeSpawnCoroutine = null;
  }

  faunaManager?.StopAllSpawnCoroutines();
 }

 pub void ResetForNewRound() {
  Debug.Log("[WaveManager] Resetting for new round");

  StopCurrentWaveSpawning();

  if (deletePreviousWaveAnimals) {
   ClearAllActiveAnimals();
  }

  currentWaveDef = null;
  currentWaveIndex = -1;
  currentState = WaveState.Idle;
  hasSpawnedThisWave = false;
  waveStartTick = 0;
  waveEndTick = 0;
  waveSpawnTick = 0;
 }

 void ClearAllActiveAnimals() {
  AnimalController[] animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
  int count = 0;

  foreach (var animal in animals) {
   if (animal != null) {
    Destroy(animal.gameObject);
    count++;
   }
  }

  Debug.Log($"[WaveManager] Cleared {count} animals");
 }

 bool IsValidWaveIndex(int index) {
  return wavesSequence != null &&
   index >= 0 &&
   index < wavesSequence.Count;
 }

 void Update() {
  UpdateUI();
 }

 void UpdateUI() {
  UpdateTimeTracker();
  UpdateWaveStatus();
 }

 void UpdateTimeTracker() {
  if (timeTrackerText == null || TickManager.Instance == null) return;

  var config = TickManager.Instance.Config;
  if (config == null) return;

  float dayProgress = config.GetDayProgressNormalized(TickManager.Instance.CurrentTick);
  int dayNumber = TickManager.Instance.CurrentTick / config.ticksPerDay + 1;

  timeTrackerText.text = $"Day {dayNumber} - {(dayProgress * 100):F0}%";

  if (currentState != WaveState.Idle) {
   int ticksIntoWave = TickManager.Instance.CurrentTick - waveStartTick;
   int totalWaveTicks = waveEndTick - waveStartTick;
   float waveProgress = totalWaveTicks > 0 ? (float)ticksIntoWave / totalWaveTicks : 0;
   timeTrackerText.text += $" | Wave: {(waveProgress * 100):F0}%";
  }
 }

 void UpdateWaveStatus() {
  if (waveStatusText == null) return;

  if (RunManager.Instance == null) {
   waveStatusText.text = "System Offline";
   return;
  }

  if (RunManager.Instance.CurrentState == RunState.Planning) {
   waveStatusText.text = $"Prepare for Round {RunManager.Instance.CurrentRoundNumber}";
  }
  else if (RunManager.Instance.CurrentState == RunState.GrowthAndThreat) {
   if (currentWaveDef != null) {
    int ticksRemaining = Mathf.Max(0, waveEndTick - TickManager.Instance.CurrentTick);
    string waveName = string.IsNullOrEmpty(currentWaveDef.waveName)
     ? $"Wave {currentWaveIndex + 1}"
     : currentWaveDef.waveName;

    string status = currentState == WaveState.Spawning ? " [SPAWNING]" : "";
    waveStatusText.text = $"{waveName}{status} - {ticksRemaining} ticks left";
   }
   else {
    waveStatusText.text = "No active wave";
   }
  }
 }

 pub Camera GetMainCamera() => mainCamera;

 void Debug_ForceEndWave() {
  if (Application.isEditor && currentState != WaveState.Idle) {
   EndCurrentWave();
  }
 }

 void Debug_ForceSpawn() {
  if (Application.isEditor && currentState == WaveState.Active && !hasSpawnedThisWave) {
   StartSpawning();
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Spawning\WaveDefinition.cs

﻿using UnityEngine;

pub enum WaveSpawnLocationType {
 GlobalSpawnArea,
 RandomNearPlayer,
 Offscreen
}

pub class WaveSpawnEntry {
 [Tooltip("Optional description for this specific spawn group within the wave.")]
 pub string description = "Spawn Group";
 [Tooltip("The type of animal to spawn.")]
 pub AnimalDefinition animalDefinition;
 [Tooltip("How many of this animal to spawn in this specific entry.")]
 [Min(1)]
 pub int spawnCount = 1;
 [Tooltip("Delay (in seconds) AFTER the designated wave spawn time (e.g. Day 50%) before *this entry* begins spawning.")] // Clarified Tooltip
 [Min(0)]
 pub float delayAfterSpawnTime = 0f; // Renamed from delayAfterWaveStart
 [Tooltip("Time (in seconds) between spawning each individual animal in this entry (0 = spawn all instantly).")]
 [Min(0)]
 pub float spawnInterval = 0.5f;
 [Tooltip("Where these animals should spawn.")]
 pub WaveSpawnLocationType spawnLocationType = WaveSpawnLocationType.GlobalSpawnArea;
 [Tooltip("Radius used for spawning (e.g., if Spawn Location Type is RandomNearPlayer).")]
 [Min(0)]
 pub float spawnRadius = 5f;
}

pub class WaveDefinition : ScriptableObject {
 [Header("Wave Identification")]
 [Tooltip("Editor-only name for this wave.")]
 pub string waveName = "New Wave";

 [Header("Wave Content")]
 [Tooltip("Define the groups of animals that spawn during this wave.")]
 pub List<WaveSpawnEntry> spawnEntries = new List<WaveSpawnEntry>();

}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Status Effects\IStatusEffectable.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/IStatusEffectable.cs
using WegoSystem; // For GridEntity

pub interface IStatusEffectable {
 GridEntity GridEntity { get; }

 StatusEffectManager StatusManager { get; }

 // A unique name for logging/debugging
 string GetDisplayName();

 void TakeDamage(float amount);
 void Heal(float amount);
 void ModifyHunger(float amount); // Can be left empty for player
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Status Effects\StatusEffect.cs

﻿using UnityEngine;

pub class StatusEffect : ScriptableObject {
 pub string effectID = "status_effect";
 pub string displayName = "Status Effect";
 pub Sprite icon;
 pub string unicodeSymbol = "?";
 pub Color effectColor = Color.white;

 pub bool isPermanent = false;
 pub int durationTicks = 10;

 pub bool modifyAnimalColor = false;
 pub Color animalTintColor = Color.white;
 pub GameObject visualEffectPrefab;

 pub bool damagePerTick = false;
 pub float damageAmount = 0f;

 pub bool healPerTick = false;
 pub float healAmount = 0f;

 pub bool modifyHunger = false;
 pub float hungerModifier = 0f;

 [Tooltip("Multiplier for the VISUAL movement speed between tiles. Does not affect logical tiles-per-tick speed.")]
 pub float visualInterpolationSpeedMultiplier = 1f;

 pub float damageResistanceMultiplier = 1f;

 pub int additionalMoveTicks = 0;

 pub bool canStack = false;
 pub int maxStacks = 1;
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Status Effects\StatusEffectIconUI.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/StatusEffectIconUI.cs
using TMPro;

pub class StatusEffectIconUI : MonoBehaviour {
 Image iconImage;
 TextMeshProUGUI iconText;
 StatusEffect currentEffect;

 pub void Initialize(StatusEffectInstance instance) {
  currentEffect = instance.effect;

  Transform iconTransform = transform.Find("Icon");
  if (iconTransform != null) {
   iconTransform.gameObject.SetActive(true);

   iconImage = iconTransform.GetComponent<Image>();
   iconText = iconTransform.GetComponentInChildren<TextMeshProUGUI>();

   if (currentEffect.icon != null) {
    if (iconImage != null) {
     iconImage.sprite = currentEffect.icon;
     iconImage.color = currentEffect.effectColor;
     iconImage.enabled = true;
    }
    if (iconText != null) {
     iconText.enabled = false;
    }
   }
   else {
    if (iconImage != null) {
     iconImage.enabled = false;
    }
    if (iconText != null) {
     iconText.text = currentEffect.unicodeSymbol;
     iconText.color = currentEffect.effectColor;
     iconText.enabled = true;
    }
   }
  }
  else {
   Debug.LogError("Could not find child GameObject named 'Icon' in the StatusEffectIcon prefab!", this);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Status Effects\StatusEffectInstance.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/StatusEffectInstance.cs

pub class StatusEffectInstance {
 pub StatusEffect effect;
 pub int remainingTicks;
 pub int stackCount = 1;
 pub GameObject visualEffectInstance;

 pub StatusEffectInstance(StatusEffect effect) {
  this.effect = effect;
  this.remainingTicks = effect.durationTicks;
  this.stackCount = 1;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Status Effects\StatusEffectManager.cs

﻿using UnityEngine;

pub class StatusEffectManager : MonoBehaviour {
 IStatusEffectable owner;
 List<StatusEffectInstance> activeEffects = new List<StatusEffectInstance>();
 Dictionary<string, StatusEffectInstance> effectLookup = new Dictionary<string, StatusEffectInstance>();

 float cachedVisualInterpolationSpeedMultiplier = 1f;
 float cachedDamageResistanceMultiplier = 1f;
 int cachedAdditionalMoveTicks = 0;
 Color originalColor;
 SpriteRenderer spriteRenderer;

 pub float VisualInterpolationSpeedMultiplier => cachedVisualInterpolationSpeedMultiplier;
 pub float DamageResistanceMultiplier => cachedDamageResistanceMultiplier;
 pub int AdditionalMoveTicks => cachedAdditionalMoveTicks;

 pub void Initialize(IStatusEffectable owner) {
  this.owner = owner;

  Component ownerComponent = owner as Component;
  if (ownerComponent != null) {
   spriteRenderer = ownerComponent.GetComponentInChildren<SpriteRenderer>();
   if (spriteRenderer != null) {
    originalColor = spriteRenderer.color;
   }
  }
 }

 pub void OnTickUpdate(int currentTick) {
  if (owner == null || (owner as Component) == null) {
   Destroy(this);
   return;
  }

  ProcessStatusEffects();
  UpdateCachedModifiers();
  UpdateVisualEffects();
 }

 pub void ApplyStatusEffect(StatusEffect effect) {
  if (effect == null) return;

  if (effectLookup.ContainsKey(effect.effectID)) {
   var existing = effectLookup[effect.effectID];
   if (effect.canStack && existing.stackCount < effect.maxStacks) {
    existing.stackCount++;
    existing.remainingTicks = effect.durationTicks;
   }
   else if (!effect.canStack) {
    existing.remainingTicks = effect.durationTicks;
   }
  }
  else {
   var instance = new StatusEffectInstance(effect);
   activeEffects.Add(instance);
   effectLookup[effect.effectID] = instance;

   if (effect.visualEffectPrefab != null) {
    instance.visualEffectInstance = Instantiate(
     effect.visualEffectPrefab,
     (owner as Component).transform.position,
     Quaternion.identity,
     (owner as Component).transform
    );
   }
   Debug.Log($"[StatusEffect] Applied {effect.displayName} to {owner.GetDisplayName()}");
  }

  UpdateCachedModifiers();
 }

 pub void RemoveStatusEffect(string effectID) {
  if (!effectLookup.ContainsKey(effectID)) return;
  var instance = effectLookup[effectID];
  if (instance.visualEffectInstance != null) {
   Destroy(instance.visualEffectInstance);
  }
  activeEffects.Remove(instance);
  effectLookup.Remove(effectID);
  Debug.Log($"[StatusEffect] Removed {instance.effect.displayName} from {owner.GetDisplayName()}");
  UpdateCachedModifiers();
 }

 void ProcessStatusEffects() {
  for (int i = activeEffects.Count - 1; i >= 0; i--) {
   var instance = activeEffects[i];
   var effect = instance.effect;

   if (effect.damagePerTick) owner.TakeDamage(effect.damageAmount * instance.stackCount);
   if (effect.healPerTick) owner.Heal(effect.healAmount * instance.stackCount);
   if (effect.modifyHunger) owner.ModifyHunger(effect.hungerModifier * instance.stackCount);

   if (!effect.isPermanent) {
    instance.remainingTicks--;
    if (instance.remainingTicks <= 0) {
     RemoveStatusEffect(effect.effectID);
    }
   }
  }
 }

 void UpdateCachedModifiers() {
  cachedVisualInterpolationSpeedMultiplier = 1f;
  cachedDamageResistanceMultiplier = 1f;
  cachedAdditionalMoveTicks = 0;

  foreach (var instance in activeEffects) {
   var effect = instance.effect;
   cachedVisualInterpolationSpeedMultiplier *= effect.visualInterpolationSpeedMultiplier;
   cachedDamageResistanceMultiplier *= effect.damageResistanceMultiplier;
   cachedAdditionalMoveTicks += effect.additionalMoveTicks * instance.stackCount;
  }
 }

 pub bool HasStatusEffect(string effectID) {
  return effectLookup.ContainsKey(effectID);
 }
 void UpdateVisualEffects() {
  if (spriteRenderer == null) return;
  Color targetColor = originalColor;
  bool hasColorEffect = false;
  foreach (var instance in activeEffects) {
   if (instance.effect.modifyAnimalColor) {
    targetColor = instance.effect.animalTintColor;
    hasColorEffect = true;
    break;
   }
  }
  spriteRenderer.color = hasColorEffect ? targetColor : originalColor;
 }
 pub List<StatusEffectInstance> GetActiveEffects() {
  return new List<StatusEffectInstance>(activeEffects);
 }
 pub void ClearAllEffects() {
  for (int i = activeEffects.Count - 1; i >= 0; i--) {
   RemoveStatusEffect(activeEffects[i].effect.effectID);
  }
 }
 void OnDestroy() {
  foreach (var instance in activeEffects) {
   if (instance.visualEffectInstance != null) {
    Destroy(instance.visualEffectInstance);
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Status Effects\StatusEffectUIManager.cs

﻿// Assets/Scripts/Ecosystem/Status Effects/StatusEffectUIManager.cs
using TMPro;
using WegoSystem;

pub class StatusEffectUIManager : MonoBehaviour {
 [SerializeField] Transform effectIconContainer;
 [SerializeField] GameObject effectIconPrefab;

 StatusEffectManager statusManager;
 Dictionary<string, StatusEffectIconUI> activeIcons = new Dictionary<string, StatusEffectIconUI>();

 pub void Initialize(StatusEffectManager manager) {
  statusManager = manager;

  if (effectIconPrefab == null) {
   CreateDefaultIconPrefab();
  }
 }

 void Update() {
  if (statusManager == null || effectIconContainer == null) return;

  UpdateStatusIcons();
 }

 void UpdateStatusIcons() {
  var currentEffectInstances = statusManager.GetActiveEffects();
  var currentEffectIDs = currentEffectInstances.Select(e => e.effect.effectID).ToList();
  var displayedIconIDs = activeIcons.Keys.ToList();

  foreach (var id in displayedIconIDs) {
   if (!currentEffectIDs.Contains(id)) {
    if (activeIcons.TryGetValue(id, out StatusEffectIconUI iconToDestroy)) {
     if (iconToDestroy != null) Destroy(iconToDestroy.gameObject);
    }
    activeIcons.Remove(id);
   }
  }

  foreach (var instance in currentEffectInstances) {
   if (!activeIcons.ContainsKey(instance.effect.effectID)) {
    CreateEffectIcon(instance);
   }
  }

  for (int i = 0; i < currentEffectInstances.Count; i++) {
   string effectID = currentEffectInstances[i].effect.effectID;
   if (activeIcons.TryGetValue(effectID, out StatusEffectIconUI iconUI)) {
    iconUI.transform.SetSiblingIndex(i);
   }
  }
 }

 void CreateEffectIcon(StatusEffectInstance instance) {
  if (effectIconPrefab == null) {
   Debug.LogError("Effect Icon Prefab is missing!", this);
   return;
  }

  GameObject iconObj = Instantiate(effectIconPrefab, effectIconContainer);
  iconObj.SetActive(true);
  StatusEffectIconUI iconUI = iconObj.GetComponent<StatusEffectIconUI>();

  if (iconUI == null) iconUI = iconObj.AddComponent<StatusEffectIconUI>();

  iconUI.Initialize(instance);
  activeIcons[instance.effect.effectID] = iconUI;
 }

 void CreateDefaultIconPrefab() {
  float iconSize = 0.32f; // e.g., 0.32 world units
  float iconPadding = 0.04f;
  float fontSize = 0.2f;

  GameObject prefab = new GameObject("StatusEffectIcon");
  prefab.AddComponent<RectTransform>().sizeDelta = new Vector2(iconSize, iconSize);
  prefab.AddComponent<LayoutElement>();

  GameObject bg = new GameObject("Background");
  bg.transform.SetParent(prefab.transform, false);
  Image bgImage = bg.AddComponent<Image>();
  bgImage.color = new Color(0, 0, 0, 0.5f);
  bg.GetComponent<RectTransform>().sizeDelta = new Vector2(iconSize, iconSize);

  GameObject icon = new GameObject("Icon");
  icon.transform.SetParent(prefab.transform, false);
  Image iconImage = icon.AddComponent<Image>();
  iconImage.enabled = false;
  icon.GetComponent<RectTransform>().sizeDelta = new Vector2(iconSize - iconPadding, iconSize - iconPadding);

  GameObject unicodeTextGO = new GameObject("UnicodeText");
  unicodeTextGO.transform.SetParent(icon.transform, false);
  TextMeshProUGUI tmpText = unicodeTextGO.AddComponent<TextMeshProUGUI>();
  tmpText.text = "?";
  tmpText.fontSize = fontSize; // Use the smaller font size
  tmpText.alignment = TextAlignmentOptions.Center;
  tmpText.enabled = false;
  RectTransform textRect = tmpText.GetComponent<RectTransform>();
  textRect.anchorMin = Vector2.zero;
  textRect.anchorMax = Vector2.one;
  textRect.sizeDelta = Vector2.zero;
  textRect.anchoredPosition = Vector2.zero;

  effectIconPrefab = prefab;
  effectIconPrefab.SetActive(false);
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\UI\ThoughtBubbleController.cs

﻿// Assets/Scripts/Ecosystem/UI/ThoughtBubbleController.cs

using TMPro;
using WegoSystem;

pub class ThoughtBubbleController : MonoBehaviour {
 pub TMP_Text messageText;

 float lifetimeTicks;
 Transform followTarget;
 TickManager _tickManagerInstance; // Cached instance

 void Start() {
  _tickManagerInstance = TickManager.Instance;
  if (_tickManagerInstance == null) {
   Debug.LogWarning($"[{GetType().Name}] TickManager not found! Lifetime will use a fallback duration.", this);
  }
 }

 pub void Initialize(string message, Transform target, float durationInTicks) {
  if (messageText != null)
   messageText.text = message;

  followTarget = target;
  lifetimeTicks = durationInTicks;
 }

 void Update() {
  if (_tickManagerInstance?.Config != null) {
   lifetimeTicks -= _tickManagerInstance.Config.ticksPerRealSecond * Time.deltaTime;
  }
  else {
   lifetimeTicks -= 2f * Time.deltaTime;
  }

  if (lifetimeTicks <= 0f)
   Destroy(gameObject);

  if (followTarget != null) {
   transform.position = followTarget.position;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\UI\ThoughtTrigger.cs

﻿using UnityEngine;

pub enum ThoughtTrigger {
 Hungry,
 Eating,
 HealthLow,
 Fleeing,
 Pooping,
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Editor\RadiusPatternTester.cs

﻿using UnityEngine;
using WegoSystem;

#if UNITY_EDITOR
using UnityEditor;

pub class RadiusPatternTesterEditor : Editor {
 pub ovr void OnInspectorGUI() {
  DrawDefaultInspector();

  RadiusPatternTester tester = (RadiusPatternTester)target;

  if (GUILayout.Button("Test Radius Pattern")) {
   tester.TestRadiusPattern();
  }

  if (GUILayout.Button("Compare All Patterns")) {
   tester.CompareAllPatterns();
  }
 }
}
#endif

pub class RadiusPatternTester : MonoBehaviour {
 [Range(1, 10)]
 pub int testRadius = 3;

 pub void TestRadiusPattern() {
  GridRadiusUtility.DebugPrintRadius(GridPosition.Zero, testRadius);
 }

 pub void CompareAllPatterns() {
  Debug.Log("=== RADIUS PATTERN COMPARISON ===");

  for (int r = 1; r <= 5; r++) {
   Debug.Log($"\n--- Radius {r} ---");

   var circleTiles = GridRadiusUtility.GetTilesInCircle(GridPosition.Zero, r);
   Debug.Log($"Circle tiles: {circleTiles.Count}");

   GridRadiusUtility.DebugPrintRadius(GridPosition.Zero, r);

   int manhattanCount = 0;
   int chebyshevCount = 0;

   for (int x = -r; x <= r; x++) {
    for (int y = -r; y <= r; y++) {
     if (Mathf.Abs(x) + Mathf.Abs(y) <= r) manhattanCount++;
     if (Mathf.Max(Mathf.Abs(x), Mathf.Abs(y)) <= r) chebyshevCount++;
    }
   }

   Debug.Log($"Manhattan (diamond): {manhattanCount} tiles");
   Debug.Log($"Chebyshev (square): {chebyshevCount} tiles");
   Debug.Log($"Circle (ours): {circleTiles.Count} tiles");
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Editor\TileDefinitionEditor.cs

﻿#if UNITY_EDITOR
using UnityEditor;

pub class TileDefinitionEditor : Editor {
 pub ovr void OnInspectorGUI() {
  DrawDefaultInspector();

  TileDefinition tileDefinition = (TileDefinition)target;

  EditorGUILayout.Space();
  if (GUILayout.Button("UPDATE COLOR IN SCENE", GUILayout.Height(30))) {
   tileDefinition.UpdateColor();
  }
 }
}
#endif

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Editor\TileInteractionManagerEditor.cs

﻿using UnityEngine;
using UnityEditor;
using WegoSystem;

pub class TileInteractionManagerEditor : Editor {
 pub ovr void OnInspectorGUI() {
  DrawDefaultInspector();

  TileInteractionManager manager = (TileInteractionManager)target;

  EditorGUILayout.Space();
  EditorGUILayout.BeginHorizontal();

  if (GUILayout.Button("UPDATE SORTING ORDER", GUILayout.Height(30))) {
   if (manager != null) {
    manager.UpdateSortingOrder();
    EditorUtility.SetDirty(manager);
   }
  }

  if (GUILayout.Button("UPDATE ALL COLORS", GUILayout.Height(30))) {
   if (manager != null) {
    manager.UpdateAllColors();
    EditorUtility.SetDirty(manager);
   }
  }

  EditorGUILayout.EndHorizontal();

  if (manager != null) {
   EditorGUILayout.HelpBox("Order: First item in list gets highest sorting order value (" +
         manager.baseSortingOrder + "). Each subsequent item is " +
         (manager.baseSortingOrder - 1) + ", " +
         (manager.baseSortingOrder - 2) + ", etc.", MessageType.Info);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Editor\WaveDefinitionEditor.cs

﻿using UnityEngine;
using UnityEditor;
using UnityEditorInternal;

pub class WaveDefinitionEditor : Editor {
 ReorderableList spawnList;
 SerializedProperty spawnEntries;

 void OnEnable() {
  spawnEntries = serializedObject.FindProperty("spawnEntries");

  spawnList = new ReorderableList(serializedObject, spawnEntries, true, true, true, true);

  spawnList.drawHeaderCallback = (Rect rect) => {
   EditorGUI.LabelField(rect, "Spawn Entries");
  };

  spawnList.elementHeightCallback = (int index) => {
   return EditorGUIUtility.singleLineHeight * 4 + 10;
  };

  spawnList.drawElementCallback = (Rect rect, int index, bool isActive, bool isFocused) => {
   var element = spawnEntries.GetArrayElementAtIndex(index);
   rect.y += 2;

   float lineHeight = EditorGUIUtility.singleLineHeight;
   float spacing = 2;

   Rect descRect = new Rect(rect.x, rect.y, rect.width * 0.4f, lineHeight);
   Rect animalRect = new Rect(rect.x + rect.width * 0.42f, rect.y, rect.width * 0.58f, lineHeight);

   EditorGUI.PropertyField(descRect, element.FindPropertyRelative("description"), GUIContent.none);
   EditorGUI.PropertyField(animalRect, element.FindPropertyRelative("animalDefinition"), GUIContent.none);

   rect.y += lineHeight + spacing;

   Rect countRect = new Rect(rect.x, rect.y, rect.width * 0.3f, lineHeight);
   Rect delayRect = new Rect(rect.x + rect.width * 0.32f, rect.y, rect.width * 0.3f, lineHeight);
   Rect intervalRect = new Rect(rect.x + rect.width * 0.64f, rect.y, rect.width * 0.36f, lineHeight);

   EditorGUI.LabelField(countRect, "Count:");
   countRect.x += 40;
   countRect.width -= 40;
   EditorGUI.PropertyField(countRect, element.FindPropertyRelative("spawnCount"), GUIContent.none);

   EditorGUI.LabelField(delayRect, "Delay:");
   delayRect.x += 35;
   delayRect.width -= 35;
   EditorGUI.PropertyField(delayRect, element.FindPropertyRelative("delayAfterSpawnTime"), GUIContent.none);

   EditorGUI.LabelField(intervalRect, "Interval:");
   intervalRect.x += 45;
   intervalRect.width -= 45;
   EditorGUI.PropertyField(intervalRect, element.FindPropertyRelative("spawnInterval"), GUIContent.none);

   rect.y += lineHeight + spacing;

   Rect locTypeRect = new Rect(rect.x, rect.y, rect.width * 0.6f, lineHeight);
   Rect radiusRect = new Rect(rect.x + rect.width * 0.62f, rect.y, rect.width * 0.38f, lineHeight);

   EditorGUI.PropertyField(locTypeRect, element.FindPropertyRelative("spawnLocationType"), GUIContent.none);

   EditorGUI.LabelField(radiusRect, "Radius:");
   radiusRect.x += 45;
   radiusRect.width -= 45;
   EditorGUI.PropertyField(radiusRect, element.FindPropertyRelative("spawnRadius"), GUIContent.none);
  };

  spawnList.onAddCallback = (ReorderableList list) => {
   var index = list.serializedProperty.arraySize;
   list.serializedProperty.arraySize++;
   list.index = index;

   var element = list.serializedProperty.GetArrayElementAtIndex(index);
   element.FindPropertyRelative("description").stringValue = "New Spawn Entry";
   element.FindPropertyRelative("spawnCount").intValue = 1;
   element.FindPropertyRelative("delayAfterSpawnTime").floatValue = 0f;
   element.FindPropertyRelative("spawnInterval").floatValue = 0.5f;
   element.FindPropertyRelative("spawnRadius").floatValue = 5f;
  };
 }

 pub ovr void OnInspectorGUI() {
  serializedObject.Update();

  WaveDefinition waveDef = (WaveDefinition)target;

  EditorGUILayout.LabelField("Wave Definition", EditorStyles.boldLabel);
  EditorGUILayout.Space();

  EditorGUILayout.BeginHorizontal();
  EditorGUILayout.LabelField("Wave Name:", GUILayout.Width(80));
  SerializedProperty waveNameProp = serializedObject.FindProperty("waveName");
  waveNameProp.stringValue = EditorGUILayout.TextField(waveNameProp.stringValue);
  EditorGUILayout.EndHorizontal();

  EditorGUILayout.Space();

  int totalEnemies = 0;
  float totalDuration = 0;

  foreach (WaveSpawnEntry entry in waveDef.spawnEntries) {
   if (entry != null) {
    totalEnemies += entry.spawnCount;
    totalDuration = Mathf.Max(totalDuration,
     entry.delayAfterSpawnTime + (entry.spawnCount - 1) * entry.spawnInterval);
   }
  }

  EditorGUILayout.HelpBox(
   $"Total Enemies: {totalEnemies}\n" +
   $"Spawn Duration: ~{totalDuration:F1} seconds",
   MessageType.Info
  );

  EditorGUILayout.Space();

  spawnList.DoLayoutList();

  serializedObject.ApplyModifiedProperties();

  EditorGUILayout.Space();

  if (GUILayout.Button("Clear All Entries")) {
   if (EditorUtility.DisplayDialog("Clear All Entries",
    "Are you sure you want to remove all spawn entries?",
    "Clear", "Cancel")) {
    waveDef.spawnEntries.Clear();
    EditorUtility.SetDirty(waveDef);
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Editor\WaveManagerEditor.cs

﻿using UnityEngine;
using UnityEditor;
using WegoSystem;

pub class WaveManagerEditor : Editor {
 SerializedProperty waveDurationInDays;
 SerializedProperty spawnTimeNormalized;
 SerializedProperty continuousSpawning;
 SerializedProperty deletePreviousWaveAnimals;
 SerializedProperty wavesSequence;

 bool showTimingSettings = true;
 bool showWaveSequence = true;
 bool showDebugInfo = false;

 void OnEnable() {
  waveDurationInDays = serializedObject.FindProperty("waveDurationInDays");
  spawnTimeNormalized = serializedObject.FindProperty("spawnTimeNormalized");
  continuousSpawning = serializedObject.FindProperty("continuousSpawning");
  deletePreviousWaveAnimals = serializedObject.FindProperty("deletePreviousWaveAnimals");
  wavesSequence = serializedObject.FindProperty("wavesSequence");
 }

 pub ovr void OnInspectorGUI() {
  serializedObject.Update();

  WaveManager waveManager = (WaveManager)target;

  EditorGUILayout.LabelField("Wave Manager", EditorStyles.boldLabel);
  EditorGUILayout.Space();

  DrawPropertiesExcluding(serializedObject,
   "waveDurationInDays",
   "spawnTimeNormalized",
   "continuousSpawning",
   "deletePreviousWaveAnimals",
   "wavesSequence"
  );

  EditorGUILayout.Space();

  showTimingSettings = EditorGUILayout.BeginFoldoutHeaderGroup(showTimingSettings, "Wave Timing Settings");
  if (showTimingSettings) {
   EditorGUI.indentLevel++;

   EditorGUILayout.BeginHorizontal();
   EditorGUILayout.PropertyField(waveDurationInDays, new GUIContent("Wave Duration (Days)"));
   EditorGUILayout.EndHorizontal();

   if (Application.isPlaying && TickManager.Instance?.Config != null) {
    var config = TickManager.Instance.Config;
    int totalTicks = config.ticksPerDay * waveDurationInDays.intValue;
    EditorGUILayout.HelpBox($"Wave will last {totalTicks} ticks", MessageType.Info);
   }

   EditorGUILayout.Space();

   float spawnPercent = spawnTimeNormalized.floatValue * 100f;
   EditorGUILayout.LabelField($"Spawn Start: {spawnPercent:F0}% into wave");
   spawnTimeNormalized.floatValue = EditorGUILayout.Slider("Spawn Time", spawnTimeNormalized.floatValue, 0f, 1f);

   DrawTimingBar(spawnTimeNormalized.floatValue);

   EditorGUILayout.Space();

   EditorGUILayout.PropertyField(continuousSpawning, new GUIContent("Continuous Spawning", "If enabled, enemies spawn throughout the wave"));

   EditorGUI.indentLevel--;
  }
  EditorGUILayout.EndFoldoutHeaderGroup();

  EditorGUILayout.Space();

  EditorGUILayout.PropertyField(deletePreviousWaveAnimals, new GUIContent("Clear Previous Wave", "Delete all animals when starting a new wave"));

  EditorGUILayout.Space();

  showWaveSequence = EditorGUILayout.BeginFoldoutHeaderGroup(showWaveSequence, "Wave Sequence");
  if (showWaveSequence) {
   EditorGUI.indentLevel++;

   if (wavesSequence.arraySize == 0) {
    EditorGUILayout.HelpBox("No waves defined! Add wave definitions to the sequence.", MessageType.Warning);
   }

   for (int i = 0; i < wavesSequence.arraySize; i++) {
    EditorGUILayout.BeginHorizontal();

    var element = wavesSequence.GetArrayElementAtIndex(i);
    var waveDef = element.objectReferenceValue as WaveDefinition;

    string label = $"Round {i + 1}";
    if (waveDef != null && !string.IsNullOrEmpty(waveDef.waveName)) {
     label += $": {waveDef.waveName}";
    }

    EditorGUILayout.PropertyField(element, new GUIContent(label));

    if (GUILayout.Button("X", GUILayout.Width(20))) {
     wavesSequence.DeleteArrayElementAtIndex(i);
     break;
    }

    EditorGUILayout.EndHorizontal();
   }

   EditorGUILayout.BeginHorizontal();
   GUILayout.FlexibleSpace();
   if (GUILayout.Button("Add Wave", GUILayout.Width(100))) {
    wavesSequence.InsertArrayElementAtIndex(wavesSequence.arraySize);
   }
   EditorGUILayout.EndHorizontal();

   EditorGUI.indentLevel--;
  }
  EditorGUILayout.EndFoldoutHeaderGroup();

  EditorGUILayout.Space();

  // Runtime Debug Info
  if (Application.isPlaying) {
   showDebugInfo = EditorGUILayout.BeginFoldoutHeaderGroup(showDebugInfo, "Runtime Debug");
   if (showDebugInfo) {
    EditorGUI.indentLevel++;

    EditorGUILayout.LabelField("Status", waveManager.IsWaveActive ? "Wave Active" : "Idle");

    if (waveManager.IsWaveActive && TickManager.Instance != null) {
     EditorGUILayout.Space();
     DrawRuntimeWaveProgress(waveManager);
    }

    EditorGUILayout.Space();

    // Debug buttons
    EditorGUILayout.BeginHorizontal();
    if (GUILayout.Button("Force End Wave")) {
     waveManager.SendMessage("Debug_ForceEndWave", SendMessageOptions.DontRequireReceiver);
    }
    if (GUILayout.Button("Force Spawn")) {
     waveManager.SendMessage("Debug_ForceSpawn", SendMessageOptions.DontRequireReceiver);
    }
    EditorGUILayout.EndHorizontal();

    EditorGUI.indentLevel--;
   }
   EditorGUILayout.EndFoldoutHeaderGroup();
  }

  serializedObject.ApplyModifiedProperties();
 }

 void DrawTimingBar(float spawnTime) {
  Rect rect = GUILayoutUtility.GetRect(0, 20, GUILayout.ExpandWidth(true));

  EditorGUI.DrawRect(rect, new Color(0.2f, 0.2f, 0.2f));

  Rect waveRect = new Rect(rect.x, rect.y, rect.width, rect.height);
  EditorGUI.DrawRect(waveRect, new Color(0.3f, 0.5f, 0.3f));

  float spawnX = rect.x + (rect.width * spawnTime);
  Rect spawnRect = new Rect(spawnX - 2, rect.y, 4, rect.height);
  EditorGUI.DrawRect(spawnRect, Color.yellow);

  GUI.Label(new Rect(rect.x, rect.y, 50, rect.height), "Start", EditorStyles.miniLabel);
  GUI.Label(new Rect(rect.x + rect.width - 30, rect.y, 30, rect.height), "End", EditorStyles.miniLabel);
  GUI.Label(new Rect(spawnX - 25, rect.y - 20, 50, 20), "Spawn", EditorStyles.centeredGreyMiniLabel);
 }

 void DrawRuntimeWaveProgress(WaveManager waveManager) {
  EditorGUILayout.HelpBox("Wave progress visualization requires exposing runtime data", MessageType.Info);
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Core\GeneLibraryLoader.cs

﻿using UnityEngine;
using Abracodabra.Genes;
using Abracodabra.Genes.Services;

pub class GeneLibraryLoader : MonoBehaviour {
 [SerializeField]
 GeneLibrary geneLibraryAsset;

 void Awake() {

  if (geneLibraryAsset == null) {
   Debug.LogError("CRITICAL: The GeneLibrary Asset is not assigned in the GeneLibraryLoader component! The gene system will not work.", this);
   return;
  }

  geneLibraryAsset.SetActiveInstance();

  GeneServices.Register<IGeneLibrary>(geneLibraryAsset);

  Debug.Log("GeneLibrary instance was successfully set, initialized, and registered by GeneLibraryLoader.");
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Items\ItemDefinition.cs

﻿using UnityEngine;

// Note: ItemEffect is not defined yet, so it's commented out for now to prevent errors.

pub enum ItemCategory {
 Consumable,  // Food, potions
 Resource,    // Crafting materials
 QuestItem    // Example for future expansion
}

pub class ItemDefinition : ScriptableObject {
 [Header("Basic Info")]
 pub string itemName;
 pub string description;
 pub Sprite icon;

 [Header("Item Properties")]
 pub ItemCategory category = ItemCategory.Consumable;
 pub int maxStackSize = 99;
 pub float baseValue = 1f;

 [Header("World Representation")]
 pub GameObject droppedItemPrefab; // For dropping items in the world

 [Header("Consumption Effects")]
 pub bool isConsumable = false;
 pub float baseNutrition = 0f;
 pub float baseHealing = 0f;

}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Items\ItemInstance.cs

﻿using System;

pub class ItemInstance {
 pub ItemDefinition definition;
 pub Dictionary<string, float> dynamicProperties;
 pub int stackCount = 1;

 pub ItemInstance(ItemDefinition def, Dictionary<string, float> props = null) {
  definition = def;
  dynamicProperties = props ?? new Dictionary<string, float>();
  stackCount = 1;
 }

 pub float GetNutrition() {
  if (definition == null) return 0f;

  float finalNutrition = definition.baseNutrition;
  if (dynamicProperties.TryGetValue("nutrition_multiplier", out float multiplier)) {
   finalNutrition *= multiplier;
  }
  if (dynamicProperties.TryGetValue("nutrition_add", out float additive)) {
   finalNutrition += additive;
  }
  return finalNutrition;
 }

 pub float GetHealAmount() {
  if (definition == null) return 0f;
  return definition.baseHealing;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\Data\ITriggerTarget.cs

﻿// Assets/Scripts/PlantSystem/Execution/ITriggerTarget.cs

pub interface ITriggerTarget {
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\Data\LeafData.cs

﻿using UnityEngine;

pub struct LeafData {
 pub Vector2Int GridCoord;
 pub bool IsActive; // True if the leaf exists, false if it was eaten

 pub LeafData(Vector2Int coord, bool isActive = true) {
  GridCoord = coord;
  IsActive = isActive;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\Execution\NodeExecutor.cs

﻿using UnityEngine;
using Abracodabra.Genes;
using WegoSystem;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;

pub class NodeExecutor : MonoBehaviour {
 [SerializeField] GameObject plantPrefab;

 pub GameObject SpawnPlantFromState(PlantGeneRuntimeState runtimeState, Vector3 plantingPosition, Transform parentTransform) {
  if (runtimeState == null) {
   Debug.LogError("[NodeExecutor] Cannot spawn plant: Provided PlantGeneRuntimeState is null!");
   return null;
  }

  if (plantPrefab == null) {
   Debug.LogError("[NodeExecutor] Plant prefab not assigned!");
   return null;
  }

  GameObject plantObj = Instantiate(plantPrefab, plantingPosition, Quaternion.identity, parentTransform);

  PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
  if (growthComponent != null) {
   growthComponent.InitializeWithState(runtimeState);
   Debug.Log($"[NodeExecutor] Plant spawned from seed template '{runtimeState.template.templateName}'");
   return plantObj;
  }
  else {
   Debug.LogError($"[NodeExecutor] Plant prefab is missing the required PlantGrowth component!");
   Destroy(plantObj);
   return null;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\Growth\PlantCell.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/Growth/PlantCell.cs

using Abracodabra.Genes;

pub enum PlantCellType { Seed, Stem, Leaf, Flower, Fruit }

pub class PlantCell : MonoBehaviour {
 [HideInInspector] pub PlantGrowth ParentPlantGrowth;
 [HideInInspector] pub Vector2Int GridCoord;
 [HideInInspector] pub PlantCellType CellType;

 void OnDestroy() {
  if (ParentPlantGrowth != null) {
   ParentPlantGrowth.ReportCellDestroyed(GridCoord);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\Growth\PlantCellManager.cs

﻿using UnityEngine;
using Abracodabra.Genes;
using WegoSystem;

pub class PlantCellManager {
 ro PlantGrowth plant;
 ro GameObject seedCellPrefab;
 ro GameObject stemCellPrefab;
 ro GameObject leafCellPrefab;
 ro GameObject berryCellPrefab;
 ro FoodType _leafFoodType;

 pub ro Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
 ro List<GameObject> activeCellGameObjects = new List<GameObject>();

 pub List<LeafData> LeafDataList { get; } = new List<LeafData>();
 pub GameObject RootCellInstance { get; set; }

 pub PlantCellManager(PlantGrowth plant, GameObject seedPrefab, GameObject stemPrefab, GameObject leafPrefab, GameObject berryPrefab, FoodType leafFoodType) {
  this.plant = plant;
  this.seedCellPrefab = seedPrefab;
  this.stemCellPrefab = stemPrefab;
  this.leafCellPrefab = leafPrefab;
  this.berryCellPrefab = berryPrefab;
  this._leafFoodType = leafFoodType;
 }

 pub GameObject SpawnCellVisual(PlantCellType cellType, Vector2Int coords) {
  if (cells.ContainsKey(coords)) {
   Debug.LogWarning($"[{plant.gameObject.name}] Cell already exists at {coords}. Skipping spawn.");
   return GetCellGameObjectAt(coords);
  }

  GameObject prefab = GetPrefabForType(cellType);
  if (prefab == null) return null;

  float spacing = plant.GetCellWorldSpacing();
  Vector3 cellLocalPos = new Vector3(coords.x * spacing, coords.y * spacing, 0);
  Vector3 cellWorldPos = plant.transform.position + cellLocalPos;

  GameObject instance = Object.Instantiate(prefab, cellWorldPos, Quaternion.identity, plant.transform);

  PlantCell cellComponent = instance.GetComponent<PlantCell>();
  if (cellComponent == null) {
   cellComponent = instance.AddComponent<PlantCell>();
  }
  cellComponent.ParentPlantGrowth = plant;
  cellComponent.GridCoord = coords;
  cellComponent.CellType = cellType;

  cells[coords] = cellType;
  activeCellGameObjects.Add(instance);

  if (cellType == PlantCellType.Seed) {
   RootCellInstance = instance;
  }
  else if (cellType == PlantCellType.Leaf) {
   LeafDataList.Add(new LeafData(coords, true));

   var foodItem = instance.GetComponent<FoodItem>();
   if (foodItem != null) {
    if (_leafFoodType == null) {
     Debug.LogError($"[PlantCellManager] Cannot assign FoodType to new leaf on '{plant.name}' because the 'Leaf Food Type' field is not set!", plant);
    }

    GridPosition gridPos = GridPositionManager.Instance.WorldToGrid(cellWorldPos);

    foodItem.InitializeAsPlantPart(_leafFoodType, gridPos);
   }
   else {
    Debug.LogWarning($"[{plant.gameObject.name}] Leaf prefab is missing FoodItem component.", plant);
   }
  }
  else if (cellType == PlantCellType.Fruit) {
  }

  plant.VisualManager.RegisterShadowForCell(instance, cellType.ToString());
  plant.VisualManager.RegisterOutlineForCell(instance, cellType.ToString());

  return instance;
 }

 pub void ReportCellDestroyed(Vector2Int coord) {
  if (cells.TryGetValue(coord, out PlantCellType cellType)) {
   GameObject cellObj = GetCellGameObjectAt(coord);

   if (cellObj != null) {
    plant.VisualManager.UnregisterShadowForCell(cellObj);
    plant.VisualManager.OutlineController?.OnPlantCellRemoved(coord);
    activeCellGameObjects.Remove(cellObj);
    Object.Destroy(cellObj);
   }

   if (cellType == PlantCellType.Leaf) {
    for (int i = 0; i < LeafDataList.Count; i++) {
     if (LeafDataList[i].GridCoord == coord) {
      LeafDataList[i] = new LeafData(coord, false);
      break;
     }
    }
   }

   cells.Remove(coord);
  }
 }

 pub void ClearAllVisuals() {
  foreach (GameObject cellGO in new List<GameObject>(activeCellGameObjects)) {
   if (cellGO != null) {
    Object.Destroy(cellGO);
   }
  }
  activeCellGameObjects.Clear();
  cells.Clear();
  RootCellInstance = null;
 }

 GameObject GetPrefabForType(PlantCellType cellType) {
  switch (cellType) {
   case PlantCellType.Seed: return seedCellPrefab;
   case PlantCellType.Stem: return stemCellPrefab;
   case PlantCellType.Leaf: return leafCellPrefab;
   case PlantCellType.Fruit: return berryCellPrefab;
   default:
    Debug.LogError($"[{plant.gameObject.name}] No prefab assigned for PlantCellType.{cellType}!");
    return null;
  }
 }

 pub bool HasCellAt(Vector2Int coord) => cells.ContainsKey(coord);
 pub GameObject GetCellGameObjectAt(Vector2Int coord) => activeCellGameObjects.FirstOrDefault(go => go != null && go.GetComponent<PlantCell>()?.GridCoord == coord);
 pub int GetActiveLeafCount() => LeafDataList.Count(leaf => leaf.IsActive);
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\Growth\PlantEnergySystem.cs

﻿using Abracodabra.Genes;
using WegoSystem;

pub class PlantEnergySystem {
 ro PlantGrowth plant;

 pub float CurrentEnergy { get; set; }
 pub float MaxEnergy { get; set; }
 pub float BaseEnergyPerLeaf { get; set; } // Base rate from template

 ro FireflyManager fireflyManagerInstance;

 pub PlantEnergySystem(PlantGrowth plant) {
  this.plant = plant;
  this.fireflyManagerInstance = FireflyManager.Instance;
 }

 pub void OnTickUpdate() {
  if (plant.CurrentState == PlantState.Growing &&
   plant.gameObject.GetComponent<PlantGrowth>()?.rechargeEnergyDuringGrowth == false) {
   return;
  }

  if (plant.GrowthLogic == null || MaxEnergy <= 0) return;

  int leafCount = plant.CellManager.GetActiveLeafCount();
  if (leafCount <= 0) return;

  float sunlight = (WeatherManager.Instance != null) ? WeatherManager.Instance.sunIntensity : 1f;

  float fireflyBonusRate = 0f;
  if (fireflyManagerInstance != null && fireflyManagerInstance.isActiveAndEnabled) {
   int nearbyFlyCount = fireflyManagerInstance.GetNearbyFireflyCount(plant.transform.position, fireflyManagerInstance.photosynthesisRadius);
   fireflyBonusRate = Mathf.Min(
    nearbyFlyCount * fireflyManagerInstance.photosynthesisIntensityPerFly,
    fireflyManagerInstance.maxPhotosynthesisBonus
   );
  }

  float effectiveRate = BaseEnergyPerLeaf * plant.energyGenerationMultiplier;
  float totalPhotosynthesisRatePerLeaf = (effectiveRate * sunlight) + fireflyBonusRate;
  float energyThisTick = totalPhotosynthesisRatePerLeaf * leafCount;

  CurrentEnergy = UnityEngine.Mathf.Clamp(CurrentEnergy + energyThisTick, 0f, MaxEnergy);
 }

 pub void SpendEnergy(float amount) {
  CurrentEnergy = UnityEngine.Mathf.Max(0f, CurrentEnergy - amount);
 }

 pub void AddEnergy(float amount) {
  CurrentEnergy = UnityEngine.Mathf.Clamp(CurrentEnergy + amount, 0f, MaxEnergy);
 }

 pub bool HasEnergy(float amount) {
  return CurrentEnergy >= amount;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\Growth\PlantGrowthLogic.cs

﻿using UnityEngine;
using Abracodabra.Genes;
using Abracodabra.Genes.Core;

pub class PlantGrowthLogic {
 ro PlantGrowth plant;

 pub int TargetStemLength { get; set; }
 pub int GrowthTicksPerStage { get; set; }
 pub float PhotosynthesisEfficiencyPerLeaf { get; set; }

 pub PlantGrowthLogic(PlantGrowth plant) {
  this.plant = plant;
 }

 pub void CalculateAndApplyPassiveStats() {
  if (plant.geneRuntimeState == null) {
   Debug.LogError($"[{plant.gameObject.name}] CalculateAndApplyStats called with null geneRuntimeState!");
   return;
  }

  plant.growthSpeedMultiplier = 1f;
  plant.energyGenerationMultiplier = 1f;
  plant.energyStorageMultiplier = 1f;
  plant.fruitYieldMultiplier = 1f;

  var additiveBonuses = new Dictionary<PassiveStatType, float>();
  var multiplicativeBonuses = new Dictionary<PassiveStatType, float>();

  foreach (var instance in plant.geneRuntimeState.passiveInstances) {
   var passiveGene = instance.GetGene<PassiveGene>();
   if (passiveGene == null) continue;

   if (passiveGene.statToModify == PassiveStatType.None) {
    Debug.Log($"[{plant.gameObject.name}] Passive gene '{passiveGene.geneName}' has statToModify=None, skipping stat application.");
    continue;
   }

   float value = passiveGene.baseValue * instance.GetValue("power_multiplier", 1f);

   if (passiveGene.stacksAdditively) {
    if (!additiveBonuses.ContainsKey(passiveGene.statToModify))
     additiveBonuses[passiveGene.statToModify] = 0f;
    additiveBonuses[passiveGene.statToModify] += (value - 1f);
   }
   else {
    if (!multiplicativeBonuses.ContainsKey(passiveGene.statToModify))
     multiplicativeBonuses[passiveGene.statToModify] = 1f;
    multiplicativeBonuses[passiveGene.statToModify] *= value;
   }
  }

  foreach (var kvp in additiveBonuses) {
   ApplyStat(kvp.Key, 1f + kvp.Value);
  }
  foreach (var kvp in multiplicativeBonuses) {
   ApplyStat(kvp.Key, kvp.Value);
  }

  if (plant.EnergySystem != null) {
   plant.EnergySystem.BaseEnergyPerLeaf = PhotosynthesisEfficiencyPerLeaf;
  }

  Debug.Log($"[{plant.gameObject.name}] Final stats after passives: " +
   $"GrowthSpeed={plant.growthSpeedMultiplier:F2}x, " +
   $"EnergyGen={plant.energyGenerationMultiplier:F2}x, " +
   $"EnergyStore={plant.energyStorageMultiplier:F2}x, " +
   $"FruitYield={plant.fruitYieldMultiplier:F2}x");
 }

 void ApplyStat(PassiveStatType stat, float value) {
  switch (stat) {
   case PassiveStatType.None:
    break;
   case PassiveStatType.GrowthSpeed:
    plant.growthSpeedMultiplier *= value;
    break;
   case PassiveStatType.EnergyGeneration:
    plant.energyGenerationMultiplier *= value;
    break;
   case PassiveStatType.EnergyStorage:
    plant.energyStorageMultiplier *= value;
    break;
   case PassiveStatType.FruitYield:
    plant.fruitYieldMultiplier *= value;
    break;
   case PassiveStatType.Defense:
    break;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\Growth\PlantVisualManager.cs

﻿using UnityEngine;
using Abracodabra.Genes;
using TMPro;

pub class PlantVisualManager {
 ro PlantGrowth plant;
 ro PlantShadowController shadowController;
 ro GameObject shadowPartPrefab;
 ro bool enableOutline;
 pub PlantOutlineController OutlineController { get; set; }
 ro GameObject outlinePartPrefab;
 TMP_Text energyText;

pub PlantVisualManager(PlantGrowth plant, PlantShadowController shadowController, GameObject shadowPartPrefab, PlantOutlineController outlineController, GameObject outlinePartPrefab, bool enableOutline) {
  this.plant = plant;
  this.shadowController = shadowController;
  this.shadowPartPrefab = shadowPartPrefab;
  this.OutlineController = outlineController;
  this.outlinePartPrefab = outlinePartPrefab;
  this.enableOutline = enableOutline;

  FindEnergyTextComponent();
 }

 void FindEnergyTextComponent() {
  energyText = plant.GetComponentInChildren<TMP_Text>(true);

  if (energyText == null) {
   GameObject textObj = new GameObject("EnergyText");
   textObj.transform.SetParent(plant.transform);
   textObj.transform.localPosition = new Vector3(0, -0.5f, 0);

   energyText = textObj.AddComponent<TextMeshPro>();
   energyText.text = "0/0";
   energyText.fontSize = 2;
   energyText.alignment = TextAlignmentOptions.Center;

   MeshRenderer textRenderer = energyText.GetComponent<MeshRenderer>();
   if (textRenderer != null) {
    textRenderer.sortingOrder = 100; // Ensure it renders on top
   }
  }
 }

 pub void RegisterShadowForCell(GameObject cellInstance, string cellTypeName) {
  if (shadowController != null && shadowPartPrefab != null && cellInstance != null &&
   cellInstance.TryGetComponent<SpriteRenderer>(out var partRenderer)) {
   shadowController.RegisterPlantPart(partRenderer, shadowPartPrefab);
  }
 }

 pub void UnregisterShadowForCell(GameObject cellInstance) {
  if (shadowController != null && cellInstance != null &&
   cellInstance.TryGetComponent<SpriteRenderer>(out var partRenderer)) {
   shadowController.UnregisterPlantPart(partRenderer);
  }
 }

 pub void RegisterOutlineForCell(GameObject cellInstance, string cellTypeName) {
  if (enableOutline && OutlineController != null && cellInstance != null &&
   cellInstance.TryGetComponent<SpriteRenderer>(out var partRenderer)) {
   OutlineController.RegisterPlantPart(partRenderer, outlinePartPrefab);
  }
 }

 pub void UpdateUI() {
  if (energyText == null) {
   FindEnergyTextComponent();
   if (energyText == null) return;
  }

  if (plant.CurrentState == PlantState.Growing || plant.CurrentState == PlantState.Initializing) {
   UpdateGrowthPercentageUI();
  }
  else {
   UpdateEnergyUI();
  }
 }

 void UpdateGrowthPercentageUI() {
  if (energyText != null) {
   int currentHeight = plant.CellManager.cells.Count(c => c.Value == PlantCellType.Stem);
   int maxHeight = plant.maxHeight;
   float percentage = (maxHeight > 0) ? (currentHeight / (float)maxHeight * 100f) : 0f;
   energyText.text = $"Growing {percentage:F0}%";
  }
 }

 void UpdateEnergyUI() {
  if (energyText == null || plant.EnergySystem == null) return;

  float currentEnergy = plant.EnergySystem.CurrentEnergy;
  float maxEnergy = plant.EnergySystem.MaxEnergy;
  energyText.text = $"{currentEnergy:F0}/{maxEnergy:F0}";
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\UI\StartingInventory.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;
using Abracodabra.UI.Genes; // Assuming ToolDefinition is here for now

pub class StartingInventory : ScriptableObject {
 [Header("Starting Genes")]
 [Tooltip("These are raw genes that the player can slot into seeds.")]
 pub List<GeneBase> startingGenes = new List<GeneBase>();

 [Header("Starting Seeds")]
 [Tooltip("These are pre-configured seed templates that will appear in the inventory.")]
 pub List<SeedTemplate> startingSeeds = new List<SeedTemplate>();

 [Header("Starting Tools")]
 [Tooltip("Tools the player begins the game with.")]
 pub List<ToolDefinition> startingTools = new List<ToolDefinition>();
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\Visual\OutlinePartController.cs

﻿using UnityEngine;
using Abracodabra.Genes;

pub class OutlinePartController : MonoBehaviour {
 SpriteRenderer outlineRenderer;
 Transform cachedTransform;
 SpriteRenderer sourcePlantPartRenderer;

 pub Vector2Int gridCoord;

 void Awake() {
  outlineRenderer = GetComponent<SpriteRenderer>();
  cachedTransform = transform;

  if (outlineRenderer != null) {
   outlineRenderer.drawMode = SpriteDrawMode.Simple;
   outlineRenderer.enabled = false;
  }
 }

 pub void Initialize(SpriteRenderer sourceRenderer, Vector2Int myCoord, PlantOutlineController controller) {
  if (sourceRenderer == null || controller == null) {
   Destroy(gameObject);
   return;
  }

  sourcePlantPartRenderer = sourceRenderer;
  gridCoord = myCoord;

  if (outlineRenderer != null) {
   outlineRenderer.sortingLayerID = controller.OutlineSortingLayer;
   outlineRenderer.sortingOrder = controller.OutlineSortingOrder;
   outlineRenderer.color = controller.OutlineColor;
  }

  cachedTransform.SetParent(controller.transform, true);

  PlantGrowth plant = controller.GetComponentInParent<PlantGrowth>();
  float spacing = 1f; // Default fallback

  if (plant != null) {
   spacing = plant.GetCellWorldSpacing();
  }

  cachedTransform.localPosition = (Vector2)myCoord * spacing;

  if (outlineRenderer != null) {
   outlineRenderer.enabled = IsSourceRendererValid() &&
         sourcePlantPartRenderer.enabled &&
         sourcePlantPartRenderer.sprite != null;
  }

  SyncSpriteAndTransform();
 }

 void LateUpdate() {
  if (outlineRenderer == null || !outlineRenderer.enabled) return;

  if (!IsSourceRendererValid()) {
   SetVisibility(false);
   return;
  }

  if (!sourcePlantPartRenderer.enabled || sourcePlantPartRenderer.sprite == null) {
   SetVisibility(false);
   return;
  }

  SyncSpriteAndTransform();
 }

 pub bool IsSourceRendererValid() {
  if (sourcePlantPartRenderer == null) return false;
  if (!sourcePlantPartRenderer.gameObject.activeInHierarchy) return false;
  return true;
 }

 pub void UpdateSourceRenderer(SpriteRenderer newSource) {
  if (newSource != null) {
   sourcePlantPartRenderer = newSource;
   SetVisibility(outlineRenderer != null && sourcePlantPartRenderer.enabled && sourcePlantPartRenderer.sprite != null);
   SyncSpriteAndTransform();
  }
  else {
   SetVisibility(false);
  }
 }

 pub void SyncSpriteAndTransform() {
  if (!IsSourceRendererValid() || outlineRenderer == null) return;
  if (outlineRenderer.sprite != sourcePlantPartRenderer.sprite) {
   outlineRenderer.sprite = sourcePlantPartRenderer.sprite;
  }
  cachedTransform.localScale = sourcePlantPartRenderer.transform.localScale;
  outlineRenderer.flipX = sourcePlantPartRenderer.flipX;
  outlineRenderer.flipY = sourcePlantPartRenderer.flipY;
 }

 pub void SetVisibility(bool isVisible) {
  if (outlineRenderer != null && outlineRenderer.enabled != isVisible) {
   outlineRenderer.enabled = isVisible;
  }
 }

 pub void DestroyOutlinePart() {
  if (this != null && gameObject != null) {
   if (Application.isPlaying) { Destroy(gameObject); }
   else { DestroyImmediate(gameObject); }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\Visual\PlantOutlineController.cs

﻿// REWORKED FILE: Assets/Scripts/PlantSystem/Visual/PlantOutlineController.cs
using Abracodabra.Genes;

pub class PlantOutlineController : MonoBehaviour {
 [SerializeField] Color outlineColor = Color.black;
 [SerializeField] pub GameObject outlinePartPrefab;
 [SerializeField] string outlineSortingLayerName = "Default";
 [SerializeField] int outlineSortingOrder = -1;
 [SerializeField] bool debugLogging = false;

 pub Color OutlineColor => outlineColor;
 pub int OutlineSortingLayer => outlineSortingLayerID;
 pub int OutlineSortingOrder => outlineSortingOrder;

 int outlineSortingLayerID;
 PlantGrowth parentPlantGrowth;
 Dictionary<Vector2Int, OutlinePartController> outlinePartMap = new Dictionary<Vector2Int, OutlinePartController>();
 HashSet<Vector2Int> plantCellCoords = new HashSet<Vector2Int>();

 stat ro Vector2Int[] neighborOffsets = {
  new Vector2Int(-1, -1), new Vector2Int(0, -1), new Vector2Int(1, -1),
  new Vector2Int(-1, 0),                         new Vector2Int(1, 0),
  new Vector2Int(-1, 1),  new Vector2Int(0, 1),  new Vector2Int(1, 1)
 };

 void Awake() {
  parentPlantGrowth = GetComponentInParent<PlantGrowth>();
  if (parentPlantGrowth == null) {
   Debug.LogError($"[{gameObject.name}] Missing PlantGrowth parent!", gameObject);
   enabled = false;
   return;
  }
  outlineSortingLayerID = SortingLayer.NameToID(outlineSortingLayerName);
 }

 pub void RegisterPlantPart(SpriteRenderer plantPartRenderer, GameObject prefab) {
  if (plantPartRenderer == null) return;
  PlantCell plantCell = plantPartRenderer.GetComponentInParent<PlantCell>();
  if (plantCell != null) {
   OnPlantCellAdded(plantCell.GridCoord, plantCell.gameObject);
  }
 }

 pub void OnPlantCellAdded(Vector2Int plantCoord, GameObject plantCellGO) {
  if (plantCellGO == null) return;

  plantCellCoords.Add(plantCoord);
  RemoveOutlinePartIfExists(plantCoord);

  SpriteRenderer plantRenderer = plantCellGO.GetComponentInChildren<SpriteRenderer>();
  if (plantRenderer == null) return;

  foreach (var offset in neighborOffsets) {
   Vector2Int neighborCoord = plantCoord + offset;
   if (!plantCellCoords.Contains(neighborCoord) && !outlinePartMap.ContainsKey(neighborCoord)) {
    CreateOutlinePart(neighborCoord, plantRenderer);
   }
  }
 }

 pub void OnPlantCellRemoved(Vector2Int plantCoord) {
  if (!plantCellCoords.Remove(plantCoord)) return;

  if (!outlinePartMap.ContainsKey(plantCoord)) {
   SpriteRenderer sourceRenderer = FindValidNeighborRenderer(plantCoord);
   if (sourceRenderer != null) {
    CreateOutlinePart(plantCoord, sourceRenderer);
   }
  }

  foreach (var offset in neighborOffsets) {
   Vector2Int neighborCoord = plantCoord + offset;
   if (outlinePartMap.TryGetValue(neighborCoord, out var outlinePart)) {
    if (outlinePart == null) {
     outlinePartMap.Remove(neighborCoord);
     continue;
    }
    if (!HasPlantNeighbor(neighborCoord)) {
     RemoveOutlinePartIfExists(neighborCoord);
    }
    else if (!outlinePart.IsSourceRendererValid()) {
     SpriteRenderer newSource = FindValidNeighborRenderer(neighborCoord);
     if (newSource != null) {
      outlinePart.UpdateSourceRenderer(newSource);
     }
     else {
      RemoveOutlinePartIfExists(neighborCoord);
     }
    }
   }
  }
 }

 void CreateOutlinePart(Vector2Int coord, SpriteRenderer sourceRenderer) {
  if (outlinePartMap.ContainsKey(coord) || sourceRenderer == null || outlinePartPrefab == null) {
   return;
  }

  GameObject outlineInstance = Instantiate(outlinePartPrefab, transform);

  float spacing = 1f / 6f; // Default fallback (1 world unit at 6 PPU)
  if (parentPlantGrowth != null) {
   spacing = parentPlantGrowth.GetCellWorldSpacing();
  }

  outlineInstance.transform.localPosition = (Vector2)coord * spacing;

  OutlinePartController outlineController = outlineInstance.GetComponent<OutlinePartController>();
  if (outlineController != null) {
   outlineController.Initialize(sourceRenderer, coord, this);
   outlinePartMap.Add(coord, outlineController);

   if (debugLogging) {
    Debug.Log($"[{gameObject.name}] Created outline at {coord}, spacing: {spacing:F4} world units");
   }
  }
  else {
   Debug.LogError("Outline Part Prefab is missing the OutlinePartController script!", outlinePartPrefab);
   Destroy(outlineInstance);
  }
 }

 void RemoveOutlinePartIfExists(Vector2Int coord) {
  if (outlinePartMap.TryGetValue(coord, out var part)) {
   if (part != null) part.DestroyOutlinePart();
   outlinePartMap.Remove(coord);
  }
 }

 bool HasPlantNeighbor(Vector2Int coord) {
  foreach (var offset in neighborOffsets)
   if (plantCellCoords.Contains(coord + offset)) return true;
  return false;
 }

 SpriteRenderer FindValidNeighborRenderer(Vector2Int coord) {
  foreach (var offset in neighborOffsets) {
   Vector2Int neighborCoord = coord + offset;
   if (plantCellCoords.Contains(neighborCoord)) {
    GameObject plantGO = parentPlantGrowth.GetCellGameObjectAt(neighborCoord);
    if (plantGO != null && plantGO.TryGetComponent<SpriteRenderer>(out var renderer)) {
     return renderer;
    }
   }
  }
  // FIX: Using the debug flag
  if (debugLogging)
   Debug.LogWarning($"[{gameObject.name}] Could not find any valid neighbor renderer for outline at {coord}");
  return null;
 }

}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\Visual\PlantShadowController.cs

﻿using UnityEngine;

pub class PlantShadowController : MonoBehaviour {
 [Header("Global Shadow Settings")]
 [SerializeField] Color shadowColor = new Color(0f, 0f, 0f, 0.5f);
 [SerializeField] [Range(0.1f, 2f)] [Tooltip("Vertical squash factor (1 = none, <1 = flatter, >1 = taller)")]
 float squashFactor = 0.6f;
 [SerializeField] [Range(0f, 360f)] [Tooltip("Rotation angle of the shadow around the plant's base (0 = right, 90 = up, 180 = left, 270 = down)")]
 float shadowAngleDegrees = 270f; // Default to directly downwards
 [SerializeField] [Tooltip("Flip the shadow horizontally?")]
 bool flipShadow = false;

 [Header("Distance Fade")]
 [Tooltip("Enable fading parts based on distance from the root.")]
 [SerializeField] bool enableDistanceFade = true;
 [Tooltip("Distance from the root where the shadow part starts fading.")]
 [SerializeField] float fadeStartDistance = 1.5f;
 [Tooltip("Distance from the root where the shadow part is fully faded (alpha 0).")]
 [SerializeField] float fadeEndDistance = 3.0f;
 [Tooltip("Minimum alpha value even when fully faded (e.g., 0.1 for slight visibility).")]
 [SerializeField] [Range(0f, 1f)] float minFadeAlpha = 0.0f;

 [Header("Sorting")]
 [SerializeField] [Tooltip("Name of the Sorting Layer for shadows (e.g., 'Shadows')")]
 string shadowSortingLayerName = "Default";
 [SerializeField] [Tooltip("Sorting Order within the layer (lower values are rendered first)")]
 int shadowSortingOrder = -1;

 int shadowSortingLayerID;

 pub Color ShadowColor => shadowColor;
 pub int ShadowSortingLayer => shadowSortingLayerID;
 pub int ShadowSortingOrder => shadowSortingOrder;

 pub bool EnableDistanceFade => enableDistanceFade;
 pub float FadeStartDistance => fadeStartDistance;
 pub float FadeEndDistance => fadeEndDistance;
 pub float MinFadeAlpha => minFadeAlpha;

 Vector3 baseLocalScale;
 Quaternion baseLocalRotation;
 Vector3 baseLocalPosition;

 Dictionary<SpriteRenderer, ShadowPartController> shadowPartMap = new Dictionary<SpriteRenderer, ShadowPartController>();

 void Awake() {
  shadowSortingLayerID = SortingLayer.NameToID(shadowSortingLayerName);
  if (shadowSortingLayerID == 0 && shadowSortingLayerName != "Default") {
   Debug.LogWarning($"Sorting Layer '{shadowSortingLayerName}' not found. Shadow will use 'Default'.", this);
   shadowSortingLayerID = SortingLayer.NameToID("Default");
  }

  baseLocalScale = transform.localScale;
  baseLocalRotation = transform.localRotation;
  baseLocalPosition = transform.localPosition;
  if (baseLocalPosition != Vector3.zero) {
   Debug.LogWarning($"'{gameObject.name}' initial localPosition is not zero ({baseLocalPosition}). Shadow origin might be slightly offset from plant root.", gameObject);
  }
 }

 void LateUpdate() {
  transform.localPosition = baseLocalPosition; // Should typically be Vector3.zero

  Quaternion angleRotation = Quaternion.Euler(0, 0, shadowAngleDegrees);
  transform.localRotation = baseLocalRotation * angleRotation;

  Vector3 finalScale = baseLocalScale; // Start with original scale
  finalScale.y *= squashFactor;

  if (flipShadow) {
   finalScale.x *= -1f;
  }
  transform.localScale = finalScale;

 }

 pub void RegisterPlantPart(SpriteRenderer plantPartRenderer, GameObject shadowPartPrefab) {
  if (plantPartRenderer == null || shadowPartPrefab == null) return;
  if (shadowPartMap.ContainsKey(plantPartRenderer)) return;
  GameObject shadowInstance = Instantiate(shadowPartPrefab, transform);
  ShadowPartController shadowController = shadowInstance.GetComponent<ShadowPartController>();
  if (shadowController != null) { shadowController.Initialize(plantPartRenderer, this); shadowPartMap.Add(plantPartRenderer, shadowController); }
  else { Debug.LogError($"Shadow Part Prefab '{shadowPartPrefab.name}' missing ShadowPartController.", shadowPartPrefab); Destroy(shadowInstance); }
 }

 pub void UnregisterPlantPart(SpriteRenderer plantPartRenderer) {
  if (plantPartRenderer != null && shadowPartMap.TryGetValue(plantPartRenderer, out ShadowPartController shadowController)) {
   if (shadowController != null) { shadowController.OnPlantPartDestroyed(); }
   shadowPartMap.Remove(plantPartRenderer);
  }
 }

 void OnDestroy() {
  foreach (var kvp in shadowPartMap) {
   if (kvp.Value != null) {
    if (Application.isPlaying) {
     Destroy(kvp.Value.gameObject);
    }
    else {
     DestroyImmediate(kvp.Value.gameObject);
    }
   }
  }
  shadowPartMap.Clear(); // Prevent memory leaks from the dictionary itself
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\Visual\ShadowPartController.cs

﻿using UnityEngine;

pub class ShadowPartController : MonoBehaviour {
 SpriteRenderer shadowRenderer;
 Transform cachedTransform;

 SpriteRenderer plantPartRenderer;
 Transform plantPartTransform;
 Transform shadowRootTransform;
 PlantShadowController mainShadowController;

 void Awake() {
  shadowRenderer = GetComponent<SpriteRenderer>();
  cachedTransform = transform;

  shadowRenderer.drawMode = SpriteDrawMode.Simple;
  shadowRenderer.enabled = false;
 }

 pub void Initialize(SpriteRenderer targetPlantPartRenderer, PlantShadowController controller) {
  if (targetPlantPartRenderer == null || controller == null) {
   Destroy(gameObject);
   return;
  }

  plantPartRenderer = targetPlantPartRenderer;
  plantPartTransform = targetPlantPartRenderer.transform;
  mainShadowController = controller;
  shadowRootTransform = controller.transform;

  shadowRenderer.sortingLayerID = mainShadowController.ShadowSortingLayer;
  shadowRenderer.sortingOrder = mainShadowController.ShadowSortingOrder;

  cachedTransform.SetParent(shadowRootTransform, true); // Parent first

  shadowRenderer.enabled = plantPartRenderer.enabled && plantPartRenderer.sprite != null;
  UpdateColorAndFade();
 }

 void LateUpdate() {
  if (plantPartRenderer == null || !plantPartRenderer.enabled || plantPartRenderer.sprite == null || shadowRenderer == null || mainShadowController == null) {
   if (shadowRenderer != null)
    shadowRenderer.enabled = false;
   return;
  }

  shadowRenderer.enabled = true;
  shadowRenderer.sprite = plantPartRenderer.sprite;

  Vector3 plantPartPosRelativeToPlantRoot = plantPartTransform.parent.InverseTransformPoint(plantPartTransform.position);
  cachedTransform.localPosition = plantPartPosRelativeToPlantRoot;
  cachedTransform.localRotation = plantPartTransform.localRotation;
  cachedTransform.localScale = plantPartTransform.localScale;

  shadowRenderer.flipX = plantPartRenderer.flipX;
  shadowRenderer.flipY = plantPartRenderer.flipY;

  UpdateColorAndFade();
 }

 void UpdateColorAndFade() {
  if (mainShadowController == null || shadowRenderer == null) return;

  Color baseShadowColor = mainShadowController.ShadowColor;
  float finalAlpha = baseShadowColor.a; // Start with the controller's base alpha

  if (mainShadowController.EnableDistanceFade) {
   float distance = Vector3.Distance(cachedTransform.position, shadowRootTransform.position); // Distance from shadow part to shadow root

   float fadeStart = mainShadowController.FadeStartDistance;
   float fadeEnd = mainShadowController.FadeEndDistance;
   float minAlpha = mainShadowController.MinFadeAlpha;

   if (distance >= fadeEnd) {
    finalAlpha *= minAlpha; // Apply min alpha
   }
   else if (distance > fadeStart) {
    float t = Mathf.InverseLerp(fadeStart, fadeEnd, distance);
    float distanceAlphaMultiplier = Mathf.Lerp(1f, minAlpha, t);
    finalAlpha *= distanceAlphaMultiplier; // Modulate base alpha
   }
  }

  shadowRenderer.color = new Color(baseShadowColor.r, baseShadowColor.g, baseShadowColor.b, finalAlpha);
 }

 pub void OnPlantPartDestroyed() {
  if (this != null && gameObject != null) {
   if (Application.isPlaying) {
    Destroy(gameObject);
   }
   else {
    DestroyImmediate(gameObject);
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\ProceduralGeneration\Editor\SceneSetupManagerEditor.cs

﻿using UnityEngine;
using UnityEditor;
using WegoSystem; // <-- ADDED THIS LINE to resolve the namespace issue.

pub class SceneSetupManagerEditor : Editor {
 pub ovr void OnInspectorGUI() {
  DrawDefaultInspector();

  SceneSetupManager setupManager = (SceneSetupManager)target;

  EditorGUILayout.Space(10);

  GUIStyle buttonStyle = new GUIStyle(GUI.skin.button);
  buttonStyle.padding = new RectOffset(10, 10, 10, 10);
  buttonStyle.fontSize = 13;

  if (GUILayout.Button("Setup Scene Now (Move Player & Camera)", buttonStyle)) {
   if (setupManager != null) {
    setupManager.SetupScene();
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ticks\GridDebugVisualizer.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes;
using WegoSystem;

pub class GridDebugVisualizer : MonoBehaviour {
 pub stat GridDebugVisualizer Instance { get; set; }

 pub enum RadiusType {
  AnimalSearch,
  PlantPoop,
  Scent,
  FireflyPhotosynthesis,
  ToolUse
 }

 [Header("Master Control")]
 [SerializeField] bool showRadiusVisualizations = true;
 [SerializeField] float tileVisualizationAlpha = 0.3f;
 [SerializeField] GameObject tilePrefab;

 [Header("Radius Colors (Centralized)")]
 [SerializeField] pub Color animalSearchRadiusColor = new Color(1f, 0.5f, 0f, 0.3f);
 [SerializeField] pub Color plantPoopRadiusColor = new Color(0.6f, 0.4f, 0.2f, 0.3f);
 [SerializeField] pub Color scentRadiusColor = new Color(1f, 1f, 0f, 0.3f);
 [SerializeField] pub Color fireflyPhotosynthesisColor = new Color(0f, 1f, 0.5f, 0.3f);
 [SerializeField] pub Color toolUseRadiusColor = new Color(0f, 0.5f, 1f, 0.3f);

 [Header("Individual Type Controls")]
 [SerializeField] bool enableAnimalSearchRadius = true;
 [SerializeField] bool enablePlantPoopRadius = true;
 [SerializeField] bool enableScentRadius = true;
 [SerializeField] bool enableFireflyPhotosynthesis = true;
 [SerializeField] bool enableToolUseRadius = true;

 class RadiusRequest {
  pub GridPosition Center;
  pub int Radius;
  pub RadiusType Type;
 }

 ro Dictionary<object, List<GameObject>> oneShotVisualizations = new Dictionary<object, List<GameObject>>();
 ro Dictionary<object, RadiusRequest> continuousRequests = new Dictionary<object, RadiusRequest>();
 ro Dictionary<object, (GridPosition center, int radius)> lastDrawnState = new Dictionary<object, (GridPosition, int)>();

 void Awake() {
  if (Instance != null && Instance != this) {
   Destroy(gameObject);
   return;
  }
  Instance = this;
 }

 void OnDestroy() {
  ClearAllVisualizations();
  if (Instance == this) Instance = null;
 }

 void Update() {
  ProcessContinuousRequests();
 }

 pub void ShowContinuousRadius(object source, GridPosition center, int radius, RadiusType type) {
  if (!showRadiusVisualizations || source == null || !IsTypeEnabled(type)) return;

  if (!continuousRequests.ContainsKey(source)) {
   continuousRequests.Add(source, new RadiusRequest());
  }
  continuousRequests[source].Center = center;
  continuousRequests[source].Radius = radius;
  continuousRequests[source].Type = type;
 }

 pub void HideContinuousRadius(object source) {
  if (source == null) return;

  if (continuousRequests.Remove(source)) {
   ClearVisualization(source);
  }
 }

 pub void VisualizeRadius(object source, GridPosition center, int radius, Color color, float duration = 0f) {
  if (!showRadiusVisualizations || tilePrefab == null) return;

  ClearVisualization(source);

  var tiles = GridRadiusUtility.GetTilesInCircle(center, radius);
  var tileObjects = new List<GameObject>();

  foreach (var tile in tiles) {
   Vector3 worldPos = GridPositionManager.Instance.GridToWorld(tile);
   GameObject tileVis = Instantiate(tilePrefab, worldPos, Quaternion.identity, transform);

   SpriteRenderer sr = tileVis.GetComponent<SpriteRenderer>();
   if (sr != null) {
    Color finalColor = color;
    finalColor.a = tileVisualizationAlpha;
    sr.color = finalColor;
    sr.sortingOrder = -100;
   }
   tileObjects.Add(tileVis);

   if (duration > 0) {
    Destroy(tileVis, duration);
   }
  }

  if (duration <= 0) {
   oneShotVisualizations[source] = tileObjects;
  }
 }

 pub void ClearVisualization(object source) {
  if (oneShotVisualizations.TryGetValue(source, out var tiles)) {
   foreach (var tile in tiles) {
    if (tile != null) Destroy(tile);
   }
   oneShotVisualizations.Remove(source);
  }
  if (lastDrawnState.ContainsKey(source)) {
   lastDrawnState.Remove(source);
  }
 }

 pub void VisualizeAnimalSearchRadius(AnimalController animal, GridPosition center, int radius) {
  ShowContinuousRadius(animal, center, radius, RadiusType.AnimalSearch);
 }

 pub void VisualizePlantPoopRadius(PlantGrowth plant, GridPosition center, int radius) {
  ShowContinuousRadius(plant, center, radius, RadiusType.PlantPoop);
 }

 pub void VisualizeScentRadius(ScentSource scentSource, GridPosition center, int radius) {
  ShowContinuousRadius(scentSource, center, radius, RadiusType.Scent);
 }

 pub void VisualizeFireflyPhotosynthesisRadius(FireflyController firefly, GridPosition center, int radius) {
  ShowContinuousRadius(firefly, center, radius, RadiusType.FireflyPhotosynthesis);
 }

 pub void VisualizeToolUseRadius(object tool, GridPosition center, int radius) {
  ShowContinuousRadius(tool, center, radius, RadiusType.ToolUse);
 }

 pub void SetAnimalSearchRadiusEnabled(bool enabled) { enableAnimalSearchRadius = enabled; }
 pub void SetPlantPoopRadiusEnabled(bool enabled) { enablePlantPoopRadius = enabled; }
 pub void SetScentRadiusEnabled(bool enabled) { enableScentRadius = enabled; }
 pub void SetFireflyPhotosynthesisEnabled(bool enabled) { enableFireflyPhotosynthesis = enabled; }
 pub void SetToolUseRadiusEnabled(bool enabled) { enableToolUseRadius = enabled; }

 pub void SetRadiusVisualizationsEnabled(bool enabled) {
  showRadiusVisualizations = enabled;
  if (!enabled) {
   ClearAllVisualizations();
  }
 }

 pub Color GetColorForType(RadiusType type) {
  switch (type) {
   case RadiusType.AnimalSearch: return animalSearchRadiusColor;
   case RadiusType.PlantPoop: return plantPoopRadiusColor;
   case RadiusType.Scent: return scentRadiusColor;
   case RadiusType.FireflyPhotosynthesis: return fireflyPhotosynthesisColor;
   case RadiusType.ToolUse: return toolUseRadiusColor;
   default: return Color.white;
  }
 }

 bool IsTypeEnabled(RadiusType type) {
  switch (type) {
   case RadiusType.AnimalSearch: return enableAnimalSearchRadius;
   case RadiusType.PlantPoop: return enablePlantPoopRadius;
   case RadiusType.Scent: return enableScentRadius;
   case RadiusType.FireflyPhotosynthesis: return enableFireflyPhotosynthesis;
   case RadiusType.ToolUse: return enableToolUseRadius;
   default: return true;
  }
 }

 void ProcessContinuousRequests() {
  if (!showRadiusVisualizations || tilePrefab == null) return;

  List<object> sourcesToRemove = new List<object>();
  foreach (var drawnSource in lastDrawnState.Keys) {
   if (!continuousRequests.ContainsKey(drawnSource)) {
    sourcesToRemove.Add(drawnSource);
   }
  }
  foreach (var source in sourcesToRemove) {
   ClearVisualization(source);
  }

  foreach (var kvp in continuousRequests) {
   object source = kvp.Key;
   RadiusRequest request = kvp.Value;

   if (!IsTypeEnabled(request.Type)) {
    if (lastDrawnState.ContainsKey(source)) {
     ClearVisualization(source);
    }
    continue;
   }

   bool needsRedraw = false;
   if (lastDrawnState.TryGetValue(source, out var lastState)) {
    if (lastState.center != request.Center || lastState.radius != request.Radius) {
     needsRedraw = true;
    }
   }
   else {
    needsRedraw = true;
   }

   if (needsRedraw) {
    Color color = GetColorForType(request.Type);
    VisualizeRadius(source, request.Center, request.Radius, color, 0);
    lastDrawnState[source] = (request.Center, request.Radius);
   }
  }
 }

 void ClearAllVisualizations() {
  foreach (var kvp in oneShotVisualizations) {
   foreach (var tile in kvp.Value) {
    if (tile != null) Destroy(tile);
   }
  }
  oneShotVisualizations.Clear();
  continuousRequests.Clear();
  lastDrawnState.Clear();
 }

 pub bool IsRadiusVisualizationEnabled => showRadiusVisualizations;
 pub bool IsAnimalSearchRadiusEnabled => enableAnimalSearchRadius;
 pub bool IsPlantPoopRadiusEnabled => enablePlantPoopRadius;
 pub bool IsScentRadiusEnabled => enableScentRadius;
 pub bool IsFireflyPhotosynthesisEnabled => enableFireflyPhotosynthesis;
 pub bool IsToolUseRadiusEnabled => enableToolUseRadius;
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ticks\GridSnapStartup.cs

﻿// Assets\Scripts\Core\GridSnapStartup.cs

using Abracodabra.Genes;
using WegoSystem;

pub class GridSnapStartup : MonoBehaviour {
 [SerializeField] bool snapAllAnimals = true;
 [SerializeField] bool snapAllPlants = true;
 [SerializeField] bool snapPlayer = true;
 [SerializeField] bool debugLog = true;

 void Awake() {
  if (GridPositionManager.Instance == null) {
   Debug.LogError("[GridSnapStartup] GridPositionManager not found! Cannot snap entities.");
   return;
  }
 }

 void Start() {
  PerformGridSnapping();
 }

 void PerformGridSnapping() {
  int snappedCount = 0;

  if (snapPlayer) {
   GardenerController[] gardeners = FindObjectsByType<GardenerController>(FindObjectsSortMode.None);
   foreach (var gardener in gardeners) {
    GridPositionManager.Instance.SnapEntityToGrid(gardener.gameObject);
    snappedCount++;
   }
  }

  if (snapAllAnimals) {
   AnimalController[] animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
   foreach (var animal in animals) {
    GridPositionManager.Instance.SnapEntityToGrid(animal.gameObject);
    snappedCount++;
   }
  }

  if (snapAllPlants) {
   PlantGrowth[] plants = FindObjectsByType<PlantGrowth>(FindObjectsSortMode.None);
   foreach (var plant in plants) {
    GridPositionManager.Instance.SnapEntityToGrid(plant.gameObject);
    snappedCount++;
   }
  }

  if (debugLog) {
   Debug.Log($"[GridSnapStartup] Snapped {snappedCount} entities to grid on startup");
  }
 }

 void SnapAllEntitiesNow() {
  if (GridPositionManager.Instance == null) {
   Debug.LogError("GridPositionManager not found in scene!");
   return;
  }

  PerformGridSnapping();
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ticks\TickDebugMonitor.cs

﻿// REWORKED FILE: Assets/Scripts/Ticks/TickDebugMonitor.cs
using TMPro;
using WegoSystem;
using Abracodabra.Genes;

pub class TickDebugMonitor : MonoBehaviour {
 [SerializeField] GameObject monitorPanel;
 [SerializeField] TextMeshProUGUI tickCounterText;
 [SerializeField] TextMeshProUGUI animalCountText;
 [SerializeField] TextMeshProUGUI plantCountText;
 [SerializeField] KeyCode toggleKey = KeyCode.F3;

 void Update() {
  if (Input.GetKeyDown(toggleKey)) {
   monitorPanel.SetActive(!monitorPanel.activeSelf);
  }

  if (monitorPanel.activeSelf) {
   UpdateDisplay();
  }
 }

 void UpdateDisplay() {
  if (TickManager.Instance == null) return;

  tickCounterText.text = $"Tick: {TickManager.Instance.CurrentTick}";
  animalCountText.text = $"Animals: {FindObjectsByType<AnimalController>(FindObjectsSortMode.None).Length}";

  plantCountText.text = $"Plants: {PlantGrowth.AllActivePlants.Count}";

 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\Utilities\ColorExtensions.cs

﻿using UnityEngine;

pub stat class ColorExtensions {
 pub stat Color WithAlpha(this Color c, float alpha) {
  return new Color(c.r, c.g, c.b, alpha);
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\Utilities\PrefabOrigin.cs

﻿// Assets/Scripts/Utility/PrefabOrigin.cs

pub class PrefabOrigin : MonoBehaviour {
 [Tooltip("Drag the child GameObject here that should act as the prefab's true origin/pivot point.")]
 pub Transform originTransform;

 void Awake() {
  if (originTransform == null) {
   Debug.LogError($"[PrefabOrigin] The 'Origin Transform' is not assigned on '{gameObject.name}'. The script cannot function.", this);
   Destroy(this); // Destroy self if not configured
   return;
  }

  if (!originTransform.IsChildOf(transform)) {
   Debug.LogError($"[PrefabOrigin] The assigned 'Origin Transform' ('{originTransform.name}') is not a child of '{gameObject.name}'. The script cannot function.", this);
   Destroy(this); // Destroy self if configuration is invalid
   return;
  }

  Vector3 worldOffset = transform.TransformVector(originTransform.localPosition);

  transform.position -= worldOffset;

  Destroy(this);
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\InventoryBarItem.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Templates;

// Note: ItemInstance and ItemDefinition are assumed to be in the global namespace

pub class InventoryBarItem {
 pub enum ItemType { Gene, Seed, Tool, Resource }

 pub ItemType Type { get; set; }

 pub RuntimeGeneInstance GeneInstance { get; set; }
 pub ToolDefinition ToolDefinition { get; set; }
 pub SeedTemplate SeedTemplate { get; set; }
 pub PlantGeneRuntimeState SeedRuntimeState { get; set; }

 pub ItemInstance ItemInstance { get; set; }

 pub stat InventoryBarItem FromGene(RuntimeGeneInstance instance) {
  if (instance == null) return null;
  return new InventoryBarItem {
   Type = ItemType.Gene,
   GeneInstance = instance
  };
 }

 pub stat InventoryBarItem FromSeed(SeedTemplate seed) {
  if (seed == null) return null;
  return new InventoryBarItem {
   Type = ItemType.Seed,
   SeedTemplate = seed,
   SeedRuntimeState = seed.CreateRuntimeState()
  };
 }

 pub stat InventoryBarItem FromTool(ToolDefinition tool) {
  if (tool == null) return null;
  return new InventoryBarItem {
   Type = ItemType.Tool,
   ToolDefinition = tool
  };
 }

 pub stat InventoryBarItem FromItem(ItemInstance instance) {
  if (instance == null || instance.definition == null) return null;
  return new InventoryBarItem {
   Type = ItemType.Resource,
   ItemInstance = instance
  };
 }

 pub string GetDisplayName() {
  switch (Type) {
   case ItemType.Gene:
    return GeneInstance?.GetGene()?.geneName ?? "Unknown Gene";
   case ItemType.Seed:
    return SeedTemplate?.templateName ?? "Unknown Seed";
   case ItemType.Tool:
    return ToolDefinition?.displayName ?? "Unknown Tool";
   case ItemType.Resource: // NEW
    return ItemInstance?.definition?.itemName ?? "Unknown Item";
   default:
    return "Invalid Item";
  }
 }

 pub Sprite GetIcon() {
  switch (Type) {
   case ItemType.Gene:
    return GeneInstance?.GetGene()?.icon;
   case ItemType.Seed:
    return SeedTemplate?.icon;
   case ItemType.Tool:
    return ToolDefinition?.icon;
   case ItemType.Resource: // NEW
    return ItemInstance?.definition?.icon;
   default:
    return null;
  }
 }

 pub bool IsValid() {
  switch (Type) {
   case ItemType.Gene:
    return GeneInstance?.GetGene() != null;
   case ItemType.Seed:
    return SeedTemplate != null && SeedRuntimeState != null;
   case ItemType.Tool:
    return ToolDefinition != null;
   case ItemType.Resource: // NEW
    return ItemInstance?.definition != null;
   default:
    return false;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\InventoryColorManager.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;

// Note: Add 'using' for ItemDefinition if it's in a namespace.

pub class InventoryColorManager : MonoBehaviour {
 pub stat InventoryColorManager Instance { get; set; }

 [Header("Cell Background Colors")]
 [SerializeField] Color toolCellColor = new Color(0.5f, 0.5f, 0.5f, 1f);
 [SerializeField] Color seedCellColor = new Color(0.8f, 1f, 0.8f, 1f);
 [SerializeField] Color passiveGeneCellColor = new Color(0.8f, 0.8f, 1f, 1f);
 [SerializeField] Color activeGeneCellColor = new Color(1f, 0.8f, 0.8f, 1f);
 [SerializeField] Color modifierGeneCellColor = new Color(1f, 1f, 0.7f, 1f);
 [SerializeField] Color payloadGeneCellColor = new Color(1f, 0.7f, 1f, 1f);
 [SerializeField] Color resourceCellColor = new Color(0.9f, 0.85f, 0.7f, 1f);
 [SerializeField] Color defaultCellColor = new Color(0.9f, 0.9f, 0.9f, 1f);

 void Awake() {
  if (Instance != null && Instance != this) { Destroy(gameObject); return; }
  Instance = this;
 }

 pub Color GetCellColorForItem(GeneBase gene, SeedTemplate seed, ToolDefinition tool, ItemDefinition item) {
  switch (GetItemCategory(gene, seed, tool, item)) {
   case ItemUIType.Tool: return toolCellColor;
   case ItemUIType.Seed: return seedCellColor;
   case ItemUIType.PassiveGene: return passiveGeneCellColor;
   case ItemUIType.ActiveGene: return activeGeneCellColor;
   case ItemUIType.ModifierGene: return modifierGeneCellColor;
   case ItemUIType.PayloadGene: return payloadGeneCellColor;
   case ItemUIType.Resource: return resourceCellColor; // NEW
   default: return defaultCellColor;
  }
 }

 pub enum ItemUIType {
  Tool,
  Seed,
  PassiveGene,
  ActiveGene,
  ModifierGene,
  PayloadGene,
  Resource, // NEW
  Default
 }

 pub ItemUIType GetItemCategory(GeneBase gene, SeedTemplate seed, ToolDefinition tool, ItemDefinition item) {
  if (tool != null) return ItemUIType.Tool;
  if (seed != null) return ItemUIType.Seed;
  if (item != null) return ItemUIType.Resource; // NEW
  if (gene != null) {
   switch (gene.Category) {
    case GeneCategory.Passive: return ItemUIType.PassiveGene;
    case GeneCategory.Active: return ItemUIType.ActiveGene;
    case GeneCategory.Modifier: return ItemUIType.ModifierGene;
    case GeneCategory.Payload: return ItemUIType.PayloadGene;
   }
  }
  return ItemUIType.Default;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\InventoryGridController.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Templates;
using Abracodabra.UI.Genes;

pub class InventoryGridController : MonoBehaviour {
 pub stat InventoryGridController Instance { get; set; }

 [Header("Grid Layout")]
 [SerializeField][Min(1)] int inventoryRows = 4;
 [SerializeField][Min(1)] int inventoryColumns = 4;
 [SerializeField] Vector2 cellSize = new Vector2(64f, 64f);
 [SerializeField] float cellMargin = 10f;

 [Header("Component References")]
 [SerializeField] GameObject itemSlotPrefab;
 [SerializeField] Transform cellContainer;
 [SerializeField] StartingInventory startingInventory;

 List<GeneSlotUI> inventorySlots = new List<GeneSlotUI>();

 pub event System.Action OnInventoryChanged;

 void Awake() {
  if (Instance != null && Instance != this) {
   Destroy(gameObject);
   return;
  }
  Instance = this;
 }

 void OnDestroy() {
  if (Instance == this) {
   Instance = null;
  }
 }

 void Start() {
  if (cellContainer == null) Debug.LogError("InventoryGridController: Cell Container not assigned!", this);
  if (itemSlotPrefab == null) Debug.LogError("InventoryGridController: Item Slot Prefab not assigned!", this);

  if (startingInventory == null) {
   Debug.LogError("InventoryGridController: Starting Inventory asset is not assigned! The player will have no items.", this);
  }

  CreateInventoryCells();
  PopulateInitialInventory();
 }

 void CreateInventoryCells() {
  if (itemSlotPrefab == null || cellContainer == null) return;

  foreach (Transform child in cellContainer) {
   Destroy(child.gameObject);
  }
  inventorySlots.Clear();

  var gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
  if (gridLayout == null) {
   gridLayout = cellContainer.gameObject.AddComponent<GridLayoutGroup>();
  }
  gridLayout.cellSize = cellSize;
  gridLayout.spacing = new Vector2(cellMargin, cellMargin);
  gridLayout.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
  gridLayout.constraintCount = inventoryColumns;

  for (int i = 0; i < inventoryRows * inventoryColumns; i++) {
   GameObject slotObj = Instantiate(itemSlotPrefab, cellContainer);
   slotObj.name = $"ItemSlot_{i}";
   GeneSlotUI slot = slotObj.GetComponent<GeneSlotUI>();
   if (slot != null) {
    slot.slotIndex = i;
    inventorySlots.Add(slot);
   }
   else {
    Debug.LogError($"[InventoryGridController] The 'itemSlotPrefab' is missing the required GeneSlotUI component!", itemSlotPrefab);
    Destroy(slotObj);
   }
  }
 }

 void PopulateInitialInventory() {
  if (startingInventory == null) return;

  foreach (var tool in startingInventory.startingTools) {
   if (tool != null) AddItemToInventory(InventoryBarItem.FromTool(tool));
  }

  foreach (var seed in startingInventory.startingSeeds) {
   if (seed != null) AddItemToInventory(InventoryBarItem.FromSeed(seed));
  }

  foreach (var gene in startingInventory.startingGenes) {
   if (gene != null) AddItemToInventory(InventoryBarItem.FromGene(new RuntimeGeneInstance(gene)));
  }
 }

 pub bool AddItemToInventory(InventoryBarItem item) {
  if (item == null || !item.IsValid()) return false;

  GeneSlotUI emptySlot = inventorySlots.FirstOrDefault(slot => slot.CurrentItem == null);
  if (emptySlot == null) {
   Debug.LogWarning($"Inventory is full! Cannot add item: {item.GetDisplayName()}", this);
   return false;
  }

  emptySlot.SetItem(item);
  OnInventoryChanged?.Invoke();
  return true;
 }

 pub void RemoveItemFromInventory(InventoryBarItem item) {
  if (item == null) return;
  GeneSlotUI slot = inventorySlots.FirstOrDefault(s => s.CurrentItem == item);
  if (slot != null) {
   slot.ClearSlot();
   OnInventoryChanged?.Invoke();
  }
 }

 pub List<InventoryBarItem> GetAllItems() {
  return inventorySlots
   .Where(s => s.CurrentItem != null && s.CurrentItem.IsValid())
   .Select(s => s.CurrentItem)
   .ToList();
 }

 pub List<InventoryBarItem> GetFirstNItems(int count) {
  var items = new List<InventoryBarItem>();
  for (int i = 0; i < count; i++) {
   if (i < inventorySlots.Count) {
    items.Add(inventorySlots[i].CurrentItem);
   }
   else {
    items.Add(null);
   }
  }
  return items;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\TooltipTrigger.cs

﻿// Reworked File: Assets/Scripts/UI/Tooltips/TooltipTrigger.cs
using UnityEngine.EventSystems;
using Abracodabra.UI.Genes; // For ItemView
using Abracodabra.Genes.Core; // For GeneTooltipContext

pub class TooltipTrigger : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler {
 ItemView _itemView;
 bool _isShowingTooltip = false;

 void Awake() {
  _itemView = GetComponent<ItemView>();
 }

 pub void OnPointerEnter(PointerEventData eventData) {
  if (UniversalTooltipManager.Instance == null || _isShowingTooltip || _itemView == null) return;
  ShowTooltip();
 }

 pub void OnPointerExit(PointerEventData eventData) {
  if (UniversalTooltipManager.Instance == null || !_isShowingTooltip) return;
  HideTooltip();
 }

 void ShowTooltip() {
  ITooltipDataProvider provider = null;
  GeneTooltipContext context = new GeneTooltipContext();

  if (_itemView.GetGene() != null) {
   provider = _itemView.GetGene();
   context.instance = _itemView.GetRuntimeInstance();
  }
  else if (_itemView.GetToolDefinition() != null) {
   provider = _itemView.GetToolDefinition();
  }
  else if (_itemView.GetSeedTemplate() != null) {
  }

  if (provider != null) {
   UniversalTooltipManager.Instance.ShowTooltip(provider, transform, context);
   _isShowingTooltip = true;
  }
 }

 void HideTooltip() {
  UniversalTooltipManager.Instance?.HideTooltip();
  _isShowingTooltip = false;
 }

 void OnDisable() {
  if (_isShowingTooltip) {
   HideTooltip();
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\UIManager.cs

﻿using UnityEngine;
using TMPro;
using WegoSystem;
using Abracodabra.UI.Genes;

pub class UIManager : MonoBehaviour {
 pub stat UIManager Instance { get; set; }

 [Header("Panels")]
 [SerializeField] GameObject uiCanvasRoot;
 [SerializeField] GameObject planningPanel;
 [SerializeField] GameObject growthAndThreatPanel;
 [SerializeField] GameObject geneSequenceUIPanel;
 [SerializeField] GameObject gameOverPanel; // NEW: Assign your Game Over UI panel here

 [Header("Buttons")]
 [SerializeField] Button startGrowthPhaseButton;
 [SerializeField] Button startNewPlanningPhaseButton;
 [SerializeField] Button endPlanningPhaseButton;
 [SerializeField] Button advanceTickButton;
 [SerializeField] Button restartButton; // NEW: Assign your Restart button from the GameOver panel

 [Header("Text Displays")]
 [SerializeField] TextMeshProUGUI tickCounterText;

 RunManager runManager;
 TickManager tickManager;

 void Awake() {
  if (Instance != null && Instance != this) {
   Destroy(gameObject);
   return;
  }
  Instance = this;

  if (uiCanvasRoot != null) {
   uiCanvasRoot.SetActive(true);
   Debug.Log($"[UIManager] Activated main UI canvas '{uiCanvasRoot.name}'.");
  }
  else {
   Debug.LogWarning("[UIManager] UI Canvas Root is not assigned. UI may not appear.", this);
  }
 }

 void OnDestroy() {
  if (runManager != null) {
   runManager.OnRunStateChanged -= HandleRunStateChanged;
   runManager.OnPhaseChanged -= HandlePhaseChanged;
   runManager.OnRoundChanged -= HandleRoundChanged;
  }

  if (tickManager != null) {
   tickManager.OnTickAdvanced -= HandleTickAdvanced;
  }
 }

 void Update() {
  if (Input.GetKeyDown(KeyCode.Space)) {
   if (runManager?.CurrentPhase == GamePhase.Planning) {
    OnEndPlanningPhaseClicked();
   }
  }
  if (Input.GetKeyDown(KeyCode.R) && (Application.isEditor || Debug.isDebugBuild)) {
   runManager?.ForcePhase(GamePhase.Planning);
  }
 }

 pub void Initialize() {
  runManager = RunManager.Instance;
  tickManager = TickManager.Instance;

  if (runManager == null) {
   Debug.LogError("[UIManager] RunManager.Instance not found! UI will not fn correctly.");
   return;
  }

  runManager.OnRunStateChanged += HandleRunStateChanged;
  runManager.OnPhaseChanged += HandlePhaseChanged;
  runManager.OnRoundChanged += HandleRoundChanged;

  if (tickManager != null) {
   tickManager.OnTickAdvanced += HandleTickAdvanced;
  }

  SetupButtons();

  if (gameOverPanel != null) gameOverPanel.SetActive(false);
  HandleRunStateChanged(runManager.CurrentState);
  UpdateTickDisplay();
 }

 void SetupButtons() {
  startGrowthPhaseButton?.onClick.AddListener(OnStartGrowthPhaseClicked);
  startNewPlanningPhaseButton?.onClick.AddListener(OnStartNewPlanningPhaseClicked);
  endPlanningPhaseButton?.onClick.AddListener(OnEndPlanningPhaseClicked);
  advanceTickButton?.onClick.AddListener(OnAdvanceTickClicked);
  restartButton?.onClick.AddListener(OnRestartClicked); // NEW
 }

 void HandleRunStateChanged(RunState newState) {
  if (planningPanel != null) planningPanel.SetActive(false);
  if (growthAndThreatPanel != null) growthAndThreatPanel.SetActive(false);
  if (gameOverPanel != null) gameOverPanel.SetActive(false);
  if (geneSequenceUIPanel != null) geneSequenceUIPanel.SetActive(false);
  if (InventoryGridController.Instance != null) InventoryGridController.Instance.gameObject.SetActive(false);
  InventoryBarController.Instance?.HideBar();

  switch (newState) {
   case RunState.Planning:
    if (planningPanel != null) planningPanel.SetActive(true);
    if (geneSequenceUIPanel != null) geneSequenceUIPanel.SetActive(true);
    if (InventoryGridController.Instance != null) InventoryGridController.Instance.gameObject.SetActive(true);
    break;

   case RunState.GrowthAndThreat:
    if (growthAndThreatPanel != null) growthAndThreatPanel.SetActive(true);
    if (geneSequenceUIPanel != null) {
     geneSequenceUIPanel.GetComponent<GeneSequenceUI>()?.CleanupOnPhaseEnd();
    }
    StartCoroutine(ShowInventoryBarDelayed());
    break;

   case RunState.GameOver:
    if (gameOverPanel != null) gameOverPanel.SetActive(true);
    break;
  }

  UpdateButtonStates(newState);
 }

 void HandlePhaseChanged(GamePhase oldPhase, GamePhase newPhase) {
  UpdateButtonStates(runManager.CurrentState);
 }

 void HandleRoundChanged(int newRound) {
 }

 void HandleTickAdvanced(int currentTick) {
  UpdateTickDisplay();
 }

 void UpdateTickDisplay() {
  if (tickCounterText != null && tickManager != null) {
   tickCounterText.text = $"Tick: {tickManager.CurrentTick}";
  }
 }

 void UpdateButtonStates(RunState state) {
  bool isPlanning = (state == RunState.Planning);
  bool isPlanningPhase = (runManager?.CurrentPhase == GamePhase.Planning);

  if (startGrowthPhaseButton != null) startGrowthPhaseButton.interactable = isPlanning && isPlanningPhase;
  if (startNewPlanningPhaseButton != null) startNewPlanningPhaseButton.interactable = !isPlanning;
  if (endPlanningPhaseButton != null) endPlanningPhaseButton.interactable = isPlanning && isPlanningPhase;
  if (advanceTickButton != null) advanceTickButton.interactable = !isPlanningPhase;
 }

 void OnStartGrowthPhaseClicked() { runManager?.StartGrowthAndThreatPhase(); }
 void OnStartNewPlanningPhaseClicked() { runManager?.StartNewPlanningPhase(); }
 void OnEndPlanningPhaseClicked() { runManager?.EndPlanningPhase(); }
 void OnAdvanceTickClicked() { tickManager?.DebugAdvanceTick(); }
 void OnRestartClicked() { runManager?.RestartGame(); } // NEW

 IEnumerator ShowInventoryBarDelayed() {
  yield return null; // Wait one frame for layout to build
  InventoryBarController.Instance?.ShowBar();
 }

 pub void ShowNotification(string message, float duration = 3f) {
  StartCoroutine(ShowNotificationCoroutine(message, duration));
 }

 IEnumerator ShowNotificationCoroutine(string message, float duration) {
  GameObject notification = new GameObject("Notification");
  notification.transform.SetParent(transform, false);

  var canvasGroup = notification.AddComponent<CanvasGroup>();
  var rectTransform = notification.AddComponent<RectTransform>();
  var image = notification.AddComponent<Image>();
  var text = new GameObject("Text").AddComponent<TextMeshProUGUI>();
  text.transform.SetParent(notification.transform, false);

  rectTransform.anchorMin = new Vector2(0.5f, 0.8f);
  rectTransform.anchorMax = new Vector2(0.5f, 0.8f);
  rectTransform.sizeDelta = new Vector2(300, 60);

  image.color = new Color(0, 0, 0, 0.8f);
  text.text = message;
  text.color = Color.white;
  text.alignment = TextAlignmentOptions.Center;
  text.fontSize = 16;
  text.rectTransform.sizeDelta = rectTransform.sizeDelta;

  float elapsedTime = 0f;
  while (elapsedTime < 0.5f) {
   canvasGroup.alpha = elapsedTime / 0.5f;
   elapsedTime += Time.deltaTime;
   yield return null;
  }
  canvasGroup.alpha = 1f;

  yield return new WaitForSeconds(duration - 1f);

  elapsedTime = 0f;
  while (elapsedTime < 0.5f) {
   canvasGroup.alpha = 1f - (elapsedTime / 0.5f);
   elapsedTime += Time.deltaTime;
   yield return null;
  }

  Destroy(notification);
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\UniversalTooltipManager.cs

﻿using UnityEngine;
using TMPro;

pub interface ITooltipDataProvider {
 string GetTooltipTitle();
 string GetTooltipDescription();
 string GetTooltipDetails(object source = null);
}

pub class UniversalTooltipManager : MonoBehaviour {
 pub stat UniversalTooltipManager Instance { get; set; }

 [Header("UI References")]
 [SerializeField] GameObject tooltipPanel;
 [SerializeField] TextMeshProUGUI titleText;
 [SerializeField] TextMeshProUGUI descriptionText;
 [SerializeField] TextMeshProUGUI detailsText;
 [SerializeField] Image backgroundImage;
 [SerializeField] CanvasGroup canvasGroup;
 [SerializeField] VerticalLayoutGroup layoutGroup;

 [Header("Behavior")]
 [SerializeField] float fadeDuration = 0.15f;
 [SerializeField] bool moveTooltipWithMouse = true;
 [SerializeField] Vector2 mouseFollowOffset = new Vector2(15f, -15f);

 [Header("Styling")]
 [SerializeField] Color backgroundColor = new Color(0.1f, 0.1f, 0.1f, 0.95f);
 [SerializeField] Color titleColor = Color.white;
 [SerializeField] Color descriptionColor = new Color(0.8f, 0.8f, 0.8f, 1f);
 [SerializeField] Color detailsColor = new Color(0.7f, 0.7f, 0.7f, 1f);
 [SerializeField] int titleFontSize = 18;
 [SerializeField] int descriptionFontSize = 14;
 [SerializeField] int detailsFontSize = 12;

 Coroutine _fadeCoroutine;
 object _currentTarget;
 bool _isVisible = false;

 void Awake() {
  if (Instance != null && Instance != this) {
   Destroy(gameObject);
   return;
  }
  Instance = this;

  if (!ValidateReferences()) {
   enabled = false;
   return;
  }

  SetupTooltipPanel();
  if (tooltipPanel != null) tooltipPanel.SetActive(false);
  if (canvasGroup != null) canvasGroup.alpha = 0f;
  _isVisible = false;
 }

 void Update() {
  if (_isVisible && IsTargetNullOrDestroyed(_currentTarget)) {
   HideTooltip();
  }
 }

 pub void ShowTooltip(ITooltipDataProvider provider, Transform anchor = null, object source = null) {
  if (provider == null) return;

  if (_isVisible && ReferenceEquals(_currentTarget, provider)) return;

  _currentTarget = provider;

  string title = provider.GetTooltipTitle();
  string description = provider.GetTooltipDescription();
  string details = provider.GetTooltipDetails(source);

  ShowTooltipInternal(title, description, details, anchor);
 }

 pub void HideTooltip() {
  _currentTarget = null;
  if (tooltipPanel == null || canvasGroup == null) return;

  if (_fadeCoroutine != null) {
   StopCoroutine(_fadeCoroutine);
  }

  if (fadeDuration > 0f && gameObject.activeInHierarchy) {
   _fadeCoroutine = StartCoroutine(FadeTooltip(false));
  }
  else {
   canvasGroup.alpha = 0f;
   if (tooltipPanel != null) tooltipPanel.SetActive(false);
   _isVisible = false;
  }
 }

 void ShowTooltipInternal(string title, string description, string details, Transform itemAnchor) {
  if (tooltipPanel == null || canvasGroup == null) return;

  if (_fadeCoroutine != null) {
   StopCoroutine(_fadeCoroutine);
  }

  if (titleText != null) {
   titleText.text = title;
   titleText.gameObject.SetActive(!string.IsNullOrEmpty(title));
  }
  if (descriptionText != null) {
   descriptionText.text = description;
   descriptionText.gameObject.SetActive(!string.IsNullOrEmpty(description));
  }
  if (detailsText != null) {
   detailsText.text = details;
   detailsText.gameObject.SetActive(!string.IsNullOrEmpty(details));
  }

  tooltipPanel.SetActive(true);
  if (layoutGroup != null) {
   LayoutRebuilder.ForceRebuildLayoutImmediate(layoutGroup.GetComponent<RectTransform>());
  }

  if (moveTooltipWithMouse) {
   PositionTooltipWithMouse();
  }

  if (fadeDuration > 0f) {
   _fadeCoroutine = StartCoroutine(FadeTooltip(true));
  }
  else {
   canvasGroup.alpha = 1f;
   _isVisible = true;
  }
 }

 void PositionTooltipWithMouse() {
  var tooltipRect = tooltipPanel.GetComponent<RectTransform>();
  var rootCanvas = tooltipPanel.GetComponentInParent<Canvas>()?.rootCanvas;

  if (tooltipRect == null || rootCanvas == null || !Input.mousePresent) return;

  Vector2 targetScreenPos = Input.mousePosition;
  targetScreenPos += mouseFollowOffset; // Apply user offset

  var panelRect = tooltipRect.rect;
  targetScreenPos.x = Mathf.Clamp(targetScreenPos.x, 0, Screen.width - panelRect.width);
  targetScreenPos.y = Mathf.Clamp(targetScreenPos.y, 0, Screen.height - panelRect.height);

  var parentRect = tooltipRect.parent as RectTransform;
  if (parentRect == null) return;

  Camera renderCamera = (rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay) ? null : rootCanvas.worldCamera;
  if (RectTransformUtility.ScreenPointToLocalPointInRectangle(parentRect, targetScreenPos, renderCamera, out var localPos)) {
   tooltipRect.localPosition = localPos;
  }
 }

 IEnumerator FadeTooltip(bool fadeIn) {
  if (canvasGroup == null) yield break;

  float elapsed = 0f;
  float startAlpha = canvasGroup.alpha;
  float targetAlpha = fadeIn ? 1f : 0f;

  if (fadeIn) _isVisible = true;

  if (fadeIn && tooltipPanel != null && !tooltipPanel.activeSelf)
   tooltipPanel.SetActive(true);

  while (elapsed < fadeDuration) {
   elapsed += Time.unscaledDeltaTime;
   float t = (fadeDuration > 0) ? elapsed / fadeDuration : 1f;
   canvasGroup.alpha = Mathf.Lerp(startAlpha, targetAlpha, t);
   yield return null;
  }

  canvasGroup.alpha = targetAlpha;

  if (!fadeIn) {
   if (tooltipPanel != null) tooltipPanel.SetActive(false);
   _isVisible = false;
  }
 }

 bool IsTargetNullOrDestroyed(object target) {
  if (target is UnityEngine.Object unityObject) {
   return unityObject == null;
  }
  return System.Object.ReferenceEquals(target, null);
 }

 void SetupTooltipPanel() {
  if (canvasGroup != null) {
   canvasGroup.alpha = 0f;
   canvasGroup.interactable = false;
   canvasGroup.blocksRaycasts = false;
  }
  if (backgroundImage != null) backgroundImage.color = backgroundColor;
  ApplyTextStyles();
 }

 void ApplyTextStyles() {
  if (titleText != null) { titleText.color = titleColor; titleText.fontSize = titleFontSize; titleText.fontStyle = FontStyles.Bold; }
  if (descriptionText != null) { descriptionText.color = descriptionColor; descriptionText.fontSize = descriptionFontSize; }
  if (detailsText != null) { detailsText.color = detailsColor; detailsText.fontSize = detailsFontSize; }
 }

 bool ValidateReferences() {
  if (tooltipPanel == null) { Debug.LogError("[UniversalTooltipManager] Tooltip Panel not assigned!"); return false; }

  if (canvasGroup == null) canvasGroup = tooltipPanel.GetComponent<CanvasGroup>() ?? tooltipPanel.AddComponent<CanvasGroup>();
  if (layoutGroup == null) layoutGroup = tooltipPanel.GetComponent<VerticalLayoutGroup>();
  if (backgroundImage == null) backgroundImage = tooltipPanel.GetComponent<Image>();
  if (titleText == null) titleText = FindTextComponent("Title");
  if (descriptionText == null) descriptionText = FindTextComponent("Description");
  if (detailsText == null) detailsText = FindTextComponent("Details");

  if (titleText == null) { Debug.LogError("[UniversalTooltipManager] Missing required title text component!"); return false; }

  return true;
 }

 TextMeshProUGUI FindTextComponent(string nameContains) {
  if (tooltipPanel == null) return null;
  foreach (var text in tooltipPanel.GetComponentsInChildren<TextMeshProUGUI>(true)) {
   if (text.name.ToLower().Contains(nameContains.ToLower()))
    return text;
  }
  return null;
 }

}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visual\Effects\NightColorPostProcess.cs

﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

pub class NightColorPostProcess : MonoBehaviour {
 [Header("Dependencies")]
 [Tooltip("The WeatherManager that controls the day/night cycle.")]
 pub WeatherManager weatherManager;

 [Tooltip("The global post-processing Volume to modify.")]
 pub Volume globalVolume;

 [Header("Day/Night Settings")]
 pub Color dayColorFilter = Color.white;
 pub Color nightColorFilter = new Color(0.75f, 0.8f, 1f, 1f);

 pub float dayPostExposure = 0f;
 pub float nightPostExposure = -0.5f;

 pub float daySaturation = 0f;
 pub float nightSaturation = -50f;

 [Range(0f, 1f)]
 pub float dayFilmGrainIntensity = 0.1f;
 [Range(0f, 1f)]
 pub float nightFilmGrainIntensity = 0.5f;

 [Range(0f, 1f)]
 pub float dayVignetteIntensity = 0.2f;
 [Range(0f, 1f)]
 pub float nightVignetteIntensity = 0.5f;

 [Range(0.01f, 1f)]
 pub float dayVignetteSmoothness = 0.2f;
 [Range(0.01f, 1f)]
 pub float nightVignetteSmoothness = 0.3f;

 [Header("Transition Smoothing")]
 [Tooltip("How quickly the visual effects catch up to the target day/night state. Higher is faster.")]
 [SerializeField] float transitionSmoothingSpeed = 5f;

 ColorAdjustments colorAdjustments;
 FilmGrain filmGrain;
 Vignette vignette;

 float smoothedSunIntensity;

 void Start() {
  if (!weatherManager) {
   Debug.LogError($"[{nameof(NightColorPostProcess)}] WeatherManager not assigned!", this);
   enabled = false; // Disable script if core references are missing
   return;
  }
  if (!globalVolume) {
   Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume not assigned!", this);
   enabled = false;
   return;
  }
  if (globalVolume.profile == null) {
   Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume has no profile assigned!", this);
   enabled = false;
   return;
  }

  if (!globalVolume.profile.TryGet<ColorAdjustments>(out colorAdjustments)) {
   Debug.LogWarning($"[{nameof(NightColorPostProcess)}] ColorAdjustments ovr not found in Volume profile.", this);
  }
  if (!globalVolume.profile.TryGet<FilmGrain>(out filmGrain)) {
   Debug.LogWarning($"[{nameof(NightColorPostProcess)}] FilmGrain ovr not found in Volume profile.", this);
  }
  if (!globalVolume.profile.TryGet<Vignette>(out vignette)) {
   Debug.LogWarning($"[{nameof(NightColorPostProcess)}] Vignette ovr not found in Volume profile.", this);
  }

  smoothedSunIntensity = weatherManager.sunIntensity;
 }

 void Update() {
  if (colorAdjustments == null && filmGrain == null && vignette == null)
   return; // Nothing to update if no overrides were found

  if (weatherManager != null) {
   smoothedSunIntensity = Mathf.Lerp(smoothedSunIntensity, weatherManager.sunIntensity, transitionSmoothingSpeed * Time.deltaTime);
  }

  float sun = Mathf.Clamp01(smoothedSunIntensity); // Use the smoothed value
  float t = 1f - sun;  // t=0 at day, t=1 at night

  if (colorAdjustments != null) {
   colorAdjustments.colorFilter.value = Color.Lerp(dayColorFilter, nightColorFilter, t);
   colorAdjustments.postExposure.value = Mathf.Lerp(dayPostExposure, nightPostExposure, t);
   colorAdjustments.saturation.value = Mathf.Lerp(daySaturation, nightSaturation, t);
  }

  if (filmGrain != null) {
   filmGrain.intensity.value = Mathf.Lerp(dayFilmGrainIntensity, nightFilmGrainIntensity, t);
  }

  if (vignette != null) {
   vignette.intensity.value = Mathf.Lerp(dayVignetteIntensity, nightVignetteIntensity, t);
   vignette.smoothness.value = Mathf.Lerp(dayVignetteSmoothness, nightVignetteSmoothness, t);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visual\Effects\RuntimeCircleDrawer.cs

﻿using UnityEngine;

pub class RuntimeCircleDrawer : MonoBehaviour {
 [Range(3, 60)]
 pub int segments = 30; // Number of line segments to approximate the circle
 pub float radius = 1.0f;
 pub float lineWidth = 0.02f;
 pub Color color = Color.yellow;
 pub Material lineMaterial; // Assign the same material used for firefly lines, or a specific one

 LineRenderer lineRenderer;
 bool needsRedraw = true; // Flag to force redraw on first UpdateCircle call or when params change
 float currentRadius = -1f; // Store current values to detect changes
 Color currentColor = Color.clear;

 void Awake() {
  lineRenderer = GetComponent<LineRenderer>();
  if (lineRenderer == null) { // Should not happen with RequireComponent
   Debug.LogError($"[{gameObject.name}] RuntimeCircleDrawer: Missing required LineRenderer component!");
   enabled = false; // Disable script if component missing
   return;
  }
  ConfigureLineRendererDefaults();
  lineRenderer.enabled = false; // Start hidden
 }

 void ConfigureLineRendererDefaults() {
  lineRenderer.useWorldSpace = false; // Draw relative to this object's transform
  lineRenderer.loop = true; // Connect the last point to the first
  lineRenderer.startWidth = lineWidth;
  lineRenderer.endWidth = lineWidth;

  if (lineMaterial != null && lineRenderer.material == null) {
   lineRenderer.material = lineMaterial;
  }

  SpriteRenderer parentSprite = GetComponentInParent<SpriteRenderer>();
  if (parentSprite != null) {
   lineRenderer.sortingLayerName = parentSprite.sortingLayerName;
   lineRenderer.sortingOrder = parentSprite.sortingOrder + 1; // Draw slightly in front
  } else {
   lineRenderer.sortingLayerName = "Default";
   lineRenderer.sortingOrder = 1;
  }
 }

 pub void UpdateCircle(float newRadius, Color newColor) {
  bool radiusChanged = !Mathf.Approximately(currentRadius, newRadius);
  bool colorChanged = currentColor != newColor;

  if (!needsRedraw && !radiusChanged && !colorChanged) {
   if (!lineRenderer.enabled) lineRenderer.enabled = true;
   return; // No change needed
  }

  currentRadius = newRadius;
  radius = newRadius; // Update pub field for potential inspector viewing
  currentColor = newColor;
  color = newColor; // Update pub field

  lineRenderer.startColor = currentColor;
  lineRenderer.endColor = currentColor;

  // Log color change for debugging
  if (colorChanged && Debug.isDebugBuild) {
   Debug.Log($"[RuntimeCircleDrawer] Updated color to: {newColor}", gameObject);
  }

  DrawCircle(); // Recalculate points
  lineRenderer.enabled = true; // Ensure it's visible
  needsRedraw = false; // Mark as drawn
 }

 pub void HideCircle() {
  if (lineRenderer != null && lineRenderer.enabled) {
   lineRenderer.enabled = false;
   needsRedraw = true; // Needs redraw next time it's shown
  }
 }

 void DrawCircle() {
  if (lineRenderer == null || segments <= 2 || radius <= 0f) {
   lineRenderer.positionCount = 0; // Clear points if invalid params
   return;
  };

  if (lineRenderer.positionCount != segments + 1) {
   lineRenderer.positionCount = segments + 1;
  }

  float angleStep = 360f / segments;
  Vector3[] points = new Vector3[segments + 1];

  for (int i = 0; i <= segments; i++) {
   float currentAngle = Mathf.Deg2Rad * (i * angleStep);
   float x = Mathf.Cos(currentAngle) * radius;
   float y = Mathf.Sin(currentAngle) * radius;
   points[i] = new Vector3(x, y, 0); // Z is 0 for local space relative to transform
  }

  lineRenderer.SetPositions(points);
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visual\Effects\WaterReflection.cs

﻿using UnityEngine;
using UnityEngine.Tilemaps;
using WegoSystem;
#if UNITY_EDITOR
using UnityEditor;
#endif

pub class WaterReflection : MonoBehaviour {
 pub class OverrideSettings {
  [Tooltip("If checked, the local 'Reflection Opacity' value will be used instead of the global manager's default.")]
  pub bool reflectionOpacity = false;
  [Tooltip("If checked, the local 'Reflection Tint' value will be used instead of the global manager's default.")]
  pub bool reflectionTint = false;
  [Tooltip("If checked, the local 'Gradient Fade Base Material' will be used. Otherwise, manager's default is used.")]
  pub bool gradientFadeBaseMaterial = false;
  [Tooltip("If checked, the local 'Sorting Order Offset' value will be used instead of the global manager's default.")]
  pub bool sortingOrderOffset = false;
  [Tooltip("If checked, the local 'Use Water Masking' value will be used instead of the global manager's default.")]
  pub bool useWaterMasking = false;
  [Tooltip("If checked, the local 'Water Tilemap Tag' value will be used instead of the global manager's default.")]
  pub bool waterTilemapTag = false;
  [Tooltip("If checked, the local 'Show Debug Info' value will be used instead of the global manager's default.")]
  pub bool showDebugInfo = false;
 }
 [Header("Overrides (Global Defaults from WaterReflectionManager)")]
 [SerializeField] OverrideSettings overrides;

 [Header("Reflection Source")]
 [Tooltip("If true, Y Offset and Distance Fade calculations will be relative to this GameObject's parent. If false (default), relative to this GameObject.")]
 [SerializeField] bool useParentAsReference = false; // This remains a local setting

 [Header("Local Reflection Settings (If Overridden)")]
 [Tooltip("Vertical offset of the reflection. Interpretation depends on 'Use Parent As Reference'.")]
 [SerializeField] float yOffset = -1f; // This remains a local setting

 [Tooltip("Local opacity of the reflection (0 = invisible, 1 = fully opaque)")]
 [SerializeField] [Range(0f, 1f)] float localReflectionOpacity = 0.5f;

 [Tooltip("Local additional tint color for the reflection")]
 [SerializeField] Color localReflectionTint = Color.white;

 [Header("Local Distance Fade (If Overridden)")]
 [Tooltip("Enable fading reflection. Requires 'Gradient Fade Base Material' (local or global) to be assigned.")]
 [SerializeField] bool enableDistanceFade = true; // This remains local as it depends on material
 [Tooltip("Vertical distance from the reference Y where fade starts.")]
 [SerializeField] float fadeStartDistance = 0.0f; // Local
 [Tooltip("Vertical distance from the reference Y where reflection becomes min alpha.")]
 [SerializeField] float fadeEndDistance = 1.0f; // Local
 [Tooltip("Minimum alpha when fully faded.")]
 [SerializeField] [Range(0f, 1f)] float minFadeAlpha = 0.0f; // Local
 [Tooltip("Local ovr for the gradient fade material. If unassigned and ovr is false, uses manager's default.")]
 [SerializeField] Material localGradientFadeBaseMaterial;

 [Header("Local Sorting (If Overridden)")]
 [Tooltip("Local sorting order offset for the reflection")]
 [SerializeField] int localSortingOrderOffset = -1;

 [Header("Local Water Masking (If Overridden)")]
 [Tooltip("Local ovr for using water masking")]
 [SerializeField] bool localUseWaterMasking = true;
 [Tooltip("Local ovr for the water tilemap tag")]
 [SerializeField] string localWaterTilemapTag = "Water";

 [Header("Local Debug (If Overridden)")]
 [SerializeField] bool localShowDebugInfo = false;

 SpriteRenderer originalRenderer;
 Animator originalAnimator;
 GameObject reflectionObject;
 SpriteRenderer reflectionRenderer;
 Animator reflectionAnimator;
 Material reflectionMaterialInstance; // Instanced material for this reflection

 float _actualReflectionOpacity;
 Color _actualReflectionTint;
 Material _actualGradientFadeBaseMaterial;
 int _actualSortingOrderOffset;
 bool _actualUseWaterMasking;
 string _actualWaterTilemapTag;
 bool _actualShowDebugInfo;

 Sprite lastSprite;
 Color lastOriginalColor;
 bool lastFlipX, lastFlipY;
 bool lastEnabled;
 Vector3 lastScale;
 Vector3 lastPosition;
 float lastParentY;

 void Awake() {
  _actualReflectionOpacity = localReflectionOpacity;
  _actualReflectionTint = localReflectionTint;
  _actualGradientFadeBaseMaterial = localGradientFadeBaseMaterial;
  _actualSortingOrderOffset = localSortingOrderOffset;
  _actualUseWaterMasking = localUseWaterMasking;
  _actualWaterTilemapTag = localWaterTilemapTag;
  _actualShowDebugInfo = localShowDebugInfo;

  originalRenderer = GetComponent<SpriteRenderer>();
  originalAnimator = GetComponent<Animator>();

  if (originalRenderer == null) {
   if (_actualShowDebugInfo) Debug.LogError($"[WaterReflection] No SpriteRenderer found on {gameObject.name}! Component disabled.", this);
   enabled = false;
   return;
  }

  if (useParentAsReference && transform.parent == null) {
   if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] 'Use Parent As Reference' is true on {gameObject.name}, but it has no parent. Will use self as reference.", this);
   useParentAsReference = false;
  }

  if (Application.isPlaying) {
   if (enableDistanceFade && _actualGradientFadeBaseMaterial == null) {
    if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection Awake] '{gameObject.name}': 'Enable Distance Fade' is true, but no 'Gradient Fade Base Material' (local or global) is assigned/found. Distance fade will not use the custom shader.", this);
   }
  }

  CreateReflectionObject();

  if (_actualUseWaterMasking) {
   SetupWaterMaskingInteraction();
  }
 }

 void ResolveSettings() {
  if (WaterReflectionManager.Instance != null) {
   _actualReflectionOpacity = overrides.reflectionOpacity ? localReflectionOpacity : WaterReflectionManager.Instance.defaultReflectionOpacity;
   _actualReflectionTint = overrides.reflectionTint ? localReflectionTint : WaterReflectionManager.Instance.defaultReflectionTint;
   _actualGradientFadeBaseMaterial = overrides.gradientFadeBaseMaterial ? localGradientFadeBaseMaterial : WaterReflectionManager.Instance.defaultGradientFadeMaterial;
   _actualSortingOrderOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : WaterReflectionManager.Instance.defaultSortingOrderOffset;
   _actualUseWaterMasking = overrides.useWaterMasking ? localUseWaterMasking : WaterReflectionManager.Instance.defaultUseWaterMasking;
   _actualWaterTilemapTag = overrides.waterTilemapTag && !string.IsNullOrEmpty(localWaterTilemapTag) ? localWaterTilemapTag : WaterReflectionManager.Instance.defaultWaterTilemapTag;
   _actualShowDebugInfo = overrides.showDebugInfo ? localShowDebugInfo : WaterReflectionManager.Instance.globalShowDebugInfo;
  }
  else // Fallback if no manager in scene {
   _actualReflectionOpacity = localReflectionOpacity;
   _actualReflectionTint = localReflectionTint;
   _actualGradientFadeBaseMaterial = localGradientFadeBaseMaterial;
   _actualSortingOrderOffset = localSortingOrderOffset;
   _actualUseWaterMasking = localUseWaterMasking;
   _actualWaterTilemapTag = localWaterTilemapTag;
   _actualShowDebugInfo = localShowDebugInfo;
   if (Application.isPlaying) Debug.LogWarning("[WaterReflection] WaterReflectionManager not found in scene. Using local settings for all reflections.", this);
  }
 }

 void Start() {
  ResolveSettings(); // Now resolve settings after all Awake() calls are completed
  UpdateReflectionVisuals();
  UpdateReflectionTransform();
  CacheCurrentState();
 }

 void LateUpdate() {
  if (originalRenderer == null || reflectionObject == null) {
   if (reflectionObject != null) reflectionObject.SetActive(false);
   return;
  }
  UpdateReflectionTransform();
  if (HasVisualStateChanged()) {
   UpdateReflectionVisuals();
   CacheCurrentState();
  }
 }

 void CreateReflectionObject() {
  reflectionObject = new GameObject($"{gameObject.name}_Reflection");
  reflectionObject.transform.SetParent(transform.parent, false);
  reflectionObject.transform.SetSiblingIndex(transform.GetSiblingIndex() + 1);

  reflectionRenderer = reflectionObject.AddComponent<SpriteRenderer>();
  reflectionRenderer.sortingLayerName = originalRenderer.sortingLayerName;
  reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + _actualSortingOrderOffset; // Use resolved
  reflectionRenderer.drawMode = originalRenderer.drawMode;

  if (enableDistanceFade && _actualGradientFadeBaseMaterial != null) // Use resolved {
   reflectionMaterialInstance = new Material(_actualGradientFadeBaseMaterial);
   reflectionRenderer.material = reflectionMaterialInstance;
   if (_actualShowDebugInfo && Application.isPlaying) Debug.Log($"[{gameObject.name}] Instantiated gradient material for reflection using '{_actualGradientFadeBaseMaterial.name}'.", this);
  }
  else {
   reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
   if (enableDistanceFade && _actualGradientFadeBaseMaterial == null && _actualShowDebugInfo && Application.isPlaying) {
    Debug.Log($"[{gameObject.name}] Using sharedMaterial for reflection as no gradientFadeBaseMaterial (local or global) was resolved during CreateReflectionObject.", this);
   }
  }

  if (originalAnimator != null) {
   reflectionAnimator = reflectionObject.AddComponent<Animator>();
   reflectionAnimator.runtimeAnimatorController = originalAnimator.runtimeAnimatorController;
  }
  SortableEntity originalSortable = GetComponent<SortableEntity>();
  if (originalSortable != null) {
   reflectionObject.AddComponent<SortableEntity>();
  }
  if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Created reflection for {gameObject.name}", this);
 }

 void UpdateReflectionTransform() {
  if (reflectionObject == null || originalRenderer == null) return;
  Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
  Vector3 originalWorldPos = transform.position;
  Vector3 reflectionWorldPos = originalWorldPos;
  float referenceYForOffset = referenceTransform.position.y;
  reflectionWorldPos.y = referenceYForOffset + yOffset - (originalWorldPos.y - referenceYForOffset);
  reflectionObject.transform.position = reflectionWorldPos;
  reflectionObject.transform.rotation = transform.rotation;
  reflectionObject.transform.localScale = transform.localScale;
  Vector3 currentLocalScale = reflectionObject.transform.localScale;
  currentLocalScale.y *= -1;
  reflectionObject.transform.localScale = currentLocalScale;
 }

 void UpdateReflectionVisuals() {
  if (reflectionRenderer == null || originalRenderer == null) return;

  reflectionRenderer.sprite = originalRenderer.sprite;
  reflectionRenderer.flipX = originalRenderer.flipX;
  reflectionRenderer.flipY = originalRenderer.flipY;

  Color baseOriginalSpriteColor = originalRenderer.color;
  Color finalReflectionTintedColor = baseOriginalSpriteColor * _actualReflectionTint; // Use resolved
  float finalCombinedAlpha = baseOriginalSpriteColor.a * _actualReflectionOpacity; // Use resolved
  reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);

  if (enableDistanceFade && reflectionMaterialInstance != null) {
   Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
   float waterSurfaceY = referenceTransform.position.y;
   reflectionMaterialInstance.SetFloat("_FadeStart", fadeStartDistance);
   reflectionMaterialInstance.SetFloat("_FadeEnd", fadeEndDistance);
   reflectionMaterialInstance.SetFloat("_MinAlpha", minFadeAlpha);
   reflectionMaterialInstance.SetFloat("_OriginalY", waterSurfaceY);
   Color materialBaseColor = _actualReflectionTint; // Use resolved
   materialBaseColor.a = _actualReflectionOpacity * baseOriginalSpriteColor.a; // Use resolved
   reflectionMaterialInstance.SetColor("_Color", materialBaseColor);
  }
  else if (!enableDistanceFade && reflectionMaterialInstance != null) {
   reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
   Destroy(reflectionMaterialInstance);
   reflectionMaterialInstance = null;
  }

  reflectionRenderer.enabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;

  if (reflectionAnimator != null && originalAnimator != null) {
   reflectionAnimator.enabled = originalAnimator.enabled;
   if (originalAnimator.runtimeAnimatorController != null && originalAnimator.parameterCount > 0) {
    foreach (AnimatorControllerParameter param in originalAnimator.parameters) {
     try {
      switch (param.type) {
       case AnimatorControllerParameterType.Bool:
        reflectionAnimator.SetBool(param.name, originalAnimator.GetBool(param.name));
        break;
       case AnimatorControllerParameterType.Float:
        reflectionAnimator.SetFloat(param.name, originalAnimator.GetFloat(param.name));
        break;
       case AnimatorControllerParameterType.Int:
        reflectionAnimator.SetInteger(param.name, originalAnimator.GetInteger(param.name));
        break;
      }
     } catch (System.Exception e) {
      if(_actualShowDebugInfo) Debug.LogWarning($"Failed to sync animator param '{param.name}': {e.Message}", reflectionAnimator);
     }
    }
   }
  }
 }

 bool HasVisualStateChanged() {
  if (originalRenderer == null) return false;
  bool parentYChanged = false;
  if (useParentAsReference && transform.parent != null) {
   parentYChanged = !Mathf.Approximately(lastParentY, transform.parent.position.y);
  }
  return lastSprite != originalRenderer.sprite ||
   !ColorsApproximatelyEqual(lastOriginalColor, originalRenderer.color) ||
   lastFlipX != originalRenderer.flipX ||
   lastFlipY != originalRenderer.flipY ||
   lastEnabled != (originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy) ||
   lastScale != transform.localScale ||
   lastPosition != transform.position ||
   parentYChanged;
 }

 void CacheCurrentState() {
  if (originalRenderer == null) return;
  lastSprite = originalRenderer.sprite;
  lastOriginalColor = originalRenderer.color;
  lastFlipX = originalRenderer.flipX;
  lastFlipY = originalRenderer.flipY;
  lastEnabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;
  lastScale = transform.localScale;
  lastPosition = transform.position;
  if (useParentAsReference && transform.parent != null) {
   lastParentY = transform.parent.position.y;
  }
 }

 bool ColorsApproximatelyEqual(Color c1, Color c2, float tolerance = 0.001f) {
  return Mathf.Abs(c1.r - c2.r) < tolerance &&
   Mathf.Abs(c1.g - c2.g) < tolerance &&
   Mathf.Abs(c1.b - c2.b) < tolerance &&
   Mathf.Abs(c1.a - c2.a) < tolerance;
 }

 void SetupWaterMaskingInteraction() {
  if (!_actualUseWaterMasking || reflectionRenderer == null) return; // Use resolved
  GameObject waterTilemapGO = FindWaterTilemapByTag(); // FindWaterTilemapByTag will use resolved tag
  if (waterTilemapGO == null) {
   if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Water tilemap for masking not found on {gameObject.name} using tag '{_actualWaterTilemapTag}'. Masking disabled.", this);
   return;
  }
  SpriteMask maskComponent = waterTilemapGO.GetComponent<SpriteMask>();
  if (maskComponent == null) {
   maskComponent = waterTilemapGO.AddComponent<SpriteMask>();
   maskComponent.sprite = null;
   if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Added SpriteMask to water tilemap '{waterTilemapGO.name}' for object '{gameObject.name}'.", waterTilemapGO);
  }
  reflectionRenderer.maskInteraction = SpriteMaskInteraction.VisibleInsideMask;
  if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Reflection of '{gameObject.name}' will be masked by '{waterTilemapGO.name}'.", this);
 }

 GameObject FindWaterTilemapByTag() {
  if (string.IsNullOrEmpty(_actualWaterTilemapTag)) return FindWaterTilemapFallback();
  GameObject taggedWater = GameObject.FindGameObjectWithTag(_actualWaterTilemapTag);
  if (taggedWater != null && taggedWater.GetComponent<Tilemap>() != null) {
   if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Found water tilemap by tag '{_actualWaterTilemapTag}': {taggedWater.name} for {gameObject.name}", this);
   return taggedWater;
  }
  if (taggedWater != null && taggedWater.GetComponent<Tilemap>() == null && _actualShowDebugInfo) {
   Debug.LogWarning($"[WaterReflection] GameObject '{taggedWater.name}' (tag '{_actualWaterTilemapTag}') has no Tilemap component!", this);
  }
  return FindWaterTilemapFallback();
 }

 GameObject FindWaterTilemapFallback() {
  if (TileInteractionManager.Instance != null) {
   var mappings = TileInteractionManager.Instance.tileDefinitionMappings;
   if (mappings != null) {
    foreach (var mapping in mappings) {
     if (mapping?.tileDef != null && mapping.tilemapModule != null && mapping.tileDef.isWaterTile) {
      Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
      if (renderTilemapTransform != null && renderTilemapTransform.GetComponent<Tilemap>() != null) {
       if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Auto-detected water tilemap via TIM: {renderTilemapTransform.name} for {gameObject.name}", this);
       return renderTilemapTransform.gameObject;
      }
     }
    }
   }
  }
  if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Could not auto-detect water tilemap via TileInteractionManager for {gameObject.name}.", this);
  return null;
 }

 void OnDestroy() {
  if (reflectionObject != null) {
   if (Application.isPlaying) Destroy(reflectionObject);
   else DestroyImmediate(reflectionObject);
  }
  if (reflectionMaterialInstance != null) {
   if (Application.isPlaying) Destroy(reflectionMaterialInstance);
   else DestroyImmediate(reflectionMaterialInstance);
  }
 }

 void OnValidate() {
  #if UNITY_EDITOR
  EditorApplication.delayCall -= EditorUpdatePreview; // Remove previous requests to avoid stacking
  EditorApplication.delayCall += EditorUpdatePreview; // Add a new request
  #endif
 }

#if UNITY_EDITOR
 void EditorUpdatePreview() {
  if (this == null || gameObject == null) // The object could be destroyed before the call {
   return;
  }

  if (Application.isEditor && !Application.isPlaying) {
   // Only show validation logs if the local debug flag is enabled.
   if (localShowDebugInfo) {
    bool localMaterialNeeded = enableDistanceFade && (!overrides.gradientFadeBaseMaterial || localGradientFadeBaseMaterial == null);
    bool globalMaterialMightBeUsed = enableDistanceFade && !overrides.gradientFadeBaseMaterial && localGradientFadeBaseMaterial == null;

    if (localMaterialNeeded && !globalMaterialMightBeUsed) // Warn if local ovr is on but local material missing {
     Debug.LogWarning($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true and 'Override Gradient Material' is true, but 'Local Gradient Fade Base Material' is not assigned. Assign local material or uncheck override.", this);
    }
    else if (globalMaterialMightBeUsed) // Inform that global will be used if local isn't set {
     Debug.Log($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true. If 'Local Gradient Fade Base Material' remains unassigned and ovr is false, the global default from WaterReflectionManager will be used in Play mode.", this);
    }
   }

   if (reflectionRenderer != null && originalRenderer != null) {
    Color previewTint = overrides.reflectionTint ? localReflectionTint : Color.white; // Default to white if no manager
    float previewOpacity = overrides.reflectionOpacity ? localReflectionOpacity : 0.5f;
    int previewSortOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : -1;

    reflectionRenderer.sprite = originalRenderer.sprite;
    reflectionRenderer.flipX = originalRenderer.flipX;
    reflectionRenderer.flipY = originalRenderer.flipY;
    reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + previewSortOffset;
    Color baseOriginalSpriteColor = originalRenderer.color;
    Color finalReflectionTintedColor = baseOriginalSpriteColor * previewTint;
    float finalCombinedAlpha = baseOriginalSpriteColor.a * previewOpacity;
    reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);
    UpdateReflectionTransform(); // Keep transform updated
   }
  }
 }
#endif

 pub void SetLocalReflectionOpacity(float opacity) // Example of changing a local-only value {
  localReflectionOpacity = Mathf.Clamp01(opacity);
  if (overrides.reflectionOpacity) // Only re-resolve and update if this local value is being used {
   ResolveSettings();
   if (Application.isPlaying && originalRenderer != null) UpdateReflectionVisuals();
  }
 }

}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Visual\Effects\WaterReflectionManager.cs

﻿using UnityEngine;

pub class WaterReflectionManager : MonoBehaviour {
 pub stat WaterReflectionManager Instance { get; set; }

 [Header("Global Default Reflection Settings")]
 [Tooltip("Default material to use for reflections if 'Enable Distance Fade' is true and no specific material is assigned on the WaterReflection component. Assign your 'Custom/WaterReflectionGradient' material asset here.")]
 pub Material defaultGradientFadeMaterial;

 [Tooltip("Default opacity for all reflections (0 = invisible, 1 = fully opaque). Can be overridden per instance.")]
 [Range(0f, 1f)] pub float defaultReflectionOpacity = 0.5f;

 [Tooltip("Default additional tint color for all reflections. Can be overridden per instance.")]
 pub Color defaultReflectionTint = Color.white;

 [Tooltip("Default sorting order offset for reflections (usually negative). Can be overridden per instance.")]
 pub int defaultSortingOrderOffset = -1;

 [Header("Global Default Water Masking Settings")]
 [Tooltip("Default setting for whether to use water masking. Can be overridden per instance.")]
 pub bool defaultUseWaterMasking = true;

 [Tooltip("Default tag used to identify the water tilemap. Can be overridden per instance.")]
 pub string defaultWaterTilemapTag = "Water";

 [Header("Global Debug Settings")]
 [Tooltip("Enable debug logs for all WaterReflection instances that don't ovr this.")]
 pub bool globalShowDebugInfo = false;

 void Awake() {
  if (Instance != null && Instance != this) {
   Debug.LogWarning($"[WaterReflectionManager] Duplicate instance found on {gameObject.name}. Destroying self.", gameObject);
   Destroy(gameObject);
   return;
  }
  Instance = this;

  if (defaultGradientFadeMaterial == null) {
   Debug.LogWarning("[WaterReflectionManager] Default Gradient Fade Material is not assigned. Distance fade may not work correctly for reflections that don't have their own material specified.", this);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Placement\PlantGrowthModifierManager.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes;
using WegoSystem;

pub class PlantGrowthModifierManager : MonoBehaviour, ITickUpdateable {
 pub stat PlantGrowthModifierManager Instance { get; set; }

 pub class TileGrowthModifier {
  pub TileDefinition tileDefinition;
  [Tooltip("Multiplier for growth progress per tick. 2.0 is twice as fast, 0.5 is half speed.")]
  pub float growthSpeedMultiplier = 1.0f;
  [Tooltip("Multiplier for energy gained per tick. 2.0 is twice as much, 0.5 is half.")]
  pub float energyRechargeMultiplier = 1.0f;
 }

 [Header("Default Modifiers")]
 pub float defaultGrowthSpeedMultiplier = 1.0f;
 pub float defaultEnergyRechargeMultiplier = 1.0f;

 [Header("Tile-Specific Modifiers")]
 pub List<TileGrowthModifier> tileModifiers = new List<TileGrowthModifier>();

 [Header("Setup")]
 [SerializeField] TileInteractionManager tileInteractionManager;
 [SerializeField] bool showDebugMessages = true;
 [SerializeField] bool showTileChangeMessages = true;

 Dictionary<string, TileGrowthModifier> modifierLookup = new Dictionary<string, TileGrowthModifier>();
 Dictionary<PlantGrowth, TileDefinition> plantTiles = new Dictionary<PlantGrowth, TileDefinition>();

 void Awake() {
  if (Instance != null && Instance != this) {
   Destroy(gameObject);
   return;
  }
  Instance = this;

  BuildModifierLookup();
 }

 pub void Initialize() {
  if (tileInteractionManager == null) {
   tileInteractionManager = TileInteractionManager.Instance;
   if (tileInteractionManager == null && showDebugMessages) {
    Debug.LogWarning("PlantGrowthModifierManager: TileInteractionManager not found!");
   }
  }

  if (TickManager.Instance != null) {
   TickManager.Instance.RegisterTickUpdateable(this);
  }
  else {
   Debug.LogError("[PlantGrowthModifierManager] TickManager not found! Modifiers will not update.");
  }
 }

 void OnDestroy() {
  var tickManager = TickManager.Instance;
  if (tickManager != null) {
   tickManager.UnregisterTickUpdateable(this);
  }
 }

 pub void OnTickUpdate(int currentTick) {
  UpdateAllPlantTiles();
 }

 void UpdateAllPlantTiles() {
  if (tileInteractionManager == null) return;

  List<PlantGrowth> plantsToCheck = new List<PlantGrowth>(plantTiles.Keys);

  foreach (PlantGrowth plant in plantsToCheck) {
   if (plant == null) {
    plantTiles.Remove(plant);
    continue;
   }

   Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
   TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);

   if (plantTiles.TryGetValue(plant, out TileDefinition previousTileDef) && currentTileDef != previousTileDef) {
    plantTiles[plant] = currentTileDef;

    if (showTileChangeMessages) {
     string previousTileName = previousTileDef != null ? previousTileDef.displayName : "None";
     string currentTileName = currentTileDef != null ? currentTileDef.displayName : "None";
     Debug.Log($"Plant '{plant.name}' tile changed: {previousTileName} -> {currentTileName}");
    }
   }
  }
 }

 void BuildModifierLookup() {
  modifierLookup.Clear();
  foreach (var modifier in tileModifiers) {
   if (modifier.tileDefinition != null && !string.IsNullOrEmpty(modifier.tileDefinition.displayName) && !modifierLookup.ContainsKey(modifier.tileDefinition.displayName)) {
    modifierLookup.Add(modifier.tileDefinition.displayName, modifier);
   }
  }
 }

 pub void RegisterPlantTile(PlantGrowth plant, TileDefinition tileDef) {
  if (plant == null) return;
  plantTiles[plant] = tileDef;

  if (showDebugMessages) {
   string tileName = tileDef != null ? tileDef.displayName : "Unknown Tile";
   Debug.Log($"Registered plant {plant.name} on tile {tileName}");
  }
 }

 pub void UnregisterPlant(PlantGrowth plant) {
  if (plant != null) {
   plantTiles.Remove(plant);
  }
 }

 pub float GetGrowthSpeedMultiplier(PlantGrowth plant) {
  if (plant == null) return defaultGrowthSpeedMultiplier;

  if (!plantTiles.ContainsKey(plant)) {
   RegisterNewPlant(plant); // Auto-register if not found
  }

  if (plantTiles.TryGetValue(plant, out TileDefinition tileDef) && tileDef != null) {
   if (modifierLookup.TryGetValue(tileDef.displayName, out TileGrowthModifier modifier)) {
    return modifier.growthSpeedMultiplier;
   }
  }

  return defaultGrowthSpeedMultiplier;
 }

 pub float GetEnergyRechargeMultiplier(PlantGrowth plant) {
  if (plant == null) return defaultEnergyRechargeMultiplier;

  if (!plantTiles.ContainsKey(plant)) {
   RegisterNewPlant(plant); // Auto-register if not found
  }

  if (plantTiles.TryGetValue(plant, out TileDefinition tileDef) && tileDef != null) {
   if (modifierLookup.TryGetValue(tileDef.displayName, out TileGrowthModifier modifier)) {
    return modifier.energyRechargeMultiplier;
   }
  }

  return defaultEnergyRechargeMultiplier;
 }

 void RegisterNewPlant(PlantGrowth plant) {
  if (plant == null || tileInteractionManager == null) return;

  Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
  TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
  plantTiles[plant] = currentTileDef;

  if (showDebugMessages) {
   string tileName = currentTileDef != null ? currentTileDef.displayName : "Unknown Tile";
   Debug.Log($"Auto-registered new plant {plant.name} on tile {tileName}");
  }
 }

 void OnValidate() {
  BuildModifierLookup();
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Placement\PlayerTileInteractor.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Components;
using Abracodabra.UI.Genes;
using WegoSystem;

pub seal class PlayerTileInteractor : MonoBehaviour {
 [Header("References")]
 [SerializeField] TileInteractionManager tileInteractionManager;
 [SerializeField] Transform playerTransform;

 [Header("Debug")]
 [SerializeField] bool showDebug = false;

 bool pendingLeftClick;
 bool pendingRightClick;

 void Awake() {
  if (playerTransform == null)
   playerTransform = transform;
 }

 void Start() {
  FindReferences();
 }

 void Update() {
  if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat)
   return;

  if (Input.GetMouseButtonDown(0)) pendingLeftClick = true;
  if (Input.GetMouseButtonDown(1)) pendingRightClick = true;
 }

 void LateUpdate() {
  if (pendingLeftClick) {
   pendingLeftClick = false;
   HandleLeftClick();
  }
  if (pendingRightClick) {
   pendingRightClick = false;
   HandleRightClick();
  }
 }

 void HandleRightClick() {
  if (!EnsureReferences()) return;

  if (TryEatFoodFromWorld())
   return;

  TryEatFromInventory();
 }

 bool TryEatFoodFromWorld() {
  Vector3 mouseWorldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);
  mouseWorldPos.z = 0;

  if (!tileInteractionManager.IsWithinInteractionRange)
   return false;

  Collider2D[] colliders = Physics2D.OverlapPointAll(mouseWorldPos);

  foreach (var collider in colliders) {
   FoodItem foodItem = collider.GetComponent<FoodItem>();
   if (foodItem == null) continue;

   Fruit fruit = collider.GetComponent<Fruit>();

   if (fruit != null && fruit.RepresentingItemDefinition == null) {
    if (showDebug) Debug.Log("[PlayerTileInteractor] Fruit doesn't have item definition yet");
    continue;
   }

   GardenerController player = playerTransform.GetComponent<GardenerController>();
   if (player == null || player.HungerSystem == null) {
    if (showDebug) Debug.LogWarning("[PlayerTileInteractor] Player has no HungerSystem");
    return false;
   }

   float nutrition = 0f;
   if (fruit != null && fruit.RepresentingItemDefinition != null) {
    nutrition = fruit.RepresentingItemDefinition.baseNutrition;
    if (fruit.DynamicProperties != null &&
     fruit.DynamicProperties.TryGetValue("nutrition_multiplier", out float mult)) {
     nutrition *= mult;
    }
   }
   else if (foodItem.foodType != null) {
    nutrition = foodItem.foodType.baseSatiationValue;
   }

   player.HungerSystem.Eat(nutrition);

   if (showDebug) Debug.Log($"[PlayerTileInteractor] Ate food from world for {nutrition:F1} nutrition");

   Destroy(collider.gameObject);

   if (PlayerActionManager.Instance != null) {
    PlayerActionManager.Instance.ExecutePlayerAction(
     PlayerActionType.Interact,
     tileInteractionManager.WorldToCell(mouseWorldPos),
     "EatingFromWorld"
    );
   }

   return true;
  }

  return false;
 }

 void TryEatFromInventory() {
  InventoryBarItem selected = HotbarSelectionService.SelectedItem;
  if (selected == null || !selected.IsValid()) {
   if (showDebug) Debug.Log("[PlayerTileInteractor] Right-click: No valid item selected");
   return;
  }

  if (selected.Type != InventoryBarItem.ItemType.Resource) {
   if (showDebug) Debug.Log("[PlayerTileInteractor] Right-click: Selected item is not a resource");
   return;
  }

  ItemInstance itemToConsume = selected.ItemInstance;
  if (itemToConsume == null || !itemToConsume.definition.isConsumable) {
   if (showDebug) Debug.Log("[PlayerTileInteractor] Right-click: Item is not consumable");
   return;
  }

  GardenerController player = playerTransform.GetComponent<GardenerController>();
  if (player == null || player.HungerSystem == null) {
   if (showDebug) Debug.LogWarning("[PlayerTileInteractor] Player has no HungerSystem");
   return;
  }

  float nutrition = itemToConsume.GetNutrition();
  player.HungerSystem.Eat(nutrition);

  if (showDebug) Debug.Log($"[PlayerTileInteractor] Ate '{selected.GetDisplayName()}' for {nutrition:F1} nutrition");

  int selectedIndex = HotbarSelectionService.SelectedIndex;
  InventoryService.RemoveItemAtIndex(selectedIndex);

  if (PlayerActionManager.Instance != null) {
   PlayerActionManager.Instance.ExecutePlayerAction(
    PlayerActionType.Interact,
    tileInteractionManager.WorldToCell(playerTransform.position),
    "EatingFromInventory"
   );
  }
 }

 void HandleLeftClick() {
  if (!EnsureReferences()) return;

  if (tileInteractionManager.DidRefillThisFrame) {
   if (showDebug) Debug.Log("[PlayerTileInteractor] Left-click ignored: Refill happened this frame.");
   return;
  }

  InventoryBarItem selected = HotbarSelectionService.SelectedItem;
  if (selected == null || !selected.IsValid()) {
   if (showDebug) Debug.Log("[PlayerTileInteractor] Left-click ignored: No valid item selected.");
   return;
  }

  if (!tileInteractionManager.IsWithinInteractionRange) {
   if (showDebug) Debug.Log("[PlayerTileInteractor] Left-click ignored: Target cell out of range.");
   return;
  }

  if (!tileInteractionManager.CurrentlyHoveredCell.HasValue) {
   if (showDebug) Debug.Log("[PlayerTileInteractor] Left-click ignored: No hovered cell.");
   return;
  }

  Vector3Int cellPos = tileInteractionManager.CurrentlyHoveredCell.Value;

  if (showDebug) Debug.Log($"[PlayerTileInteractor] Action '{selected.Type}' with '{selected.GetDisplayName()}' at {cellPos}");

  switch (selected.Type) {
   case InventoryBarItem.ItemType.Tool:
    HandleToolUse(selected, cellPos);
    break;

   case InventoryBarItem.ItemType.Seed:
    HandleSeedPlanting(selected, cellPos);
    break;
  }
 }

 void HandleToolUse(InventoryBarItem selected, Vector3Int cellPos) {
  var toolDef = selected.ToolDefinition;
  if (toolDef == null) return;

  if (ToolSwitcher.Instance != null && ToolSwitcher.Instance.CurrentTool != toolDef) {
   ToolSwitcher.Instance.SelectToolByDefinition(toolDef);
  }

  if (toolDef.toolType == ToolType.HarvestPouch) {
   HandleHarvest(cellPos);
  }
  else {
   if (ToolSwitcher.Instance != null && toolDef.limitedUses) {
    if (!ToolSwitcher.Instance.TryConsumeUse()) {
     if (showDebug) Debug.Log($"[PlayerTileInteractor] Tool '{toolDef.displayName}' is out of uses.");
     return;
    }
   }
   PlayerActionManager.Instance?.ExecutePlayerAction(PlayerActionType.UseTool, cellPos, toolDef);
  }
 }

 void HandleSeedPlanting(InventoryBarItem selected, Vector3Int cellPos) {
  int selectedIndex = HotbarSelectionService.SelectedIndex;

  System.Action onSuccess = () => {
   if (showDebug) Debug.Log($"[PlayerTileInteractor] Successfully planted '{selected.GetDisplayName()}'. Removing from inventory.");

   InventoryService.RemoveItemAtIndex(selectedIndex);
  };

bool success = PlayerActionManager.Instance?.ExecutePlayerAction( PlayerActionType.PlantSeed, cellPos, selected, onSuccess ) ?? false;

  if (!success && showDebug) {
   Debug.Log($"[PlayerTileInteractor] Failed to plant '{selected.GetDisplayName()}' at {cellPos}");
  }
 }

 void HandleHarvest(Vector3Int cellPos) {
bool success = PlayerActionManager.Instance?.ExecutePlayerAction( PlayerActionType.Harvest, cellPos ) ?? false;

  if (!success && showDebug) {
   Debug.Log($"[PlayerTileInteractor] Harvest failed at {cellPos}");
  }
 }

 void FindReferences() {
  if (tileInteractionManager == null)
   tileInteractionManager = TileInteractionManager.Instance;

  if (playerTransform == null)
   playerTransform = FindFirstObjectByType<GardenerController>()?.transform;
 }

 bool EnsureReferences() {
  if (tileInteractionManager == null) {
   tileInteractionManager = TileInteractionManager.Instance;
   if (tileInteractionManager == null) {
    if (showDebug) Debug.LogWarning("[PlayerTileInteractor] TileInteractionManager reference missing.");
    return false;
   }
  }
  return true;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Player\HarvestableTag.cs

﻿using UnityEngine;

pub class HarvestableTag : MonoBehaviour {
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Player\HarvestedItem.cs

﻿using UnityEngine;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Implementations;
using Abracodabra.Genes.Core;

// Note: Ensure your ItemInstance and ItemDefinition classes are accessible here,

pub class HarvestedItem {
 pub ItemInstance Item { get; set; }

 pub HarvestedItem(ItemDefinition definition, Dictionary<string, float> dynamicProps = null) {
  Item = new ItemInstance(definition, dynamicProps);
 }

 pub float GetNutritionValue() {
  return Item.GetNutrition();
 }

 pub bool IsConsumable() {
  return Item.definition != null && Item.definition.isConsumable;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Player\HungerUI.cs

﻿using UnityEngine;
using TMPro;
using WegoSystem; // <-- ADDED THIS LINE to resolve the namespace issue.

pub class HungerUI : MonoBehaviour {
 [SerializeField] PlayerHungerSystem playerHungerSystem;
 [SerializeField] Slider hungerSlider;
 [SerializeField] TextMeshProUGUI hungerText;

 void Start() {
  if (playerHungerSystem == null) {
   GardenerController player = FindAnyObjectByType<GardenerController>();
   if (player != null) {
    playerHungerSystem = player.GetComponent<PlayerHungerSystem>();
   }
  }

  if (playerHungerSystem != null) {
   playerHungerSystem.OnHungerChanged += UpdateUI;
   UpdateUI(playerHungerSystem.CurrentHunger, playerHungerSystem.MaxHunger);
  }
  else {
   Debug.LogError("[HungerUI] PlayerHungerSystem reference not found! UI will not update.", this);
   gameObject.SetActive(false);
  }
 }

 void OnDestroy() {
  if (playerHungerSystem != null) {
   playerHungerSystem.OnHungerChanged -= UpdateUI;
  }
 }

 void UpdateUI(float currentHunger, float maxHunger) {
  if (hungerSlider != null) {
   hungerSlider.maxValue = maxHunger;
   hungerSlider.value = currentHunger;
  }

  if (hungerText != null) {
   hungerText.text = $"{Mathf.CeilToInt(currentHunger)} / {Mathf.CeilToInt(maxHunger)}";
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Player\PlayerActionManager.cs

﻿using System;
using WegoSystem;
using Abracodabra.Genes;
using Abracodabra.UI.Genes;
using Abracodabra.UI.Toolkit;

pub enum PlayerActionType {
 Move,
 UseTool,
 PlantSeed,
 Harvest,
 Interact
}

pub class PlayerActionManager : MonoBehaviour {
 pub stat PlayerActionManager Instance { get; set; }

 pub class ToolActionData {
  pub ToolDefinition Tool;
  pub Vector3Int GridPosition;
 }

 [SerializeField] bool debugMode = true;
 [SerializeField] int tickCostPerAction = 1;
 [SerializeField] float multiTickActionDelay = 0.5f;

 pub event Action<PlayerActionType, object> OnActionExecuted;
 pub event Action<string> OnActionFailed;

 void Awake() {
  if (Instance != null && Instance != this) {
   Destroy(gameObject);
   return;
  }
  Instance = this;
 }

 pub bool ExecutePlayerAction(PlayerActionType actionType, Vector3Int gridPosition, object actionData = null, Action onSuccessCallback = null) {
  if (debugMode) Debug.Log($"[PlayerActionManager] Executing {actionType} at {gridPosition}");

  bool success = false;
  int tickCost = tickCostPerAction;
  object eventPayload = actionData;

  switch (actionType) {
   case PlayerActionType.UseTool:
    var toolDef = actionData as ToolDefinition;
    success = ExecuteToolUse(gridPosition, toolDef);
    if (success) {
     eventPayload = new ToolActionData { Tool = toolDef, GridPosition = gridPosition };
    }
    break;

   case PlayerActionType.PlantSeed:
    tickCost = 2; // Planting takes longer
    var seedItem = actionData as InventoryBarItem;
    success = ExecutePlantSeed(gridPosition, seedItem);
    break;

   case PlayerActionType.Harvest:
    success = ExecuteHarvest(gridPosition);
    break;

   case PlayerActionType.Interact:
    success = ExecuteInteraction(gridPosition, actionData);
    break;
  }

  if (success) {
   AdvanceGameTick(tickCost);
   onSuccessCallback?.Invoke();
   OnActionExecuted?.Invoke(actionType, eventPayload);
  }
  else {
   OnActionFailed?.Invoke($"{actionType} failed at {gridPosition}");
  }

  return success;
 }

 bool ExecuteToolUse(Vector3Int gridPosition, ToolDefinition tool) {
  if (tool == null) return false;
  TileInteractionManager.Instance?.ApplyToolAction(tool);
  return true;
 }

 bool ExecutePlantSeed(Vector3Int gridPosition, InventoryBarItem seedItem) {
  if (debugMode) Debug.Log($"[ExecutePlantSeed] Attempting to plant {seedItem?.GetDisplayName()} at {gridPosition}");

  if (seedItem == null || seedItem.Type != InventoryBarItem.ItemType.Seed) {
   Debug.LogError("[ExecutePlantSeed] Action failed: Provided item was not a valid seed.");
   return false;
  }

bool result = PlantPlacementManager.Instance?.TryPlantSeedFromInventory( seedItem.SeedRuntimeState, gridPosition, TileInteractionManager.Instance.interactionGrid.GetCellCenterWorld(gridPosition)
  ) ?? false;

  if (debugMode) Debug.Log($"[ExecutePlantSeed] PlantPlacementManager returned: {result}");
  return result;
 }

 bool ExecuteHarvest(Vector3Int gridPosition) {
  var entities = GridPositionManager.Instance?.GetEntitiesAt(new GridPosition(gridPosition));
  var plantEntity = entities?.FirstOrDefault(e => e.GetComponent<PlantGrowth>() != null);

  if (plantEntity == null) {
   if (debugMode) Debug.Log($"[PlayerActionManager] Harvest failed: No plant found at {gridPosition}");
   return false;
  }

  var plant = plantEntity.GetComponent<PlantGrowth>();
  if (plant == null) return false;

  List<HarvestedItem> harvestedItems = plant.HarvestAllFruits();

  if (harvestedItems == null || harvestedItems.Count == 0) {
   if (debugMode) Debug.Log($"[PlayerActionManager] Harvest action on plant '{plant.name}' yielded no items.");
   return false;
  }

  int itemsAdded = 0;

  if (InventoryService.IsInitialized) {
   foreach (var harvestedItem in harvestedItems) {
    if (InventoryService.AddHarvestedItem(harvestedItem.Item)) {
     itemsAdded++;
     if (debugMode) Debug.Log($"[PlayerActionManager] Added '{harvestedItem.Item.definition.itemName}' to inventory via InventoryService");
    }
    else {
     if (debugMode) Debug.LogWarning($"[PlayerActionManager] Failed to add harvested item '{harvestedItem.Item.definition.itemName}' to inventory. Inventory may be full.");
    }
   }
  }
  else {
   Debug.LogWarning("[PlayerActionManager] InventoryService not initialized, trying legacy InventoryGridController");

   if (InventoryGridController.Instance != null) {
    foreach (var harvestedItem in harvestedItems) {
     var inventoryItem = InventoryBarItem.FromItem(harvestedItem.Item);
     if (InventoryGridController.Instance.AddItemToInventory(inventoryItem)) {
      itemsAdded++;
     }
    }
   }
   else {
    Debug.LogError("[PlayerActionManager] Neither InventoryService nor InventoryGridController available!");
   }
  }

  if (debugMode) Debug.Log($"[PlayerActionManager] Successfully added {itemsAdded}/{harvestedItems.Count} harvested items to inventory.");

  return itemsAdded > 0;
 }

 bool ExecuteInteraction(Vector3Int gridPosition, object interactionData) {
  if (debugMode) Debug.Log($"[PlayerActionManager] Interaction at {gridPosition}: {interactionData}");
  return true;
 }

 IEnumerator ExecuteDelayedAction(Func<bool> action, int tickCost, Action onSuccessCallback, PlayerActionType actionType, object actionData) {
  for (int i = 0; i < tickCost - 1; i++) {
   yield return new WaitForSeconds(multiTickActionDelay);
   AdvanceGameTick(1);
  }

  bool success = action.Invoke();

  if (success) {
   AdvanceGameTick(1);
   onSuccessCallback?.Invoke();
   OnActionExecuted?.Invoke(actionType, actionData);
  }
  else {
   OnActionFailed?.Invoke($"{actionType} (delayed) failed");
  }
 }

 pub int GetMovementTickCost(Vector3 worldPosition, Component movingEntity = null) {
  int totalCost = tickCostPerAction;
  if (movingEntity != null) {
   IStatusEffectable effectable = movingEntity.GetComponent<IStatusEffectable>();
   if (effectable != null) {
    totalCost += effectable.StatusManager.AdditionalMoveTicks;
   }
  }
  return totalCost;
 }

 void AdvanceGameTick(int tickCount = 1) {
  if (TickManager.Instance == null) return;
  for (int i = 0; i < tickCount; i++) {
   TickManager.Instance.AdvanceTick();
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Player\PlayerHungerSystem.cs

﻿using UnityEngine;
using WegoSystem;

pub class PlayerHungerSystem : MonoBehaviour, ITickUpdateable {
 float maxHunger;

 [Tooltip("What fraction of max hunger the player starts with (e.g., 1.0 for 100%).")]
 [SerializeField] [Range(0f, 1f)] float startingHungerFraction = 1.0f;

 [SerializeField] float hungerDepletionPerTick = 0.1f;

 pub float CurrentHunger { get; set; }
 pub float MaxHunger => maxHunger;

 pub event Action<float, float> OnHungerChanged;
 pub event Action OnStarvation;

 bool hasStarved = false;

 void Start() {
  if (RunManager.HasInstance) {
   maxHunger = RunManager.Instance.playerMaxHunger;
  }
  else {
   Debug.LogError("[PlayerHungerSystem] RunManager not found! Defaulting max hunger to 100.");
   maxHunger = 100f;
  }

  CurrentHunger = maxHunger * startingHungerFraction;
  OnHungerChanged?.Invoke(CurrentHunger, maxHunger);

  if (TickManager.Instance != null) {
   TickManager.Instance.RegisterTickUpdateable(this);
  }
  else {
   Debug.LogError("[PlayerHungerSystem] TickManager not found! Hunger will not deplete.");
  }
 }

 void OnDestroy() {
  var tickManager = TickManager.Instance;
  if (tickManager != null) {
   tickManager.UnregisterTickUpdateable(this);
  }
 }

 pub void OnTickUpdate(int currentTick) {
  if (hasStarved || (RunManager.HasInstance && RunManager.Instance.CurrentState != RunState.GrowthAndThreat)) {
   return;
  }

  CurrentHunger -= hungerDepletionPerTick;
  CurrentHunger = Mathf.Max(0, CurrentHunger);

  OnHungerChanged?.Invoke(CurrentHunger, maxHunger);

  if (CurrentHunger <= 0) {
   hasStarved = true;
   OnStarvation?.Invoke();
   Debug.LogWarning("Player has starved!");
  }
 }

 pub void Eat(float nutritionValue) {
  if (hasStarved || nutritionValue <= 0) return;

  CurrentHunger += nutritionValue;
  CurrentHunger = Mathf.Clamp(CurrentHunger, 0, maxHunger);

  Debug.Log($"Player ate food. Restored {nutritionValue} hunger. Current hunger: {CurrentHunger}/{maxHunger}");
  OnHungerChanged?.Invoke(CurrentHunger, maxHunger);
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Tiles\TileDefinition.cs

﻿using UnityEngine;
using UnityEngine.Tilemaps;
using WegoSystem;

pub class TileDefinition : ScriptableObject {
 [Header("Display")]
 pub string displayName;    // e.g. "Grass", "Dirt", "Wet Dirt"

 [Header("Interaction Priority")]
 [Tooltip("Higher priority tiles are detected first when multiple tiles overlap. " +
   "Use higher values for surface tiles (Grass=100, TilledSoil=90) and lower for underlay tiles (Dirt=10).")]
 [Range(0, 200)]
 pub int interactionPriority = 50;

 [Header("Visuals")]
 pub Color tintColor = Color.white;

 [Header("Tile Behavior")]
 [Tooltip("If > 0, this tile will revert after this many ticks")]
 pub int revertAfterTicks = 0;

 [Tooltip("The tile to revert to when revertAfterTicks expires")]
 pub TileDefinition revertToTile;

 [Tooltip("If true, the tile below this one is kept when this tile is placed")]
 pub bool keepBottomTile = false;

 [Tooltip("If true, this tile is treated as water for reflection masking")]
 pub bool isWaterTile = false;

#if UNITY_EDITOR
 pub void UpdateColor() {
  var manager = UnityEngine.Object.FindAnyObjectByType<TileInteractionManager>();
  if (manager == null) return;

  foreach (var mapping in manager.tileDefinitionMappings) {
   if (mapping.tileDef == this && mapping.tilemapModule != null) {
    Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
    if (renderTilemapTransform != null) {
     Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
     if (renderTilemap != null) {
      renderTilemap.color = tintColor;
      UnityEditor.EditorUtility.SetDirty(renderTilemap);
     }
    }
   }
  }
 }
#endif
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Tiles\TileHoverColorManager.cs

﻿using UnityEngine;

pub class TileHoverColorManager : ScriptableObject {
 [Header("Hover Tile Colors")]
 [SerializeField, Tooltip("Color when player is within range to interact")]
 Color withinRangeColor = new Color(1f, 1f, 1f, 0.8f);

 [SerializeField, Tooltip("Color when player is outside interaction range")]
 Color outsideRangeColor = new Color(1f, 1f, 1f, 0.3f);

 pub Color WithinRangeColor => withinRangeColor;
 pub Color OutsideRangeColor => outsideRangeColor;

 pub Color GetColorForRange(bool isWithinRange) {
  return isWithinRange ? withinRangeColor : outsideRangeColor;
 }

 void OnValidate() {
  if (withinRangeColor.a < outsideRangeColor.a) {
   Debug.LogWarning("[TileHoverColorManager] Within range alpha should typically be higher than outside range alpha for better visibility.");
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Tiles\TileInteractionLibrary.cs

﻿using System.Collections.Generic;
using System; // Needed for [Serializable]

[Serializable] // Make it visible in the Inspector
pub class ToolRefillRule {
 [Tooltip("The tool that can be refilled.")]
 pub ToolDefinition toolToRefill;

 [Tooltip("The tile that must be interacted with to trigger the refill.")]
 pub TileDefinition refillSourceTile;
}

pub class TileInteractionLibrary : ScriptableObject {
 [Header("Standard Tile Transformations")]
 [Tooltip("List of rules: (Tool, fromTile) => toTile.")]
 pub List<TileInteractionRule> rules; // Existing transformation rules

 [Header("Tool Refill Rules")] // <<< NEW HEADER
 [Tooltip("List of rules defining how tools are refilled.")]
 pub List<ToolRefillRule> refillRules; // <<< NEW LIST FOR REFILLS
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Tiles\TileInteractionRule.cs

﻿using System;

pub class TileInteractionRule {
 [Header("Tool Condition")]
 [Tooltip("Which tool triggers this rule.")]
 pub ToolDefinition tool;

 [Header("Tile Transformation")]
 [Tooltip("Which tile must be present to apply the rule.")]
 pub TileDefinition fromTile;
 [Tooltip("Which tile to transform into.")]
 pub TileDefinition toTile;
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Tools\ToolDefinition.cs

﻿using UnityEngine;
using System.Text;

// NOTE: The ITooltipDataProvider interface is defined in UniversalTooltipManager.cs

pub class ToolDefinition : ScriptableObject, ITooltipDataProvider {

 pub ToolType toolType;
 pub string displayName;

 [Header("Visuals")]
 pub Sprite icon;
 pub Color iconTint = Color.white;

 [Header("Usage")]
 pub bool limitedUses = false;
 pub int initialUses = 10;

 [Header("Auto-Add to Inventory")]
 pub bool autoAddToInventory = true;

 pub string GetTooltipTitle() {
  return displayName ?? "Unknown Tool";
 }

 pub string GetTooltipDescription() {
  return $"Tool Type: {toolType}";
 }

 pub string GetTooltipDetails(object source = null) {
  var sb = new StringBuilder();
  sb.Append(limitedUses ? $"<b>Uses:</b> {initialUses}" : "<b>Uses:</b> Unlimited");
  return sb.ToString().TrimEnd();
 }

}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Tools\ToolSwitcher.cs

﻿using UnityEngine;

pub class ToolSwitcher : MonoBehaviour {
 pub stat ToolSwitcher Instance { get; set; }

 pub ToolDefinition[] toolDefinitions;

 Dictionary<ToolDefinition, int> toolUses = new Dictionary<ToolDefinition, int>();

 int currentIndex = 0;

 pub ToolDefinition CurrentTool { get; set; } = null;
 pub int CurrentRemainingUses { get; set; } = -1; // Setter is now private

 pub event Action<ToolDefinition> OnToolChanged;
 pub event Action<int> OnUsesChanged;

 void Awake() {
  if (Instance != null && Instance != this) {
   Destroy(gameObject);
   return;
  }
  Instance = this;

  InitializeAllToolUses();
 }

 void Start() {
  SelectToolByIndex(0);
 }

 void OnDestroy() {
  if (Instance == this) {
   Instance = null;
  }
 }

 void InitializeAllToolUses() {
  toolUses.Clear();
  if (toolDefinitions == null) return;

  foreach (var toolDef in toolDefinitions) {
   if (toolDef != null) {
    if (toolDef.limitedUses) {
     toolUses[toolDef] = toolDef.initialUses;
    }
    else {
     toolUses[toolDef] = -1; // -1 indicates unlimited
    }
   }
  }
 }

 pub void SelectToolByIndex(int index) {
  if (toolDefinitions == null || toolDefinitions.Length == 0 || index < 0 || index >= toolDefinitions.Length) {
   return;
  }

  currentIndex = index;
  ToolDefinition newTool = toolDefinitions[currentIndex];

  if (CurrentTool != newTool) {
   CurrentTool = newTool;
   CurrentRemainingUses = toolUses.ContainsKey(CurrentTool) ? toolUses[CurrentTool] : (CurrentTool.limitedUses ? CurrentTool.initialUses : -1);

   OnToolChanged?.Invoke(CurrentTool);
   OnUsesChanged?.Invoke(CurrentRemainingUses);
   LogToolChange($"[ToolSwitcher SelectToolByIndex]");
  }
 }

 pub void SelectToolByDefinition(ToolDefinition toolDef) {
  if (toolDef == null || toolDefinitions == null) return;

  for (int i = 0; i < toolDefinitions.Length; i++) {
   if (toolDefinitions[i] == toolDef) {
    if (currentIndex == i && CurrentTool == toolDef) return;

    currentIndex = i;
    CurrentTool = toolDef;
    CurrentRemainingUses = toolUses.ContainsKey(CurrentTool) ? toolUses[CurrentTool] : (CurrentTool.limitedUses ? CurrentTool.initialUses : -1);

    OnToolChanged?.Invoke(CurrentTool);
    OnUsesChanged?.Invoke(CurrentRemainingUses);
    LogToolChange($"[ToolSwitcher SelectToolByDefinition]");
    return;
   }
  }
  Debug.LogWarning($"[ToolSwitcher] Tool '{toolDef.displayName}' not found in definitions array");
 }

 pub void RefillCurrentTool() {
  if (CurrentTool == null || !CurrentTool.limitedUses) return;

  toolUses[CurrentTool] = CurrentTool.initialUses;
  CurrentRemainingUses = CurrentTool.initialUses;

  Debug.Log($"[ToolSwitcher RefillCurrentTool] Refilled tool '{CurrentTool.displayName}' to {CurrentRemainingUses} uses.");
  OnUsesChanged?.Invoke(CurrentRemainingUses);
 }

 pub bool TryConsumeUse() {
  if (CurrentTool == null) return false;

  if (!CurrentTool.limitedUses || CurrentRemainingUses == -1) {
   return true;
  }

  if (CurrentRemainingUses > 0) {
   CurrentRemainingUses--;
   toolUses[CurrentTool] = CurrentRemainingUses; // Update the persistent dictionary
   Debug.Log($"[ToolSwitcher TryConsumeUse] Consumed use for '{CurrentTool.displayName}'. Remaining: {CurrentRemainingUses}");
   OnUsesChanged?.Invoke(CurrentRemainingUses);
   return true;
  }
  else {
   Debug.Log($"[ToolSwitcher TryConsumeUse] Tool '{CurrentTool.displayName}' is out of uses.");
   return false;
  }
 }

 void LogToolChange(string prefix = "[ToolSwitcher]") {
  string toolName = (CurrentTool != null) ? CurrentTool.displayName : "(none)";
  string usesSuffix = "";
  if (CurrentTool != null && CurrentTool.limitedUses) {
   usesSuffix = $" ({CurrentRemainingUses}/{CurrentTool.initialUses})";
  }

  Debug.Log($"{prefix} Switched to: {toolName}{usesSuffix} (Index: {currentIndex})");
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Tools\ToolType.cs

﻿pub enum ToolType {
 None,
 Hoe,
 WateringCan,
 SeedPouch,
 HarvestPouch // <<< NEW
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Components\TemporaryFruitSpawnMarker.cs

﻿using UnityEngine;

namespace Abracodabra.Genes {
 pub class TemporaryFruitSpawnMarker : MonoBehaviour {
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\GeneLibrary.cs

﻿using UnityEngine;
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Core;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Abracodabra.Genes {
 pub class GeneLibrary : ScriptableObject, IGeneLibrary {
  pub stat GeneLibrary Instance { get; set; }

  pub void SetActiveInstance() {
   if (Instance != null && Instance != this) {
    Debug.LogWarning("An existing GeneLibrary instance was already active. It is being overwritten.", this);
   }
   Instance = this;
   Initialize();
  }

  [Header("Gene Categories")]
  pub List<PassiveGene> passiveGenes = new List<PassiveGene>();
  pub List<ActiveGene> activeGenes = new List<ActiveGene>();
  pub List<ModifierGene> modifierGenes = new List<ModifierGene>();
  pub List<PayloadGene> payloadGenes = new List<PayloadGene>();

  [Header("System Genes")]
  pub PlaceholderGene placeholderGene;

  Dictionary<string, GeneBase> _guidLookup;
  Dictionary<string, GeneBase> _nameLookup;

  void Initialize() {
   BuildLookupCaches();
  }

  void BuildLookupCaches() {
   _guidLookup = new Dictionary<string, GeneBase>();
   _nameLookup = new Dictionary<string, GeneBase>();

   foreach (var gene in GetAllGenes()) {
    if (gene == null) continue;

    if (!string.IsNullOrEmpty(gene.GUID)) {
     if (!_guidLookup.ContainsKey(gene.GUID)) {
      _guidLookup[gene.GUID] = gene;
     }
     else {
      Debug.LogWarning($"Gene Library: Duplicate GUID '{gene.GUID}' detected. The gene '{gene.name}' will be ignored by GUID lookup. The existing entry is '{_guidLookup[gene.GUID].name}'.", gene);
     }
    }

    if (!string.IsNullOrEmpty(gene.geneName)) {
     if (!_nameLookup.ContainsKey(gene.geneName)) {
      _nameLookup[gene.geneName] = gene;
     }
     else {
      Debug.LogWarning($"Gene Library: Duplicate gene name '{gene.geneName}' detected. The gene '{gene.name}' will be ignored by name lookup. The existing entry is '{_nameLookup[gene.geneName].name}'.", gene);
     }
    }
   }
  }

  pub IEnumerable<GeneBase> GetAllGenes() {
   foreach (var g in passiveGenes) if (g != null) yield return g;
   foreach (var g in activeGenes) if (g != null) yield return g;
   foreach (var g in modifierGenes) if (g != null) yield return g;
   foreach (var g in payloadGenes) if (g != null) yield return g;
  }

  pub GeneBase GetGeneByGUID(string guid) {
   if (string.IsNullOrEmpty(guid)) return null;
   if (_guidLookup == null) BuildLookupCaches();
   return _guidLookup.TryGetValue(guid, out var gene) ? gene : null;
  }

  pub GeneBase GetGeneByName(string name) {
   if (string.IsNullOrEmpty(name)) return null;
   if (_nameLookup == null) BuildLookupCaches();
   return _nameLookup.TryGetValue(name, out var gene) ? gene : null;
  }

  pub GeneBase GetPlaceholderGene() {
   if (placeholderGene == null) {
    Debug.LogError("PlaceholderGene is not assigned in the GeneLibrary asset! The system may be unstable. Please assign it in the editor.", this);
    placeholderGene = ScriptableObject.CreateInstance<PlaceholderGene>();
    placeholderGene.name = "RUNTIME_PLACEHOLDER";
   }
   return placeholderGene;
  }

  pub List<GeneBase> GetGenesOfCategory(GeneCategory category) {
   switch (category) {
    case GeneCategory.Passive: return passiveGenes.Cast<GeneBase>().ToList();
    case GeneCategory.Active: return activeGenes.Cast<GeneBase>().ToList();
    case GeneCategory.Modifier: return modifierGenes.Cast<GeneBase>().ToList();
    case GeneCategory.Payload: return payloadGenes.Cast<GeneBase>().ToList();
    default: return new List<GeneBase>();
   }
  }

  #if UNITY_EDITOR
  void OnValidate() {
   if (placeholderGene == null) {
    string[] guids = AssetDatabase.FindAssets("t:PlaceholderGene");
    if (guids.Length > 0) {
     string path = AssetDatabase.GUIDToAssetPath(guids[0]);
     placeholderGene = AssetDatabase.LoadAssetAtPath<PlaceholderGene>(path);
     Debug.LogWarning("GeneLibrary's PlaceholderGene was unassigned. Auto-assigned from project assets.", this);
     EditorUtility.SetDirty(this);
    }
    else {
     Debug.LogError("Could not find a 'PlaceholderGene' asset in the project. Please create one.", this);
    }
   }
  }

  void AutoPopulate() {
   passiveGenes.Clear();
   activeGenes.Clear();
   modifierGenes.Clear();
   payloadGenes.Clear();

   string[] guids = AssetDatabase.FindAssets("t:GeneBase");
   foreach (string guid in guids) {
    string path = AssetDatabase.GUIDToAssetPath(guid);
    GeneBase gene = AssetDatabase.LoadAssetAtPath<GeneBase>(path);

    if (gene is PlaceholderGene) continue;

    if (gene is PassiveGene p)
     passiveGenes.Add(p);
    else if (gene is ActiveGene a)
     activeGenes.Add(a);
    else if (gene is ModifierGene m)
     modifierGenes.Add(m);
    else if (gene is PayloadGene pay)
     payloadGenes.Add(pay);
   }

   passiveGenes = passiveGenes.OrderBy(g => g.name).ToList();
   activeGenes = activeGenes.OrderBy(g => g.name).ToList();
   modifierGenes = modifierGenes.OrderBy(g => g.name).ToList();
   payloadGenes = payloadGenes.OrderBy(g => g.name).ToList();

   EditorUtility.SetDirty(this);
   Debug.Log($"Auto-populated library: {passiveGenes.Count} passive, {activeGenes.Count} active, {modifierGenes.Count} modifier, {payloadGenes.Count} payload genes.");
  }
  #endif
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\PlantSequenceExecutor.cs

﻿using UnityEngine;
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;

namespace Abracodabra.Genes {
 pub class PlantSequenceExecutor : MonoBehaviour {
  pub PlantGrowth plantGrowth;
  pub PlantGeneRuntimeState runtimeState;

  IGeneEventBus eventBus;
  IDeterministicRandom random;

  void Awake() {
   eventBus = GeneServices.Get<IGeneEventBus>();
   random = GeneServices.Get<IDeterministicRandom>();

   if (eventBus == null || random == null) {
    Debug.LogError($"[{nameof(PlantSequenceExecutor)}] on {gameObject.name} could not retrieve required gene services! This indicates a critical initialization order problem. The component will be disabled.", this);
    enabled = false;
   }
  }

  void Start() {
   if (plantGrowth == null) {
    plantGrowth = GetComponent<PlantGrowth>();
   }
  }

  pub void InitializeWithTemplate(SeedTemplate template) {
   runtimeState = template.CreateRuntimeState();
  }

  pub void InitializeWithTemplate(PlantGeneRuntimeState state) {
   this.runtimeState = state;
   if (runtimeState == null || runtimeState.activeSequence == null || runtimeState.activeSequence.Count == 0) {
    Debug.LogWarning($"Plant '{plantGrowth.name}' has no active gene sequence. Executor will remain idle.", this);
   }
  }

  pub void OnTickUpdate(int currentTick) {
   if (runtimeState == null || runtimeState.template == null || plantGrowth == null) {
    return;
   }

   if (plantGrowth.CurrentState != PlantState.Mature) {
    return;
   }

   var energySystem = plantGrowth.EnergySystem;
   if (energySystem == null) {
    return;
   }

   if (runtimeState.rechargeTicksRemaining > 0) {
    runtimeState.rechargeTicksRemaining--;
    return;
   }

   if (TryExecuteCurrentSlot()) {
    runtimeState.currentPosition++;

    if (runtimeState.currentPosition >= runtimeState.activeSequence.Count) {
     OnSequenceComplete();
    }
   }
  }

  bool TryExecuteCurrentSlot() {
   if (runtimeState.currentPosition >= runtimeState.activeSequence.Count) {
    return false;
   }

   var slot = runtimeState.activeSequence[runtimeState.currentPosition];

   if (!slot.HasContent) {
    return true; // Skip empty slot, advance sequence
   }

   if (slot.delayTicksRemaining > 0) {
    slot.delayTicksRemaining--;
    return false; // Still waiting, do not advance sequence
   }

   var activeGene = slot.activeInstance?.GetGene<ActiveGene>();
   if (activeGene == null) {
    Debug.LogError($"Active gene instance at sequence position {runtimeState.currentPosition} has a null or invalid gene reference! Skipping slot.", this);
    return true; // Skip invalid slot, advance sequence
   }

   float energyCost = slot.GetEnergyCost();
   var energySystem = plantGrowth.EnergySystem;

   if (!energySystem.HasEnergy(energyCost)) {
    eventBus?.Publish(new GeneValidationFailedEvent {
     GeneId = activeGene.GUID,
     Reason = $"Insufficient energy. Has {energySystem.CurrentEnergy}, needs {energyCost}."
    });
    return false; // Not enough energy, do not advance sequence
   }

   energySystem.SpendEnergy(energyCost);
   slot.isExecuting = true;

   var context = new ActiveGeneContext {
    plant = plantGrowth,
    activeInstance = slot.activeInstance,
    modifiers = slot.modifierInstances,
    payloads = slot.payloadInstances,
    sequencePosition = runtimeState.currentPosition,
    executor = this,
    random = random
   };

   foreach (var modInstance in slot.modifierInstances) {
    var modifierGene = modInstance?.GetGene<ModifierGene>();
    if (modifierGene != null) {
     modifierGene.PreExecution(context);
    }
    else {
     Debug.LogWarning($"A modifier gene in the slot at position {runtimeState.currentPosition} is missing or invalid.", this);
    }
   }

   if (activeGene.executionDelayTicks > 0) {
    slot.delayTicksRemaining = activeGene.executionDelayTicks;
   }
   else {
    PerformExecutionLogic(activeGene, context, slot);
   }

   return true; // Execution successful, advance sequence
  }

  void PerformExecutionLogic(ActiveGene activeGene, ActiveGeneContext context, RuntimeSequenceSlot slot) {
   activeGene.Execute(context);

   foreach (var modInstance in slot.modifierInstances) {
    var modifierGene = modInstance?.GetGene<ModifierGene>();
    if (modifierGene != null) {
     modifierGene.PostExecution(context);
    }
   }

   eventBus?.Publish(new GeneExecutedEvent {
    Gene = activeGene,
    SequencePosition = context.sequencePosition,
    Success = true,
    EnergyCost = slot.GetEnergyCost()
   });

   StartCoroutine(ClearExecutionFlag(slot));
  }

  IEnumerator ClearExecutionFlag(RuntimeSequenceSlot slot) {
   yield return new WaitForSeconds(0.5f);
   if(slot != null) {
    slot.isExecuting = false;
   }
  }

  void OnSequenceComplete() {
   var energySystem = plantGrowth.EnergySystem;

   eventBus?.Publish(new SequenceCompletedEvent {
    TotalSlotsExecuted = runtimeState.activeSequence.Count,
    TotalEnergyUsed = (energySystem != null) ? (energySystem.MaxEnergy - energySystem.CurrentEnergy) : 0f
   });

   runtimeState.currentPosition = 0;
   runtimeState.rechargeTicksRemaining = runtimeState.template.baseRechargeTime;
  }

 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\PlantSystem\Growth\PlantGrowth.cs

﻿using UnityEngine;
using Abracodabra.Genes.Components;
using WegoSystem;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Implementations;
using Abracodabra.Genes.Services;

namespace Abracodabra.Genes {
 pub enum PlantState {
  Initializing,
  Growing,
  Mature
 }

 pub class PlantGrowth : MonoBehaviour, ITickUpdateable {
  pub stat ro List<PlantGrowth> AllActivePlants = new List<PlantGrowth>();

  pub SeedTemplate seedTemplate { get; set; }
  pub PlantGeneRuntimeState geneRuntimeState { get; set; }
  pub PlantSequenceExecutor sequenceExecutor { get; set; }

  pub PlantCellManager CellManager { get; set; }
  pub PlantGrowthLogic GrowthLogic { get; set; }
  pub PlantEnergySystem EnergySystem { get; set; }
  pub PlantVisualManager VisualManager { get; set; }

  [SerializeField] pub float desiredPixelsPerCell = 1f;

  pub float GetCellWorldSpacing() {
   if (ResolutionManager.HasInstance && ResolutionManager.Instance.CurrentPPU > 0) {
    return desiredPixelsPerCell / ResolutionManager.Instance.CurrentPPU;
   }
   return desiredPixelsPerCell / 16f;
  }

  pub float cellSpacingInPixels => desiredPixelsPerCell;
  pub float cellSpacing => GetCellWorldSpacing();

  [SerializeField] GameObject seedCellPrefab;
  [SerializeField] GameObject stemCellPrefab;
  [SerializeField] GameObject leafCellPrefab;
  [SerializeField] GameObject berryCellPrefab;

  [SerializeField] PlantShadowController shadowController;
  [SerializeField] PlantOutlineController outlineController;
  [SerializeField] GameObject outlinePartPrefab;
  [SerializeField] bool enableOutline = true;
  [SerializeField] FoodType leafFoodType;

  [SerializeField] bool allowFruitsAroundLeaves = false;
  [SerializeField] int fruitSearchRadius = 2;

  [SerializeField] pub bool rechargeEnergyDuringGrowth = false;

  pub float growthSpeedMultiplier = 1f;
  pub float energyGenerationMultiplier = 1f;
  pub float energyStorageMultiplier = 1f;
  pub float fruitYieldMultiplier = 1f;

  pub float baseGrowthChance;
  pub int minHeight;
  pub int maxHeight;
  pub int leafDensity;
  pub int leafGap;

  pub PlantState CurrentState { get; set; } = PlantState.Initializing;

  HashSet<Vector2Int> activeFruitPositions = new HashSet<Vector2Int>();
  IDeterministicRandom _deterministicRandom;

  void Awake() {
   AllActivePlants.Add(this);

   CellManager = new PlantCellManager(this, seedCellPrefab, stemCellPrefab, leafCellPrefab, berryCellPrefab, leafFoodType);
   GrowthLogic = new PlantGrowthLogic(this);
   EnergySystem = new PlantEnergySystem(this);
   VisualManager = new PlantVisualManager(this, shadowController, null, outlineController, outlinePartPrefab, enableOutline);

   _deterministicRandom = GeneServices.Get<IDeterministicRandom>();
   if (_deterministicRandom == null) {
    Debug.LogError($"[{nameof(PlantGrowth)}] could not retrieve IDeterministicRandom service! Growth will be non-deterministic.", this);
   }
  }

  void OnDestroy() {
   AllActivePlants.Remove(this);
   var tickManager = TickManager.Instance;
   if (tickManager != null) {
    tickManager.UnregisterTickUpdateable(this);
   }
  }

  pub void InitializeWithState(PlantGeneRuntimeState state) {
   if (state == null || state.template == null) {
    Debug.LogError($"Cannot initialize plant on '{gameObject.name}': Provided state or its template is null.", this);
    Destroy(gameObject);
    return;
   }

   this.seedTemplate = state.template;
   this.geneRuntimeState = state;

   this.baseGrowthChance = seedTemplate.baseGrowthChance;
   this.minHeight = seedTemplate.minHeight;
   this.maxHeight = seedTemplate.maxHeight;
   this.leafDensity = seedTemplate.leafDensity;
   this.leafGap = seedTemplate.leafGap;

   sequenceExecutor = GetComponent<PlantSequenceExecutor>();
   if (sequenceExecutor == null) {
    sequenceExecutor = gameObject.AddComponent<PlantSequenceExecutor>();
   }
   sequenceExecutor.plantGrowth = this;

   GrowthLogic.CalculateAndApplyPassiveStats();

   EnergySystem.MaxEnergy = geneRuntimeState.template.maxEnergy * energyStorageMultiplier;
   EnergySystem.CurrentEnergy = geneRuntimeState.template.startingEnergy;
   EnergySystem.BaseEnergyPerLeaf = seedTemplate.energyRegenRate;

   sequenceExecutor.InitializeWithTemplate(this.geneRuntimeState);

   CellManager.SpawnCellVisual(PlantCellType.Seed, Vector2Int.zero);

   CurrentState = PlantState.Initializing;

   StartCoroutine(DelayedGrowthStart());

   if (TickManager.Instance != null) {
    TickManager.Instance.RegisterTickUpdateable(this);
   }

   Debug.Log($"Plant '{gameObject.name}' initialized from template '{seedTemplate.templateName}'. State: {CurrentState}");
  }

  IEnumerator DelayedGrowthStart() {
   yield return new WaitForSeconds(0.5f);
   CurrentState = PlantState.Growing;
   Debug.Log($"Plant '{gameObject.name}' transitioned to Growing state");
  }

  pub void OnTickUpdate(int currentTick) {
   if (CurrentState == PlantState.Mature || rechargeEnergyDuringGrowth) {
    EnergySystem.OnTickUpdate();
   }

   if (sequenceExecutor != null) {
    sequenceExecutor.OnTickUpdate(currentTick);
   }

   if (VisualManager != null) {
    VisualManager.UpdateUI();
   }

   if (CurrentState == PlantState.Growing) {
    float randomValue = (_deterministicRandom != null) ?
     _deterministicRandom.Range(0f, 1f) : Random.value;
    if (randomValue < baseGrowthChance * growthSpeedMultiplier) {
     GrowSomething();
    }
   }
  }

  void GrowSomething() {
   int oldHeight = CellManager.cells.Count(c => c.Value == PlantCellType.Stem);

   if (oldHeight < maxHeight) {
    int newHeight = oldHeight + 1;
    Vector2Int stemPos = new Vector2Int(0, newHeight);
    CellManager.SpawnCellVisual(PlantCellType.Stem, stemPos);

    if (newHeight > 0 && newHeight % leafGap == 0) {
     int leafY = newHeight;

     for (int i = 0; i < leafDensity; i++) {
      int leafOffset = (i / 2) + 1;
      int xOffset = (i % 2 == 0) ? -leafOffset : leafOffset;

      var leafPos = new Vector2Int(xOffset, leafY);

      if (!CellManager.HasCellAt(leafPos)) {
       CellManager.SpawnCellVisual(PlantCellType.Leaf, leafPos);
      }
     }
    }
   }
   else {
    CurrentState = PlantState.Mature;
   }
  }

  pub void HandleBeingEaten(AnimalController eater, PlantCell eatenCell) {
   Debug.Log($"{eater.SpeciesName} ate cell at {eatenCell.GridCoord} on plant {name}");
   CellManager?.ReportCellDestroyed(eatenCell.GridCoord);
  }

  pub void ReportCellDestroyed(Vector2Int coord) {
   if (CellManager.cells.TryGetValue(coord, out var cellType) && cellType == PlantCellType.Fruit) {
    activeFruitPositions.Remove(coord);
   }
   CellManager?.ReportCellDestroyed(coord);
  }

  pub GameObject GetCellGameObjectAt(Vector2Int coord) {
   return CellManager?.GetCellGameObjectAt(coord);
  }

  pub Transform[] GetFruitSpawnPoints() {
   List<Transform> spawnPoints = new List<Transform>();
   List<Vector2Int> sourcePositions = GetFruitSourcePositions();
   HashSet<Vector2Int> emptyPositions = FindEmptyPositionsAround(sourcePositions);

   var availablePositions = emptyPositions.Where(pos => !activeFruitPositions.Contains(pos)).ToList();

   foreach (Vector2Int emptyPos in availablePositions) {
    GameObject tempSpawnPoint = CreateTemporarySpawnPoint(emptyPos);
    if (tempSpawnPoint != null) {
     spawnPoints.Add(tempSpawnPoint.transform);
     activeFruitPositions.Add(emptyPos);
    }
   }

   if (spawnPoints.Count > 0) {
    StartCoroutine(CleanupTemporarySpawnPoints(spawnPoints, 0.1f));
   }

   return spawnPoints.ToArray();
  }

  List<Vector2Int> GetFruitSourcePositions() {
   List<Vector2Int> sourcePositions = new List<Vector2Int>();

   foreach (var kvp in CellManager.cells) {
    if (kvp.Value == PlantCellType.Stem) {
     sourcePositions.Add(kvp.Key);
    }
   }

   if (allowFruitsAroundLeaves) {
    foreach (var kvp in CellManager.cells) {
     if (kvp.Value == PlantCellType.Leaf) {
      sourcePositions.Add(kvp.Key);
     }
    }
   }

   return sourcePositions;
  }

  HashSet<Vector2Int> FindEmptyPositionsAround(List<Vector2Int> sourcePositions) {
   HashSet<Vector2Int> emptyPositions = new HashSet<Vector2Int>();

   foreach (Vector2Int sourcePos in sourcePositions) {
    for (int x = -fruitSearchRadius; x <= fruitSearchRadius; x++) {
     for (int y = -fruitSearchRadius; y <= fruitSearchRadius; y++) {
      if (x == 0 && y == 0) continue;

      Vector2Int checkPos = sourcePos + new Vector2Int(x, y);

      if (!CellManager.HasCellAt(checkPos)) {
       float distance = Vector2Int.Distance(sourcePos, checkPos);
       if (distance <= fruitSearchRadius) {
        emptyPositions.Add(checkPos);
       }
      }
     }
    }
   }

   return emptyPositions;
  }

  GameObject CreateTemporarySpawnPoint(Vector2Int gridPos) {
   float spacing = GetCellWorldSpacing();
   Vector3 worldPos = transform.position + new Vector3(gridPos.x * spacing, gridPos.y * spacing, 0);

   GameObject spawnPoint = new GameObject($"TempFruitSpawnPoint_{gridPos.x}_{gridPos.y}");
   spawnPoint.transform.position = worldPos;
   spawnPoint.transform.SetParent(transform);

   spawnPoint.AddComponent<TemporaryFruitSpawnMarker>();

   return spawnPoint;
  }

  IEnumerator CleanupTemporarySpawnPoints(List<Transform> spawnPoints, float delay) {
   yield return new WaitForSeconds(delay);

   foreach (Transform spawnPoint in spawnPoints) {
    if (spawnPoint != null && spawnPoint.GetComponent<TemporaryFruitSpawnMarker>() != null) {
     Destroy(spawnPoint.gameObject);
    }
   }
  }

  pub List<HarvestedItem> HarvestAllFruits() {
   var harvestedItems = new List<HarvestedItem>();
   if (CellManager == null) return harvestedItems;

   var fruitGameObjects = new List<GameObject>();
   foreach (var cell in CellManager.cells) {
    if (cell.Value == PlantCellType.Fruit) {
     var fruitGO = GetCellGameObjectAt(cell.Key);
     if (fruitGO != null && fruitGO.GetComponent<HarvestableTag>() != null) {
      fruitGameObjects.Add(fruitGO);
     }
    }
   }

   if (fruitGameObjects.Count == 0) {
    return harvestedItems;
   }

   foreach (var fruitGO in fruitGameObjects) {
    var fruitComponent = fruitGO.GetComponent<Fruit>();
    if (fruitComponent != null && fruitComponent.RepresentingItemDefinition != null) {
     harvestedItems.Add(new HarvestedItem(
      fruitComponent.RepresentingItemDefinition,
      fruitComponent.DynamicProperties
     ));
    }

    Destroy(fruitGO);
   }

   Debug.Log($"[{name}] Harvested {harvestedItems.Count} items.");
   return harvestedItems;
  }

#if UNITY_EDITOR
  void OnDrawGizmos() {
   if (!Application.isPlaying) return;
   if (CellManager == null || CellManager.cells == null) return;

   float spacing = GetCellWorldSpacing();

   foreach (var cell in CellManager.cells) {
    Vector2 cellWorldPos = (Vector2)transform.position + (Vector2)cell.Key * spacing;

    switch (cell.Value) {
     case PlantCellType.Stem: Gizmos.color = new Color(0, 1, 0, 0.5f); break;
     case PlantCellType.Leaf: Gizmos.color = new Color(1, 1, 0, 0.5f); break;
     case PlantCellType.Seed: Gizmos.color = new Color(1, 1, 1, 0.5f); break;
     case PlantCellType.Fruit: Gizmos.color = new Color(1, 0, 0, 0.5f); break;
    }

    Gizmos.DrawCube(cellWorldPos, Vector3.one * spacing * 0.9f);
    Gizmos.color = new Color(Gizmos.color.r, Gizmos.color.g, Gizmos.color.b, 1f);
    Gizmos.DrawWireCube(cellWorldPos, Vector3.one * spacing);
   }

   Gizmos.color = new Color(0, 1, 1, 0.2f);
   Vector3Int tilePos = GridPositionManager.Instance?.WorldToGrid(transform.position).ToVector3Int() ?? Vector3Int.zero;
   Vector3 tileWorldPos = GridPositionManager.Instance?.GridToWorld(new GridPosition(tilePos)) ?? transform.position;
   Gizmos.DrawWireCube(tileWorldPos, Vector3.one * 1f);

   UnityEditor.Handles.Label(
    transform.position + Vector3.up * (maxHeight + 1) * spacing,
    $"Cell Spacing: {spacing:F4} wu\nPPU: {(ResolutionManager.HasInstance ? ResolutionManager.Instance.CurrentPPU.ToString() : "Unknown")}\nTile Aligned: {Mathf.Approximately(spacing, 1f)}"
   );
  }

  void OnDrawGizmosSelected() {
   if (!Application.isPlaying || CellManager == null) return;

   List<Vector2Int> sourcePositions = GetFruitSourcePositions();
   HashSet<Vector2Int> emptyPositions = FindEmptyPositionsAround(sourcePositions);

   float spacing = GetCellWorldSpacing();

   Gizmos.color = Color.green;
   foreach (Vector2Int sourcePos in sourcePositions) {
    Vector3 worldPos = transform.position + new Vector3(sourcePos.x * spacing, sourcePos.y * spacing, 0);
    Gizmos.DrawWireSphere(worldPos, spacing * 0.2f);
   }

   Gizmos.color = Color.cyan;
   foreach (Vector2Int emptyPos in emptyPositions) {
    Vector3 worldPos = transform.position + new Vector3(emptyPos.x * spacing, emptyPos.y * spacing, 0);
    Gizmos.DrawWireCube(worldPos, Vector3.one * spacing * 0.5f);
   }
  }
#endif

 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Components\Creature.cs

﻿// File: Assets/Scripts/Genes/Components/Creature.cs

namespace Abracodabra.Genes.Components {
 pub class Creature : MonoBehaviour {
  pub void Feed(float amount) {
   Debug.Log($"{name} was fed for {amount} nutrition points.", this);
   var animalNeeds = GetComponent<AnimalNeeds>();
   if (animalNeeds != null) {
    animalNeeds.ModifyHunger(-amount); // Negative amount to reduce hunger
   }
  }

  pub void Heal(float amount) {
   Debug.Log($"{name} was healed for {amount} HP.", this);
   var animalNeeds = GetComponent<AnimalNeeds>();
   if (animalNeeds != null) {
    animalNeeds.Heal(amount);
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Components\Fruit.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

// Note: Add 'using' for your ItemDefinition namespace if it's not global.

namespace Abracodabra.Genes.Components {
 pub class Fruit : MonoBehaviour {
  pub PlantGrowth SourcePlant { get; set; }
  pub float GrowthTime { get; set; }

  pub ItemDefinition RepresentingItemDefinition { get; set; }

  pub Dictionary<string, float> DynamicProperties { get; set; } = new Dictionary<string, float>();

  pub List<RuntimeGeneInstance> PayloadGeneInstances { get; set; } = new List<RuntimeGeneInstance>();

  pub void LaunchImmediate(Vector2 force) {
   var rb = GetComponent<Rigidbody2D>() ?? gameObject.AddComponent<Rigidbody2D>();
   rb.AddForce(force, ForceMode2D.Impulse);
  }

  pub void StartGrowing() {
   Debug.Log($"Fruit '{gameObject.name}' has started growing for {GrowthTime}s.", this);
  }

  pub void AddVisualEffect(Color color) {
   var renderer = GetComponent<SpriteRenderer>();
   if (renderer != null) {
    renderer.color = Color.Lerp(renderer.color, color, 0.5f);
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Components\NutritionComponent.cs

﻿// File: Assets/Scripts/Genes/Components/NutritionComponent.cs

namespace Abracodabra.Genes.Components {
 pub class NutritionComponent : MonoBehaviour {
  pub float nutritionValue;
  pub float healAmount;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Core\ActiveGene.cs

﻿using UnityEngine;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
 pub abs class ActiveGene : GeneBase {
  pub ovr GeneCategory Category => GeneCategory.Active;

  pub float baseEnergyCost = 20f;
  pub ActiveGeneSlotConfig slotConfig = new ActiveGeneSlotConfig();

  pub bool canExecuteEmpty = false;

  pub int executionDelayTicks = 0;

  pub bool requiresTarget = false;

  pub virt bool IsValidConfiguration(List<ModifierGene> modifiers, List<PayloadGene> payloads) {
   if (!canExecuteEmpty && payloads.Count == 0)
    return false;

   return true;
  }

  pub virt bool CanExecuteNow(PlantGrowth plant, float availableEnergy) {
   return availableEnergy >= baseEnergyCost;
  }

  pub float GetFinalEnergyCost(List<RuntimeGeneInstance> modifiers) {
   float cost = baseEnergyCost;
   foreach (var modInstance in modifiers) {
    if (modInstance == null) continue;

    var modifier = modInstance.GetGene<ModifierGene>();
    if (modifier != null)
     cost = modifier.ModifyEnergyCost(cost, modInstance);
   }
   return Mathf.Max(0, cost);
  }

  pub abs void Execute(ActiveGeneContext context);
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Core\ActiveGeneContext.cs

﻿// File: Assets/Scripts/Genes/Core/ActiveGeneContext.cs
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Services;

namespace Abracodabra.Genes.Core {
 pub class ActiveGeneContext {
  pub PlantGrowth plant;
  pub RuntimeGeneInstance activeInstance;
  pub List<RuntimeGeneInstance> modifiers;
  pub List<RuntimeGeneInstance> payloads;
  pub int sequencePosition;
  pub PlantSequenceExecutor executor;
  pub IDeterministicRandom random;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Core\ActiveGeneSlotConfig.cs

﻿// File: Assets/Scripts/Genes/Core/ActiveGeneSlotConfig.cs

namespace Abracodabra.Genes.Core {
 pub class ActiveGeneSlotConfig {
  pub int modifierSlots = 1;
  pub int payloadSlots = 1;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Core\ModifierGene.cs

﻿// File: Assets/Scripts/Genes/Core/ModifierGene.cs
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
 pub abs class ModifierGene : GeneBase {
  pub ovr GeneCategory Category => GeneCategory.Modifier;

  [Header("Modifier Settings")]
  pub ModifierType modifierType;
  pub float power = 1f;

  pub virt float ModifyEnergyCost(float baseCost, RuntimeGeneInstance instance) => baseCost;
  pub virt void PreExecution(ActiveGeneContext context) { }
  pub virt void PostExecution(ActiveGeneContext context) { }
  pub virt bool ModifyTriggerCondition(ActiveGene gene, PlantGrowth plant) => true;

  pub ovr bool CanAttachTo(GeneBase other) {
   return other.Category == GeneCategory.Active;
  }
 }

 pub enum ModifierType {
  Cost,       // Affects energy consumption
  Trigger,    // Changes when active executes
  Behavior,   // Multi-cast, spread, etc.
  Condition   // Adds requirements
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Core\PassiveGene.cs

﻿using UnityEngine;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
 pub enum PassiveStatType {
  None,           // For passive genes that don't modify stats (e.g., TerrainAffinityGene)
  GrowthSpeed,
  EnergyGeneration,
  EnergyStorage,
  FruitYield,
  Defense
 }

 pub abs class PassiveGene : GeneBase {
  pub ovr GeneCategory Category => GeneCategory.Passive;

  [Header("Stat Modification")]
  [Tooltip("Which stat this gene modifies. Set to 'None' for genes that don't modify stats (like TerrainAffinity).")]
  pub PassiveStatType statToModify = PassiveStatType.None;

  [Tooltip("Base value of the modification (multiplier). 1.0 = no change.")]
  pub float baseValue = 1f;

  [Tooltip("If true, multiple copies stack additively. If false, they stack multiplicatively.")]
  pub bool stacksAdditively = true;

  [Tooltip("Maximum number of this gene that can be stacked. -1 for unlimited.")]
  pub int maxStacks = -1;

  pub abs void ApplyToPlant(PlantGrowth plant, RuntimeGeneInstance instance);

  pub abs string GetStatModificationText();

  pub virt bool MeetsRequirements(PlantGrowth plant) => true;

  pub virt bool IsCompatibleWith(PassiveGene other) => true;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Core\PayloadGene.cs

﻿// File: Assets/Scripts/Genes/Core/PayloadGene.cs
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Components; // FIX: Added using statement for Fruit

namespace Abracodabra.Genes.Core {
 pub abs class PayloadGene : GeneBase {
  pub ovr GeneCategory Category => GeneCategory.Payload;

  [Header("Payload Settings")]
  pub PayloadType payloadType;
  pub float basePotency = 1f;

  pub abs void ApplyPayload(PayloadContext context);

  pub virt void ConfigureFruit(Fruit fruit, RuntimeGeneInstance instance) { }

  pub virt void ApplyToTarget(GameObject target, RuntimeGeneInstance instance) { }

  pub ovr bool CanAttachTo(GeneBase other) {
   return other.Category == GeneCategory.Active;
  }

  pub float GetFinalPotency(RuntimeGeneInstance instance) {
   if (instance == null) return basePotency;
   return basePotency * instance.GetValue("potency_multiplier", 1f);
  }
 }

 pub enum PayloadType {
  Substance,  // Damage/status effects
  Nutrition,  // Healing/hunger
  Special     // Unique effects
 }

 pub class PayloadContext {
  pub GameObject target;
  pub PlantGrowth source;
  pub ActiveGene parentGene;
  pub RuntimeGeneInstance payloadInstance;
  pub float effectMultiplier = 1f;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Core\PlaceholderGene.cs

﻿using UnityEngine;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
 pub class PlaceholderGene : PassiveGene {
  pub ovr void ApplyToPlant(PlantGrowth plant, RuntimeGeneInstance instance) {
  }

  pub ovr string GetStatModificationText() {
   return "Missing Gene";
  }

  pub ovr string GetTooltip(GeneTooltipContext context) {
   return "This gene could not be loaded. It may have been deleted or renamed.";
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Core\SafeGeneLoader.cs

﻿// File: Assets/Scripts/Genes/Core/SafeGeneLoader.cs
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
 pub stat class SafeGeneLoader {
  pub stat GeneBase LoadGeneWithFallback(string guid, string fallbackName = null) {
   var library = GeneServices.Get<IGeneLibrary>();
   if (library == null) {
    Debug.LogError("Gene Library service not available! Cannot load gene.");
    return null;
   }

   var gene = library.GetGeneByGUID(guid);
   if (gene != null) return gene;

   if (!string.IsNullOrEmpty(fallbackName)) {
    gene = library.GetGeneByName(fallbackName);
    if (gene != null) {
     Debug.LogWarning($"Gene with GUID '{guid}' not found, but a gene with the fallback name '{fallbackName}' was loaded instead. The original asset may have been deleted or its GUID changed.");
     return gene;
    }
   }

   Debug.LogError($"Could not find gene with GUID '{guid}' or fallback name '{fallbackName}'. Returning placeholder.");
   return library.GetPlaceholderGene();
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\GeneBase.cs

﻿using UnityEngine;
using Abracodabra.Genes.Runtime; // For RuntimeGeneInstance in context

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Abracodabra.Genes.Core {
 pub abs class GeneBase : ScriptableObject, ITooltipDataProvider {
  pub string geneName;
  pub string description;
  pub Sprite icon;
  pub int tier = 1;

  pub Color geneColor = Color.white;
  pub GameObject effectPrefab;

  [SerializeField]
  string _persistentGUID;
  [SerializeField]
  int _version = 1;

#if UNITY_EDITOR
  void OnValidate() {
   if (string.IsNullOrEmpty(_persistentGUID)) {
    _persistentGUID = System.Guid.NewGuid().ToString();
    EditorUtility.SetDirty(this);
   }
  }
#endif

  pub string GUID {
   get {
#if UNITY_EDITOR
    if (string.IsNullOrEmpty(_persistentGUID)) {
     _persistentGUID = System.Guid.NewGuid().ToString();
     EditorUtility.SetDirty(this);
    }
#endif
    return _persistentGUID;
   }
  }

  pub int Version => _version;
  pub abs GeneCategory Category { get; }

  pub abs string GetTooltip(GeneTooltipContext context);
  pub string GetTooltipTitle() => geneName;
  pub string GetTooltipDescription() => $"Tier {tier} {Category} Gene";
  pub string GetTooltipDetails(object source = null) {
   if (source is GeneTooltipContext context) {
    return GetTooltip(context);
   }
   return description;
  }

  pub virt bool CanAttachTo(GeneBase other) => false;
  pub virt void MigrateFromVersion(int oldVersion, GeneInstanceData instanceData) { }
 }

 pub enum GeneCategory {
  Passive,
  Active,
  Modifier,
  Payload,
  Seed // NEW: The dedicated category for the editor slot.
 }

 pub class GeneTooltipContext {
  pub PlantGrowth plant; // The plant the gene is on
  pub bool showAdvanced; // Show detailed stats
  pub RuntimeGeneInstance instance; // The specific instance with its current values
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Implementations\Passive\TerrainAffinityGene.cs

using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
 pub class TerrainAffinityGene : PassiveGene {
  [Header("Terrain Configuration")]
  [Tooltip("List of tile definitions where this plant CAN grow. If empty, uses global rules.")]
  [SerializeField] List<TileDefinition> allowedTiles = new List<TileDefinition>();

  [Tooltip("If true, this gene ADDS to the allowed tiles (permissive). If false, this gene RESTRICTS to only these tiles.")]
  [SerializeField] bool additive = false;

  [Header("Growth Bonuses")]
  [Tooltip("Growth speed bonus when planted on preferred terrain (multiplier, 1.0 = no bonus)")]
  [SerializeField] float preferredTerrainGrowthBonus = 1.2f;

  [Tooltip("Optional: Tiles where this plant grows faster than normal")]
  [SerializeField] List<TileDefinition> preferredTiles = new List<TileDefinition>();

  pub IReadOnlyList<TileDefinition> AllowedTiles => allowedTiles;
  pub IReadOnlyList<TileDefinition> PreferredTiles => preferredTiles;
  pub bool IsAdditive => additive;
  pub float PreferredTerrainGrowthBonus => preferredTerrainGrowthBonus;

  void OnEnable() {
   statToModify = PassiveStatType.None;
   baseValue = 1f;
  }

  void OnValidate() {
   if (statToModify != PassiveStatType.None) {
    statToModify = PassiveStatType.None;
   }
  }

  pub bool IsTileAllowed(TileDefinition tile) {
   if (tile == null) return false;
   if (allowedTiles == null || allowedTiles.Count == 0) return true; // No restriction
   return allowedTiles.Contains(tile);
  }

  pub bool IsPreferredTile(TileDefinition tile) {
   if (tile == null) return false;
   if (preferredTiles == null || preferredTiles.Count == 0) return false;
   return preferredTiles.Contains(tile);
  }

  pub float GetGrowthMultiplierForTile(TileDefinition tile) {
   if (IsPreferredTile(tile)) {
    return preferredTerrainGrowthBonus;
   }
   return 1.0f;
  }

  pub ovr void ApplyToPlant(PlantGrowth plant, RuntimeGeneInstance instance) {
   if (plant == null) return;

   Debug.Log($"[TerrainAffinityGene] Applied to plant {plant.name}");
  }

  pub ovr string GetStatModificationText() {
   if (allowedTiles == null || allowedTiles.Count == 0) {
    return "Can grow on any terrain";
   }

   var tileNames = new List<string>();
   foreach (var tile in allowedTiles) {
    if (tile != null) {
     tileNames.Add(tile.displayName);
    }
   }

   if (tileNames.Count == 0) {
    return "Can grow on any terrain";
   }

   return $"Grows on: {string.Join(", ", tileNames)}";
  }

  pub ovr string GetTooltip(GeneTooltipContext context) {
   string baseTooltip = $"<b>{geneName}</b>\n";
   baseTooltip += $"<i>Terrain Affinity Gene</i>\n\n";
   baseTooltip += description + "\n\n";
   baseTooltip += GetStatModificationText();

   if (preferredTiles != null && preferredTiles.Count > 0) {
    var prefNames = new List<string>();
    foreach (var tile in preferredTiles) {
     if (tile != null) prefNames.Add(tile.displayName);
    }
    if (prefNames.Count > 0) {
     baseTooltip += $"\n\n<color=#90EE90>Preferred: {string.Join(", ", prefNames)}</color>";
     baseTooltip += $"\n+{(preferredTerrainGrowthBonus - 1f) * 100:F0}% growth speed on preferred terrain";
    }
   }

   return baseTooltip;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Implementations\Active\BasicFruitGene.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Components;
using Abracodabra.Genes.Implementations; // Added to reference NutritiousPayload
using WegoSystem;

namespace Abracodabra.Genes.Implementations {
 pub class BasicFruitGene : ActiveGene {
  [Header("Fruit Production")]
  pub GameObject fruitPrefab;
  pub float growthTime = 2f;
  pub int fruitCount = 1;
  pub float launchForce = 5f;

  [Header("Harvest Item")]
  [Tooltip("The Item Definition this gene produces when the fruit is harvested.")]
  pub ItemDefinition harvestedItemDefinition; // NEW: Link to the item asset.

  pub ovr void Execute(ActiveGeneContext context) {
   if (fruitPrefab == null) {
    Debug.LogError($"BasicFruitGene '{geneName}' is missing its fruitPrefab!", this);
    return;
   }
   if (harvestedItemDefinition == null) {
    Debug.LogError($"BasicFruitGene '{geneName}' is missing its Harvested Item Definition!", this);
    return;
   }

   Transform[] fruitPoints = context.plant.GetFruitSpawnPoints();
   if (fruitPoints.Length == 0) {
    Debug.LogWarning($"Plant '{context.plant.name}' has no empty spaces for fruit spawning.", context.plant);
    return;
   }

   bool isInstant = false;
   foreach (var modInstance in context.modifiers) {
    if (modInstance.GetGene<ModifierGene>()?.modifierType == ModifierType.Trigger) {
     isInstant = true;
     break;
    }
   }

   int count = Mathf.Min(fruitCount, fruitPoints.Length);
   List<Transform> shuffledPoints = fruitPoints.OrderBy(x => Random.value).ToList();

   for (int i = 0; i < count; i++) {
    Vector3 spawnPosition = shuffledPoints[i].position;
    Vector2Int fruitGridCoord = Vector2Int.RoundToInt(context.plant.transform.InverseTransformPoint(spawnPosition) / context.plant.GetCellWorldSpacing());

    GameObject fruitObj = context.plant.CellManager.SpawnCellVisual(PlantCellType.Fruit, fruitGridCoord);
    if (fruitObj == null) continue;

    fruitObj.transform.position = spawnPosition;

    FoodItem foodItem = fruitObj.GetComponent<FoodItem>();
    if (foodItem != null) {
     GridPosition gridPos = GridPositionManager.Instance.WorldToGrid(spawnPosition);
     foodItem.InitializeAsPlantPart(foodItem.foodType, gridPos);
    }

    Fruit fruit = fruitObj.GetComponent<Fruit>();
    if (fruit != null) {
     ConfigureFruit(fruit, context);

     if (isInstant) {
      float angle = context.random.Range(0f, 360f);
      Vector2 direction = Quaternion.Euler(0, 0, angle) * Vector2.up;
      fruit.LaunchImmediate(direction.normalized * launchForce);
     }
     else {
      fruit.StartGrowing();
     }
    }
   }
  }

  void ConfigureFruit(Fruit fruit, ActiveGeneContext context) {
   fruit.SourcePlant = context.plant;
   fruit.GrowthTime = growthTime;

   fruit.RepresentingItemDefinition = harvestedItemDefinition;

   var dynamicProps = new Dictionary<string, float>();
   float totalPotencyMultiplier = 1f;

   foreach (var payloadInstance in context.payloads) {
    var payloadGene = payloadInstance.GetGene<PayloadGene>();
    if (payloadGene is NutritiousPayload) {
     totalPotencyMultiplier *= payloadGene.GetFinalPotency(payloadInstance);
    }
   }

   dynamicProps["nutrition_multiplier"] = totalPotencyMultiplier;
   fruit.DynamicProperties = dynamicProps;

   foreach (var payloadInstance in context.payloads) {
    payloadInstance.GetGene<PayloadGene>()?.ConfigureFruit(fruit, payloadInstance);
   }
  }

  pub ovr bool IsValidConfiguration(List<ModifierGene> modifiers, List<PayloadGene> payloads) {
   return true;
  }

  pub ovr string GetTooltip(GeneTooltipContext context) {
   return $"{description}\n\n" +
    $"Grows <b>{fruitCount}</b> fruit(s).\n" +
    $"Produces Item: <b>{(harvestedItemDefinition != null ? harvestedItemDefinition.itemName : "None")}</b>\n" +
    $"Energy Cost: <b>{baseEnergyCost} E</b>\n" +
    $"Slots: <b>{slotConfig.modifierSlots}</b> Modifiers, <b>{slotConfig.payloadSlots}</b> Payloads";
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Implementations\Modifier\CostReductionGene.cs

﻿// File: Assets/Scripts/Genes/Implementations/Modifier/CostReductionGene.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Implementations {
 pub class CostReductionGene : ModifierGene {
  [Header("Cost Settings")]
  [Range(0.1f, 0.9f)]
  pub float costMultiplier = 0.75f; // i.e., 25% reduction

  pub CostReductionGene() {
   modifierType = ModifierType.Cost;
  }

  pub ovr float ModifyEnergyCost(float baseCost, RuntimeGeneInstance instance) {
   float finalMultiplier = costMultiplier * instance.GetValue("efficiency", 1f);
   return baseCost * finalMultiplier;
  }

  pub ovr string GetTooltip(GeneTooltipContext context) {
   float reduction = (1f - costMultiplier) * 100f;
   return $"{description}\n\n" +
    $"Reduces the attached Active Gene's energy cost by <b>{reduction:F0}%</b>.";
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Implementations\Passive\GrowthSpeedGene.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Implementations {
 pub class GrowthSpeedGene : PassiveGene {
  pub GrowthSpeedGene() {
   statToModify = PassiveStatType.GrowthSpeed;
   baseValue = 1.5f; // This now represents a 50% increase
   stacksAdditively = true;
  }

  pub ovr void ApplyToPlant(PlantGrowth plant, RuntimeGeneInstance instance) {
  }

  pub ovr string GetStatModificationText() {
   float percentage = (baseValue - 1f) * 100f;
   return percentage >= 0
    ? $"+{percentage:F0}% Growth Speed"
    : $"{percentage:F0}% Growth Speed";
  }

  pub ovr string GetTooltip(GeneTooltipContext context) {
   float finalMultiplier = baseValue;
   if (context.instance != null) {
    finalMultiplier = baseValue * context.instance.GetValue("power_multiplier", 1f);
   }
   float finalPercentage = (finalMultiplier - 1f) * 100f;

   string effectText = finalPercentage >= 0
    ? $"+{finalPercentage:F0}% Growth Speed"
    : $"{finalPercentage:F0}% Growth Speed";

   return $"{description}\n\n" +
    $"<b>Effect:</b> {effectText}\n" +
    "Reduces the time required for the plant to reach maturity.";
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Implementations\Payload\NutritiousPayload.cs

﻿// File: Assets/Scripts/Genes/Implementations/Payload/NutritiousPayload.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Components;

namespace Abracodabra.Genes.Implementations {
 pub class NutritiousPayload : PayloadGene {
  pub float nutritionValue = 10f;
  pub float healAmount = 5f;

  pub NutritiousPayload() {
   payloadType = PayloadType.Nutrition;
  }

  pub ovr void ApplyPayload(PayloadContext context) {
   ApplyToTarget(context.target, context.payloadInstance);
  }

  pub ovr void ConfigureFruit(Fruit fruit, RuntimeGeneInstance instance) {
   var nutrition = fruit.gameObject.GetComponent<NutritionComponent>() ?? fruit.gameObject.AddComponent<NutritionComponent>();
   nutrition.nutritionValue = nutritionValue * GetFinalPotency(instance);
   nutrition.healAmount = healAmount;

   fruit.AddVisualEffect(geneColor);
  }

  pub ovr void ApplyToTarget(GameObject target, RuntimeGeneInstance instance) {
   var creature = target.GetComponent<Creature>();
   if (creature != null) {
    float finalNutrition = nutritionValue * GetFinalPotency(instance);
    creature.Feed(finalNutrition);
    creature.Heal(healAmount);
   }
  }

  pub ovr string GetTooltip(GeneTooltipContext context) {
   float potency = 1f;
   if (context.instance != null) {
    potency = GetFinalPotency(context.instance);
   }

   return $"{description}\n\n" +
    $"Adds <b>{nutritionValue * potency:F0}</b> nutrition to the fruit.\n" +
    $"Heals for <b>{healAmount:F0}</b> HP when consumed.";
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Runtime\PlantGeneRuntimeState.cs

﻿using System;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Core;

namespace Abracodabra.Genes.Runtime {
 pub class PlantGeneRuntimeState {
  pub SeedTemplate template;

  pub List<RuntimeGeneInstance> passiveInstances = new List<RuntimeGeneInstance>();
  pub List<RuntimeSequenceSlot> activeSequence = new List<RuntimeSequenceSlot>();

  [NonSerialized] pub int currentPosition = 0;
  [NonSerialized] pub int rechargeTicksRemaining = 0;
  [NonSerialized] pub bool isExecuting = false;

  pub void InitializeFromTemplate() {
   if (template == null) return;

   passiveInstances.Clear();
   foreach (var entry in template.passiveGenes) {
    if (entry.gene == null) continue;
    var instance = new RuntimeGeneInstance(entry.gene);
    instance.SetValue("power_multiplier", entry.powerMultiplier);
    passiveInstances.Add(instance);
   }

   activeSequence.Clear();
   foreach (var slotTemplate in template.activeSequence) {
    var slot = new RuntimeSequenceSlot();
    slot.InitializeFromTemplate(slotTemplate);
    activeSequence.Add(slot);
   }

  }

  pub void Reset() {
   currentPosition = 0;
   rechargeTicksRemaining = 0;
   isExecuting = false;
  }

  pub float CalculateTotalEnergyCost() {
   float total = 0;
   foreach (var slot in activeSequence) {
    if (slot.HasContent) {
     total += slot.GetEnergyCost();
    }
   }
   return total;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Runtime\RuntimeGeneInstance.cs

﻿// File: Assets/Scripts/Genes/Runtime/RuntimeGeneInstance.cs
using Abracodabra.Genes.Core;

namespace Abracodabra.Genes.Runtime {
 pub class RuntimeGeneInstance : ISerializationCallbackReceiver {
  [SerializeField] string geneGUID;
  [SerializeField] string geneName; // Fallback for missing genes
  [SerializeField] GeneInstanceData instanceData;

  [NonSerialized] GeneBase cachedGene;

  pub RuntimeGeneInstance(GeneBase sourceGene) {
   if (sourceGene == null) {
    Debug.LogError("Cannot create RuntimeGeneInstance from a null sourceGene!");
    return;
   }

   geneGUID = sourceGene.GUID;
   geneName = sourceGene.geneName;
   instanceData = new GeneInstanceData();
   cachedGene = sourceGene;
  }

  pub T GetGene<T>() where T : GeneBase {
   if (cachedGene == null)
    LoadGene();
   return cachedGene as T;
  }

  pub GeneBase GetGene() {
   if (cachedGene == null)
    LoadGene();
   return cachedGene;
  }

  void LoadGene() {
   cachedGene = SafeGeneLoader.LoadGeneWithFallback(geneGUID, geneName);
   if (cachedGene != null && instanceData != null) {
    if (instanceData.version < cachedGene.Version) {
     cachedGene.MigrateFromVersion(instanceData.version, instanceData);
     instanceData.version = cachedGene.Version;
    }
   }
  }

  pub float GetValue(string key, float defaultValue = 0f) {
   return instanceData.GetValue(key, defaultValue);
  }

  pub void SetValue(string key, float value) {
   instanceData.SetValue(key, value);
  }

  pub void ModifyValue(string key, float delta) {
   instanceData.ModifyValue(key, delta);
  }

  pub void OnBeforeSerialize() {
   if (cachedGene != null) {
    geneGUID = cachedGene.GUID;
    geneName = cachedGene.geneName;

    if (instanceData != null && instanceData.version < cachedGene.Version) {
     instanceData.version = cachedGene.Version;
    }
   }
  }

  pub void OnAfterDeserialize() {
   cachedGene = null;
  }
 }

 pub class GeneInstanceData : ISerializationCallbackReceiver {
  pub int version = 1;

  [SerializeField] List<string> _keys = new List<string>();
  [SerializeField] List<float> _values = new List<float>();

  [NonSerialized] Dictionary<string, float> _runtimeValues = new Dictionary<string, float>();

  pub int stackCount = 1;
  pub float powerMultiplier = 1f;

  pub float GetValue(string key, float defaultValue = 0f) {
   return _runtimeValues.TryGetValue(key, out float value) ? value : defaultValue;
  }

  pub void SetValue(string key, float value) {
   _runtimeValues[key] = value;
  }

  pub void ModifyValue(string key, float delta) {
   if (_runtimeValues.TryGetValue(key, out float currentValue)) {
    _runtimeValues[key] = currentValue + delta;
   }
   else {
    _runtimeValues[key] = delta;
   }
  }

  pub void OnBeforeSerialize() {
   _keys.Clear();
   _values.Clear();

   if (_runtimeValues == null) {
    return;
   }

   foreach (var kvp in _runtimeValues) {
    _keys.Add(kvp.Key);
    _values.Add(kvp.Value);
   }
  }

  pub void OnAfterDeserialize() {
   _runtimeValues = new Dictionary<string, float>();

   if (_keys != null && _values != null && _keys.Count == _values.Count) {
    for (int i = 0; i < _keys.Count; i++) {
     if (!string.IsNullOrEmpty(_keys[i]) && !_runtimeValues.ContainsKey(_keys[i])) {
      _runtimeValues.Add(_keys[i], _values[i]);
     }
    }
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Runtime\RuntimeSequenceSlot.cs

﻿using System;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;

namespace Abracodabra.Genes.Runtime {
 pub class RuntimeSequenceSlot {
  pub RuntimeGeneInstance activeInstance;
  pub List<RuntimeGeneInstance> modifierInstances = new List<RuntimeGeneInstance>();
  pub List<RuntimeGeneInstance> payloadInstances = new List<RuntimeGeneInstance>();

  [NonSerialized] pub bool isHighlighted;
  [NonSerialized] pub bool isExecuting;
  [NonSerialized] pub int delayTicksRemaining = 0; // For tick-based delays

  pub bool HasContent => activeInstance != null;

  pub void InitializeFromTemplate(SequenceSlotTemplate template) {
   if (template.activeGene != null)
    activeInstance = new RuntimeGeneInstance(template.activeGene);

   modifierInstances.Clear();
   foreach (var modEntry in template.modifiers) {
    if (modEntry?.gene == null) continue;
    var instance = new RuntimeGeneInstance(modEntry.gene);
    instance.SetValue("power_multiplier", modEntry.powerMultiplier);
    modifierInstances.Add(instance);
   }

   payloadInstances.Clear();
   foreach (var payloadEntry in template.payloads) {
    if (payloadEntry?.gene == null) continue;
    var instance = new RuntimeGeneInstance(payloadEntry.gene);
    instance.SetValue("power_multiplier", payloadEntry.powerMultiplier);
    payloadInstances.Add(instance);
   }
  }

  pub float GetEnergyCost() {
   var active = activeInstance?.GetGene<ActiveGene>();
   if (active == null) return 0;

   return active.GetFinalEnergyCost(modifierInstances);
  }

  pub void Clear() {
   activeInstance = null;
   modifierInstances.Clear();
   payloadInstances.Clear();
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Services\DeterministicRandom.cs

﻿// File: Assets/Scripts/Genes/Services/DeterministicRandom.cs

namespace Abracodabra.Genes.Services {
 pub class DeterministicRandom : IDeterministicRandom {
  System.Random rng;
  int currentSeed;

  pub DeterministicRandom(int seed) {
   SetSeed(seed);
  }

  pub void SetSeed(int seed) {
   currentSeed = seed;
   rng = new System.Random(seed);
  }

  pub float Range(float min, float max) {
   return (float)(rng.NextDouble() * (max - min) + min);
  }

  pub int Range(int min, int max) {
   return rng.Next(min, max);
  }

  pub void Reset() {
   rng = new System.Random(currentSeed);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Services\GeneEffectPool.cs

﻿// File: Assets/Scripts/Genes/Services/GeneEffectPool.cs

namespace Abracodabra.Genes.Services {
 pub class GeneEffectPool : MonoBehaviour, IGeneEffectPool {
  stat GeneEffectPool _instance;
  pub stat GeneEffectPool Instance {
   get {
    if (_instance == null) {
     var go = new GameObject("GeneEffectPool");
     _instance = go.AddComponent<GeneEffectPool>();
     DontDestroyOnLoad(go);
    }
    return _instance;
   }
  }

  Dictionary<GameObject, Queue<GameObject>> pools = new Dictionary<GameObject, Queue<GameObject>>();
  Transform poolContainer;

  void Awake() {
   poolContainer = new GameObject("PooledEffects").transform;
   poolContainer.SetParent(transform);
  }

  pub GameObject GetEffect(GameObject prefab, Vector3 position, Quaternion rotation) {
   if (prefab == null) return null;

   if (!pools.ContainsKey(prefab))
    pools[prefab] = new Queue<GameObject>();

   GameObject effect;
   if (pools[prefab].Count > 0) {
    effect = pools[prefab].Dequeue();
    effect.transform.SetPositionAndRotation(position, rotation);
    effect.SetActive(true);
   }
   else {
    effect = Instantiate(prefab, position, rotation);
    var poolable = effect.AddComponent<PoolableEffect>();
    poolable.sourcePrefab = prefab;
    poolable.pool = this;
   }

   return effect;
  }

  pub void ReturnEffect(GameObject effect, GameObject sourcePrefab) {
   if (effect == null || sourcePrefab == null) return;

   effect.SetActive(false);
   effect.transform.SetParent(poolContainer);

   if (!pools.ContainsKey(sourcePrefab))
    pools[sourcePrefab] = new Queue<GameObject>();

   pools[sourcePrefab].Enqueue(effect);
  }

  pub void PrewarmPool(GameObject prefab, int count) {
   if (prefab == null || count <= 0) return;
   var list = new List<GameObject>();
   for (int i = 0; i < count; i++) {
    var obj = GetEffect(prefab, Vector3.zero, Quaternion.identity);
    list.Add(obj);
   }

   foreach (var obj in list) {
    var poolable = obj.GetComponent<PoolableEffect>();
    if (poolable != null)
     ReturnEffect(obj, poolable.sourcePrefab);
   }
  }
 }

 pub class PoolableEffect : MonoBehaviour {
  pub GameObject sourcePrefab;
  pub GeneEffectPool pool;
  pub float lifetime = 2f;

  void OnEnable() {
   if (lifetime > 0)
    Invoke(nameof(ReturnToPool), lifetime);
  }

  void OnDisable() {
   CancelInvoke();
  }

  pub void ReturnToPool() {
   if (pool != null && sourcePrefab != null)
    pool.ReturnEffect(gameObject, sourcePrefab);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Services\GeneEventBus.cs

﻿// File: Assets/Scripts/Genes/Services/GeneEventBus.cs
using Abracodabra.Genes.Core; // Assuming Gene classes will be in this namespace

namespace Abracodabra.Genes.Services {
 pub class GeneEventBus : IGeneEventBus {
  Dictionary<Type, List<Delegate>> handlers = new Dictionary<Type, List<Delegate>>();

  pub void Subscribe<T>(Action<T> handler) where T : class {
   var type = typeof(T);
   if (!handlers.ContainsKey(type))
    handlers[type] = new List<Delegate>();
   handlers[type].Add(handler);
  }

  pub void Unsubscribe<T>(Action<T> handler) where T : class {
   var type = typeof(T);
   if (handlers.ContainsKey(type))
    handlers[type].Remove(handler);
  }

  pub void Publish<T>(T message) where T : class {
   var type = typeof(T);
   if (handlers.TryGetValue(type, out var list)) {
    var handlersToInvoke = new List<Delegate>(list);
    foreach (Action<T> handler in handlersToInvoke)
     handler?.Invoke(message);
   }
  }
 }

 pub class GeneExecutedEvent {
  pub ActiveGene Gene { get; set; }
  pub int SequencePosition { get; set; }
  pub bool Success { get; set; }
  pub float EnergyCost { get; set; }
 }

 pub class SequenceCompletedEvent {
  pub int TotalSlotsExecuted { get; set; }
  pub float TotalEnergyUsed { get; set; }
 }

 pub class GeneValidationFailedEvent {
  pub string GeneId { get; set; }
  pub string Reason { get; set; }
 }

}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Services\GeneServices.cs

﻿using System;
using Abracodabra.Genes.Core;

namespace Abracodabra.Genes.Services {
 pub stat class GeneServices {
  stat Dictionary<Type, object> services = new Dictionary<Type, object>();
  stat bool isInitialized = false;

  pub stat bool IsInitialized => isInitialized;

  pub stat void Initialize() {
   if (isInitialized) return;

   Register<IGeneEventBus>(new GeneEventBus());
   Register<IDeterministicRandom>(new DeterministicRandom(DateTime.Now.Millisecond));

   isInitialized = true;
   Debug.Log("Core Gene Services initialized (EventBus, Random).");
  }

  pub stat void Register<T>(T service) where T : class {
   services[typeof(T)] = service;
  }

  pub stat T Get<T>() where T : class {
   if (!isInitialized) {
    Debug.LogWarning($"GeneServices accessed for type '{typeof(T).Name}' before explicit initialization. Auto-initializing now. Please check script execution order.");
    Initialize(); // Auto-initialize if needed
   }

   if (typeof(T) == typeof(IGeneLibrary) && !services.ContainsKey(typeof(T))) {
    Debug.LogWarning("IGeneLibrary service was requested before it was registered. Attempting to find and register it now.");
    var library = GeneLibrary.Instance ?? Resources.FindObjectsOfTypeAll<GeneLibrary>().FirstOrDefault();
    if (library != null) {
     if (GeneLibrary.Instance == null) {
      library.SetActiveInstance(); // Ensures the lookups are built
     }
     Register<IGeneLibrary>(library);
     Debug.Log("Successfully found and registered IGeneLibrary service on-demand.");
    }
    else {
     Debug.LogError("CRITICAL: Could not find any GeneLibrary asset to register as a fallback service!");
    }
   }

   if (services.TryGetValue(typeof(T), out object service)) {
    return (T)service;
   }

   Debug.LogError($"Service {typeof(T).Name} not registered!");
   return null;
  }

  pub stat void Reset() {
   services.Clear();
   isInitialized = false;
  }
 }

 pub interface IGeneLibrary {
  GeneBase GetGeneByGUID(string guid);
  GeneBase GetGeneByName(string name);
  GeneBase GetPlaceholderGene();
  List<GeneBase> GetGenesOfCategory(GeneCategory category);
 }

 pub interface IGeneEventBus {
  void Subscribe<T>(Action<T> handler) where T : class;
  void Unsubscribe<T>(Action<T> handler) where T : class;
  void Publish<T>(T message) where T : class;
 }

 pub interface IGeneEffectPool {
  GameObject GetEffect(GameObject prefab, Vector3 position, Quaternion rotation);
  void ReturnEffect(GameObject effect, GameObject sourcePrefab);
 }

 pub interface IDeterministicRandom {
  float Range(float min, float max);
  int Range(int min, int max);
  void SetSeed(int seed);
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Genes\Templates\SeedTemplate.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;
using Abracodabra.UI.Tooltips; // NEW: For new enums

namespace Abracodabra.Genes.Templates {
 pub class SeedTemplate : ScriptableObject {
  pub string templateName;
  pub string description;
  pub Sprite icon;

  [Header("Tooltip Information")]
  pub SeedRarity rarity = SeedRarity.Common;
  pub PlantType plantType = PlantType.Flower;
  pub int generation = 1;

  [Header("Slot Configuration")]
  [Range(1, 8)] pub int passiveSlotCount = 3;
  [Range(1, 8)] pub int activeSequenceLength = 3;

  pub List<GeneTemplateEntry> passiveGenes = new List<GeneTemplateEntry>();
  pub List<SequenceSlotTemplate> activeSequence = new List<SequenceSlotTemplate>();

  [Header("Growth Parameters")]
  [Range(0f, 1f)] pub float baseGrowthChance = 0.1f;
  pub int minHeight = 3;
  pub int maxHeight = 5;
  pub int leafDensity = 2;
  pub int leafGap = 1;

  [Header("Energy System")]
  pub int baseRechargeTime = 3;
  pub float energyRegenRate = 10f;
  pub float maxEnergy = 100f;
  pub float startingEnergy = 0f;

  [Header("Unlock State")]
  pub bool isUnlocked = true;
  pub List<string> unlockRequirements = new List<string>();

  pub bool IsValid() {
   bool hasAtLeastOneActiveGene = false;
   foreach (var slot in activeSequence) {
    if (slot.activeGene == null) continue;
    hasAtLeastOneActiveGene = true;
    if (!slot.Validate()) return false;
   }
   return hasAtLeastOneActiveGene;
  }

  pub PlantGeneRuntimeState CreateRuntimeState() {
   var state = new PlantGeneRuntimeState();
   state.template = this;
   state.InitializeFromTemplate();
   return state;
  }

  void OnValidate() {
   while (passiveGenes.Count < passiveSlotCount) passiveGenes.Add(new GeneTemplateEntry());
   while (passiveGenes.Count > passiveSlotCount) passiveGenes.RemoveAt(passiveGenes.Count - 1);

   while (activeSequence.Count < activeSequenceLength) activeSequence.Add(new SequenceSlotTemplate());
   while (activeSequence.Count > activeSequenceLength) activeSequence.RemoveAt(activeSequence.Count - 1);
  }
 }

 pub class GeneTemplateEntry {
  pub GeneBase gene;
  pub float powerMultiplier = 1f;
 }

 pub class SequenceSlotTemplate {
  pub ActiveGene activeGene;
  pub List<GeneTemplateEntry> modifiers = new List<GeneTemplateEntry>();
  pub List<GeneTemplateEntry> payloads = new List<GeneTemplateEntry>();

  pub bool Validate() {
   if (activeGene == null) return true; // Empty slot is valid

   if (modifiers.Count > activeGene.slotConfig.modifierSlots) return false;
   if (payloads.Count > activeGene.slotConfig.payloadSlots) return false;

   var modifierGenes = modifiers.Select(m => m.gene as ModifierGene).ToList();
   var payloadGenes = payloads.Select(p => p.gene as PayloadGene).ToList();

   return activeGene.IsValidConfiguration(modifierGenes, payloadGenes);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\A_ToolkitUI\HotbarSelectionService.cs

using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;
using Abracodabra.UI.Toolkit;

namespace Abracodabra.UI.Genes {
 pub stat class HotbarSelectionService {
  stat InventoryBarItem _selectedItem;
  stat int _selectedIndex = 0;

  pub stat InventoryBarItem SelectedItem => _selectedItem;

  pub stat int SelectedIndex => _selectedIndex;

  pub stat event Action<InventoryBarItem> OnSelectionChanged;

  pub stat void SelectItem(int index, UIInventoryItem uiItem) {
   _selectedIndex = index;

   if (uiItem == null) {
    _selectedItem = null;
    Debug.Log($"[HotbarSelectionService] Selected slot {index + 1}: Empty");
    OnSelectionChanged?.Invoke(null);
    return;
   }

   if (uiItem.OriginalData is SeedTemplate seed) {
    _selectedItem = InventoryBarItem.FromSeed(seed);
    if (_selectedItem != null && uiItem.SeedRuntimeState != null) {
     _selectedItem.SeedRuntimeState = uiItem.SeedRuntimeState;
    }
   }
   else if (uiItem.OriginalData is ToolDefinition tool) {
    _selectedItem = InventoryBarItem.FromTool(tool);
   }
   else if (uiItem.OriginalData is GeneBase gene) {
    var runtimeInstance = new RuntimeGeneInstance(gene);
    _selectedItem = InventoryBarItem.FromGene(runtimeInstance);
   }
   else if (uiItem.ResourceInstance != null) {
    _selectedItem = InventoryBarItem.FromItem(uiItem.ResourceInstance);
   }
   else if (uiItem.OriginalData is ItemDefinition itemDef) {
    var itemInstance = new ItemInstance(itemDef);
    itemInstance.stackCount = uiItem.StackSize;
    _selectedItem = InventoryBarItem.FromItem(itemInstance);
   }
   else {
    _selectedItem = null;
   }

   string itemName = _selectedItem?.GetDisplayName() ?? "Unknown";
   Debug.Log($"[HotbarSelectionService] Selected slot {index + 1}: {itemName}");
   OnSelectionChanged?.Invoke(_selectedItem);
  }

  pub stat void SelectSeed(int index, SeedTemplate seedTemplate, PlantGeneRuntimeState runtimeState = null) {
   _selectedIndex = index;
   _selectedItem = InventoryBarItem.FromSeed(seedTemplate);
   if (runtimeState != null && _selectedItem != null) {
    _selectedItem.SeedRuntimeState = runtimeState;
   }
   LogSelection(index);
   OnSelectionChanged?.Invoke(_selectedItem);
  }

  pub stat void SelectTool(int index, ToolDefinition toolDef) {
   _selectedIndex = index;
   _selectedItem = InventoryBarItem.FromTool(toolDef);
   LogSelection(index);
   OnSelectionChanged?.Invoke(_selectedItem);
  }

  pub stat void SelectGene(int index, GeneBase gene) {
   _selectedIndex = index;
   var runtimeInstance = new RuntimeGeneInstance(gene);
   _selectedItem = InventoryBarItem.FromGene(runtimeInstance);
   LogSelection(index);
   OnSelectionChanged?.Invoke(_selectedItem);
  }

  pub stat void SelectResource(int index, ItemInstance itemInstance) {
   _selectedIndex = index;
   _selectedItem = InventoryBarItem.FromItem(itemInstance);
   LogSelection(index);
   OnSelectionChanged?.Invoke(_selectedItem);
  }

  pub stat void SelectEmpty(int index) {
   _selectedIndex = index;
   _selectedItem = null;
   Debug.Log($"[HotbarSelectionService] Selected slot {index + 1}: Empty");
   OnSelectionChanged?.Invoke(null);
  }

  pub stat void ClearSelection() {
   _selectedIndex = -1;
   _selectedItem = null;
   OnSelectionChanged?.Invoke(null);
  }

  stat void LogSelection(int index) {
   string itemName = _selectedItem?.GetDisplayName() ?? "Empty";
   Debug.Log($"[HotbarSelectionService] Selected slot {index + 1}: {itemName}");
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\A_ToolkitUI\InventoryService.cs

using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;
using Abracodabra.UI.Toolkit; // For UIInventoryItem

namespace Abracodabra.UI.Genes {
 pub stat class InventoryService {
  stat List<UIInventoryItem> _inventory;
  stat int _inventoryColumns;
  stat int _inventoryRows;

  pub stat event Action OnInventoryChanged;

  pub stat event Action<int> OnSlotChanged;

  pub stat bool IsInitialized => _inventory != null;

  pub stat int TotalSlots => _inventory?.Count ?? 0;

  pub stat int Columns => _inventoryColumns;

  pub stat void Register(List<UIInventoryItem> inventory, int columns, int rows) {
   _inventory = inventory;
   _inventoryColumns = columns;
   _inventoryRows = rows;
   Debug.Log($"[InventoryService] Registered inventory with {inventory.Count} slots ({columns}x{rows})");
  }

  pub stat void Unregister() {
   _inventory = null;
   Debug.Log("[InventoryService] Inventory unregistered");
  }

  pub stat UIInventoryItem GetItemAt(int index) {
   if (_inventory == null || index < 0 || index >= _inventory.Count)
    return null;
   return _inventory[index];
  }

  pub stat UIInventoryItem RemoveItemAtIndex(int index) {
   if (_inventory == null || index < 0 || index >= _inventory.Count) {
    Debug.LogWarning($"[InventoryService] Cannot remove item: invalid index {index}");
    return null;
   }

   var removedItem = _inventory[index];
   if (removedItem == null) {
    Debug.Log($"[InventoryService] Slot {index} was already empty");
    return null;
   }

   _inventory[index] = null;

   string itemName = removedItem.GetDisplayName();
   Debug.Log($"[InventoryService] Removed '{itemName}' from slot {index}");

   OnSlotChanged?.Invoke(index);
   OnInventoryChanged?.Invoke();

   return removedItem;
  }

  pub stat int AddItem(UIInventoryItem item) {
   if (_inventory == null || item == null)
    return -1;

   int emptyIndex = GetFirstEmptySlot();
   if (emptyIndex < 0) {
    Debug.LogWarning("[InventoryService] Cannot add item: inventory is full");
    return -1;
   }

   _inventory[emptyIndex] = item;

   string itemName = item.GetDisplayName();
   Debug.Log($"[InventoryService] Added '{itemName}' to slot {emptyIndex}");

   OnSlotChanged?.Invoke(emptyIndex);
   OnInventoryChanged?.Invoke();

   return emptyIndex;
  }

  pub stat bool SetItemAt(int index, UIInventoryItem item) {
   if (_inventory == null || index < 0 || index >= _inventory.Count)
    return false;

   _inventory[index] = item;

   OnSlotChanged?.Invoke(index);
   OnInventoryChanged?.Invoke();

   return true;
  }

  pub stat int GetFirstEmptySlot() {
   if (_inventory == null) return -1;

   for (int i = 0; i < _inventory.Count; i++) {
    if (_inventory[i] == null)
     return i;
   }
   return -1;
  }

  pub stat bool HasEmptySlot() {
   return GetFirstEmptySlot() >= 0;
  }

  pub stat List<UIInventoryItem> GetHotbarItems() {
   if (_inventory == null || _inventoryColumns <= 0)
    return new List<UIInventoryItem>();

   var hotbarItems = new List<UIInventoryItem>();
   int count = Mathf.Min(_inventoryColumns, _inventory.Count);

   for (int i = 0; i < count; i++) {
    hotbarItems.Add(_inventory[i]); // Add even if null!
   }

   return hotbarItems;
  }

  pub stat bool IsHotbarIndex(int index) {
   return index >= 0 && index < _inventoryColumns;
  }

  pub stat UIInventoryItem ConvertFromLegacy(InventoryBarItem legacyItem) {
   if (legacyItem == null) return null;

   switch (legacyItem.Type) {
    case InventoryBarItem.ItemType.Seed:
     var seedItem = new UIInventoryItem(legacyItem.SeedTemplate);
     if (legacyItem.SeedRuntimeState != null) {
      seedItem.SeedRuntimeState = legacyItem.SeedRuntimeState;
     }
     return seedItem;

    case InventoryBarItem.ItemType.Tool:
     return new UIInventoryItem(legacyItem.ToolDefinition);

    case InventoryBarItem.ItemType.Gene:
     var gene = legacyItem.GeneInstance?.GetGene();
     if (gene != null)
      return new UIInventoryItem(gene);
     return null;

    case InventoryBarItem.ItemType.Resource:
     if (legacyItem.ItemInstance != null)
      return new UIInventoryItem(legacyItem.ItemInstance);
     return null;

    default:
     return null;
   }
  }

  pub stat bool AddHarvestedItem(ItemInstance itemInstance) {
   if (itemInstance == null || itemInstance.definition == null)
    return false;

   var uiItem = new UIInventoryItem(itemInstance);
   return AddItem(uiItem) >= 0;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\GeneSequenceUI.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Core;
using Abracodabra.Genes;
using Abracodabra.UI.Tooltips; // NEW

namespace Abracodabra.UI.Genes {
 pub class GeneSequenceUI : MonoBehaviour {
  pub Transform passiveGenesContainer;
  pub Transform activeSequenceContainer;
  [SerializeField] GeneSlotUI seedEditSlot;

  pub GameObject sequenceRowPrefab;
  pub GameObject passiveSlotPrefab;

  pub TMPro.TextMeshProUGUI energyCostText;
  pub TMPro.TextMeshProUGUI currentEnergyText;
  pub TMPro.TextMeshProUGUI rechargeTimeText;
  pub TMPro.TextMeshProUGUI validationMessage;
  pub Slider rechargeProgress;

  pub int maxPassiveSlots = 6;
  pub int maxSequenceLength = 5;

  PlantGeneRuntimeState runtimeState;
  List<GeneSlotUI> passiveSlots = new List<GeneSlotUI>();
  List<SequenceRowUI> sequenceRows = new List<SequenceRowUI>();
  PlantSequenceExecutor executor;

  void Start() {
   ClearEditor();
  }

  pub void LoadSeedForEditing(InventoryBarItem seedItem) {
   if (seedItem == null || seedItem.Type != InventoryBarItem.ItemType.Seed) {
    ClearEditor();
    return;
   }

   this.runtimeState = seedItem.SeedRuntimeState;
   if (seedEditSlot != null) {
    seedEditSlot.SetItem(seedItem);
   }

   GenerateSlotsFromState();
   SetEditorLocked(false);
   RefreshAllVisuals();
  }

  void ClearEditor() {
   this.runtimeState = null;
   if (seedEditSlot != null) {
    seedEditSlot.ClearSlot();
   }

   foreach (var slot in passiveSlots) if (slot != null) Destroy(slot.gameObject);
   foreach (var row in sequenceRows) if (row != null) Destroy(row.gameObject);
   passiveSlots.Clear();
   sequenceRows.Clear();

   SetEditorLocked(true);
   RefreshAllVisuals();
  }

  pub void CleanupOnPhaseEnd() {
   if (seedEditSlot != null && seedEditSlot.CurrentItem != null) {
    var itemToReturn = seedEditSlot.CurrentItem;
    if (InventoryGridController.Instance != null) {
     bool success = InventoryGridController.Instance.AddItemToInventory(itemToReturn);
     if (!success) {
      Debug.LogWarning($"Could not return seed '{itemToReturn.GetDisplayName()}' to inventory on phase end, inventory may be full.");
     }
    }
   }
   ClearEditor();
  }

  void GenerateSlotsFromState() {
   foreach (var slot in passiveSlots) if (slot != null) Destroy(slot.gameObject);
   foreach (var row in sequenceRows) if (row != null) Destroy(row.gameObject);
   passiveSlots.Clear();
   sequenceRows.Clear();

   if (runtimeState == null) return;

   for (int i = 0; i < runtimeState.template.passiveSlotCount; i++) {
    GameObject slotObj = Instantiate(passiveSlotPrefab, passiveGenesContainer);
    slotObj.SetActive(true);
    GeneSlotUI slot = slotObj.GetComponent<GeneSlotUI>();
    slot.acceptedCategory = GeneCategory.Passive;
    slot.slotIndex = i;
    passiveSlots.Add(slot);
   }

   for (int i = 0; i < runtimeState.template.activeSequenceLength; i++) {
    GameObject rowObj = Instantiate(sequenceRowPrefab, activeSequenceContainer);
    rowObj.SetActive(true);
    SequenceRowUI row = rowObj.GetComponent<SequenceRowUI>();
    row.Initialize(i, this);
    sequenceRows.Add(row);
   }
  }

  void SetEditorLocked(bool isLocked) {
   foreach (var slot in passiveSlots) slot.isLocked = isLocked;
   foreach (var row in sequenceRows) {
    if (row.activeSlot != null) row.activeSlot.isLocked = isLocked;
   }
  }

  pub void UpdateDataForSlot(int slotIndex, GeneCategory slotCategory, InventoryBarItem newItem) {
   if (runtimeState == null) return;
   var newInstance = newItem?.GeneInstance;

   if (slotCategory == GeneCategory.Passive) {
    if (slotIndex < 0) return;
    while (runtimeState.passiveInstances.Count <= slotIndex) runtimeState.passiveInstances.Add(null);
    runtimeState.passiveInstances[slotIndex] = newInstance;
   }
   else {
    if (slotIndex < 0 || slotIndex >= runtimeState.activeSequence.Count) return;
    RuntimeSequenceSlot sequenceSlot = runtimeState.activeSequence[slotIndex];

    switch (slotCategory) {
     case GeneCategory.Active:
      sequenceSlot.activeInstance = newInstance;
      break;
     case GeneCategory.Modifier:
      if (sequenceSlot.modifierInstances.Count == 0) sequenceSlot.modifierInstances.Add(newInstance);
      else sequenceSlot.modifierInstances[0] = newInstance;
      break;
     case GeneCategory.Payload:
      if (sequenceSlot.payloadInstances.Count == 0) sequenceSlot.payloadInstances.Add(newInstance);
      else sequenceSlot.payloadInstances[0] = newInstance;
      break;
    }
   }
   RefreshAllVisuals();
  }

  pub ActiveGene GetActiveGeneForRow(int rowIndex) {
   if (runtimeState != null && rowIndex >= 0 && rowIndex < runtimeState.activeSequence.Count) {
    return runtimeState.activeSequence[rowIndex]?.activeInstance?.GetGene<ActiveGene>();
   }
   return null;
  }

  void RefreshAllVisuals() {
   if (runtimeState == null) {
    UpdateDisplay();
    if (SeedEditorTooltipPanel.Instance != null) {
     SeedEditorTooltipPanel.Instance.LoadSeedForAnalysis(null);
    }
    return;
   }

   for (int i = 0; i < passiveSlots.Count; i++) {
    if (i < runtimeState.passiveInstances.Count) {
     var instance = runtimeState.passiveInstances[i];
     passiveSlots[i].SetItem(instance != null && instance.GetGene() != null ? InventoryBarItem.FromGene(instance) : null);
    }
    else {
     passiveSlots[i].ClearSlot();
    }
   }

   for (int i = 0; i < sequenceRows.Count; i++) {
    if (i < runtimeState.activeSequence.Count) {
     sequenceRows[i].LoadSlot(runtimeState.activeSequence[i]);
    }
    else {
     sequenceRows[i].ClearRow();
    }
   }
   UpdateDisplay();

   if (SeedEditorTooltipPanel.Instance != null) {
    SeedEditorTooltipPanel.Instance.LoadSeedForAnalysis(runtimeState);
   }
  }

  void UpdateDisplay() {
   if (runtimeState == null) {
    if (energyCostText != null) energyCostText.text = "Cost: --";
    if (currentEnergyText != null) currentEnergyText.text = "Energy: --/--";
    if (rechargeTimeText != null) rechargeTimeText.text = "Recharge: --";
    if (validationMessage != null) {
     validationMessage.gameObject.SetActive(true);
     validationMessage.text = "Drop a seed into the slot above to begin editing.";
    }
    return;
   }

   float totalCost = runtimeState.CalculateTotalEnergyCost();
   if (energyCostText != null) energyCostText.text = $"Cost: {totalCost:F0} E/cycle";
   if (rechargeTimeText != null) rechargeTimeText.text = $"Recharge: {runtimeState.template.baseRechargeTime} ticks";
   if (currentEnergyText != null) currentEnergyText.text = $"Energy: --/{runtimeState.template.maxEnergy:F0}";

   bool isValid = ValidateConfiguration();
   if (validationMessage != null) validationMessage.gameObject.SetActive(!isValid);
  }

  bool ValidateConfiguration() {
   if (runtimeState == null) return false;
   bool hasActiveGene = false;
   foreach (var slot in runtimeState.activeSequence) {
    if (slot.HasContent) {
     hasActiveGene = true;
     break;
    }
   }
   if (!hasActiveGene) {
    if (validationMessage != null) validationMessage.text = "Sequence requires at least one Active Gene.";
    return false;
   }
   return true;
  }

  pub void ConnectToExecutor(PlantSequenceExecutor exec) {
   executor = exec;
  }

  void Update() {
   if (executor != null && executor.plantGrowth != null && executor.plantGrowth.EnergySystem != null && runtimeState != null) {
    var energySystem = executor.plantGrowth.EnergySystem;
    if (rechargeProgress != null && runtimeState.template.baseRechargeTime > 0) {
     float progress = 1f - (runtimeState.rechargeTicksRemaining / (float)runtimeState.template.baseRechargeTime);
     rechargeProgress.value = progress;
    }
    if (currentEnergyText != null) {
     currentEnergyText.text = $"Energy: {energySystem.CurrentEnergy:F0}/{energySystem.MaxEnergy:F0}";
    }
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\GeneSlotUI.cs

﻿using UnityEngine;
using UnityEngine.EventSystems;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Templates;

// Note: Add 'using' statements for ItemInstance/ItemDefinition if they are in namespaces.

namespace Abracodabra.UI.Genes {
 pub class GeneSlotUI : MonoBehaviour, IDropHandler, IPointerEnterHandler, IPointerExitHandler, IBeginDragHandler, IDragHandler, IEndDragHandler {
  pub GeneCategory acceptedCategory;
  pub int slotIndex;
  pub bool isLocked = false;
  pub bool isDraggable = true;

  [SerializeField] Image slotBackground;
  [SerializeField] GameObject emptyIndicator;
  [SerializeField] GameObject lockedOverlay;
  [SerializeField] GameObject executingEffect;
  [SerializeField] ItemView itemView;

  [SerializeField] Color normalColor = new Color(0.2f, 0.2f, 0.2f, 0.5f);
  [SerializeField] Color highlightColor = new Color(1f, 0.9f, 0.4f, 0.5f);
  [SerializeField] Color invalidColor = new Color(1f, 0.3f, 0.3f, 0.5f);
  [SerializeField] Color executingColor = new Color(0.4f, 0.8f, 1f, 0.5f);

  pub InventoryBarItem CurrentItem { get; set; }
  GeneSequenceUI parentSequence;
  IGeneEventBus eventBus;
  GameObject draggedVisual;
  Canvas canvas;
  bool isPointerOver = false;

  void Awake() {
   parentSequence = GetComponentInParent<GeneSequenceUI>();
   canvas = GetComponentInParent<Canvas>();
   if (itemView == null) itemView = GetComponentInChildren<ItemView>(true);
   if (itemView == null) Debug.LogError($"GeneSlotUI on {gameObject.name} is missing its ItemView child component.", this);
  }

  void Start() {
   eventBus = GeneServices.Get<IGeneEventBus>();
   UpdateVisuals();
  }

  void OnEnable() {
   eventBus?.Subscribe<GeneExecutedEvent>(OnGeneExecuted);
  }

  void OnDisable() {
   eventBus?.Unsubscribe<GeneExecutedEvent>(OnGeneExecuted);
  }

  pub void SetItem(InventoryBarItem item) {
   CurrentItem = item;
   UpdateVisuals();
  }

  pub void ClearSlot() {
   SetItem(null);
  }

  void UpdateVisuals() {
   if (itemView == null || slotBackground == null) return;
   bool isEmpty = CurrentItem == null || !CurrentItem.IsValid();
   if (emptyIndicator != null) emptyIndicator.SetActive(isEmpty);
   itemView.gameObject.SetActive(!isEmpty);

   if (!isEmpty) {
    switch (CurrentItem.Type) {
     case InventoryBarItem.ItemType.Gene:
      itemView.InitializeAsGene(CurrentItem.GeneInstance);
      slotBackground.color = InventoryColorManager.Instance.GetCellColorForItem(CurrentItem.GeneInstance.GetGene(), null, null, null);
      break;
     case InventoryBarItem.ItemType.Seed:
      itemView.InitializeAsSeed(CurrentItem.SeedTemplate);
      slotBackground.color = InventoryColorManager.Instance.GetCellColorForItem(null, CurrentItem.SeedTemplate, null, null);
      break;
     case InventoryBarItem.ItemType.Tool:
      itemView.InitializeAsTool(CurrentItem.ToolDefinition);
      slotBackground.color = InventoryColorManager.Instance.GetCellColorForItem(null, null, CurrentItem.ToolDefinition, null);
      break;
     case InventoryBarItem.ItemType.Resource: // NEW CASE
      itemView.InitializeAsItem(CurrentItem.ItemInstance);
      slotBackground.color = InventoryColorManager.Instance.GetCellColorForItem(null, null, null, CurrentItem.ItemInstance.definition);
      break;
    }
   }
   else {
    slotBackground.color = normalColor;
   }

   if (lockedOverlay != null) lockedOverlay.SetActive(isLocked);
   if (isPointerOver && !isLocked) {
    slotBackground.color = highlightColor;
   }
  }

  pub void OnDrop(PointerEventData eventData) {
   if (isLocked) return;
   GeneSlotUI sourceSlot = eventData.pointerDrag?.GetComponent<GeneSlotUI>();
   if (sourceSlot == null || sourceSlot == this) return;

   if (!IsValidDrop(sourceSlot, this)) {
    ShowInvalidDropFeedback();
    return;
   }

   var itemFromSource = sourceSlot.CurrentItem;
   var itemFromDestination = this.CurrentItem;

   UpdateSlotContents(sourceSlot, itemFromDestination);
   UpdateSlotContents(this, itemFromSource);
  }

  bool IsItemValidForSlot(InventoryBarItem item, GeneSlotUI slot) {
   if (item == null) return true;

   if (item.Type == InventoryBarItem.ItemType.Resource && slot.parentSequence != null) {
    return false;
   }

   if (slot.acceptedCategory == GeneCategory.Seed) {
    return item.Type == InventoryBarItem.ItemType.Seed;
   }

   if (slot.parentSequence != null) {
    if (item.Type != InventoryBarItem.ItemType.Gene) return false;
    var gene = item.GeneInstance.GetGene();
    if (gene.Category != slot.acceptedCategory) return false;

    if (slot.acceptedCategory == GeneCategory.Modifier || slot.acceptedCategory == GeneCategory.Payload) {
     var activeGene = slot.parentSequence.GetActiveGeneForRow(slot.slotIndex);
     if (activeGene == null || !gene.CanAttachTo(activeGene)) return false;
    }
   }
   return true;
  }

  bool IsValidDrop(GeneSlotUI source, GeneSlotUI destination) {
   var sourceItem = source.CurrentItem;
   var destinationItem = destination.CurrentItem;
   return IsItemValidForSlot(sourceItem, destination) && IsItemValidForSlot(destinationItem, source);
  }

  void UpdateSlotContents(GeneSlotUI slot, InventoryBarItem newItem) {
   if (slot.acceptedCategory == GeneCategory.Seed && slot.parentSequence != null) {
    slot.parentSequence.LoadSeedForEditing(newItem);
   }
   else if (slot.parentSequence != null) {
    slot.parentSequence.UpdateDataForSlot(slot.slotIndex, slot.acceptedCategory, newItem);
   }
   else {
    slot.SetItem(newItem);
   }
  }

  pub void OnPointerEnter(PointerEventData eventData) {
   isPointerOver = true;
   UpdateVisuals();
  }

  pub void OnPointerExit(PointerEventData eventData) {
   isPointerOver = false;
   UpdateVisuals();
  }

  pub void OnBeginDrag(PointerEventData eventData) {
   if (!isDraggable || CurrentItem == null || isLocked) { eventData.pointerDrag = null; return; }
   CreateDragVisual();
  }

  pub void OnDrag(PointerEventData eventData) {
   if (draggedVisual != null) draggedVisual.transform.position = eventData.position;
  }

  pub void OnEndDrag(PointerEventData eventData) {
   if (draggedVisual != null) Destroy(draggedVisual);
  }

  void CreateDragVisual() {
   if (canvas == null || CurrentItem == null) return;
   draggedVisual = new GameObject("DragVisual");
   draggedVisual.transform.SetParent(canvas.transform, false);
   draggedVisual.transform.SetAsLastSibling();
   var image = draggedVisual.AddComponent<Image>();
   image.sprite = CurrentItem.GetIcon();
   image.color = new Color(1, 1, 1, 0.7f);
   image.raycastTarget = false;
   var rect = draggedVisual.GetComponent<RectTransform>();
   rect.sizeDelta = new Vector2(64, 64);
  }

  void ShowInvalidDropFeedback() {
   StartCoroutine(FlashColor(invalidColor));
  }

  IEnumerator FlashColor(Color flashColor) {
   if (slotBackground == null) yield break;
   Color originalColor = slotBackground.color;
   slotBackground.color = flashColor;
   yield return new WaitForSeconds(0.3f);
   slotBackground.color = originalColor;
   UpdateVisuals();
  }

  void OnGeneExecuted(GeneExecutedEvent evt) {
   if (CurrentItem != null && CurrentItem.Type == InventoryBarItem.ItemType.Gene && CurrentItem.GeneInstance.GetGene()?.GUID == evt.Gene.GUID) {
    ShowExecuting();
   }
  }

  pub void ShowExecuting() {
   if (executingEffect != null) executingEffect.SetActive(true);
   if (slotBackground != null) slotBackground.color = executingColor;
   Invoke(nameof(HideExecuting), 0.5f);
  }

  pub void HideExecuting() {
   if (executingEffect != null) executingEffect.SetActive(false);
   UpdateVisuals();
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\InventoryBarController.cs

﻿using UnityEngine;
using Abracodabra.UI.Genes;

namespace Abracodabra.UI.Genes {
 pub class InventoryBarController : MonoBehaviour {
  pub stat InventoryBarController Instance { get; set; }

  [Header("Configuration")]
  [Tooltip("The fixed number of slots to display in the bar.")]
  [SerializeField] int barSlotCount = 8;
  [Tooltip("The prefab for a single inventory slot (must have a GeneSlotUI component).")]
  [SerializeField] GameObject inventorySlotPrefab;

  [Header("Component References")]
  [SerializeField] InventoryGridController inventoryGridController;
  // NOTE: This should be the child object that has the Image, GridLayoutGroup, and ContentSizeFitter
  [SerializeField] Transform cellContainer;
  [SerializeField] GameObject selectionHighlight;

  List<GeneSlotUI> barSlots = new List<GeneSlotUI>();
  int selectedSlot = 0;
  Coroutine updateHighlightCoroutine;
  RectTransform cellContainerRect; // Store a reference to the RectTransform

  pub InventoryBarItem SelectedItem { get; set; }
  pub event System.Action<InventoryBarItem> OnSelectionChanged;

  void Awake() {
   if (Instance != null && Instance != this) {
    Destroy(gameObject);
    return;
   }
   Instance = this;
   selectedSlot = 0;
  }

  void Start() {
   if (inventoryGridController == null) Debug.LogError($"[{nameof(InventoryBarController)}] InventoryGridController not assigned!", this);
   if (inventorySlotPrefab == null) Debug.LogError($"[{nameof(InventoryBarController)}] Inventory Slot Prefab not assigned!", this);
   if (cellContainer == null) Debug.LogError($"[{nameof(InventoryBarController)}] Cell Container not assigned!", this);
   else cellContainerRect = cellContainer.GetComponent<RectTransform>();

   inventoryGridController.OnInventoryChanged += HandleInventoryChanged;

   CreateBarSlots();

   if (selectionHighlight != null) {
    selectionHighlight.SetActive(false);
   }

   gameObject.SetActive(false);
  }

  void OnDestroy() {
   if (inventoryGridController != null) {
    inventoryGridController.OnInventoryChanged -= HandleInventoryChanged;
   }
  }

  void CreateBarSlots() {
   foreach (Transform child in cellContainer) {
    Destroy(child.gameObject);
   }
   barSlots.Clear();

   for (int i = 0; i < barSlotCount; i++) {
    GameObject slotGO = Instantiate(inventorySlotPrefab, cellContainer);
    GeneSlotUI slotUI = slotGO.GetComponent<GeneSlotUI>();
    if (slotUI != null) {
     slotUI.isDraggable = false;
     barSlots.Add(slotUI);
    }
   }

   if (cellContainerRect != null) {
    LayoutRebuilder.ForceRebuildLayoutImmediate(cellContainerRect);
   }
  }

  void UpdateBarDisplay() {
   if (inventoryGridController == null) return;

   List<InventoryBarItem> items = inventoryGridController.GetFirstNItems(barSlotCount);

   for (int i = 0; i < barSlotCount; i++) {
    if (i < barSlots.Count && i < items.Count) {
     barSlots[i].SetItem(items[i]);
    }
   }
  }

  void HandleInventoryChanged() {
   if (gameObject.activeInHierarchy) {
    RefreshBar();
   }
  }

  void Update() {
   if (!gameObject.activeInHierarchy) return;
   HandleNumberKeyInput();
  }

  pub void ShowBar() {
   gameObject.SetActive(true);
   RefreshBar();
   SelectSlotByIndex(0);
  }

  pub void HideBar() {
   gameObject.SetActive(false);
   if (selectionHighlight != null) {
    selectionHighlight.SetActive(false);
   }
  }

  void RefreshBar() {
   UpdateBarDisplay();
   SelectSlot(selectedSlot);
  }

  void HandleNumberKeyInput() {
   for (int i = 1; i <= 9; i++) {
    if (i <= barSlotCount && Input.GetKeyDown(KeyCode.Alpha0 + i)) { SelectSlot(i - 1); return; }
   }
   if (barSlotCount >= 10 && Input.GetKeyDown(KeyCode.Alpha0)) { SelectSlot(9); }
  }

  pub void SelectSlot(int slotIndex) {
   if (slotIndex < 0 || slotIndex >= barSlots.Count) {
    return;
   }

   selectedSlot = slotIndex;
   SelectedItem = barSlots[slotIndex].CurrentItem;

   UpdateSelection();
  }

  void UpdateSelection() {
   if (updateHighlightCoroutine != null) {
    StopCoroutine(updateHighlightCoroutine);
   }
   updateHighlightCoroutine = StartCoroutine(UpdateSelectionVisualsAfterFrame());

   OnSelectionChanged?.Invoke(SelectedItem);
  }

  IEnumerator UpdateSelectionVisualsAfterFrame() {
   yield return null;

   if (selectionHighlight != null) {
    if (selectedSlot < 0 || selectedSlot >= barSlots.Count) {
     selectionHighlight.SetActive(false);
     yield break;
    }

    bool itemIsValid = SelectedItem != null && SelectedItem.IsValid();
    selectionHighlight.SetActive(itemIsValid);

    if (itemIsValid) {
     selectionHighlight.transform.position = barSlots[selectedSlot].transform.position;
    }
   }
   updateHighlightCoroutine = null;
  }

  pub void SelectSlotByIndex(int slotIndex) {
   int targetSlot = Mathf.Clamp(slotIndex, 0, barSlotCount - 1);
   SelectSlot(targetSlot);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\ItemView.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;

// Note: Ensure ItemDefinition is accessible via a 'using' statement if it's in a namespace.

namespace Abracodabra.UI.Genes {
 pub class ItemView : MonoBehaviour {
  [SerializeField] Image thumbnailImage;
  [SerializeField] Image backgroundImage;
  [SerializeField] Sprite fallbackThumbnail;

  GeneBase _gene;
  RuntimeGeneInstance _runtimeInstance;
  ToolDefinition _toolDefinition;
  SeedTemplate _seedTemplate;
  ItemDefinition _itemDefinition; // NEW

  Color _originalBackgroundColor;

  pub void InitializeAsGene(RuntimeGeneInstance instance) {
   _runtimeInstance = instance;
   _gene = instance.GetGene();
   _toolDefinition = null;
   _seedTemplate = null;
   _itemDefinition = null;
   SetupVisuals();
   gameObject.SetActive(true);
  }

  pub void InitializeAsTool(ToolDefinition toolDef) {
   _runtimeInstance = null;
   _gene = null;
   _toolDefinition = toolDef;
   _seedTemplate = null;
   _itemDefinition = null;
   SetupVisuals();
   gameObject.SetActive(true);
  }

  pub void InitializeAsSeed(SeedTemplate seed) {
   _runtimeInstance = null;
   _gene = null;
   _toolDefinition = null;
   _seedTemplate = seed;
   _itemDefinition = null;
   SetupVisuals();
   gameObject.SetActive(true);
  }

  pub void InitializeAsItem(ItemInstance instance) {
   _runtimeInstance = null;
   _gene = null;
   _toolDefinition = null;
   _seedTemplate = null;
   _itemDefinition = instance.definition;
   SetupVisuals();
   gameObject.SetActive(true);
  }

  void SetupVisuals() {
   Sprite spriteToShow = fallbackThumbnail;
   Color tintColor = Color.white;
   _originalBackgroundColor = Color.gray;

   if (_gene != null) {
    spriteToShow = _gene.icon ?? fallbackThumbnail;
    tintColor = _gene.geneColor;
    _originalBackgroundColor = _gene.geneColor.WithAlpha(0.5f);
   }
   else if (_toolDefinition != null) {
    spriteToShow = _toolDefinition.icon ?? fallbackThumbnail;
    tintColor = _toolDefinition.iconTint;
    _originalBackgroundColor = InventoryColorManager.Instance.GetCellColorForItem(null, null, _toolDefinition, null);
   }
   else if (_seedTemplate != null) {
    spriteToShow = _seedTemplate.icon ?? fallbackThumbnail;
    tintColor = Color.white;
    _originalBackgroundColor = InventoryColorManager.Instance.GetCellColorForItem(null, _seedTemplate, null, null);
   }
   else if (_itemDefinition != null) {
    spriteToShow = _itemDefinition.icon ?? fallbackThumbnail;
    tintColor = Color.white; // Or add a tint to ItemDefinition if you want
    _originalBackgroundColor = InventoryColorManager.Instance.GetCellColorForItem(null, null, null, _itemDefinition);
   }

   if (thumbnailImage != null) {
    thumbnailImage.sprite = spriteToShow;
    thumbnailImage.color = tintColor;
    thumbnailImage.enabled = (thumbnailImage.sprite != null);
   }

   if (backgroundImage != null) {
    backgroundImage.color = _originalBackgroundColor;
   }
  }

  pub void Clear() {
   _gene = null;
   _runtimeInstance = null;
   _toolDefinition = null;
   _seedTemplate = null;
   _itemDefinition = null;
   gameObject.SetActive(false);
  }

  pub GeneBase GetGene() => _gene;
  pub RuntimeGeneInstance GetRuntimeInstance() => _runtimeInstance;
  pub ToolDefinition GetToolDefinition() => _toolDefinition;
  pub SeedTemplate GetSeedTemplate() => _seedTemplate;
  pub ItemDefinition GetItemDefinition() => _itemDefinition; // NEW
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\SequenceRowUI.cs

﻿// File: Assets/Scripts/UI/Genes/SequenceRowUI.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.UI.Genes {
 pub class SequenceRowUI : MonoBehaviour {
  pub GeneSlotUI modifierSlot;
  pub GeneSlotUI activeSlot;
  pub GeneSlotUI payloadSlot;

  int rowIndex;
  GeneSequenceUI parentSequence;

  pub void Initialize(int index, GeneSequenceUI parent) {
   rowIndex = index;
   parentSequence = parent;

   if (modifierSlot != null) {
    modifierSlot.acceptedCategory = GeneCategory.Modifier;
    modifierSlot.slotIndex = index;
   }
   if (activeSlot != null) {
    activeSlot.acceptedCategory = GeneCategory.Active;
    activeSlot.slotIndex = index;
   }
   if (payloadSlot != null) {
    payloadSlot.acceptedCategory = GeneCategory.Payload;
    payloadSlot.slotIndex = index;
   }
  }

  pub void LoadSlot(RuntimeSequenceSlot slotData) {
   activeSlot?.SetItem(slotData.activeInstance != null ? InventoryBarItem.FromGene(slotData.activeInstance) : null);

   var modInstance = slotData.modifierInstances.Count > 0 ? slotData.modifierInstances[0] : null;
   modifierSlot?.SetItem(modInstance != null ? InventoryBarItem.FromGene(modInstance) : null);

   var payloadInstance = slotData.payloadInstances.Count > 0 ? slotData.payloadInstances[0] : null;
   payloadSlot?.SetItem(payloadInstance != null ? InventoryBarItem.FromGene(payloadInstance) : null);

   UpdateAttachmentSlots(GetActiveGene());
  }

  pub void ClearRow() {
   modifierSlot?.ClearSlot();
   activeSlot?.ClearSlot();
   payloadSlot?.ClearSlot();
   UpdateAttachmentSlots(null);
  }

  pub ActiveGene GetActiveGene() {
   return activeSlot?.CurrentItem?.GeneInstance?.GetGene<ActiveGene>();
  }

  pub void UpdateAttachmentSlots(ActiveGene activeGene) {
   bool hasActive = activeGene != null;
   if (modifierSlot != null) {
    modifierSlot.isLocked = !hasActive;
    modifierSlot.gameObject.SetActive(hasActive && activeGene.slotConfig.modifierSlots > 0);
   }
   if (payloadSlot != null) {
    payloadSlot.isLocked = !hasActive;
    payloadSlot.gameObject.SetActive(hasActive && activeGene.slotConfig.payloadSlots > 0);
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Placement\PlantPlacementManager.cs

using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Core;
using WegoSystem;

namespace Abracodabra.UI.Genes {
 pub class PlantPlacementManager : MonoBehaviour {
  pub stat PlantPlacementManager Instance { get; set; }

  [SerializeField] Transform plantParent;
  [SerializeField] TileInteractionManager tileInteractionManager;
  [SerializeField] NodeExecutor nodeExecutor;
  [SerializeField] float spawnRadius = 0.25f;

  [Header("Global Invalid Tiles")]
  [Tooltip("Tiles that are NEVER valid for planting, regardless of seed terrain affinity. " +
    "Note: This is a BLACKLIST. For restricting seeds to specific tiles, use TerrainAffinityGene instead.")]
  [SerializeField] List<TileDefinition> invalidPlantingTiles = new List<TileDefinition>();

  [Header("Debug")]
  [SerializeField] bool verboseLogging = true;

  ro HashSet<TileDefinition> invalidTilesSet = new HashSet<TileDefinition>();
  ro Dictionary<Vector3Int, GameObject> plantsByGridPosition = new Dictionary<Vector3Int, GameObject>();

  void Awake() {
   if (Instance != null && Instance != this) {
    Destroy(gameObject);
    return;
   }
   Instance = this;
   RebuildInvalidTilesSet();
  }

  pub void Initialize() {
   if (plantParent == null && EcosystemManager.Instance != null)
    plantParent = EcosystemManager.Instance.plantParent;
   if (tileInteractionManager == null)
    tileInteractionManager = TileInteractionManager.Instance;
   if (nodeExecutor == null)
    nodeExecutor = FindFirstObjectByType<NodeExecutor>();
  }

  void RebuildInvalidTilesSet() {
   invalidTilesSet.Clear();
   foreach (var tile in invalidPlantingTiles) {
    if (tile != null) {
     invalidTilesSet.Add(tile);
    }
   }

   if (verboseLogging && invalidTilesSet.Count > 0) {
    string invalidNames = string.Join(", ", invalidTilesSet.Select(t => t.displayName));
    Debug.Log($"[PlantPlacementManager] Global invalid tiles: [{invalidNames}]");
   }
  }

  pub bool IsPositionOccupied(Vector3Int gridPosition) {
   CleanupDestroyedPlants();
   return plantsByGridPosition.ContainsKey(gridPosition);
  }

  pub bool IsTileValidForPlanting(TileDefinition tileDef) {
   return tileDef != null && !invalidTilesSet.Contains(tileDef);
  }

  pub bool IsTileValidForSeed(TileDefinition tileDef, PlantGeneRuntimeState runtimeState) {
   if (!IsTileValidForPlanting(tileDef)) {
    if (verboseLogging)
     Debug.Log($"[PlantPlacementManager] ❌ Tile '{tileDef?.displayName ?? "NULL"}' is in the global invalid tiles list.");
    return false;
   }

   var affinityGene = GetTerrainAffinityGene(runtimeState);

   if (affinityGene == null) {
    if (verboseLogging) {
     Debug.LogWarning($"[PlantPlacementManager] ⚠️ Seed '{runtimeState?.template?.templateName ?? "Unknown"}' has NO TerrainAffinityGene. " +
        $"It can be planted on ANY tile. Add a TerrainAffinityGene to restrict planting locations.");
    }
    return true;
   }

   if (affinityGene.AllowedTiles == null || affinityGene.AllowedTiles.Count == 0) {
    if (verboseLogging) {
     Debug.LogWarning($"[PlantPlacementManager] ⚠️ TerrainAffinityGene '{affinityGene.geneName}' has EMPTY allowedTiles. " +
        $"Seed can be planted anywhere. Add TileDefinitions to restrict.");
    }
    return true;
   }

   bool allowed = affinityGene.IsTileAllowed(tileDef);

   if (verboseLogging) {
string allowedTileNames = string.Join(", ", affinityGene.AllowedTiles .Where(t => t != null)
     .Select(t => t.displayName));

    string icon = allowed ? "✓" : "❌";
    Debug.Log($"[PlantPlacementManager] {icon} Tile '{tileDef?.displayName}' (Priority: {tileDef?.interactionPriority}) " +
      $"allowed: {allowed}. Seed requires: [{allowedTileNames}]");
   }

   return allowed;
  }

  TerrainAffinityGene GetTerrainAffinityGene(PlantGeneRuntimeState runtimeState) {
   if (runtimeState == null) {
    if (verboseLogging)
     Debug.LogError("[PlantPlacementManager] GetTerrainAffinityGene: runtimeState is null!");
    return null;
   }

   if (runtimeState.passiveInstances == null) {
    if (verboseLogging)
     Debug.LogError("[PlantPlacementManager] GetTerrainAffinityGene: passiveInstances list is null!");
    return null;
   }

   if (verboseLogging) {
    Debug.Log($"[PlantPlacementManager] Searching {runtimeState.passiveInstances.Count} passive gene slots...");

    for (int i = 0; i < runtimeState.passiveInstances.Count; i++) {
     var instance = runtimeState.passiveInstances[i];
     if (instance == null) {
      Debug.Log($"  Slot [{i}]: Empty");
     }
     else {
      var gene = instance.GetGene();
      string isAffinity = (gene is TerrainAffinityGene) ? " ← TERRAIN AFFINITY" : "";
      Debug.Log($"  Slot [{i}]: {gene?.geneName ?? "NULL"} ({gene?.GetType().Name ?? "null"}){isAffinity}");
     }
    }
   }

   foreach (var instance in runtimeState.passiveInstances) {
    if (instance == null) continue;

    var gene = instance.GetGene();
    if (gene is TerrainAffinityGene affinityGene) {
     if (verboseLogging) {
string allowedNames = string.Join(", ", affinityGene.AllowedTiles? .Where(t => t != null)
       .Select(t => t.displayName) ?? Array.Empty<string>());
      Debug.Log($"[PlantPlacementManager] Found TerrainAffinityGene: '{affinityGene.geneName}' " +
        $"with allowed tiles: [{allowedNames}]");
     }
     return affinityGene;
    }
   }

   if (verboseLogging) {
    Debug.Log("[PlantPlacementManager] No TerrainAffinityGene found in passive gene slots.");
   }
   return null;
  }

  pub string GetInvalidTileReason(TileDefinition tileDef, PlantGeneRuntimeState runtimeState) {
   if (tileDef == null) {
    return "No tile at this position";
   }

   if (invalidTilesSet.Contains(tileDef)) {
    return $"'{tileDef.displayName}' is globally blocked for planting";
   }

   var affinityGene = GetTerrainAffinityGene(runtimeState);
   if (affinityGene != null && !affinityGene.IsTileAllowed(tileDef)) {
    var allowedNames = affinityGene.AllowedTiles
     .Where(t => t != null)
     .Select(t => t.displayName)
     .ToList();

    if (allowedNames.Count > 0) {
     return $"This seed requires: {string.Join(", ", allowedNames)}";
    }
    else {
     return "TerrainAffinityGene has no allowed tiles configured";
    }
   }

   return "Unknown reason";
  }

  void CleanupDestroyedPlants() {
   var keysToRemove = plantsByGridPosition
    .Where(kvp => kvp.Value == null)
    .Select(kvp => kvp.Key)
    .ToList();

   foreach (var key in keysToRemove) {
    plantsByGridPosition.Remove(key);
   }
  }

  pub bool TryPlantSeedFromInventory(PlantGeneRuntimeState runtimeState, Vector3Int gridPosition, Vector3 worldPosition) {
   if (runtimeState == null || runtimeState.template == null) {
    Debug.LogError("[PlantPlacementManager] Failed: RuntimeState or its template was null.");
    return false;
   }

   if (!runtimeState.template.IsValid()) {
    Debug.LogError($"[PlantPlacementManager] Failed: Seed template '{runtimeState.template.templateName}' configuration is invalid.", runtimeState.template);
    return false;
   }

   if (IsPositionOccupied(gridPosition)) {
    Debug.LogWarning($"[PlantPlacementManager] Failed: Position {gridPosition} is already occupied.", this);
    return false;
   }

   TileDefinition tileDef = tileInteractionManager?.FindWhichTileDefinitionAt(gridPosition);

   if (verboseLogging) {
    Debug.Log($"[PlantPlacementManager] === PLANTING ATTEMPT ===");
    Debug.Log($"  Seed: '{runtimeState.template.templateName}'");
    Debug.Log($"  Position: {gridPosition}");
    Debug.Log($"  Detected Tile: '{tileDef?.displayName ?? "NULL"}' (Priority: {tileDef?.interactionPriority ?? 0})");

    // Show all tiles at this position for debugging
    var allTiles = tileInteractionManager?.GetAllTilesAt(gridPosition);
    if (allTiles != null && allTiles.Count > 1) {
     string allNames = string.Join(", ", allTiles.Select(t => $"{t.displayName}(P:{t.interactionPriority})"));
     Debug.Log($"  All tiles at position: [{allNames}]");
    }
   }

   if (!IsTileValidForSeed(tileDef, runtimeState)) {
    string reason = GetInvalidTileReason(tileDef, runtimeState);
    Debug.LogWarning($"[PlantPlacementManager] ❌ PLANTING BLOCKED: {reason}", this);
    return false;
   }

   if (nodeExecutor == null) {
    nodeExecutor = FindFirstObjectByType<NodeExecutor>();
    if (nodeExecutor == null) {
     Debug.LogError("[PlantPlacementManager] Failed: NodeExecutor not found!");
     return false;
    }
   }

   Vector3 finalPlantingPosition = GetRandomizedPlantingPosition(worldPosition);
   GameObject plantGO = nodeExecutor.SpawnPlantFromState(runtimeState, finalPlantingPosition, plantParent);

   if (plantGO == null) {
    Debug.LogError("[PlantPlacementManager] Failed: NodeExecutor returned null. Check Plant Prefab assignment.", this);
    return false;
   }

   GridPositionManager.Instance.SnapEntityToGrid(plantGO);
   var finalGridEntity = plantGO.GetComponent<GridEntity>();
   Vector3Int finalGridPosition = finalGridEntity.Position.ToVector3Int();

   plantsByGridPosition[finalGridPosition] = plantGO;

   if (verboseLogging) {
    Debug.Log($"[PlantPlacementManager] ✓ Successfully planted '{runtimeState.template.templateName}' at {finalGridPosition}");
   }

   return true;
  }

  Vector3 GetRandomizedPlantingPosition(Vector3 centerPosition) {
   if (spawnRadius <= 0f) return centerPosition;
   Vector2 randomOffset = UnityEngine.Random.insideUnitCircle * spawnRadius;
   return centerPosition + new Vector3(randomOffset.x, randomOffset.y, 0);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\A_ToolkitUI\GameUIManager.cs

using UnityEngine.UIElements;
using WegoSystem;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Core;
using Abracodabra.UI.Toolkit;
using Abracodabra.UI.Genes;

namespace Abracodabra.UI.Toolkit {
 pub class GameUIManager : MonoBehaviour {
  [Header("UI Templates")]
  [SerializeField] VisualTreeAsset inventorySlotTemplate;
  [SerializeField] VisualTreeAsset geneSlotTemplate;

  [Header("Starting Items")]
  [SerializeField] StartingInventory startingInventory;

  [Header("Inventory Configuration")]
  [Tooltip("Number of rows in the inventory grid")]
  [SerializeField] int inventoryRows = 4;

  [Tooltip("Number of columns in the inventory grid")]
  [SerializeField] int inventoryColumns = 6;

  List<UIInventoryItem> playerInventory = new List<UIInventoryItem>();
  int selectedInventoryIndex = -1;

  UIInventoryGridController inventoryController;
  UIDragDropController dragDropController;
  UISeedEditorController seedEditorController;
  UISpecSheetController specSheetController;
  UIHotbarController hotbarController;

  VisualElement rootElement;
  VisualElement planningPanel, hudPanel;
  Button startDayButton;

  VisualElement hungerBarFill;
  Label hungerText;
  Label tickText;
  VisualElement hudTooltipPanel;
  Image hudTooltipIcon;
  Label hudTooltipName;
  Label hudTooltipType;
  Label hudTooltipDescription;

  PlayerHungerSystem playerHungerSystem;

  int TotalInventorySlots => inventoryRows * inventoryColumns;

  void Start() {
   if (inventorySlotTemplate == null || geneSlotTemplate == null) {
    Debug.LogError("CRITICAL: UI Template assets are not assigned in the GameUIManager Inspector!");
    this.enabled = false;
    return;
   }

   rootElement = GetComponent<UIDocument>().rootVisualElement;

   planningPanel = rootElement.Q<VisualElement>("PlanningPanel");
   hudPanel = rootElement.Q<VisualElement>("HUDPanel");

   SetupPlayerInventory();

   InventoryService.Register(playerInventory, inventoryColumns, inventoryRows);

   InitializeControllers();

   InitializeHUD();

   SubscribeToEvents();

   InventoryService.OnInventoryChanged += HandleInventoryServiceChanged;

   if (ToolSwitcher.Instance != null) {
    ToolSwitcher.Instance.OnUsesChanged += HandleToolUsesChanged;
   }

   CreateStartDayButton();

   inventoryController.PopulateGrid();
   RefreshHotbar();
   seedEditorController.Clear();
   specSheetController.Clear();

   if (RunManager.Instance != null) {
    RunManager.Instance.OnRunStateChanged += HandleRunStateChanged;
    HandleRunStateChanged(RunManager.Instance.CurrentState);
   }
   else {
    ShowPlanningUI();
   }

   rootElement.schedule.Execute(() => hotbarController.SelectSlot(0)).StartingIn(10);
  }

  void Update() {
   hotbarController.HandleInput();
  }

  void OnDestroy() {
   InventoryService.OnInventoryChanged -= HandleInventoryServiceChanged;
   InventoryService.Unregister();

   if (RunManager.Instance != null) {
    RunManager.Instance.OnRunStateChanged -= HandleRunStateChanged;
   }

   if (playerHungerSystem != null) {
    playerHungerSystem.OnHungerChanged -= UpdateHungerDisplay;
   }

   if (TickManager.Instance != null) {
    TickManager.Instance.OnTickAdvanced -= UpdateTickDisplay;
   }

   if (ToolSwitcher.Instance != null) {
    ToolSwitcher.Instance.OnUsesChanged -= HandleToolUsesChanged;
   }

   HotbarSelectionService.OnSelectionChanged -= HandleHotbarSelectionChanged;
  }

  void InitializeControllers() {
   var inventoryPanel = rootElement.Q<VisualElement>("InventoryPanel");
   var geneEditorPanel = rootElement.Q<VisualElement>("SeedEditorPanel");
   var specSheetPanel = rootElement.Q<VisualElement>("SeedSpecSheetPanel");
   var inventoryGridElement = rootElement.Q<VisualElement>("inventory-grid");

   Debug.Log($"[GameUIManager] === PANEL SIZING: FIXED MODE ===");

   int slotWidth = 64;
   int slotMarginLeft = 5;
   int slotMarginRight = 5;
   int totalSpacePerSlot = slotWidth + slotMarginLeft + slotMarginRight;

   int gridWidth = inventoryColumns * totalSpacePerSlot;
   int panelPaddingLeft = 15;
   int panelPaddingRight = 15;
   int totalPanelPadding = panelPaddingLeft + panelPaddingRight;
   int inventoryPanelWidth = gridWidth + totalPanelPadding;

   if (inventoryPanel != null) {
    inventoryPanel.style.width = inventoryPanelWidth;
    inventoryPanel.style.minWidth = inventoryPanelWidth;
    inventoryPanel.style.maxWidth = inventoryPanelWidth;
    inventoryPanel.style.flexGrow = 0;
    inventoryPanel.style.flexShrink = 0;
    inventoryPanel.style.flexBasis = inventoryPanelWidth;
   }

   if (specSheetPanel != null) {
    specSheetPanel.style.width = 400;
    specSheetPanel.style.minWidth = 400;
    specSheetPanel.style.maxWidth = 400;
    specSheetPanel.style.flexGrow = 0;
    specSheetPanel.style.flexShrink = 0;
    specSheetPanel.style.flexBasis = 400;
   }

   if (geneEditorPanel != null) {
    geneEditorPanel.style.width = StyleKeyword.Null;
    geneEditorPanel.style.minWidth = 300;
    geneEditorPanel.style.maxWidth = StyleKeyword.Null;
    geneEditorPanel.style.flexGrow = 1;
    geneEditorPanel.style.flexShrink = 0;
    geneEditorPanel.style.flexBasis = 0;
   }

   if (inventoryGridElement != null) {
    inventoryGridElement.style.width = gridWidth;
    inventoryGridElement.style.minWidth = gridWidth;
    inventoryGridElement.style.maxWidth = gridWidth;
    inventoryGridElement.style.flexShrink = 0;
    inventoryGridElement.style.flexGrow = 0;
    inventoryGridElement.style.marginLeft = StyleKeyword.Auto;
    inventoryGridElement.style.marginRight = StyleKeyword.Auto;
    inventoryGridElement.style.alignSelf = Align.Center;
   }

   inventoryController = new UIInventoryGridController();
   inventoryController.Initialize(inventoryGridElement, inventorySlotTemplate, playerInventory);

   dragDropController = new UIDragDropController();
   dragDropController.Initialize(rootElement, playerInventory);

   seedEditorController = new UISeedEditorController();
   seedEditorController.Initialize(
    rootElement.Q<VisualElement>("seed-drop-slot-container"),
    rootElement.Q<VisualElement>("passive-genes-container"),
    rootElement.Q<VisualElement>("active-sequence-container"),
    geneSlotTemplate
   );

   specSheetController = new UISpecSheetController();
   specSheetController.Initialize(rootElement.Q<VisualElement>("SeedSpecSheetPanel"));

   hotbarController = new UIHotbarController();
   hotbarController.Initialize(
    rootElement.Q<ListView>("hotbar-list"),
    rootElement.Q<VisualElement>("hotbar-selector"),
    inventorySlotTemplate
   );
  }

  void InitializeHUD() {
   hungerBarFill = rootElement.Q<VisualElement>("hunger-bar-fill");
   hungerText = rootElement.Q<Label>("hunger-text");
   tickText = rootElement.Q<Label>("tick-text");

   hudTooltipPanel = rootElement.Q<VisualElement>("hud-tooltip-panel");
   hudTooltipIcon = rootElement.Q<Image>("hud-tooltip-icon");
   hudTooltipName = rootElement.Q<Label>("hud-tooltip-name");
   hudTooltipType = rootElement.Q<Label>("hud-tooltip-type");
   hudTooltipDescription = rootElement.Q<Label>("hud-tooltip-description");

   playerHungerSystem = FindFirstObjectByType<PlayerHungerSystem>();
   if (playerHungerSystem != null) {
    playerHungerSystem.OnHungerChanged += UpdateHungerDisplay;
    UpdateHungerDisplay(playerHungerSystem.CurrentHunger, playerHungerSystem.MaxHunger);
   }
   else {
    Debug.LogWarning("[GameUIManager] PlayerHungerSystem not found - hunger display won't update");
   }

   if (TickManager.Instance != null) {
    TickManager.Instance.OnTickAdvanced += UpdateTickDisplay;
    UpdateTickDisplay(TickManager.Instance.CurrentTick);
   }

   HotbarSelectionService.OnSelectionChanged += HandleHotbarSelectionChanged;

   Debug.Log("[GameUIManager] HUD initialized");
  }

  void CreateStartDayButton() {
   var buttonContainer = new VisualElement();
   buttonContainer.style.position = Position.Absolute;
   buttonContainer.style.bottom = 120;
   buttonContainer.style.left = Length.Percent(50);
   buttonContainer.style.translate = new Translate(Length.Percent(-50), 0);
   buttonContainer.style.alignItems = Align.Center;
   buttonContainer.style.justifyContent = Justify.Center;

   startDayButton = new Button();
   startDayButton.text = "▶ START DAY";
   startDayButton.AddToClassList("start-day-button");

   startDayButton.style.fontSize = 24;
   startDayButton.style.paddingTop = 15;
   startDayButton.style.paddingBottom = 15;
   startDayButton.style.paddingLeft = 40;
   startDayButton.style.paddingRight = 40;
   startDayButton.style.backgroundColor = new Color(0.2f, 0.7f, 0.3f);
   startDayButton.style.color = Color.white;
   startDayButton.style.borderTopLeftRadius = 10;
   startDayButton.style.borderTopRightRadius = 10;
   startDayButton.style.borderBottomLeftRadius = 10;
   startDayButton.style.borderBottomRightRadius = 10;
   startDayButton.style.borderLeftWidth = 0;
   startDayButton.style.borderRightWidth = 0;
   startDayButton.style.borderTopWidth = 0;
   startDayButton.style.borderBottomWidth = 0;
   startDayButton.style.unityFontStyleAndWeight = FontStyle.Bold;

   startDayButton.clicked += OnStartDayClicked;

   buttonContainer.Add(startDayButton);
   planningPanel.Add(buttonContainer);

   Debug.Log("[GameUIManager] Start Day button created");
  }

  void SubscribeToEvents() {
   inventoryController.OnSlotClicked += HandleSlotClicked;
   inventoryController.OnSlotPointerDown += HandleSlotPointerDown;
   inventoryController.OnSlotHoverEnter += HandleInventoryHover;
   inventoryController.OnSlotHoverExit += HandleHoverExit;

   dragDropController.OnInventorySwapRequested += HandleInventorySwap;
   dragDropController.OnGeneDropRequested += HandleGeneDrop;
   dragDropController.OnDragStarted += HandleDragStarted;
   dragDropController.OnDragEnded += HandleDragEnded;

   dragDropController.OnGeneDroppedToInventory += HandleGeneDroppedToInventory;
   dragDropController.OnGeneEditorInternalMove += HandleGeneEditorInternalMove;

   seedEditorController.OnGeneSlotPointerDown += HandleGeneSlotPointerDown;
   seedEditorController.OnGeneSlotHoverEnter += HandleGeneHover;
   seedEditorController.OnGeneSlotHoverExit += HandleHoverExit;
   seedEditorController.OnSeedColorChanged += HandleSeedColorChanged;
   seedEditorController.OnGeneRemovedFromEditor += HandleGeneRemovedFromEditor;
  }

  void SetupPlayerInventory() {
   playerInventory.Clear();
   if (startingInventory == null) return;

   foreach (var tool in startingInventory.startingTools)
    if (tool != null) playerInventory.Add(new UIInventoryItem(tool));

   foreach (var seed in startingInventory.startingSeeds)
    if (seed != null) playerInventory.Add(new UIInventoryItem(seed));

   foreach (var gene in startingInventory.startingGenes)
    if (gene != null) playerInventory.Add(new UIInventoryItem(gene));

   while (playerInventory.Count < TotalInventorySlots) {
    playerInventory.Add(null);
   }

   if (playerInventory.Count > TotalInventorySlots) {
    Debug.LogWarning($"[GameUIManager] Starting inventory has {playerInventory.Count} items but only {TotalInventorySlots} slots. Truncating.");
    playerInventory = playerInventory.Take(TotalInventorySlots).ToList();
   }
  }

  void RefreshHotbar() {
   var hotbarItems = new List<UIInventoryItem>();
   for (int i = 0; i < inventoryColumns && i < playerInventory.Count; i++) {
    hotbarItems.Add(playerInventory[i]);
   }
   hotbarController.SetupHotbar(hotbarItems);
  }

  void HandleInventoryServiceChanged() {
   Debug.Log("[GameUIManager] Inventory changed via service - refreshing UI");

   inventoryController.RefreshVisuals();

   RefreshHotbar();

   if (hotbarController != null) {
    hotbarController.SelectSlot(HotbarSelectionService.SelectedIndex);
   }
  }

  void HandleToolUsesChanged(int remainingUses) {
   inventoryController.RefreshVisuals();
   RefreshHotbar();

   Debug.Log($"[GameUIManager] Tool uses changed: {remainingUses} remaining - UI refreshed");
  }

  void UpdateHungerDisplay(float currentHunger, float maxHunger) {
   if (hungerBarFill != null) {
    float percentage = maxHunger > 0 ? (currentHunger / maxHunger) * 100f : 0f;
    hungerBarFill.style.width = Length.Percent(percentage);

    if (percentage <= 25f) {
     hungerBarFill.style.backgroundColor = new Color(0.85f, 0.25f, 0.25f);
    }
    else if (percentage <= 50f) {
     hungerBarFill.style.backgroundColor = new Color(0.9f, 0.6f, 0.2f);
    }
    else {
     hungerBarFill.style.backgroundColor = new Color(0.86f, 0.47f, 0.2f);
    }
   }

   if (hungerText != null) {
    hungerText.text = $"{Mathf.CeilToInt(currentHunger)}/{Mathf.CeilToInt(maxHunger)}";
   }
  }

  void UpdateTickDisplay(int currentTick) {
   if (tickText != null) {
    tickText.text = $"Tick: {currentTick}";
   }
  }

  void HandleHotbarSelectionChanged(InventoryBarItem selectedItem) {
   UpdateHUDTooltip(selectedItem);
  }

  void UpdateHUDTooltip(InventoryBarItem selectedItem) {
   if (selectedItem == null || hudTooltipPanel == null) {
    if (hudTooltipPanel != null) {
     hudTooltipPanel.style.display = DisplayStyle.None;
    }
    return;
   }

   hudTooltipPanel.style.display = DisplayStyle.Flex;

   switch (selectedItem.Type) {
    case InventoryBarItem.ItemType.Seed:
     var seed = selectedItem.SeedTemplate;
     if (seed != null) {
      if (hudTooltipIcon != null) hudTooltipIcon.sprite = seed.icon;
      if (hudTooltipName != null) hudTooltipName.text = seed.templateName;
      if (hudTooltipType != null) hudTooltipType.text = "Seed";
      if (hudTooltipDescription != null) hudTooltipDescription.text = seed.description;
     }
     break;

    case InventoryBarItem.ItemType.Tool:
     var tool = selectedItem.ToolDefinition;
     if (tool != null) {
      if (hudTooltipIcon != null) hudTooltipIcon.sprite = tool.icon;
      if (hudTooltipName != null) hudTooltipName.text = tool.displayName;
      if (hudTooltipType != null) hudTooltipType.text = $"Tool - {tool.toolType}";
      if (hudTooltipDescription != null) hudTooltipDescription.text = tool.GetTooltipDescription();
     }
     break;

    case InventoryBarItem.ItemType.Gene:
     var gene = selectedItem.GeneInstance?.GetGene();
     if (gene != null) {
      if (hudTooltipIcon != null) hudTooltipIcon.sprite = gene.icon;
      if (hudTooltipName != null) hudTooltipName.text = gene.geneName;
      if (hudTooltipType != null) hudTooltipType.text = $"Gene - {gene.Category}";
      if (hudTooltipDescription != null) hudTooltipDescription.text = gene.description;
     }
     break;

    case InventoryBarItem.ItemType.Resource:
     var resource = selectedItem.ItemInstance;
     if (resource?.definition != null) {
      if (hudTooltipIcon != null) hudTooltipIcon.sprite = resource.definition.icon;
      if (hudTooltipName != null) hudTooltipName.text = resource.definition.itemName;
      if (hudTooltipType != null) hudTooltipType.text = "Resource";
      if (hudTooltipDescription != null) hudTooltipDescription.text = resource.definition.description;
     }
     break;

    default:
     hudTooltipPanel.style.display = DisplayStyle.None;
     break;
   }
  }

  void HandleSlotClicked(int index) {
   if (dragDropController.IsDragging()) return;

   selectedInventoryIndex = index;
   inventoryController.SetSelectedSlot(index);

   var selectedItem = playerInventory[index];
   specSheetController.DisplayItem(selectedItem);

   if (selectedItem?.OriginalData is SeedTemplate) {
    inventoryController.SetLockedSeedSlot(index);
    seedEditorController.DisplaySeed(selectedItem);

    dragDropController.SetGeneEditorSlots(
     seedEditorController.GetSeedContainer(),
     seedEditorController.GetPassiveContainer(),
     seedEditorController.GetActiveContainer()
    );
   }
  }

  void HandleSlotPointerDown(int index) {
   dragDropController.StartDrag(index);
   dragDropController.SetInventorySlots(inventoryController.GetSlots());
  }

  void HandleGeneSlotPointerDown(GeneBase gene, VisualElement slot, int slotIndex, string slotType) {
   if (gene == null) return;

   dragDropController.StartDragFromGeneEditor(gene, slot, slotIndex, slotType);
   dragDropController.SetInventorySlots(inventoryController.GetSlots());
  }

  void HandleInventoryHover(int index) {
   if (dragDropController.IsDragging()) return;

   var item = playerInventory[index];
   if (item != null) {
    specSheetController.DisplayItem(item);
   }
  }

  void HandleGeneHover(GeneBase gene) {
   if (dragDropController.IsDragging()) return;

   if (gene != null) {
    specSheetController.DisplayGene(gene);
   }
  }

  void HandleHoverExit() {
   if (selectedInventoryIndex >= 0 && selectedInventoryIndex < playerInventory.Count) {
    var selectedItem = playerInventory[selectedInventoryIndex];
    specSheetController.DisplayItem(selectedItem);
   }
  }

  void HandleDragStarted(GeneCategory? category) {
   seedEditorController.HighlightCompatibleSlots(category);
  }

  void HandleDragEnded() {
   seedEditorController.ClearSlotHighlighting();
  }

  void HandleSeedColorChanged(Color newColor) {
   inventoryController.RefreshVisuals();
   hotbarController.RefreshHotbar();
  }

  void HandleGeneRemovedFromEditor(GeneBase gene, int slotIndex, string slotType) {
   int emptySlot = playerInventory.FindIndex(item => item == null);

   if (emptySlot >= 0) {
    playerInventory[emptySlot] = new UIInventoryItem(gene);
    inventoryController.RefreshVisuals();
    RefreshHotbar();
    Debug.Log($"[GameUIManager] Returned {gene.geneName} to inventory slot {emptySlot}");
   }
   else {
    Debug.LogWarning($"[GameUIManager] No empty inventory slot to return {gene.geneName}!");
   }
  }

  void HandleGeneDroppedToInventory(GeneBase gene, int inventoryIndex, int editorSlotIndex, string editorSlotType) {
   seedEditorController.RemoveGeneFromSlot(editorSlotIndex, editorSlotType);

   var targetItem = playerInventory[inventoryIndex];

   if (targetItem == null) {
    playerInventory[inventoryIndex] = new UIInventoryItem(gene);
    Debug.Log($"[GameUIManager] Dropped {gene.geneName} to empty inventory slot {inventoryIndex}");
   }
   else if (targetItem.OriginalData is GeneBase targetGene && CanGeneGoInSlot(targetGene, editorSlotType)) {
    playerInventory[inventoryIndex] = new UIInventoryItem(gene);
    seedEditorController.AddGeneToSlot(targetGene, editorSlotIndex, editorSlotType);
    Debug.Log($"[GameUIManager] Swapped {gene.geneName} with {targetGene.geneName}");
   }
   else {
    int emptySlot = playerInventory.FindIndex(item => item == null);
    if (emptySlot >= 0) {
     playerInventory[emptySlot] = new UIInventoryItem(gene);
     Debug.Log($"[GameUIManager] Target occupied - placed {gene.geneName} in empty slot {emptySlot}");
    }
    else {
     seedEditorController.AddGeneToSlot(gene, editorSlotIndex, editorSlotType);
     Debug.LogWarning($"[GameUIManager] No space in inventory - returned {gene.geneName} to editor");
    }
   }

   inventoryController.RefreshVisuals();
   RefreshHotbar();
  }

  void HandleGeneEditorInternalMove(GeneBase gene, int fromIndex, string fromType, int toIndex, string toType) {
   if (!CanGeneGoInSlot(gene, toType)) {
    Debug.Log($"[GameUIManager] Cannot move {gene.Category} gene to {toType} slot");
    return;
   }

   var destinationGene = seedEditorController.GetGeneAtSlot(toIndex, toType);

   seedEditorController.RemoveGeneFromSlot(fromIndex, fromType);

   if (destinationGene != null) {
    if (CanGeneGoInSlot(destinationGene, fromType)) {
     seedEditorController.AddGeneToSlot(gene, toIndex, toType);
     seedEditorController.AddGeneToSlot(destinationGene, fromIndex, fromType);
     Debug.Log($"[GameUIManager] Swapped {gene.geneName} with {destinationGene.geneName}");
    }
    else {
     seedEditorController.AddGeneToSlot(gene, toIndex, toType);

     int emptySlot = playerInventory.FindIndex(item => item == null);
     if (emptySlot >= 0) {
      playerInventory[emptySlot] = new UIInventoryItem(destinationGene);
      inventoryController.RefreshVisuals();
      RefreshHotbar();
      Debug.Log($"[GameUIManager] Moved {gene.geneName} to {toType} slot, {destinationGene.geneName} to inventory");
     }
     else {
      seedEditorController.RemoveGeneFromSlot(toIndex, toType);
      seedEditorController.AddGeneToSlot(destinationGene, toIndex, toType);
      seedEditorController.AddGeneToSlot(gene, fromIndex, fromType);
      Debug.LogWarning($"[GameUIManager] No inventory space - reverted move");
     }
    }
   }
   else {
    seedEditorController.AddGeneToSlot(gene, toIndex, toType);
    Debug.Log($"[GameUIManager] Moved {gene.geneName} from {fromType}[{fromIndex}] to {toType}[{toIndex}]");
   }
  }

  bool CanGeneGoInSlot(GeneBase gene, string slotType) {
   return slotType switch {
    "passive" => gene.Category == GeneCategory.Passive,
    "active" => gene.Category == GeneCategory.Active,
    "modifier" => gene.Category == GeneCategory.Modifier,
    "payload" => gene.Category == GeneCategory.Payload,
    _ => false
   };
  }

  void HandleInventorySwap(int fromIndex, int toIndex) {
   var temp = playerInventory[fromIndex];
   playerInventory[fromIndex] = playerInventory[toIndex];
   playerInventory[toIndex] = temp;

   inventoryController.UpdateIndicesAfterSwap(fromIndex, toIndex);
   inventoryController.RefreshVisuals();

   if (fromIndex < inventoryColumns || toIndex < inventoryColumns) {
    RefreshHotbar();
   }
  }

  void HandleGeneDrop(int dragSourceIndex, VisualElement targetSlot, string slotType) {
   var draggedItem = playerInventory[dragSourceIndex];
   if (draggedItem == null) return;

   bool validDrop = false;

   if (draggedItem.OriginalData is GeneBase gene) {
    validDrop = slotType switch {
     "passive" => gene.Category == GeneCategory.Passive,
     "active" => gene.Category == GeneCategory.Active,
     "modifier" => gene.Category == GeneCategory.Modifier,
     "payload" => gene.Category == GeneCategory.Payload,
     _ => false
    };

    if (validDrop) {
     int slotIndex = GetSlotIndexFromElement(targetSlot, slotType);

     Debug.Log($"[GameUIManager] Attempting to add {gene.geneName} to {slotType} slot {slotIndex}");

     bool added = seedEditorController.AddGeneToSlot(gene, slotIndex, slotType);

     if (added) {
      playerInventory[dragSourceIndex] = null;
      inventoryController.RefreshVisuals();
      RefreshHotbar();
      Debug.Log($"[GameUIManager] ✓ Added {gene.geneName} to editor, removed from inventory");
     }
     else {
      Debug.LogWarning($"[GameUIManager] ✗ Failed to add {gene.geneName} to slot");
     }
    }
    else {
     Debug.Log($"[GameUIManager] Invalid drop: {gene.Category} gene cannot go in {slotType} slot");
    }
   }
   else if (draggedItem.OriginalData is SeedTemplate && slotType == "seed") {
    inventoryController.SetLockedSeedSlot(dragSourceIndex);
    seedEditorController.DisplaySeed(draggedItem);

    dragDropController.SetGeneEditorSlots(
     seedEditorController.GetSeedContainer(),
     seedEditorController.GetPassiveContainer(),
     seedEditorController.GetActiveContainer()
    );

    validDrop = true;
   }
  }

  int GetSlotIndexFromElement(VisualElement element, string slotType) {
   if (slotType == "passive") {
    var container = rootElement.Q<VisualElement>("passive-genes-container");
    if (container != null) {
     int index = 0;
     foreach (var child in container.Children()) {
      if (child.Contains(element)) return index;
      index++;
     }
    }
   }
   else if (slotType == "active" || slotType == "modifier" || slotType == "payload") {
    var container = rootElement.Q<VisualElement>("active-sequence-container");
    if (container != null) {
     int rowIndex = 0;
     foreach (var row in container.Children()) {
      if (row.ClassListContains("active-sequence-header")) continue;

      if (row.Contains(element)) {
       return rowIndex;
      }
      rowIndex++;
     }
    }
   }

   return 0;
  }

  void OnStartDayClicked() {
   Debug.Log("[GameUIManager] START DAY clicked - transitioning to Growth & Threat phase");

   if (RunManager.Instance != null) {
    RunManager.Instance.StartGrowthAndThreatPhase();
   }
   else {
    Debug.LogError("[GameUIManager] RunManager.Instance is null! Cannot start day.");
   }
  }

  void HandleRunStateChanged(RunState newState) {
   if (newState == RunState.Planning) ShowPlanningUI();
   else ShowHUD();
  }

  void ShowPlanningUI() {
   planningPanel.style.display = DisplayStyle.Flex;
   hudPanel.style.display = DisplayStyle.None;

   rootElement.style.backgroundColor = new Color(20f / 255f, 20f / 255f, 25f / 255f);

   if (startDayButton != null) {
    startDayButton.style.display = DisplayStyle.Flex;
   }
  }

  void ShowHUD() {
   planningPanel.style.display = DisplayStyle.None;
   hudPanel.style.display = DisplayStyle.Flex;

   rootElement.style.backgroundColor = new Color(0, 0, 0, 0);

   if (hudPanel != null) {
    hudPanel.style.backgroundColor = new Color(0, 0, 0, 0);
   }

   if (startDayButton != null) {
    startDayButton.style.display = DisplayStyle.None;
   }

   if (playerHungerSystem != null) {
    UpdateHungerDisplay(playerHungerSystem.CurrentHunger, playerHungerSystem.MaxHunger);
   }

   if (TickManager.Instance != null) {
    UpdateTickDisplay(TickManager.Instance.CurrentTick);
   }

   UpdateHUDTooltip(HotbarSelectionService.SelectedItem);

   Debug.Log("[GameUIManager] HUD shown - UI background set to transparent");
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\A_ToolkitUI\UIDragDropController.cs

using UnityEngine.UIElements;
using Abracodabra.Genes.Core;

namespace Abracodabra.UI.Toolkit {
 pub class UIDragDropController {
  pub event Action<int, int> OnInventorySwapRequested;
  pub event Action<int, VisualElement, string> OnGeneDropRequested;
  pub event Action<GeneCategory?> OnDragStarted;
  pub event Action OnDragEnded;

  pub event Action<GeneBase, int, int, string> OnGeneDroppedToInventory;

  pub event Action<GeneBase, int, string, int, string> OnGeneEditorInternalMove;

  VisualElement rootElement;
  VisualElement dragPreview;
  List<UIInventoryItem> inventory;
  List<VisualElement> inventorySlots;

  VisualElement seedDropSlotContainer;
  VisualElement passiveGenesContainer;
  VisualElement activeSequenceContainer;

  int dragSourceIndex = -1;
  GeneBase draggedGene = null;
  VisualElement draggedGeneSlot = null;
  int draggedGeneSlotIndex = -1;
  string draggedGeneSlotType = null;
  bool isDragging = false;

  pub void Initialize(VisualElement root, List<UIInventoryItem> inventoryData) {
   rootElement = root;
   inventory = inventoryData;

   rootElement.RegisterCallback<PointerMoveEvent>(OnGlobalPointerMove);
   rootElement.RegisterCallback<PointerUpEvent>(OnGlobalPointerUp);
  }

  pub void SetInventorySlots(List<VisualElement> slots) {
   inventorySlots = slots;
  }

  pub void SetGeneEditorSlots(VisualElement seedContainer, VisualElement passiveContainer, VisualElement activeContainer) {
   seedDropSlotContainer = seedContainer;
   passiveGenesContainer = passiveContainer;
   activeSequenceContainer = activeContainer;
  }

  pub void StartDrag(int sourceIndex) {
   if (inventory[sourceIndex] == null) return;

   dragSourceIndex = sourceIndex;
   draggedGene = null;
   draggedGeneSlot = null;
   draggedGeneSlotIndex = -1;
   draggedGeneSlotType = null;
   isDragging = false;
  }

  pub void StartDragFromGeneEditor(GeneBase gene, VisualElement sourceSlot, int slotIndex, string slotType) {
   draggedGene = gene;
   draggedGeneSlot = sourceSlot;
   draggedGeneSlotIndex = slotIndex;
   draggedGeneSlotType = slotType;
   dragSourceIndex = -1;
   isDragging = false;
  }

  pub bool IsDragging() => isDragging;

  void OnGlobalPointerMove(PointerMoveEvent evt) {
   if (dragSourceIndex == -1 && draggedGene == null) return;

   if (!isDragging) {
    isDragging = true;

    if (draggedGene != null) {
     CreateDragPreviewFromGene(draggedGene);
     OnDragStarted?.Invoke(draggedGene.Category);
    }
    else {
     CreateDragPreview(dragSourceIndex);
     var item = inventory[dragSourceIndex];
     if (item?.OriginalData is GeneBase gene) {
      OnDragStarted?.Invoke(gene.Category);
     }
     else {
      OnDragStarted?.Invoke(null);
     }
    }
   }

   if (dragPreview != null) {
    dragPreview.style.left = evt.position.x - 32;
    dragPreview.style.top = evt.position.y - 32;
   }
  }

  void OnGlobalPointerUp(PointerUpEvent evt) {
   if (!isDragging || (dragSourceIndex == -1 && draggedGene == null)) {
    dragSourceIndex = -1;
    draggedGene = null;
    draggedGeneSlot = null;
    draggedGeneSlotIndex = -1;
    draggedGeneSlotType = null;
    return;
   }

   bool dropHandled = false;

   int inventoryDropIndex = GetInventorySlotAtPosition(evt.position);
   if (inventoryDropIndex >= 0) {
    if (dragSourceIndex >= 0 && dragSourceIndex != inventoryDropIndex) {
     OnInventorySwapRequested?.Invoke(dragSourceIndex, inventoryDropIndex);
     dropHandled = true;
    }
    else if (draggedGene != null && draggedGeneSlotType != null) {
     OnGeneDroppedToInventory?.Invoke(
      draggedGene,
      inventoryDropIndex,
      draggedGeneSlotIndex,
      draggedGeneSlotType
     );
     dropHandled = true;
    }
   }

   if (!dropHandled) {
    var geneSlotDrop = GetGeneSlotAtPositionWithIndex(evt.position);

    if (geneSlotDrop.slot != null) {
     if (dragSourceIndex >= 0) {
      OnGeneDropRequested?.Invoke(dragSourceIndex, geneSlotDrop.slot, geneSlotDrop.slotType);
      dropHandled = true;
     }
     else if (draggedGene != null && draggedGeneSlotType != null) {
      bool isDifferentSlot = (geneSlotDrop.slotIndex != draggedGeneSlotIndex) ||
           (geneSlotDrop.slotType != draggedGeneSlotType);

      if (isDifferentSlot) {
       OnGeneEditorInternalMove?.Invoke(
        draggedGene,
        draggedGeneSlotIndex,
        draggedGeneSlotType,
        geneSlotDrop.slotIndex,
        geneSlotDrop.slotType
       );
      }
      dropHandled = true;
     }
    }
   }

   CleanupDrag();
  }

  int GetInventorySlotAtPosition(Vector2 screenPos) {
   if (inventorySlots == null) return -1;

   for (int i = 0; i < inventorySlots.Count; i++) {
    var slot = inventorySlots[i];
    if (slot.worldBound.Contains(screenPos)) {
     return i;
    }
   }
   return -1;
  }

  (VisualElement slot, string slotType, int slotIndex) GetGeneSlotAtPositionWithIndex(Vector2 screenPos) {
   if (seedDropSlotContainer != null && seedDropSlotContainer.childCount > 0) {
    var seedSlot = seedDropSlotContainer.ElementAt(0);
    if (seedSlot.worldBound.Contains(screenPos)) {
     return (seedSlot, "seed", 0);
    }
   }

   if (passiveGenesContainer != null) {
    int passiveIndex = 0;
    foreach (var wrapper in passiveGenesContainer.Children()) {
     if (wrapper.worldBound.Contains(screenPos)) {
      return (wrapper, "passive", passiveIndex);
     }
     passiveIndex++;
    }
   }

   if (activeSequenceContainer != null) {
    int rowIndex = 0;
    foreach (var row in activeSequenceContainer.Children()) {
     if (row.ClassListContains("active-sequence-header")) continue;

     int columnIndex = 0;
     foreach (var wrapper in row.Children()) {
      if (wrapper.worldBound.Contains(screenPos)) {
       string slotType = columnIndex switch {
        0 => "active",
        1 => "modifier",
        2 => "payload",
        _ => "unknown"
       };
       return (wrapper, slotType, rowIndex);
      }
      columnIndex++;
     }
     rowIndex++;
    }
   }

   return (null, null, -1);
  }

  void CleanupDrag() {
   if (dragPreview != null) {
    dragPreview.RemoveFromHierarchy();
    dragPreview = null;
   }

   if (isDragging) {
    OnDragEnded?.Invoke();
   }

   isDragging = false;
   dragSourceIndex = -1;
   draggedGene = null;
   draggedGeneSlot = null;
   draggedGeneSlotIndex = -1;
   draggedGeneSlotType = null;
  }

  void CreateDragPreview(int index) {
   var item = inventory[index];
   if (item == null) return;

   dragPreview = new VisualElement();
   dragPreview.AddToClassList("slot");
   dragPreview.style.position = Position.Absolute;
   dragPreview.style.width = 64;
   dragPreview.style.height = 64;
   dragPreview.style.overflow = Overflow.Hidden;
   dragPreview.pickingMode = PickingMode.Ignore;

   var icon = new Image();
   icon.sprite = item.Icon;
   icon.AddToClassList("slot-icon");

   icon.style.width = Length.Percent(100);
   icon.style.height = Length.Percent(100);
   icon.style.position = Position.Absolute;
   icon.style.top = 0;
   icon.style.left = 0;
   icon.scaleMode = ScaleMode.ScaleToFit;

   dragPreview.Add(icon);

   rootElement.Add(dragPreview);
  }

  void CreateDragPreviewFromGene(GeneBase gene) {
   if (gene == null) return;

   dragPreview = new VisualElement();
   dragPreview.AddToClassList("slot");
   dragPreview.style.position = Position.Absolute;
   dragPreview.style.width = 64;
   dragPreview.style.height = 64;
   dragPreview.style.overflow = Overflow.Hidden;
   dragPreview.pickingMode = PickingMode.Ignore;

   var icon = new Image();
   icon.sprite = gene.icon;
   icon.AddToClassList("slot-icon");

   icon.style.width = Length.Percent(100);
   icon.style.height = Length.Percent(100);
   icon.style.position = Position.Absolute;
   icon.style.top = 0;
   icon.style.left = 0;
   icon.scaleMode = ScaleMode.ScaleToFit;

   dragPreview.Add(icon);

   rootElement.Add(dragPreview);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\A_ToolkitUI\UIHotbarController.cs

using UnityEngine.UIElements;
using Abracodabra.UI.Genes;

namespace Abracodabra.UI.Toolkit {
 pub class UIHotbarController {
  VisualElement hotbarContainer;
  VisualElement slotsContainer;
  VisualElement hotbarSelector;
  VisualTreeAsset slotTemplate;
  List<UIInventoryItem> hotbarItems;
  List<VisualElement> slotElements = new List<VisualElement>();

  int selectedHotbarIndex = 0;
  int maxHotbarSlots = 8;

  const int SLOT_WIDTH = 64;
  const int SLOT_MARGIN = 5;
  const int SLOT_TOTAL_WIDTH = SLOT_WIDTH + SLOT_MARGIN * 2;

  pub void Initialize(ListView hotbarList, VisualElement selector, VisualTreeAsset template) {
   if (hotbarList != null) {
    hotbarList.style.display = DisplayStyle.None;
   }

   hotbarSelector = selector;
   if (hotbarSelector != null) {
    hotbarSelector.style.display = DisplayStyle.None;
   }

   slotTemplate = template;

   var hotbarPanel = hotbarList?.parent;
   if (hotbarPanel == null) {
    Debug.LogError("[UIHotbarController] Cannot find hotbar panel!");
    return;
   }

   slotsContainer = new VisualElement();
   slotsContainer.name = "hotbar-slots-container";
   slotsContainer.AddToClassList("hotbar-slots-container");
   slotsContainer.style.flexDirection = FlexDirection.Row;
   slotsContainer.style.justifyContent = Justify.Center;
   slotsContainer.style.alignItems = Align.Center;
   slotsContainer.style.height = SLOT_WIDTH + 10;

   hotbarPanel.Add(slotsContainer);
  }

  pub void SetupHotbar(List<UIInventoryItem> items) {
   hotbarItems = items ?? new List<UIInventoryItem>();

   slotsContainer.Clear();
   slotElements.Clear();

   int slotCount = Mathf.Min(hotbarItems.Count, maxHotbarSlots);

   for (int i = 0; i < slotCount; i++) {
    var slotInstance = slotTemplate.Instantiate();
    var slotElement = slotInstance.Q(className: "slot");
    if (slotElement == null) {
     slotElement = slotInstance;
     slotElement.AddToClassList("slot");
    }

    slotElement.style.width = SLOT_WIDTH;
    slotElement.style.height = SLOT_WIDTH;
    slotElement.style.marginLeft = SLOT_MARGIN;
    slotElement.style.marginRight = SLOT_MARGIN;
    slotElement.style.position = Position.Relative;
    slotElement.style.overflow = Overflow.Hidden;

    int index = i;
slotElement.RegisterCallback<PointerDownEvent>(evt => { SelectSlot(index);
    });

    slotElements.Add(slotElement);
    slotsContainer.Add(slotInstance);

    BindSlot(slotElement, hotbarItems[i]);
   }

   UpdateSelectionVisual();
  }

  void BindSlot(VisualElement slotElement, UIInventoryItem item) {
   var icon = slotElement.Q<Image>("icon");
   var stack = slotElement.Q<Label>("stack-size");

   if (icon != null) {
    icon.style.width = Length.Percent(100);
    icon.style.height = Length.Percent(100);
    icon.style.position = Position.Absolute;
    icon.style.top = 0;
    icon.style.left = 0;
    icon.scaleMode = ScaleMode.ScaleToFit;

    if (item != null && item.Icon != null) {
     icon.sprite = item.Icon;
     icon.style.display = DisplayStyle.Flex;
    }
    else {
     icon.sprite = null;
     icon.style.display = DisplayStyle.None;
    }
   }

   if (stack != null) {
    stack.style.position = Position.Absolute;
    stack.style.bottom = 2;
    stack.style.right = 4;
    stack.style.fontSize = 12;
    stack.style.unityFontStyleAndWeight = FontStyle.Bold;
    stack.style.textShadow = new TextShadow {
     offset = new Vector2(1, 1),
     blurRadius = 0,
     color = Color.black
    };

    if (item != null && item.ShouldShowCounter()) {
     int count = item.GetDisplayCount();
     stack.text = count.ToString();
     stack.style.display = DisplayStyle.Flex;

     if (count <= 1) {
      stack.style.color = new Color(1f, 0.6f, 0.6f); // Red
     }
     else if (count <= 3) {
      stack.style.color = new Color(1f, 0.9f, 0.6f); // Yellow
     }
     else {
      stack.style.color = Color.white;
     }
    }
    else {
     stack.text = "";
     stack.style.display = DisplayStyle.None;
    }
   }

   if (item != null && item.HasCustomColor()) {
    slotElement.style.backgroundColor = item.BackgroundColor;
   }
   else {
    slotElement.style.backgroundColor = StyleKeyword.Null;
   }

   slotElement.RemoveFromClassList("slot--selected");
   slotElement.RemoveFromClassList("slot--empty");

   if (item == null || item.Icon == null) {
    slotElement.AddToClassList("slot--empty");
    slotElement.style.backgroundColor = new Color(0.12f, 0.12f, 0.15f, 0.5f);
   }
  }

  pub void RefreshHotbar() {
   if (slotElements == null || hotbarItems == null) return;

   for (int i = 0; i < slotElements.Count && i < hotbarItems.Count; i++) {
    BindSlot(slotElements[i], hotbarItems[i]);
   }

   UpdateSelectionVisual();
  }

  pub void HandleInput() {
   if (Input.GetKeyDown(KeyCode.Alpha1) || Input.GetKeyDown(KeyCode.Keypad1)) SelectSlot(0);
   if (Input.GetKeyDown(KeyCode.Alpha2) || Input.GetKeyDown(KeyCode.Keypad2)) SelectSlot(1);
   if (Input.GetKeyDown(KeyCode.Alpha3) || Input.GetKeyDown(KeyCode.Keypad3)) SelectSlot(2);
   if (Input.GetKeyDown(KeyCode.Alpha4) || Input.GetKeyDown(KeyCode.Keypad4)) SelectSlot(3);
   if (Input.GetKeyDown(KeyCode.Alpha5) || Input.GetKeyDown(KeyCode.Keypad5)) SelectSlot(4);
   if (Input.GetKeyDown(KeyCode.Alpha6) || Input.GetKeyDown(KeyCode.Keypad6)) SelectSlot(5);
   if (Input.GetKeyDown(KeyCode.Alpha7) || Input.GetKeyDown(KeyCode.Keypad7)) SelectSlot(6);
   if (Input.GetKeyDown(KeyCode.Alpha8) || Input.GetKeyDown(KeyCode.Keypad8)) SelectSlot(7);
  }

  pub void SelectSlot(int index) {
   if (index < 0 || index >= maxHotbarSlots) return;

   selectedHotbarIndex = index;

   UpdateSelectionVisual();

   UIInventoryItem selectedItem = null;
   if (hotbarItems != null && index < hotbarItems.Count) {
    selectedItem = hotbarItems[index];
   }

   HotbarSelectionService.SelectItem(index, selectedItem);

   string itemName = selectedItem != null ? selectedItem.GetDisplayName() : "Empty";
   Debug.Log($"[UIHotbarController] Selected slot {index + 1}: {itemName}");
  }

  void UpdateSelectionVisual() {
   foreach (var slot in slotElements) {
    slot.RemoveFromClassList("slot--selected");
   }

   if (selectedHotbarIndex >= 0 && selectedHotbarIndex < slotElements.Count) {
    slotElements[selectedHotbarIndex].AddToClassList("slot--selected");
   }
  }

  pub int GetSelectedIndex() => selectedHotbarIndex;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\A_ToolkitUI\UIInventoryGridController.cs

using UnityEngine.UIElements;

namespace Abracodabra.UI.Toolkit {
 pub class UIInventoryGridController {
  pub event Action<int> OnSlotClicked;
  pub event Action<int> OnSlotPointerDown;
  pub event Action<int> OnSlotHoverEnter;
  pub event Action OnSlotHoverExit;

  List<UIInventoryItem> inventory;
  List<VisualElement> inventorySlots = new List<VisualElement>();
  int selectedInventoryIndex = -1;
  int lockedSeedIndex = -1;

  VisualElement inventoryGrid;
  VisualTreeAsset slotTemplate;

  pub void Initialize(VisualElement gridElement, VisualTreeAsset template, List<UIInventoryItem> inventoryData) {
   inventoryGrid = gridElement;
   slotTemplate = template;
   inventory = inventoryData;
  }

  pub void PopulateGrid() {
   inventoryGrid.Clear();
   inventorySlots.Clear();

   for (int i = 0; i < inventory.Count; i++) {
    var newSlot = slotTemplate.Instantiate();
    newSlot.userData = i;

    int slotIndex = i;

    var actualSlot = newSlot.Q(className: "slot");
    if (actualSlot == null) {
     actualSlot = newSlot;
     actualSlot.AddToClassList("slot");
    }

    actualSlot.style.position = Position.Relative;
    actualSlot.style.overflow = Overflow.Hidden;

actualSlot.RegisterCallback<PointerDownEvent>(evt => { OnSlotClicked?.Invoke(slotIndex);
     OnSlotPointerDown?.Invoke(slotIndex);
    });

actualSlot.RegisterCallback<PointerEnterEvent>(evt => { OnSlotHoverEnter?.Invoke(slotIndex);
    });

actualSlot.RegisterCallback<PointerLeaveEvent>(evt => { OnSlotHoverExit?.Invoke();
    });

    inventorySlots.Add(actualSlot);
    inventoryGrid.Add(newSlot);
   }

   RefreshVisuals();
  }

  pub void RefreshVisuals() {
   for (int i = 0; i < inventorySlots.Count; i++) {
    var element = inventorySlots[i];
    var item = inventory[i];

    BindSlot(element, item, i);
   }
  }

  void BindSlot(VisualElement element, UIInventoryItem item, int index) {
   var icon = element.Q<Image>("icon");
   var stack = element.Q<Label>("stack-size");

   if (icon != null) {
    icon.style.width = Length.Percent(100);
    icon.style.height = Length.Percent(100);
    icon.style.position = Position.Absolute;
    icon.style.top = 0;
    icon.style.left = 0;
    icon.scaleMode = ScaleMode.ScaleToFit;

    if (item != null && item.Icon != null) {
     icon.sprite = item.Icon;
     icon.style.display = DisplayStyle.Flex;
    }
    else {
     icon.sprite = null;
     icon.style.display = DisplayStyle.None;
    }
   }

   if (stack != null) {
    stack.style.position = Position.Absolute;
    stack.style.bottom = 2;
    stack.style.right = 4;
    stack.style.fontSize = 12;
    stack.style.unityFontStyleAndWeight = FontStyle.Bold;
    stack.style.textShadow = new TextShadow {
     offset = new Vector2(1, 1),
     blurRadius = 0,
     color = Color.black
    };

    if (item != null && item.ShouldShowCounter()) {
     int count = item.GetDisplayCount();
     stack.text = count.ToString();
     stack.style.display = DisplayStyle.Flex;

     if (count <= 1) {
      stack.style.color = new Color(1f, 0.6f, 0.6f); // Red
     }
     else if (count <= 3) {
      stack.style.color = new Color(1f, 0.9f, 0.6f); // Yellow
     }
     else {
      stack.style.color = Color.white;
     }
    }
    else {
     stack.text = "";
     stack.style.display = DisplayStyle.None;
    }
   }

   if (item != null && item.HasCustomColor()) {
    element.style.backgroundColor = item.BackgroundColor;
   }
   else {
    element.style.backgroundColor = StyleKeyword.Null;
   }

   element.RemoveFromClassList("slot--selected");
   element.RemoveFromClassList("slot--locked-for-editing");

   if (index == selectedInventoryIndex) {
    element.AddToClassList("slot--selected");
   }
   if (index == lockedSeedIndex) {
    element.AddToClassList("slot--locked-for-editing");
   }
  }

  pub void SetSelectedSlot(int index) {
   if (selectedInventoryIndex >= 0 && selectedInventoryIndex < inventorySlots.Count) {
    inventorySlots[selectedInventoryIndex].RemoveFromClassList("slot--selected");
   }

   selectedInventoryIndex = index;

   if (selectedInventoryIndex >= 0 && selectedInventoryIndex < inventorySlots.Count) {
    inventorySlots[selectedInventoryIndex].AddToClassList("slot--selected");
   }
  }

  pub void SetLockedSeedSlot(int index) {
   if (lockedSeedIndex >= 0 && lockedSeedIndex < inventorySlots.Count) {
    inventorySlots[lockedSeedIndex].RemoveFromClassList("slot--locked-for-editing");
   }

   lockedSeedIndex = index;

   if (lockedSeedIndex >= 0 && lockedSeedIndex < inventorySlots.Count) {
    inventorySlots[lockedSeedIndex].AddToClassList("slot--locked-for-editing");
   }
  }

  pub void UpdateIndicesAfterSwap(int fromIndex, int toIndex) {
   if (selectedInventoryIndex == fromIndex)
    selectedInventoryIndex = toIndex;
   else if (selectedInventoryIndex == toIndex)
    selectedInventoryIndex = fromIndex;

   if (lockedSeedIndex == fromIndex)
    lockedSeedIndex = toIndex;
   else if (lockedSeedIndex == toIndex)
    lockedSeedIndex = fromIndex;
  }

  pub List<VisualElement> GetSlots() => inventorySlots;
  pub int GetSelectedIndex() => selectedInventoryIndex;
  pub int GetLockedSeedIndex() => lockedSeedIndex;
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\A_ToolkitUI\UIInventoryItem.cs

using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.UI.Toolkit {
 pub class UIInventoryItem {
  pub Sprite Icon { get; set; }
  pub int StackSize { get; set; } = 1;
  pub object OriginalData { get; }

  pub PlantGeneRuntimeState SeedRuntimeState { get; set; }

  pub ItemInstance ResourceInstance { get; }

  pub Color BackgroundColor { get; set; } = new Color(0, 0, 0, 0);

  pub string CustomName { get; set; } = "";

  pub UIInventoryItem(SeedTemplate seed) {
   OriginalData = seed;
   Icon = seed?.icon;
   SeedRuntimeState = seed?.CreateRuntimeState();
  }

  pub UIInventoryItem(ToolDefinition tool) {
   OriginalData = tool;
   Icon = tool?.icon;
  }

  pub UIInventoryItem(GeneBase gene) {
   OriginalData = gene;
   Icon = gene?.icon;
  }

  pub UIInventoryItem(ItemInstance itemInstance) {
   OriginalData = itemInstance?.definition;
   ResourceInstance = itemInstance;
   Icon = itemInstance?.definition?.icon;
   StackSize = itemInstance?.stackCount ?? 1;
  }

  pub UIInventoryItem(object data) {
   OriginalData = data;

   if (data is SeedTemplate seed) {
    Icon = seed.icon;
    SeedRuntimeState = seed.CreateRuntimeState();
   }
   else if (data is ToolDefinition tool) {
    Icon = tool.icon;
   }
   else if (data is GeneBase gene) {
    Icon = gene.icon;
   }
   else if (data is ItemInstance item) {
    Icon = item.definition?.icon;
    StackSize = item.stackCount;
   }
   else if (data is ItemDefinition itemDef) {
    Icon = itemDef.icon;
   }
  }

  pub bool HasCustomColor() {
   return BackgroundColor.a > 0.01f;
  }

  pub bool IsConsumable() {
   if (ResourceInstance != null)
    return ResourceInstance.definition?.isConsumable ?? false;
   if (OriginalData is SeedTemplate)
    return true;
   return false;
  }

  pub bool ShouldShowCounter() {
   if (OriginalData is SeedTemplate) {
    return true;
   }

   if (OriginalData is ToolDefinition tool && tool.limitedUses) {
    return true;
   }

   if (StackSize > 1) {
    return true;
   }

   return false;
  }

  pub int GetDisplayCount() {
   if (OriginalData is ToolDefinition tool && tool.limitedUses) {
    if (ToolSwitcher.Instance != null && ToolSwitcher.Instance.CurrentTool == tool) {
     return ToolSwitcher.Instance.CurrentRemainingUses;
    }
    return GetToolUsesFromSwitcher(tool);
   }

   return StackSize;
  }

  int GetToolUsesFromSwitcher(ToolDefinition tool) {
   if (ToolSwitcher.Instance == null || tool == null) {
    return tool?.initialUses ?? 0;
   }

   if (ToolSwitcher.Instance.CurrentTool == tool) {
    return ToolSwitcher.Instance.CurrentRemainingUses;
   }

   return tool.initialUses;
  }

  pub string GetDisplayName() {
   if (!string.IsNullOrEmpty(CustomName)) {
    return CustomName;
   }

   return OriginalData switch {
    SeedTemplate seed => seed.templateName,
    ToolDefinition tool => tool.displayName,
    GeneBase gene => gene.geneName,
    ItemDefinition itemDef => itemDef.itemName,
    _ => "Unknown Item"
   };
  }

  pub string GetDescription() {
   return OriginalData switch {
    SeedTemplate seed => seed.description,
    ToolDefinition tool => tool.GetTooltipDescription(),
    GeneBase gene => gene.description,
    ItemDefinition itemDef => itemDef.description,
    _ => ""
   };
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\A_ToolkitUI\UISeedEditorController.cs

using UnityEngine.UIElements;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.UI.Toolkit {
 pub class UISeedEditorController {
  pub event Action<GeneBase, VisualElement, int, string> OnGeneSlotPointerDown;
  pub event Action<GeneBase> OnGeneSlotHoverEnter;
  pub event Action OnGeneSlotHoverExit;
  pub event Action<Color> OnSeedColorChanged;
  pub event Action<string> OnSeedNameChanged;
  pub event Action<GeneBase, int, string> OnGeneRemovedFromEditor;

  VisualElement seedDropSlotContainer;
  VisualElement passiveGenesContainer;
  VisualElement activeSequenceContainer;
  VisualTreeAsset geneSlotTemplate;

  TextField seedNameField;
  VisualElement nameEditorContainer;

  VisualElement colorPickerContainer;
  UIInventoryItem currentSeedItem;

  pub void Initialize(VisualElement seedContainer, VisualElement passiveContainer, VisualElement activeContainer, VisualTreeAsset slotTemplate) {
   seedDropSlotContainer = seedContainer;
   passiveGenesContainer = passiveContainer;
   activeSequenceContainer = activeContainer;
   geneSlotTemplate = slotTemplate;

   CreateNameEditor();
   CreateColorPicker();
  }

  pub void DisplaySeed(UIInventoryItem seedItem) {
   if (seedItem == null || seedItem.OriginalData is not SeedTemplate template) {
    Clear();
    return;
   }

   currentSeedItem = seedItem;

   seedDropSlotContainer.Clear();
   passiveGenesContainer.Clear();
   activeSequenceContainer.Clear();

   var seedSlot = geneSlotTemplate.Instantiate();
   BindGeneSlot(seedSlot, seedItem.OriginalData, -1, "seed");
   seedSlot.name = "seed-drop-slot";

   if (seedItem.HasCustomColor()) {
    var background = seedSlot.Q("background");
    if (background != null) {
     background.style.backgroundColor = seedItem.BackgroundColor;
    }
   }

   seedDropSlotContainer.Add(seedSlot);

   if (nameEditorContainer != null) {
    seedDropSlotContainer.Add(nameEditorContainer);
    UpdateNameEditor(seedItem);
   }

   if (colorPickerContainer != null) {
    seedDropSlotContainer.Add(colorPickerContainer);
    UpdateColorPickerSelection(seedItem.BackgroundColor);
   }

   var runtimeState = seedItem.SeedRuntimeState;

   for (int i = 0; i < template.passiveSlotCount; i++) {
    var geneInstance = (i < runtimeState.passiveInstances.Count) ? runtimeState.passiveInstances[i] : null;
    var gene = geneInstance?.GetGene();

    string labelText = gene != null ? $"T{gene.tier}" : $"P{i + 1}";
    var wrappedSlot = CreateGeneSlotWithLabel(gene, labelText, i, "passive");
    passiveGenesContainer.Add(wrappedSlot);
   }

   var headerRow = new VisualElement();
   headerRow.AddToClassList("active-sequence-header");

   var activeHeader = new Label("Active");
   activeHeader.style.width = 64;
   activeHeader.style.marginLeft = 2;
   activeHeader.style.marginRight = 2;

   var modifierHeader = new Label("Modifier");
   modifierHeader.style.width = 64;
   modifierHeader.style.marginLeft = 2;
   modifierHeader.style.marginRight = 2;

   var payloadHeader = new Label("Payload");
   payloadHeader.style.width = 64;
   payloadHeader.style.marginLeft = 2;
   payloadHeader.style.marginRight = 2;

   headerRow.Add(activeHeader);
   headerRow.Add(modifierHeader);
   headerRow.Add(payloadHeader);
   activeSequenceContainer.Add(headerRow);

   for (int i = 0; i < template.activeSequenceLength; i++) {
    var sequenceRow = new VisualElement();
    sequenceRow.AddToClassList("sequence-row");
    activeSequenceContainer.Add(sequenceRow);

    var sequenceData = (i < runtimeState.activeSequence.Count) ? runtimeState.activeSequence[i] : null;

    var activeGene = sequenceData?.activeInstance?.GetGene();
    string activeLabel = activeGene != null ? $"T{activeGene.tier}" : $"A{i + 1}";
    var activeWrapped = CreateGeneSlotWithLabel(activeGene, activeLabel, i, "active");
    sequenceRow.Add(activeWrapped);

    var modifierGene = sequenceData?.modifierInstances.FirstOrDefault()?.GetGene();
    string modifierLabel = modifierGene != null ? $"T{modifierGene.tier}" : $"M{i + 1}";
    var modifierWrapped = CreateGeneSlotWithLabel(modifierGene, modifierLabel, i, "modifier");
    sequenceRow.Add(modifierWrapped);

    var payloadGene = sequenceData?.payloadInstances.FirstOrDefault()?.GetGene();
    string payloadLabel = payloadGene != null ? $"T{payloadGene.tier}" : $"Y{i + 1}";
    var payloadWrapped = CreateGeneSlotWithLabel(payloadGene, payloadLabel, i, "payload");
    sequenceRow.Add(payloadWrapped);
   }
  }

  pub bool AddGeneToSlot(GeneBase gene, int slotIndex, string slotType) {
   if (currentSeedItem == null || gene == null) return false;

   var runtimeState = currentSeedItem.SeedRuntimeState;
   var template = currentSeedItem.OriginalData as SeedTemplate;
   if (runtimeState == null || template == null) return false;

   var instance = new RuntimeGeneInstance(gene);
   instance.SetValue("power_multiplier", 1f);

   bool success = false;

   if (slotType == "passive") {
    if (slotIndex < template.passiveSlotCount) {
     while (runtimeState.passiveInstances.Count <= slotIndex) {
      runtimeState.passiveInstances.Add(null);
     }

     runtimeState.passiveInstances[slotIndex] = instance;
     success = true;
    }
   }
   else if (slotType == "active" || slotType == "modifier" || slotType == "payload") {
    while (runtimeState.activeSequence.Count <= slotIndex) {
     runtimeState.activeSequence.Add(new RuntimeSequenceSlot());
    }

    var slot = runtimeState.activeSequence[slotIndex];

    if (slotType == "active") {
     slot.activeInstance = instance;
     success = true;
    }
    else if (slotType == "modifier") {
     slot.modifierInstances.Clear();
     slot.modifierInstances.Add(instance);
     success = true;
    }
    else if (slotType == "payload") {
     slot.payloadInstances.Clear();
     slot.payloadInstances.Add(instance);
     success = true;
    }
   }

   if (success) {
    Debug.Log($"[SeedEditor] Added {gene.geneName} to {slotType} slot {slotIndex}");
    DisplaySeed(currentSeedItem);
   }

   return success;
  }

  pub GeneBase RemoveGeneFromSlot(int slotIndex, string slotType) {
   if (currentSeedItem == null) return null;

   var runtimeState = currentSeedItem.SeedRuntimeState;
   if (runtimeState == null) return null;

   GeneBase removedGene = null;

   if (slotType == "passive") {
    if (slotIndex < runtimeState.passiveInstances.Count) {
     var instance = runtimeState.passiveInstances[slotIndex];
     removedGene = instance?.GetGene();
     runtimeState.passiveInstances[slotIndex] = null;
    }
   }
   else if (slotType == "active" || slotType == "modifier" || slotType == "payload") {
    if (slotIndex < runtimeState.activeSequence.Count) {
     var slot = runtimeState.activeSequence[slotIndex];

     if (slotType == "active") {
      removedGene = slot.activeInstance?.GetGene();
      slot.activeInstance = null;
     }
     else if (slotType == "modifier" && slot.modifierInstances.Count > 0) {
      removedGene = slot.modifierInstances[0]?.GetGene();
      slot.modifierInstances.Clear();
     }
     else if (slotType == "payload" && slot.payloadInstances.Count > 0) {
      removedGene = slot.payloadInstances[0]?.GetGene();
      slot.payloadInstances.Clear();
     }
    }
   }

   if (removedGene != null) {
    Debug.Log($"[SeedEditor] Removed {removedGene.geneName} from {slotType} slot {slotIndex}");
    DisplaySeed(currentSeedItem);
   }

   return removedGene;
  }

  pub GeneBase GetGeneAtSlot(int slotIndex, string slotType) {
   if (currentSeedItem == null) return null;

   var runtimeState = currentSeedItem.SeedRuntimeState;
   if (runtimeState == null) return null;

   if (slotType == "passive") {
    if (slotIndex < runtimeState.passiveInstances.Count) {
     return runtimeState.passiveInstances[slotIndex]?.GetGene();
    }
   }
   else if (slotIndex < runtimeState.activeSequence.Count) {
    var slot = runtimeState.activeSequence[slotIndex];

    return slotType switch {
     "active" => slot.activeInstance?.GetGene(),
     "modifier" => slot.modifierInstances.FirstOrDefault()?.GetGene(),
     "payload" => slot.payloadInstances.FirstOrDefault()?.GetGene(),
     _ => null
    };
   }

   return null;
  }

  pub void Clear() {
   currentSeedItem = null;

   seedDropSlotContainer.Clear();
   passiveGenesContainer.Clear();
   activeSequenceContainer.Clear();

   var emptySeedSlot = geneSlotTemplate.Instantiate();
   var label = emptySeedSlot.Q<Label>("tier-label");
   if (label != null) {
    label.text = "SEED";
    label.style.display = DisplayStyle.Flex;
   }
   emptySeedSlot.Q("icon").style.display = DisplayStyle.None;

   var background = emptySeedSlot.Q("background");
   if (background != null) {
    background.AddToClassList("gene-slot--empty");
   }
   emptySeedSlot.AddToClassList("gene-slot--seed");
   emptySeedSlot.name = "seed-drop-slot";
   seedDropSlotContainer.Add(emptySeedSlot);
  }

  pub bool HasSeedLoaded() => currentSeedItem != null;

  void CreateNameEditor() {
   nameEditorContainer = new VisualElement();
   nameEditorContainer.style.flexDirection = FlexDirection.Row;
   nameEditorContainer.style.alignItems = Align.Center;
   nameEditorContainer.style.justifyContent = Justify.Center;
   nameEditorContainer.style.marginTop = 10;
   nameEditorContainer.style.marginBottom = 6;
   nameEditorContainer.style.width = Length.Percent(100);

   seedNameField = new TextField();
   seedNameField.AddToClassList("seed-name-field");

   seedNameField.style.width = 280;
   seedNameField.style.height = 36;

   seedNameField.RegisterCallback<AttachToPanelEvent>(evt => {
    seedNameField.schedule.Execute(() => StyleNameFieldInput()).StartingIn(10);
   });

   seedNameField.RegisterCallback<GeometryChangedEvent>(evt => StyleNameFieldInput());

   seedNameField.RegisterValueChangedCallback(evt => {
    if (currentSeedItem != null) {
     currentSeedItem.CustomName = evt.newValue;
     OnSeedNameChanged?.Invoke(evt.newValue);
    }
   });

   nameEditorContainer.Add(seedNameField);
  }

  void StyleNameFieldInput() {
   if (seedNameField == null) return;

   var textInput = seedNameField.Q("unity-text-input");
   if (textInput != null) {
    textInput.style.backgroundColor = new Color(0.05f, 0.05f, 0.08f, 1f);
    textInput.style.color = Color.white;
    textInput.style.fontSize = 18;
    textInput.style.unityFontStyleAndWeight = FontStyle.Bold;
    textInput.style.unityTextAlign = TextAnchor.MiddleCenter;

    textInput.style.borderTopLeftRadius = 6;
    textInput.style.borderTopRightRadius = 6;
    textInput.style.borderBottomLeftRadius = 6;
    textInput.style.borderBottomRightRadius = 6;

    textInput.style.paddingLeft = 12;
    textInput.style.paddingRight = 12;
    textInput.style.paddingTop = 6;
    textInput.style.paddingBottom = 6;

    textInput.style.borderLeftWidth = 2;
    textInput.style.borderRightWidth = 2;
    textInput.style.borderTopWidth = 2;
    textInput.style.borderBottomWidth = 2;
    textInput.style.borderLeftColor = new Color(0.4f, 0.4f, 0.5f, 1f);
    textInput.style.borderRightColor = new Color(0.4f, 0.4f, 0.5f, 1f);
    textInput.style.borderTopColor = new Color(0.4f, 0.4f, 0.5f, 1f);
    textInput.style.borderBottomColor = new Color(0.4f, 0.4f, 0.5f, 1f);
   }

   var textElement = seedNameField.Q<TextElement>();
   if (textElement != null) {
    textElement.style.color = Color.white;
   }
  }

  void UpdateNameEditor(UIInventoryItem seedItem) {
   if (seedNameField == null || seedItem == null) return;

   string displayName = !string.IsNullOrEmpty(seedItem.CustomName)
    ? seedItem.CustomName
    : (seedItem.OriginalData as SeedTemplate)?.templateName ?? "Unnamed Seed";

   seedNameField.SetValueWithoutNotify(displayName);
  }

  void CreateColorPicker() {
   colorPickerContainer = new VisualElement();
   colorPickerContainer.AddToClassList("color-picker-container");
   colorPickerContainer.style.flexDirection = FlexDirection.Row;
   colorPickerContainer.style.flexWrap = Wrap.Wrap;
   colorPickerContainer.style.marginTop = 6;
   colorPickerContainer.style.marginBottom = 10;
   colorPickerContainer.style.justifyContent = Justify.Center;
   colorPickerContainer.style.alignItems = Align.Center;
   colorPickerContainer.style.maxWidth = 400;
   colorPickerContainer.style.width = Length.Percent(100);

   var colors = new[] {
    new Color(0, 0, 0, 0),
    new Color(1.0f, 0.7f, 0.7f, 0.6f),
    new Color(1.0f, 0.5f, 0.5f, 0.6f),
    new Color(1.0f, 0.85f, 0.7f, 0.6f),
    new Color(1.0f, 0.75f, 0.5f, 0.6f),
    new Color(1.0f, 0.95f, 0.7f, 0.6f),
    new Color(1.0f, 1.0f, 0.5f, 0.6f),
    new Color(0.85f, 1.0f, 0.7f, 0.6f),
    new Color(0.7f, 1.0f, 0.7f, 0.6f),
    new Color(0.5f, 1.0f, 0.5f, 0.6f),
    new Color(0.7f, 1.0f, 0.9f, 0.6f),
    new Color(0.7f, 0.85f, 1.0f, 0.6f),
    new Color(0.6f, 0.7f, 1.0f, 0.6f),
    new Color(0.85f, 0.7f, 1.0f, 0.6f),
    new Color(1.0f, 0.7f, 0.9f, 0.6f),
    new Color(0.8f, 0.8f, 0.8f, 0.5f),
   };

   foreach (var color in colors) {
    var colorButton = new Button();
    colorButton.AddToClassList("color-picker-button");
    colorButton.style.width = 22;
    colorButton.style.height = 22;
    colorButton.style.marginTop = 2;
    colorButton.style.marginBottom = 2;
    colorButton.style.marginLeft = 2;
    colorButton.style.marginRight = 2;
    colorButton.style.borderTopLeftRadius = 4;
    colorButton.style.borderTopRightRadius = 4;
    colorButton.style.borderBottomLeftRadius = 4;
    colorButton.style.borderBottomRightRadius = 4;
    colorButton.style.borderLeftWidth = 2;
    colorButton.style.borderRightWidth = 2;
    colorButton.style.borderTopWidth = 2;
    colorButton.style.borderBottomWidth = 2;
    colorButton.style.borderLeftColor = new Color(0.3f, 0.3f, 0.3f);
    colorButton.style.borderRightColor = new Color(0.3f, 0.3f, 0.3f);
    colorButton.style.borderTopColor = new Color(0.3f, 0.3f, 0.3f);
    colorButton.style.borderBottomColor = new Color(0.3f, 0.3f, 0.3f);

    if (color.a < 0.01f) {
     colorButton.style.backgroundColor = new Color(0.3f, 0.3f, 0.3f);
     colorButton.text = "✕";
     colorButton.style.unityFontStyleAndWeight = FontStyle.Bold;
     colorButton.style.fontSize = 14;
     colorButton.style.color = new Color(0.6f, 0.6f, 0.6f);
    }
    else {
     colorButton.style.backgroundColor = color;
    }

    colorButton.userData = color;

    colorButton.clicked += () => {
     var selectedColor = (Color)colorButton.userData;
     if (currentSeedItem != null) {
      currentSeedItem.BackgroundColor = selectedColor;

      var seedSlot = seedDropSlotContainer.Q("seed-drop-slot");
      if (seedSlot != null) {
       var bg = seedSlot.Q("background");
       if (bg != null) {
        bg.style.backgroundColor = selectedColor;
       }
      }

      UpdateColorPickerSelection(selectedColor);
      OnSeedColorChanged?.Invoke(selectedColor);
     }
    };

    colorPickerContainer.Add(colorButton);
   }

   var labelElement = new Label("Seed Color");
   labelElement.style.fontSize = 10;
   labelElement.style.color = new Color(0.6f, 0.6f, 0.6f);
   labelElement.style.unityTextAlign = TextAnchor.MiddleCenter;
   labelElement.style.width = Length.Percent(100);
   labelElement.style.marginBottom = 3;
   colorPickerContainer.Insert(0, labelElement);
  }

  void UpdateColorPickerSelection(Color currentColor) {
   if (colorPickerContainer == null) return;

   foreach (var child in colorPickerContainer.Children()) {
    if (child is Button button && button.userData is Color buttonColor) {
     bool isSelected = Mathf.Approximately(buttonColor.r, currentColor.r) &&
      Mathf.Approximately(buttonColor.g, currentColor.g) &&
      Mathf.Approximately(buttonColor.b, currentColor.b) &&
      Mathf.Approximately(buttonColor.a, currentColor.a);

     if (isSelected) {
      button.style.borderLeftColor = new Color(1f, 1f, 0.3f);
      button.style.borderRightColor = new Color(1f, 1f, 0.3f);
      button.style.borderTopColor = new Color(1f, 1f, 0.3f);
      button.style.borderBottomColor = new Color(1f, 1f, 0.3f);
      button.style.borderLeftWidth = 3;
      button.style.borderRightWidth = 3;
      button.style.borderTopWidth = 3;
      button.style.borderBottomWidth = 3;
     }
     else {
      button.style.borderLeftColor = new Color(0.3f, 0.3f, 0.3f);
      button.style.borderRightColor = new Color(0.3f, 0.3f, 0.3f);
      button.style.borderTopColor = new Color(0.3f, 0.3f, 0.3f);
      button.style.borderBottomColor = new Color(0.3f, 0.3f, 0.3f);
      button.style.borderLeftWidth = 2;
      button.style.borderRightWidth = 2;
      button.style.borderTopWidth = 2;
      button.style.borderBottomWidth = 2;
     }
    }
   }
  }

  void BindGeneSlot(VisualElement slot, object data, int slotIndex, string slotType) {
   var background = slot.Q("background");
   var icon = slot.Q<Image>("icon");
   var tierLabel = slot.Q<Label>("tier-label");

   background.ClearClassList();
   background.AddToClassList("gene-slot__background");

   if (tierLabel != null) {
    tierLabel.style.display = DisplayStyle.None;
   }

   if (data == null) {
    icon.style.display = DisplayStyle.None;
    background.AddToClassList("gene-slot--empty");
    return;
   }

   icon.style.display = DisplayStyle.Flex;
   icon.style.width = Length.Percent(100);
   icon.style.height = Length.Percent(100);
   icon.style.position = Position.Absolute;
   icon.style.top = 0;
   icon.style.left = 0;
   icon.scaleMode = ScaleMode.ScaleToFit;

   if (data is GeneBase gene) {
    icon.sprite = gene.icon;
    background.AddToClassList($"gene-slot--{gene.Category.ToString().ToLower()}");

slot.RegisterCallback<PointerDownEvent>(evt => { if (evt.button == 0) {
      OnGeneSlotPointerDown?.Invoke(gene, slot, slotIndex, slotType);
     }
    });

slot.RegisterCallback<PointerEnterEvent>(evt => { OnGeneSlotHoverEnter?.Invoke(gene);
    });

slot.RegisterCallback<PointerLeaveEvent>(evt => { OnGeneSlotHoverExit?.Invoke();
    });
   }
   else if (data is SeedTemplate seed) {
    icon.sprite = seed.icon;
    background.AddToClassList("gene-slot--seed");
   }
  }

  VisualElement CreateGeneSlotWithLabel(object data, string labelText, int slotIndex, string slotType) {
   var wrapper = new VisualElement();
   wrapper.style.flexDirection = FlexDirection.Column;
   wrapper.style.alignItems = Align.Center;
   wrapper.style.marginLeft = 2;
   wrapper.style.marginRight = 2;
   wrapper.style.marginBottom = 5;
   wrapper.style.width = 68;
   wrapper.style.maxWidth = 68;
   wrapper.style.minWidth = 68;
   wrapper.style.flexShrink = 0;
   wrapper.style.flexGrow = 0;

   wrapper.userData = new SlotMetadata { index = slotIndex, type = slotType };

   var slot = geneSlotTemplate.Instantiate();
   BindGeneSlot(slot, data, slotIndex, slotType);

   if (data is GeneBase gene) {
slot.RegisterCallback<PointerDownEvent>(evt => { if (evt.button == 1) {
      var removedGene = RemoveGeneFromSlot(slotIndex, slotType);
      if (removedGene != null) {
       OnGeneRemovedFromEditor?.Invoke(removedGene, slotIndex, slotType);
      }
      evt.StopPropagation();
     }
    });
   }

   wrapper.Add(slot);

   var label = new Label(labelText);
   label.style.fontSize = 9;
   label.style.color = new StyleColor(new Color(0.7f, 0.7f, 0.7f));
   label.style.unityTextAlign = TextAnchor.MiddleCenter;
   label.style.marginTop = 2;
   label.style.maxWidth = 68;
   label.style.overflow = Overflow.Hidden;
   wrapper.Add(label);

   return wrapper;
  }

  pub VisualElement GetSeedContainer() => seedDropSlotContainer;
  pub VisualElement GetPassiveContainer() => passiveGenesContainer;
  pub VisualElement GetActiveContainer() => activeSequenceContainer;

  pub void HighlightCompatibleSlots(GeneCategory? draggedCategory) {
   if (draggedCategory == null) return;

   foreach (var wrapper in passiveGenesContainer.Children()) {
    var slot = wrapper.Q(className: "gene-slot");
    if (slot != null) {
     if (draggedCategory == GeneCategory.Passive) {
      slot.RemoveFromClassList("gene-slot--incompatible");
     }
     else {
      slot.AddToClassList("gene-slot--incompatible");
     }
    }
   }

   foreach (var row in activeSequenceContainer.Children()) {
    if (row.ClassListContains("active-sequence-header")) continue;

    foreach (var wrapper in row.Children()) {
     var slot = wrapper.Q(className: "gene-slot");
     if (slot != null) {
      var metadata = wrapper.userData as SlotMetadata;
      if (metadata == null) continue;

      bool compatible = metadata.type switch {
       "active" => draggedCategory == GeneCategory.Active,
       "modifier" => draggedCategory == GeneCategory.Modifier,
       "payload" => draggedCategory == GeneCategory.Payload,
       _ => false
      };

      if (compatible) {
       slot.RemoveFromClassList("gene-slot--incompatible");
      }
      else {
       slot.AddToClassList("gene-slot--incompatible");
      }
     }
    }
   }
  }

  pub void ClearSlotHighlighting() {
   foreach (var wrapper in passiveGenesContainer.Children()) {
    var slot = wrapper.Q(className: "gene-slot");
    slot?.RemoveFromClassList("gene-slot--incompatible");
   }

   foreach (var row in activeSequenceContainer.Children()) {
    if (row.ClassListContains("active-sequence-header")) continue;

    foreach (var wrapper in row.Children()) {
     var slot = wrapper.Q(className: "gene-slot");
     slot?.RemoveFromClassList("gene-slot--incompatible");
    }
   }
  }

  class SlotMetadata {
   pub int index;
   pub string type;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\A_ToolkitUI\UISpecSheetController.cs

using UnityEngine.UIElements;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Core;
using Abracodabra.UI.Tooltips;

namespace Abracodabra.UI.Toolkit {
 pub class UISpecSheetController {
  Image seedIcon;
  Label seedNameText, qualityText, descriptionText;
  Label maturityTimeText, energyBalanceText, yieldText, cycleTimeText;
  VisualElement attributeContainer, sequenceContainer, synergiesContainer, warningsContainer;

  const int THUMBNAIL_SIZE = 64;

  pub void Initialize(VisualElement specSheetPanel) {
   seedIcon = specSheetPanel.Q<Image>("seed-icon");
   seedNameText = specSheetPanel.Q<Label>("seed-name-text");
   qualityText = specSheetPanel.Q<Label>("quality-text");
   descriptionText = specSheetPanel.Q<Label>("description-text");
   maturityTimeText = specSheetPanel.Q<Label>("maturity-time-text");
   energyBalanceText = specSheetPanel.Q<Label>("energy-balance-text");
   yieldText = specSheetPanel.Q<Label>("yield-text");
   cycleTimeText = specSheetPanel.Q<Label>("cycle-time-text");
   attributeContainer = specSheetPanel.Q<VisualElement>("attribute-breakdown-container");
   sequenceContainer = specSheetPanel.Q<VisualElement>("sequence-breakdown-container");
   synergiesContainer = specSheetPanel.Q<VisualElement>("synergies-container");
   warningsContainer = specSheetPanel.Q<VisualElement>("warnings-container");

   if (seedIcon != null) {
    seedIcon.style.width = THUMBNAIL_SIZE;
    seedIcon.style.height = THUMBNAIL_SIZE;
    seedIcon.style.minWidth = THUMBNAIL_SIZE;
    seedIcon.style.minHeight = THUMBNAIL_SIZE;
    seedIcon.style.maxWidth = THUMBNAIL_SIZE;
    seedIcon.style.maxHeight = THUMBNAIL_SIZE;
    seedIcon.scaleMode = ScaleMode.ScaleToFit;
   }
  }

  pub void DisplayItem(UIInventoryItem item) {
   if (item == null) {
    Clear();
    return;
   }

   if (item.OriginalData is SeedTemplate seedTemplate) {
    DisplaySeed(item, seedTemplate);
   }
   else if (item.OriginalData is GeneBase gene) {
    DisplayGene(gene);
   }
   else if (item.OriginalData is ToolDefinition tool) {
    DisplayTool(tool);
   }
   else {
    Clear();
   }
  }

  void DisplaySeed(UIInventoryItem item, SeedTemplate seedTemplate) {
   var data = SeedTooltipData.CreateFromSeed(seedTemplate, item.SeedRuntimeState);
   if (data == null) {
    Clear();
    return;
   }

   seedIcon.sprite = item.Icon;
   ApplyIconSizing();

   seedNameText.text = item.GetDisplayName();
   qualityText.text = SeedQualityCalculator.GetQualityDescription(data.qualityTier);
   qualityText.style.color = SeedQualityCalculator.GetQualityColor(data.qualityTier);
   descriptionText.text = seedTemplate.description;

   maturityTimeText.text = $"Maturity: {data.estimatedMaturityTicks:F0} ticks";
   energyBalanceText.text = $"Energy Balance: {data.energySurplusPerCycle:F1} E/cycle";
   yieldText.text = $"Primary Yield: {data.primaryYieldSummary}";

   attributeContainer.Clear();
   CreateAttributeDisplay("Growth", data.growthSpeedMultiplier);
   CreateAttributeDisplay("Storage", data.energyStorageMultiplier);
   CreateAttributeDisplay("Generation", data.energyGenerationMultiplier);
   CreateAttributeDisplay("Yield", data.fruitYieldMultiplier);
   CreateAttributeDisplay("Defense", data.defenseMultiplier);

   cycleTimeText.text = $"Cycle Time: {data.totalCycleTime} ticks";
   sequenceContainer.Clear();
   foreach (var slot in data.sequenceSlots) {
    var label = new Label($"A{slot.position}: {slot.actionName} ({slot.modifiedCost:F0}E)");
    sequenceContainer.Add(label);
   }

   synergiesContainer.Clear();
   warningsContainer.Clear();
   foreach (var synergy in data.synergies) {
    var label = new Label($"✓ {synergy}");
    label.style.color = new StyleColor(new Color(0.5f, 1f, 0.5f));
    synergiesContainer.Add(label);
   }
   foreach (var warning in data.warnings) {
    var label = new Label($"⚠ {warning}");
    label.style.color = new StyleColor(new Color(1f, 0.8f, 0.5f));
    warningsContainer.Add(label);
   }
  }

  pub void DisplayGene(GeneBase gene) {
   seedIcon.sprite = gene.icon;
   ApplyIconSizing();

   seedNameText.text = gene.geneName;
   qualityText.text = $"Tier {gene.tier} {gene.Category}";
   qualityText.style.color = Color.cyan;
   descriptionText.text = gene.description;

   maturityTimeText.text = "";
   energyBalanceText.text = "";
   yieldText.text = "";
   cycleTimeText.text = "";

   attributeContainer.Clear();
   sequenceContainer.Clear();
   synergiesContainer.Clear();
   warningsContainer.Clear();

   var categoryLabel = new Label($"Category: {gene.Category}");
   attributeContainer.Add(categoryLabel);

   var tierLabel = new Label($"Tier: {gene.tier}");
   attributeContainer.Add(tierLabel);
  }

  void DisplayTool(ToolDefinition tool) {
   seedIcon.sprite = tool.icon;
   ApplyIconSizing();

   seedNameText.text = tool.displayName;
   qualityText.text = "Tool";
   qualityText.style.color = Color.white;
   descriptionText.text = tool.GetTooltipDescription();

   maturityTimeText.text = "";
   energyBalanceText.text = "";
   yieldText.text = "";
   cycleTimeText.text = "";

   attributeContainer.Clear();
   sequenceContainer.Clear();
   synergiesContainer.Clear();
   warningsContainer.Clear();

   var typeLabel = new Label($"Tool Type: {tool.toolType}");
   attributeContainer.Add(typeLabel);
  }

  pub void Clear() {
   seedNameText.text = "Select an Item";
   qualityText.text = "Awaiting Selection...";
   qualityText.style.color = Color.gray;
   descriptionText.text = "Select an item from the inventory to see its details.";
   seedIcon.sprite = null;
   maturityTimeText.text = "";
   energyBalanceText.text = "";
   yieldText.text = "";
   cycleTimeText.text = "";
   attributeContainer.Clear();
   sequenceContainer.Clear();
   synergiesContainer.Clear();
   warningsContainer.Clear();
  }

  void ApplyIconSizing() {
   if (seedIcon != null) {
    seedIcon.style.width = THUMBNAIL_SIZE;
    seedIcon.style.height = THUMBNAIL_SIZE;
    seedIcon.style.minWidth = THUMBNAIL_SIZE;
    seedIcon.style.minHeight = THUMBNAIL_SIZE;
    seedIcon.style.maxWidth = THUMBNAIL_SIZE;
    seedIcon.style.maxHeight = THUMBNAIL_SIZE;
    seedIcon.scaleMode = ScaleMode.ScaleToFit;
   }
  }

  void CreateAttributeDisplay(string label, float value) {
   var labelElement = new Label($"{label}: {value:F2}x");
   labelElement.style.fontSize = 13;
   attributeContainer.Add(labelElement);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\EnhancedTooltipTrigger.cs

﻿using UnityEngine;
using UnityEngine.EventSystems;
using Abracodabra.UI.Genes;

namespace Abracodabra.UI.Tooltips {
 pub class EnhancedTooltipTrigger : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler {
  GeneSlotUI slotUI;
  Coroutine showTooltipCoroutine;
  bool isPointerOver = false;

  [SerializeField] float hoverDelay = 0.3f;

  void Awake() {
   slotUI = GetComponent<GeneSlotUI>();
  }

  pub void OnPointerEnter(PointerEventData eventData) {
   isPointerOver = true;
   if (slotUI.CurrentItem != null && slotUI.CurrentItem.IsValid()) {
    showTooltipCoroutine = StartCoroutine(ShowTooltipAfterDelay());
   }
  }

  pub void OnPointerExit(PointerEventData eventData) {
   isPointerOver = false;
   if (showTooltipCoroutine != null) {
    StopCoroutine(showTooltipCoroutine);
   }
   InventoryTooltipPanel.Instance?.HideTooltip();
  }

  System.Collections.IEnumerator ShowTooltipAfterDelay() {
   yield return new WaitForSeconds(hoverDelay);
   if(isPointerOver) // Check if pointer is still over the slot {
    InventoryTooltipPanel.Instance?.ShowTooltipForItem(slotUI.CurrentItem);
   }
  }

  void OnDisable() {
   if (isPointerOver) {
    isPointerOver = false;
    if (showTooltipCoroutine != null) {
     StopCoroutine(showTooltipCoroutine);
    }
    InventoryTooltipPanel.Instance?.HideTooltip();
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\InventoryTooltipPanel.cs

﻿using UnityEngine;
using TMPro;
using Abracodabra.UI.Genes;
using Abracodabra.Genes.Templates;

namespace Abracodabra.UI.Tooltips {
 pub class InventoryTooltipPanel : MonoBehaviour {
  pub stat InventoryTooltipPanel Instance { get; set; }

  [Header("UI References")]
  [SerializeField] GameObject panelRoot;
  [SerializeField] Image itemIcon;
  [SerializeField] TextMeshProUGUI itemNameText;
  [SerializeField] TextMeshProUGUI qualityText;
  [SerializeField] TextMeshProUGUI descriptionText;
  [SerializeField] TextMeshProUGUI keyStat1Text; // Max Energy
  [SerializeField] TextMeshProUGUI keyStat2Text; // Growth Chance
  [SerializeField] TextMeshProUGUI keyStat3Text; // Cycle Cost

  void Awake() {
   if (Instance != null && Instance != this) {
    Destroy(gameObject);
    return;
   }
   Instance = this;
   if(panelRoot != null) panelRoot.SetActive(false);
  }

  pub void ShowTooltipForItem(InventoryBarItem item) {
   if (item == null || !item.IsValid() || panelRoot == null) {
    HideTooltip();
    return;
   }

   switch (item.Type) {
    case InventoryBarItem.ItemType.Seed:
     DisplaySeedTooltip(item);
     break;
    case InventoryBarItem.ItemType.Gene:
    case InventoryBarItem.ItemType.Tool:
    case InventoryBarItem.ItemType.Resource:
     DisplayGenericTooltip(item);
     break;
   }

   panelRoot.SetActive(true);
  }

  pub void HideTooltip() {
   if(panelRoot != null) panelRoot.SetActive(false);
  }

  void DisplaySeedTooltip(InventoryBarItem item) {
   var data = SeedTooltipData.CreateFromSeed(item.SeedTemplate, item.SeedRuntimeState);
   if (data == null) {
    HideTooltip();
    return;
   }

   itemIcon.sprite = item.GetIcon();
   itemNameText.text = data.seedName;
   descriptionText.text = $"<i>{item.SeedTemplate.description}</i>";

   qualityText.text = SeedQualityCalculator.GetQualityDescription(data.qualityTier);
   qualityText.color = SeedQualityCalculator.GetQualityColor(data.qualityTier);

   keyStat1Text.text = $"<sprite=energy> {item.SeedTemplate.maxEnergy * data.energyStorageMultiplier:F0} E";
   keyStat2Text.text = $"<sprite=growth> {item.SeedTemplate.baseGrowthChance * data.growthSpeedMultiplier:P0}/tick";
   keyStat3Text.text = $"<sprite=cycle> {data.totalModifiedEnergyCost:F0} E/cycle";
  }

  void DisplayGenericTooltip(InventoryBarItem item) {
   itemIcon.sprite = item.GetIcon();
   itemNameText.text = item.GetDisplayName();

   qualityText.text = item.Type.ToString();
   qualityText.color = Color.grey;

   string desc = "";
   switch (item.Type) {
    case InventoryBarItem.ItemType.Gene:
     desc = item.GeneInstance?.GetGene()?.description ?? "";
     break;
    case InventoryBarItem.ItemType.Tool:
     desc = item.ToolDefinition?.GetTooltipDetails() ?? "";
     break;
    case InventoryBarItem.ItemType.Resource:
     desc = item.ItemInstance?.definition?.description ?? "";
     break;
   }
   descriptionText.text = $"<i>{desc}</i>";

   keyStat1Text.text = "";
   keyStat2Text.text = "";
   keyStat3Text.text = "";
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\SeedEditorTooltipPanel.cs

﻿using System.Collections.Generic;
using TMPro;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.UI.Tooltips {
 pub class SeedEditorTooltipPanel : MonoBehaviour {
  pub stat SeedEditorTooltipPanel Instance { get; set; }

  [Header("Main Panel")]
  [SerializeField] GameObject panelRoot;

  [Header("Header")]
  [SerializeField] Image seedIcon;
  [SerializeField] TextMeshProUGUI seedNameText;
  [SerializeField] TextMeshProUGUI qualityText;
  [SerializeField] TextMeshProUGUI descriptionText;

  [Header("Performance Overview")]
  [SerializeField] TextMeshProUGUI maturityTimeText;
  [SerializeField] TextMeshProUGUI energyBalanceText;
  [SerializeField] TextMeshProUGUI yieldText;

  [Header("Attribute Breakdown")]
  [SerializeField] StatBarUI growthSpeedBar;
  [SerializeField] StatBarUI energyStorageBar;
  [SerializeField] StatBarUI energyGenerationBar;
  [SerializeField] StatBarUI fruitYieldBar;
  [SerializeField] StatBarUI defenseBar;

  [Header("Sequence Analysis")]
  [SerializeField] TextMeshProUGUI cycleTimeText;
  [SerializeField] Transform sequenceBreakdownContainer;
  [SerializeField] GameObject sequenceBreakdownEntryPrefab;

  [Header("Synergies & Warnings")]
  [SerializeField] Transform synergiesContainer;
  [SerializeField] Transform warningsContainer;
  [SerializeField] GameObject synergyWarningEntryPrefab;

  List<GameObject> pooledSequenceEntries = new List<GameObject>();
  List<GameObject> pooledSynergyEntries = new List<GameObject>();
  List<GameObject> pooledWarningEntries = new List<GameObject>();

  pub class StatBarUI {
   pub TextMeshProUGUI labelText;
   pub Slider slider;
   pub TextMeshProUGUI valueText;
   pub Image fillImage;
   pub Gradient colorGradient;

   pub void UpdateBar(string label, float value, float baseline, float maxValue = 2f, bool higherIsBetter = true, string format = "P0") {
    if (labelText != null) labelText.text = label;
    if (slider != null) slider.value = Mathf.Clamp01((value - 0.5f) / (maxValue - 0.5f)); // Normalize from 0.5 to max
    if (fillImage != null && colorGradient != null) fillImage.color = colorGradient.Evaluate(slider.value);

    if (valueText != null) {
     string formattedValue = (format == "P0") ? $"{value:P0}" : $"{value:F0}";
     string baseFormatted = (format == "P0") ? $"{baseline:P0}" : $"{baseline:F0}";
     valueText.text = $"{TooltipFormatting.ColorizeValue(value, baseline, formattedValue, higherIsBetter)} <size=70%>(Base: {baseFormatted})</size>";
    }
   }
  }

  void Awake() {
   if (Instance != null && Instance != this) {
    Destroy(gameObject);
    return;
   }
   Instance = this;
   if(panelRoot != null) panelRoot.SetActive(false);
  }

  pub void LoadSeedForAnalysis(PlantGeneRuntimeState runtimeState) {
   if (runtimeState == null || runtimeState.template == null) {
    if(panelRoot != null) panelRoot.SetActive(false);
    return;
   }

   var data = SeedTooltipData.CreateFromSeed(runtimeState.template, runtimeState);
   if (data == null) {
    if(panelRoot != null) panelRoot.SetActive(false);
    return;
   }

   DisplayAnalysis(data, runtimeState.template);
   if(panelRoot != null) panelRoot.SetActive(true);
  }

  void DisplayAnalysis(SeedTooltipData data, SeedTemplate template) {
   seedIcon.sprite = template.icon;
   seedNameText.text = data.seedName;
   qualityText.text = SeedQualityCalculator.GetQualityDescription(data.qualityTier);
   qualityText.color = SeedQualityCalculator.GetQualityColor(data.qualityTier);
   descriptionText.text = $"<i>{template.description}</i>";

   maturityTimeText.text = TooltipFormatting.ColorizeValue(data.estimatedMaturityTicks, 40, $"{data.estimatedMaturityTicks:F0} ticks", false);
   energyBalanceText.text = TooltipFormatting.ColorizeValue(data.energySurplusPerCycle, 0, $"{data.energySurplusPerCycle:F1} E/cycle");
   yieldText.text = data.primaryYieldSummary;

   growthSpeedBar.UpdateBar("Growth", data.growthSpeedMultiplier, 1f, 2.5f, true, "P0");
   energyStorageBar.UpdateBar("Storage", data.energyStorageMultiplier, 1f, 2.5f, true, "P0");
   energyGenerationBar.UpdateBar("Generation", data.energyGenerationMultiplier, 1f, 2.5f, true, "P0");
   fruitYieldBar.UpdateBar("Yield", data.fruitYieldMultiplier, 1f, 2.5f, true, "P0");
   defenseBar.UpdateBar("Defense", data.defenseMultiplier, 1f, 2.5f, true, "P0");

   cycleTimeText.text = $"<b>{data.totalCycleTime} ticks</b> (Cycle Time)";
   UpdateList(sequenceBreakdownContainer, pooledSequenceEntries, data.sequenceSlots.Count, (go, i) => {
    var entryText = go.GetComponent<TextMeshProUGUI>();
    var slotData = data.sequenceSlots[i];
    entryText.text = $"{slotData.actionName}: {slotData.baseCost:F0}E → {TooltipFormatting.ColorizeValue(slotData.modifiedCost, slotData.baseCost, $"{slotData.modifiedCost:F0}E", false)}";
   }, sequenceBreakdownEntryPrefab);

   UpdateList(synergiesContainer, pooledSynergyEntries, data.synergies.Count, (go, i) => {
    go.GetComponent<TextMeshProUGUI>().text = $"<color=#88FF88>✓</color> {data.synergies[i]}";
   }, synergyWarningEntryPrefab);

   UpdateList(warningsContainer, pooledWarningEntries, data.warnings.Count, (go, i) => {
    go.GetComponent<TextMeshProUGUI>().text = $"<color=#FF8888>⚠</color> {data.warnings[i]}";
   }, synergyWarningEntryPrefab);
  }

  void UpdateList(Transform container, List<GameObject> pool, int count, System.Action<GameObject, int> updateAction, GameObject prefab) {
   while (pool.Count < count) {
    var newEntry = Instantiate(prefab, container);
    pool.Add(newEntry);
   }

   for (int i = 0; i < count; i++) {
    pool[i].SetActive(true);
    updateAction(pool[i], i);
   }

   for (int i = count; i < pool.Count; i++) {
    pool[i].SetActive(false);
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\SeedTooltipData.cs

﻿using System;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Core;

namespace Abracodabra.UI.Tooltips {
 pub class SeedTooltipData {

  pub string seedName;
  pub PlantType plantType;
  pub int generation;
  pub SeedRarity rarity;

  pub float growthSpeedMultiplier = 1f;
  pub float energyStorageMultiplier = 1f;
  pub float energyGenerationMultiplier = 1f;
  pub float fruitYieldMultiplier = 1f;
  pub float defenseMultiplier = 1f;

  pub List<PassiveGeneInfo> passiveGenes = new List<PassiveGeneInfo>();
  pub List<SequenceSlotInfo> sequenceSlots = new List<SequenceSlotInfo>();
  pub float totalBaseEnergyCost;
  pub float totalModifiedEnergyCost;
  pub int totalCycleTime;

  pub List<string> synergies = new List<string>();
  pub List<string> warnings = new List<string>();

  pub float estimatedMaturityTicks;
  pub float energySurplusPerCycle;
  pub string primaryYieldSummary;
  pub SeedQualityCalculator.QualityTier qualityTier;

  pub class PassiveGeneInfo {
   pub string geneName;
   pub PassiveStatType statType;
   pub string effectText;
  }

  pub class SequenceSlotInfo {
   pub int position;
   pub string actionName;
   pub float baseCost;
   pub float modifiedCost;
   pub List<string> modifiers = new List<string>();
   pub List<string> payloads = new List<string>();
  }

  pub stat SeedTooltipData CreateFromSeed(SeedTemplate template, PlantGeneRuntimeState runtimeState) {
   if (template == null || runtimeState == null) return null;

   var data = new SeedTooltipData();

   data.seedName = template.templateName;
   data.plantType = template.plantType;
   data.generation = template.generation;
   data.rarity = template.rarity;

   data.ProcessPassives(runtimeState);
   data.ProcessSequence(runtimeState, template);
   data.CalculateHighLevelMetrics(template);
   data.DetectSynergiesAndWarnings();

   data.qualityTier = SeedQualityCalculator.CalculateQuality(data);

   return data;
  }

  void ProcessPassives(PlantGeneRuntimeState state) {
   var statBonuses = new Dictionary<PassiveStatType, float>();
   var multiplicativeBonuses = new Dictionary<PassiveStatType, float>();

   foreach (var instance in state.passiveInstances) {
    var gene = instance?.GetGene<PassiveGene>();
    if (gene == null) continue;

    var info = new PassiveGeneInfo {
     geneName = gene.geneName,
     statType = gene.statToModify,
     effectText = gene.GetStatModificationText()
    };
    passiveGenes.Add(info);

    float value = gene.baseValue * instance.GetValue("power_multiplier", 1f);

    if (gene.stacksAdditively) {
     if (!statBonuses.ContainsKey(gene.statToModify)) statBonuses[gene.statToModify] = 0f;
     statBonuses[gene.statToModify] += (value - 1f);
    }
    else {
     if (!multiplicativeBonuses.ContainsKey(gene.statToModify)) multiplicativeBonuses[gene.statToModify] = 1f;
     multiplicativeBonuses[gene.statToModify] *= value;
    }
   }

   growthSpeedMultiplier = (1f + statBonuses.GetValueOrDefault(PassiveStatType.GrowthSpeed)) * multiplicativeBonuses.GetValueOrDefault(PassiveStatType.GrowthSpeed, 1f);
   energyGenerationMultiplier = (1f + statBonuses.GetValueOrDefault(PassiveStatType.EnergyGeneration)) * multiplicativeBonuses.GetValueOrDefault(PassiveStatType.EnergyGeneration, 1f);
   energyStorageMultiplier = (1f + statBonuses.GetValueOrDefault(PassiveStatType.EnergyStorage)) * multiplicativeBonuses.GetValueOrDefault(PassiveStatType.EnergyStorage, 1f);
   fruitYieldMultiplier = (1f + statBonuses.GetValueOrDefault(PassiveStatType.FruitYield)) * multiplicativeBonuses.GetValueOrDefault(PassiveStatType.FruitYield, 1f);
   defenseMultiplier = (1f + statBonuses.GetValueOrDefault(PassiveStatType.Defense)) * multiplicativeBonuses.GetValueOrDefault(PassiveStatType.Defense, 1f);
  }

  void ProcessSequence(PlantGeneRuntimeState state, SeedTemplate template) {
   totalBaseEnergyCost = 0;
   totalModifiedEnergyCost = 0;
   int activeSlots = 0;

   for (int i = 0; i < state.activeSequence.Count; i++) {
    var slot = state.activeSequence[i];
    if (!slot.HasContent) continue;

    activeSlots++;
    var activeGene = slot.activeInstance.GetGene<ActiveGene>();

    var info = new SequenceSlotInfo {
     position = i + 1,
     actionName = activeGene?.geneName ?? "Unknown",
     baseCost = activeGene?.baseEnergyCost ?? 0,
     modifiedCost = slot.GetEnergyCost(),
     modifiers = slot.modifierInstances.Select(m => m?.GetGene()?.geneName ?? "?").ToList(),
     payloads = slot.payloadInstances.Select(p => p?.GetGene()?.geneName ?? "?").ToList()
    };
    sequenceSlots.Add(info);

    totalBaseEnergyCost += info.baseCost;
    totalModifiedEnergyCost += info.modifiedCost;
   }

   totalCycleTime = template.baseRechargeTime + activeSlots;
  }

  void CalculateHighLevelMetrics(SeedTemplate template) {
   float avgHeight = (template.minHeight + template.maxHeight) / 2f;
   float effectiveGrowthRate = template.baseGrowthChance * growthSpeedMultiplier;
   estimatedMaturityTicks = effectiveGrowthRate > 0 ? (avgHeight / effectiveGrowthRate) : float.PositiveInfinity;

   float energyGeneratedPerCycle = template.energyRegenRate * energyGenerationMultiplier * totalCycleTime;
   energySurplusPerCycle = energyGeneratedPerCycle - totalModifiedEnergyCost;

   var yieldCounts = new Dictionary<string, int>();
   foreach(var slot in sequenceSlots) {
    var fruitGene = passiveGenes.FirstOrDefault(g => g.geneName == slot.actionName); // Simplistic lookup
    if(slot.actionName.ToLower().Contains("fruit")) {
     string itemName = "Fruit"; // Placeholder
     if (!yieldCounts.ContainsKey(itemName)) yieldCounts[itemName] = 0;
     yieldCounts[itemName]++;
    }
   }
   primaryYieldSummary = yieldCounts.Any()
    ? string.Join(", ", yieldCounts.Select(kvp => $"{kvp.Key} (x{kvp.Value})"))
    : "No yield";
  }

  void DetectSynergiesAndWarnings() {
   if (growthSpeedMultiplier > 1.25f && energyGenerationMultiplier > 1.25f) {
    synergies.Add("Rapid Growth Engine: High growth speed is fueled by increased energy generation.");
   }
   if (energySurplusPerCycle < 0) {
    warnings.Add("Energy Deficit: This plant consumes more energy per cycle than it generates.");
   }
   if (defenseMultiplier < 0.8f) {
    warnings.Add("Vulnerable: Low defense makes this plant an easy target for herbivores.");
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\TooltipEnums.cs

﻿namespace Abracodabra.UI.Tooltips {
 pub enum SeedRarity {
  Common,
  Uncommon,
  Rare,
  Epic,
  Legendary
 }

 pub enum PlantType {
  Flower,
  Bush,
  Tree,
  Vine,
  Mushroom,
  Cactus
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\TooltipSystemManager.cs

﻿using UnityEngine;

namespace Abracodabra.UI.Tooltips {
 pub class TooltipSystemManager : MonoBehaviour {
  [Header("Tooltip Panel Prefabs")]
  [SerializeField] GameObject inventoryTooltipPanelPrefab;
  [SerializeField] GameObject seedEditorTooltipPanelPrefab;

  [Header("Parent Canvases")]
  [SerializeField] Transform mainUICanvas;

  void Awake() {
   if (InventoryTooltipPanel.Instance == null && inventoryTooltipPanelPrefab != null) {
    Instantiate(inventoryTooltipPanelPrefab, mainUICanvas);
   }

   if (SeedEditorTooltipPanel.Instance == null && seedEditorTooltipPanelPrefab != null) {
    Instantiate(seedEditorTooltipPanelPrefab, mainUICanvas);
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\UI\_UGUI_Legacy\TooltipUtilities.cs

﻿using UnityEngine;
using Abracodabra.Genes.Core;

namespace Abracodabra.UI.Tooltips {
 pub stat class PassiveStatTypeExtensions {
  pub stat string GetDisplayName(this PassiveStatType stat) {
   switch (stat) {
    case PassiveStatType.None: return "Special"; // Kept new change
    case PassiveStatType.GrowthSpeed: return "Growth Speed";
    case PassiveStatType.EnergyGeneration: return "Energy Generation";
    case PassiveStatType.EnergyStorage: return "Energy Storage";
    case PassiveStatType.FruitYield: return "Fruit Yield";
    case PassiveStatType.Defense: return "Defense";
    default: return stat.ToString();
   }
  }
 }

 pub stat class TooltipFormatting {
  pub stat string FormatPercentage(float value, bool showSign = true) {
   float percentage = (value - 1f) * 100f;
   string sign = percentage >= 0 && showSign ? "+" : "";
   return $"{sign}{percentage:F0}%";
  }

  pub stat string ColorizeValue(float value, float baseline, string text, bool higherIsBetter = true) {
   Color goodColor = new Color(0.5f, 1f, 0.5f); // Light Green
   Color badColor = new Color(1f, 0.5f, 0.5f);  // Light Red

   bool isGood = higherIsBetter ? (value > baseline) : (value < baseline);

   if (Mathf.Approximately(value, baseline))
    return text;

   Color finalColor = isGood ? goodColor : badColor;
   return $"<color=#{ColorUtility.ToHtmlStringRGB(finalColor)}>{text}</color>";
  }

  pub stat string GetColorForValue(float value) {
   if (value > 1f) return "#90EE90"; // Light green for buffs
   if (value < 1f) return "#FF6B6B"; // Light red for debuffs
   return "#FFFFFF"; // White for neutral
  }

  pub stat string FormatStatChange(PassiveStatType stat, float value) {
   if (stat == PassiveStatType.None) return ""; // No stat change to display

   string color = GetColorForValue(value);
   string statName = stat.GetDisplayName();
   string change = FormatPercentage(value);
   return $"<color={color}>{change} {statName}</color>";
  }
 }

 pub stat class SeedQualityCalculator {
  pub enum QualityTier { Trash, Poor, Common, Good, Excellent, Legendary }

  pub stat QualityTier CalculateQuality(SeedTooltipData data) {
   if (data == null) return QualityTier.Common;

   float score = 0f;

   float efficiencyScore = Mathf.Clamp01((data.energySurplusPerCycle + 10) / 50f); // Normalize around a surplus of 40 being max
   score += efficiencyScore * 30f;

   float maturityScore = 1f - Mathf.Clamp01(data.estimatedMaturityTicks / 100f); // 100 ticks is slow
   score += maturityScore * 25f;

   score += Mathf.Clamp01((data.fruitYieldMultiplier - 1f) / 1.5f) * 25f; // 150% bonus is max

   score += Mathf.Clamp01(data.defenseMultiplier) * 20f;

   if (data.warnings != null) {
    score -= data.warnings.Count * 10f;
   }

   if (score >= 90) return QualityTier.Legendary;
   if (score >= 70) return QualityTier.Excellent;
   if (score >= 50) return QualityTier.Good;
   if (score >= 30) return QualityTier.Common;
   if (score >= 15) return QualityTier.Poor;
   return QualityTier.Trash;
  }

  pub stat string GetQualityDescription(QualityTier tier) {
   switch (tier) {
    case QualityTier.Legendary: return "★★★★★ Legendary";
    case QualityTier.Excellent: return "★★★★☆ Excellent";
    case QualityTier.Good: return "★★★☆☆ Good";
    case QualityTier.Common: return "★★☆☆☆ Common";
    case QualityTier.Poor: return "★☆☆☆☆ Poor";
    case QualityTier.Trash: return "☆☆☆☆☆ Trash";
    default: return "Unknown";
   }
  }

  pub stat Color GetQualityColor(QualityTier tier) {
   switch (tier) {
    case QualityTier.Legendary: return new Color(1f, 0.6f, 0.1f);
    case QualityTier.Excellent: return new Color(0.2f, 0.6f, 1f);
    case QualityTier.Good: return new Color(0.2f, 0.8f, 0.2f);
    case QualityTier.Common: return Color.white;
    case QualityTier.Poor: return new Color(0.6f, 0.6f, 0.6f);
    case QualityTier.Trash: return new Color(0.4f, 0.2f, 0.2f);
    default: return Color.grey;
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\CameraController.cs

﻿using UnityEngine;
using UnityEngine.U2D;
using WegoSystem;

namespace WegoSystem {
 pub class CameraController : MonoBehaviour {
  [Header("Core References")]
  [SerializeField] MapConfiguration mapConfig;
  [SerializeField] pub Transform followTarget;
  [SerializeField] Camera cam;

  [Header("Follow Settings")]
  [Tooltip("If enabled, the camera will smoothly follow the target. Disabled by default.")]
  [SerializeField] bool enableFollow = false;
  [SerializeField] float smoothSpeed = 5f;
  [SerializeField] Vector2 offset = Vector2.zero;

  [Header("Boundaries")]
  [SerializeField] bool constrainToMap = true;
  [SerializeField] float boundaryPadding = 2f; // Tiles from edge

  PixelPerfectCamera pixelPerfectCam;
  Vector2 minBounds, maxBounds;

  void Awake() {
   if (cam == null) cam = GetComponent<Camera>();
   pixelPerfectCam = GetComponent<PixelPerfectCamera>();

   if (mapConfig == null) {
    Debug.LogError("[CameraController] MapConfiguration is not assigned! Camera cannot calculate bounds.", this);
    enabled = false;
   }
  }

  void Start() {
   CalculateCameraBounds();

   if (followTarget == null) {
    var player = FindFirstObjectByType<GardenerController>();
    if (player != null) {
     followTarget = player.transform;
     Debug.Log("[CameraController] Follow target not set, automatically assigned to GardenerController.", this);
    }
   }
  }

  void LateUpdate() {
   if (!enableFollow || followTarget == null || mapConfig == null) return;

   Vector3 desiredPosition = followTarget.position + (Vector3)offset;
   desiredPosition.z = transform.position.z; // Keep Z unchanged

   if (constrainToMap) {
    desiredPosition.x = Mathf.Clamp(desiredPosition.x, minBounds.x, maxBounds.x);
    desiredPosition.y = Mathf.Clamp(desiredPosition.y, minBounds.y, maxBounds.y);
   }

   Vector3 smoothedPosition = Vector3.Lerp(
    transform.position,
    desiredPosition,
    smoothSpeed * Time.deltaTime
   );

   if (pixelPerfectCam != null && pixelPerfectCam.enabled) {
    float pixelSize = 1f / pixelPerfectCam.assetsPPU;
    smoothedPosition.x = Mathf.Round(smoothedPosition.x / pixelSize) * pixelSize;
    smoothedPosition.y = Mathf.Round(smoothedPosition.y / pixelSize) * pixelSize;
   }

   transform.position = smoothedPosition;
  }

  void CalculateCameraBounds() {
   if (mapConfig == null) return;

   float height = cam.orthographicSize * 2;
   float width = height * cam.aspect;

   minBounds.x = (width / 2f) + boundaryPadding;
   maxBounds.x = mapConfig.mapSize.x - (width / 2f) - boundaryPadding;
   minBounds.y = (height / 2f) + boundaryPadding;
   maxBounds.y = mapConfig.mapSize.y - (height / 2f) - boundaryPadding;

   if (maxBounds.x < minBounds.x) {
    float center = mapConfig.mapSize.x / 2f;
    minBounds.x = maxBounds.x = center;
   }
   if (maxBounds.y < minBounds.y) {
    float center = mapConfig.mapSize.y / 2f;
    minBounds.y = maxBounds.y = center;
   }
  }

  pub void SnapToTarget() {
   if (followTarget == null) return;
   Vector3 targetPos = followTarget.position + (Vector3)offset;
   targetPos.z = transform.position.z;
   transform.position = targetPos;
  }

  pub void OnResolutionChanged() {
   CalculateCameraBounds();
   var zoomController = GetComponent<CameraZoomController>();
   if (zoomController != null) {
    zoomController.StoreBaseSize();
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\CameraZoomController.cs

﻿using UnityEngine;
using WegoSystem;

namespace WegoSystem {
 pub class CameraZoomController : MonoBehaviour {
  [SerializeField] Camera targetCamera;
  [SerializeField] float zoomSpeed = 0.5f;
  [SerializeField] float minZoom = 0.5f;  // 2x closer
  [SerializeField] float maxZoom = 3.0f;  // 3x further
  [SerializeField] bool enableZoom = true;

  float baseOrthographicSize;
  float currentZoomLevel = 1f;

  void Start() {
   if (targetCamera == null) targetCamera = Camera.main;
   StoreBaseSize();
  }

  void Update() {
   if (!enableZoom) return;

   float scroll = Input.GetAxis("Mouse ScrollWheel");
   if (Mathf.Abs(scroll) > 0.01f) {
    ZoomCamera(-scroll * zoomSpeed);
   }
  }

  void ZoomCamera(float zoomDelta) {
   currentZoomLevel = Mathf.Clamp(currentZoomLevel + zoomDelta, minZoom, maxZoom);
   targetCamera.orthographicSize = baseOrthographicSize * currentZoomLevel;
  }

  pub void StoreBaseSize() {
   if (targetCamera != null) {
    baseOrthographicSize = targetCamera.orthographicSize;
   }
  }

  pub void ResetZoom() {
   currentZoomLevel = 1f;
   targetCamera.orthographicSize = baseOrthographicSize;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\InitializationManager.cs

﻿using UnityEngine;
using WegoSystem;

namespace WegoSystem {
 pub class InitializationManager : SingletonMonoBehaviour<InitializationManager> {
  [SerializeField] GameEvent onCoreSystemsInitialized;
  [SerializeField] GameEvent onGameManagersInitialized;
  [SerializeField] GameEvent onGameplaySystemsInitialized;

  IEnumerator Start() {
   Debug.Log("[InitializationManager] Starting initialization sequence...");

   Debug.Log("[InitializationManager] Phase 1: Initializing Core Systems...");
   onCoreSystemsInitialized.Raise();
   yield return null;

   Debug.Log("[InitializationManager] Phase 2: Initializing Game Managers...");
   onGameManagersInitialized.Raise();
   yield return null;

   if (EnvironmentalStatusEffectSystem.Instance != null) {
    Debug.Log("[InitializationManager] Initializing EnvironmentalStatusEffectSystem...");
    EnvironmentalStatusEffectSystem.Instance.Initialize();
   }
   else {
    Debug.LogWarning("[InitializationManager] EnvironmentalStatusEffectSystem instance not found. Tile-based status effects will not function.");
   }

   Debug.Log("[InitializationManager] Phase 3: Initializing Gameplay Systems & UI...");
   onGameplaySystemsInitialized.Raise();
   yield return null;

   Debug.Log("[InitializationManager] All systems initialized successfully.");
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\PixelGridSnapper.cs

﻿using UnityEngine;
using WegoSystem;

namespace WegoSystem {
 pub stat class PixelGridSnapper {
  stat float cachedPixelSize;
  stat bool pixelSizeIsCached = false;

  pub stat Vector3 SnapToGrid(Vector3 position) {
   if (ResolutionManager.HasInstance) {
    if (!pixelSizeIsCached) // Cache it once for performance {
     cachedPixelSize = 1f / ResolutionManager.Instance.CurrentPPU;
     pixelSizeIsCached = true;
    }

    position.x = Mathf.Round(position.x / cachedPixelSize) * cachedPixelSize;
    position.y = Mathf.Round(position.y / cachedPixelSize) * cachedPixelSize;
    return position;
   }

   return position;
  }

  pub stat Vector2 SnapToGrid(Vector2 position) {
   Vector3 snapped = SnapToGrid((Vector3)position);
   return new Vector2(snapped.x, snapped.y);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\RunManager.cs

﻿using UnityEngine;
using WegoSystem;
using UnityEngine.SceneManagement; // Required for restarting the scene

namespace WegoSystem {
 pub enum RunState {
  Planning,
  GrowthAndThreat,
  GameOver // NEW: State for when the game has ended
 }

 pub enum GamePhase {
  Planning,
  Execution
 }

 pub class RunManager : SingletonMonoBehaviour<RunManager> {
  [Header("Game State")]
  [SerializeField] RunState currentState = RunState.Planning;
  [SerializeField] GamePhase currentPhase = GamePhase.Planning;
  [SerializeField] int currentRoundNumber = 1;
  [SerializeField] int currentPhaseTicks = 0;

  [Header("Player Stats Configuration")]
  [Tooltip("The maximum hunger the player starts with.")]
  pub float playerMaxHunger = 100f;
  [Tooltip("If checked, the game will end when the player's hunger reaches zero.")]
  pub bool playerDeathEnabled = true; // NEW FIELD

  pub RunState CurrentState => currentState;
  pub GamePhase CurrentPhase => currentPhase;
  pub int CurrentRoundNumber => currentRoundNumber;
  pub int CurrentPhaseTicks => currentPhaseTicks;

  pub event Action<RunState> OnRunStateChanged;
  pub event Action<GamePhase, GamePhase> OnPhaseChanged;
  pub event Action<int> OnRoundChanged;

  prot ovr void OnAwake() {
   SetState(RunState.Planning, true);
  }

  pub void Initialize() {
   if (TickManager.Instance != null) {
    TickManager.Instance.RegisterTickUpdateable(new PhaseTickHandler(this));
   }
   else {
    Debug.LogError("[RunManager] Initialization failed: TickManager not found!");
   }

   PlayerHungerSystem playerHunger = FindFirstObjectByType<PlayerHungerSystem>();
   if (playerHunger != null) {
    playerHunger.OnStarvation += HandlePlayerStarvation;
   }
   else {
    Debug.LogError("[RunManager] Could not find PlayerHungerSystem to subscribe to OnStarvation event!");
   }
  }

  void OnDestroy() {
   PlayerHungerSystem playerHunger = FindFirstObjectByType<PlayerHungerSystem>();
   if (playerHunger != null) {
    playerHunger.OnStarvation -= HandlePlayerStarvation;
   }
  }

  void HandlePlayerStarvation() {
   if (!playerDeathEnabled) {
    Debug.Log("[RunManager] Player has starved, but player death is disabled. No action taken.");
    return;
   }

   Debug.Log("[RunManager] Player has starved! Triggering Game Over.");
   SetState(RunState.GameOver);
  }

  void SetState(RunState newState, bool force = false) {
   if (currentState == newState && !force) return;

   currentState = newState;
   Debug.Log($"[RunManager] State changed to: {currentState}");

   switch (currentState) {
    case RunState.Planning:
     WeatherManager.Instance?.PauseCycleAtDay();
     SetPhase(GamePhase.Planning);
     break;

    case RunState.GrowthAndThreat:
     WeatherManager.Instance?.ResumeCycle();
     WaveManager.Instance?.StartWaveForRound(currentRoundNumber);
     SetPhase(GamePhase.Execution);
     break;

    case RunState.GameOver:
     break;
   }

   OnRunStateChanged?.Invoke(currentState);
  }

  void SetPhase(GamePhase newPhase) {
   if (currentPhase == newPhase) return;

   GamePhase oldPhase = currentPhase;
   currentPhase = newPhase;
   currentPhaseTicks = 0;

   Debug.Log($"[RunManager] Phase changed: {oldPhase} -> {newPhase}");
   OnPhaseChanged?.Invoke(oldPhase, newPhase);
  }

  pub void StartGrowthAndThreatPhase() {
   if (currentState == RunState.Planning) {
    Debug.Log($"[RunManager] Starting Growth & Threat for Round {currentRoundNumber}");
    SetState(RunState.GrowthAndThreat);
   }
  }

  pub void EndPlanningPhase() {
   if (currentState == RunState.Planning && currentPhase == GamePhase.Planning) {
    SetPhase(GamePhase.Execution);
    StartGrowthAndThreatPhase();
   }
  }

  pub void StartNewPlanningPhase() {
   if (currentState != RunState.Planning) {
    if (WaveManager.Instance != null && WaveManager.Instance.IsCurrentWaveDefeated()) {
     StartNewRound();
    }
    else {
     SetState(RunState.Planning);
    }
   }
  }

  void StartNewRound() {
   currentRoundNumber++;
   Debug.Log($"[RunManager] Starting new round: {currentRoundNumber}");

   WaveManager.Instance?.ResetForNewRound();
   SetState(RunState.Planning);

   OnRoundChanged?.Invoke(currentRoundNumber);
  }

  pub void RestartGame() {
   SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
  }

  class PhaseTickHandler : ITickUpdateable {
   RunManager manager;
   pub PhaseTickHandler(RunManager manager) { this.manager = manager; }
   pub void OnTickUpdate(int currentTick) { manager.currentPhaseTicks++; }
  }

  pub void ForcePhase(GamePhase phase) {
   if (Application.isEditor || Debug.isDebugBuild) {
    SetPhase(phase);
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Core\SingletonMonoBehaviour.cs

﻿using UnityEngine;

namespace WegoSystem {
 pub abs class SingletonMonoBehaviour<T> : MonoBehaviour where T : MonoBehaviour {
  stat T _instance;
  stat ro object _lock = new object();
  stat bool _applicationIsQuitting = false;

  pub stat T Instance {
   get {
    if (_applicationIsQuitting) {
     return null;
    }

    lock (_lock) {
     if (_instance == null) {
      _instance = FindFirstObjectByType<T>();

      if (_instance == null) {
       Debug.LogError($"[Singleton] CRITICAL: An instance of '{typeof(T).Name}' is needed in the scene, but none was found. " +
          "Ensure a GameObject with this component exists and is active in your scene.");
      }
     }
     return _instance;
    }
   }
  }

  pub stat bool HasInstance => _instance != null;

  #if UNITY_EDITOR
  stat void ResetStaticData() {
   _applicationIsQuitting = false;
  }
  #endif

  prot virt void Awake() {
   if (_instance == null) {
    _instance = this as T;

    transform.SetParent(null);
    DontDestroyOnLoad(gameObject);
   }
   else if (_instance != this) {
    Debug.LogWarning($"[Singleton] Another instance of '{typeof(T).Name}' already exists. Destroying duplicate on '{gameObject.name}'.", gameObject);
    Destroy(gameObject);
    return;
   }

   OnAwake();
  }

  prot virt void OnAwake() { }

  prot virt void OnApplicationQuit() {
   _applicationIsQuitting = true;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ecosystem\Status Effects\EnvironmentalStatusEffectSystem.cs

﻿using System.Collections.Generic;
using WegoSystem;

namespace WegoSystem {
 pub class EnvironmentalStatusEffectSystem : MonoBehaviour, ITickUpdateable {
  pub stat EnvironmentalStatusEffectSystem Instance { get; set; }

  pub class TileStatusRule {
   pub TileDefinition tile;
   pub List<StatusEffect> statusEffectsToApply;
  }

  pub class ToolStatusRule {
   pub ToolDefinition tool;
   pub List<StatusEffect> statusEffectsToApply;
  }

  pub List<TileStatusRule> tileRules = new List<TileStatusRule>();
  pub List<ToolStatusRule> toolRules = new List<ToolStatusRule>();

  ro Dictionary<TileDefinition, List<StatusEffect>> tileRuleLookup = new Dictionary<TileDefinition, List<StatusEffect>>();
  ro Dictionary<ToolDefinition, List<StatusEffect>> toolRuleLookup = new Dictionary<ToolDefinition, List<StatusEffect>>();
  ro List<IStatusEffectable> allEffectableEntities = new List<IStatusEffectable>();

  void Awake() {
   if (Instance != null && Instance != this) {
    Destroy(gameObject);
    return;
   }
   Instance = this;
   BuildLookups();
  }

  pub void Initialize() {
   if (TickManager.Instance != null) {
    TickManager.Instance.RegisterTickUpdateable(this);
   }
   if (PlayerActionManager.Instance != null) {
    PlayerActionManager.Instance.OnActionExecuted += HandlePlayerAction;
   }
  }

  void OnDestroy() {
   if (Instance == this) Instance = null;

   var tickManager = TickManager.Instance;
   if (tickManager != null) {
    tickManager.UnregisterTickUpdateable(this);
   }

   if (PlayerActionManager.Instance != null) {
    PlayerActionManager.Instance.OnActionExecuted -= HandlePlayerAction;
   }
  }

  void BuildLookups() {
   tileRuleLookup.Clear();
   foreach (var rule in tileRules) {
    if (rule.tile != null && rule.statusEffectsToApply != null && rule.statusEffectsToApply.Count > 0) {
     tileRuleLookup[rule.tile] = rule.statusEffectsToApply;
    }
   }

   toolRuleLookup.Clear();
   foreach (var rule in toolRules) {
    if (rule.tool != null && rule.statusEffectsToApply != null && rule.statusEffectsToApply.Count > 0) {
     toolRuleLookup[rule.tool] = rule.statusEffectsToApply;
    }
   }
  }

  pub void OnTickUpdate(int currentTick) {
   RefreshAllEntityTileEffects();
  }

  void HandlePlayerAction(PlayerActionType actionType, object actionData) {
   if (actionType != PlayerActionType.UseTool) return;

   var toolData = actionData as PlayerActionManager.ToolActionData;
   if (toolData == null) return;

   if (toolRuleLookup.TryGetValue(toolData.Tool, out List<StatusEffect> effectsToApply)) {
    if (GridPositionManager.Instance == null) return;
    GridPosition gridPos = new GridPosition(toolData.GridPosition);
    HashSet<GridEntity> entitiesOnTile = GridPositionManager.Instance.GetEntitiesAt(gridPos);

    foreach(var entity in entitiesOnTile) {
     IStatusEffectable effectable = entity.GetComponent<IStatusEffectable>();
     if (effectable != null) {
      foreach(var effect in effectsToApply) {
       effectable.StatusManager.ApplyStatusEffect(effect);
      }
     }
    }
   }
  }

  void RefreshAllEntityTileEffects() {
   var animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
   var players = FindObjectsByType<GardenerController>(FindObjectsSortMode.None);

   allEffectableEntities.Clear();
   foreach (var animal in animals) allEffectableEntities.Add(animal);
   foreach (var player in players) allEffectableEntities.Add(player);

   foreach(var entity in allEffectableEntities) {
    CheckAndApplyTileEffects(entity);
   }
  }

  pub void CheckAndApplyTileEffects(IStatusEffectable entity) {
   if (entity == null || entity.GridEntity == null || TileInteractionManager.Instance == null) return;

   Component entityComponent = entity as Component;
   if (entityComponent == null || !entityComponent.gameObject.activeInHierarchy) return;

   GridPosition currentPos = entity.GridEntity.Position;

   TileDefinition currentTile = TileInteractionManager.Instance.FindWhichTileDefinitionAt(currentPos.ToVector3Int());

   if (currentTile == null) return;

   if (tileRuleLookup.TryGetValue(currentTile, out List<StatusEffect> effectsToApply)) {
    foreach (var effect in effectsToApply) {
     if (effect != null) {
      entity.StatusManager.ApplyStatusEffect(effect);
     }
    }
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\ProceduralGeneration\MapConfiguration.cs

﻿using UnityEngine;
using WegoSystem;

namespace WegoSystem {
 pub class MapConfiguration : ScriptableObject {
  [Header("Map Dimensions")]
  pub Vector2Int mapSize = new Vector2Int(100, 100);
  pub Vector2Int gridOffset = Vector2Int.zero;

  [Header("Visual Settings")]
  pub int gizmoDisplayRadius = 20;
  pub bool autoScaleGizmos = true;

  [Header("Camera Settings")] // Renamed header for clarity
  pub Vector2Int referenceResolution = new Vector2Int(320, 180);
  pub int pixelsPerUnit = 6;

  pub GridPosition GetMapCenter() => new GridPosition(mapSize.x / 2, mapSize.y / 2);

  pub int GetAdaptiveGizmoSize() {
   if (!autoScaleGizmos) return gizmoDisplayRadius;
   return Mathf.Min(gizmoDisplayRadius, Mathf.Max(mapSize.x, mapSize.y) / 5);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\ProceduralGeneration\ResolutionManager.cs

﻿using UnityEngine;
using URPPixelPerfectCamera = UnityEngine.Rendering.Universal.PixelPerfectCamera;
using WegoSystem;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
 pub class ResolutionManager : SingletonMonoBehaviour<ResolutionManager> {
  pub class ResolutionProfile {
   pub string name;
   pub Vector2Int resolution;
   pub int pixelsPerUnit = 6;
   pub float cameraZoomMultiplier = 1f;
  }

  [Header("Core References")]
  [Tooltip("Drag your Main Camera GameObject here. This is the most reliable way to link the camera.")]
  [SerializeField] Camera mainCamera;
  [SerializeField] MapConfiguration mapConfig;

  [Header("Profiles")]
  [SerializeField] ResolutionProfile[] profiles = {
   new ResolutionProfile {
    name = "Pixel Perfect 320x180",
    resolution = new Vector2Int(320, 180),
    pixelsPerUnit = 16,
    cameraZoomMultiplier = 1f
   },
   new ResolutionProfile {
    name = "HD 640x360",
    resolution = new Vector2Int(640, 360),
    pixelsPerUnit = 16,
    cameraZoomMultiplier = 1f
   },
   new ResolutionProfile {
    name = "Full HD 1280x720",
    resolution = new Vector2Int(1280, 720),
    pixelsPerUnit = 16,
    cameraZoomMultiplier = 1f
   },
   new ResolutionProfile {
    name = "4K 2560x1440",
    resolution = new Vector2Int(2560, 1440),
    pixelsPerUnit = 16,
    cameraZoomMultiplier = 1f
   }
  };

  [Tooltip("The profile that will be applied on game start and by the editor button.")]
  [SerializeField] int currentProfileIndex = 0;

  pub int CurrentPPU { get; set; } = 6;

  URPPixelPerfectCamera pixelPerfectCam;

  prot ovr void OnAwake() {
   base.OnAwake();
   if (mainCamera == null) {
    mainCamera = Camera.main;
   }
   if (mainCamera != null) {
    pixelPerfectCam = mainCamera.GetComponent<URPPixelPerfectCamera>();
   }
  }

  void Start() {
   ApplyProfile(currentProfileIndex);
  }

  pub void ApplyProfileInEditor() {
   Camera camToApply = mainCamera;
   if (camToApply == null) {
    camToApply = Camera.main;
   }

   if (camToApply == null) {
    Debug.LogError("[ResolutionManager] Could not find Main Camera. Ensure it's tagged or assigned in the Inspector.");
    return;
   }

   var ppCamComponent = camToApply.GetComponent("UnityEngine.Rendering.Universal.PixelPerfectCamera");

   if (ppCamComponent == null) {
    Debug.LogError($"[ResolutionManager] Failed to find URP PixelPerfectCamera component on '{camToApply.name}'. Please ensure the component exists.", camToApply.gameObject);
    return;
   }

   URPPixelPerfectCamera ppCam = ppCamComponent as URPPixelPerfectCamera;

   ApplyProfileLogic(currentProfileIndex, camToApply, ppCam);
  }

  pub void ApplyProfile(int index) {
   if (mainCamera == null || pixelPerfectCam == null) {
    Debug.LogError("[ResolutionManager] The 'Main Camera' reference is not set in the Inspector or was not found at startup! Disabling ResolutionManager.", this);
    this.enabled = false;
    return;
   }

   ApplyProfileLogic(index, mainCamera, pixelPerfectCam);
  }

  void ApplyProfileLogic(int index, Camera targetCam, URPPixelPerfectCamera targetPPCam) {
   if (mapConfig == null) {
    Debug.LogError("[ResolutionManager] MapConfiguration is not assigned! Cannot apply profile.", this);
    return;
   }

   if (index < 0 || index >= profiles.Length) {
    Debug.LogWarning($"[ResolutionManager] Invalid profile index {index}. Aborting.", this);
    return;
   }

   var profile = profiles[index];
   currentProfileIndex = index;

   CurrentPPU = profile.pixelsPerUnit;
   targetPPCam.assetsPPU = profile.pixelsPerUnit;
   targetPPCam.refResolutionX = profile.resolution.x;
   targetPPCam.refResolutionY = profile.resolution.y;

   float baseOrthoSize = (float)profile.resolution.y / (2f * profile.pixelsPerUnit);
   targetCam.orthographicSize = baseOrthoSize * profile.cameraZoomMultiplier;

   #if UNITY_EDITOR
   if (!Application.isPlaying) {
    EditorUtility.SetDirty(targetCam);
    EditorUtility.SetDirty(targetPPCam);
   }
   #endif

   var cameraController = targetCam.GetComponent<CameraController>();
   if (cameraController != null) {
    cameraController.OnResolutionChanged();
   }

   Debug.Log($"[ResolutionManager] Applied profile: '{profile.name}' (PPU: {CurrentPPU}, Res: {profile.resolution}, Zoom: {targetCam.orthographicSize})");
  }

  pub void CycleResolution() {
   int nextIndex = (currentProfileIndex + 1) % profiles.Length;
   ApplyProfile(nextIndex);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\ProceduralGeneration\SceneSetupManager.cs

﻿using UnityEngine;
using WegoSystem;

namespace WegoSystem {
 pub class SceneSetupManager : MonoBehaviour {
  [SerializeField] bool setupOnStart = true;

  void Start() {
   if (setupOnStart) {
    SetupScene();
   }
  }

  pub void SetupScene() {
   Debug.Log("--- Starting Scene Setup ---");

   GridPositionManager gridManager = GridPositionManager.Instance;

   if (gridManager == null) {
    gridManager = FindFirstObjectByType<GridPositionManager>();
    if (gridManager != null) {
     Debug.LogWarning("[SceneSetupManager] GridPositionManager.Instance was null (expected in Edit Mode). Found manager manually.", this);
    }
   }

   if (gridManager == null) {
    Debug.LogError("[SceneSetupManager] GridPositionManager could not be found in the scene. Aborting setup.", this);
    return;
   }

   GardenerController player = FindFirstObjectByType<GardenerController>();
   if (player != null) {
    gridManager.SnapEntityToGrid(player.gameObject);

    GridPosition centerPosition = gridManager.GetMapCenter();
    player.GetComponent<GridEntity>().SetPosition(centerPosition, true);

    Debug.Log($"Player '{player.name}' snapped, registered, and moved to map center: {centerPosition}", player);

    SetupMainCamera(player.transform);
   }
   else {
    Debug.LogWarning("[SceneSetupManager] No GardenerController found in the scene to position.", this);
   }

   Debug.Log("--- Scene Setup Complete ---");
  }

  void SetupMainCamera(Transform target) {
   Camera mainCamera = Camera.main;
   if (mainCamera != null) {
    CameraController cameraController = mainCamera.GetComponent<CameraController>();
    if (cameraController == null) {
     Debug.LogWarning($"[SceneSetupManager] Main Camera does not have a CameraController. Adding one now.", mainCamera);
     cameraController = mainCamera.gameObject.AddComponent<CameraController>();
    }

    cameraController.followTarget = target;
    cameraController.SnapToTarget(); // Immediate snap on scene setup

    Debug.Log($"Main Camera's CameraController set to follow '{target.name}' and snapped to position.", mainCamera);
   }
   else {
    Debug.LogWarning("[SceneSetupManager] Could not find Main Camera to configure. Ensure it has the 'MainCamera' tag.", this);
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ticks\GridEntity.cs

﻿using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
 pub class GridEntity : MonoBehaviour {
  pub bool isTileOccupant = true;

  GridPosition gridPosition;

  [SerializeField] Vector3 groundPointOffset = Vector3.zero;
  [SerializeField] Vector3 visualOffset = Vector3.zero;
  [SerializeField] float visualInterpolationSpeed = 5f;
  [SerializeField] AnimationCurve movementCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

  GridPosition previousGridPosition;
  Vector3 visualStartPosition;
  Vector3 visualTargetPosition;
  float movementProgress = 1f;
  bool isMoving = false;
  float speedMultiplier = 1f;

  bool isPositionLocked = false;

  pub GridPosition Position {
   get => gridPosition;
   set {
    if (gridPosition != value) {
     previousGridPosition = gridPosition;
     gridPosition = value;
     // Note: We no longer call OnGridPositionChanged here. It's called from SetPosition.
    }
   }
  }

  pub GridPosition PreviousPosition => previousGridPosition;
  pub bool IsMoving => isMoving;
  pub float MovementProgress => movementProgress;
  pub Vector3 GroundWorldPosition => transform.position + groundPointOffset;

  pub event Action<GridPosition, GridPosition> OnPositionChanged;
  pub event Action<GridPosition> OnMovementComplete;
  pub event Action OnMovementStart;

  prot virt void Start() {
   if (gridPosition == GridPosition.Zero && movementProgress >= 1f) {
    SnapToGrid();
   }
  }

  prot virt void OnDestroy() {
   var gridManager = GridPositionManager.Instance;
   if (gridManager != null) {
    gridManager.UnregisterEntity(this);
   }
  }

  prot virt void Update() {
   if (isPositionLocked || movementProgress >= 1f) {
    return;
   }

   movementProgress += Time.deltaTime * visualInterpolationSpeed * speedMultiplier;
   movementProgress = Mathf.Clamp01(movementProgress);

   float curvedProgress = movementCurve.Evaluate(movementProgress);
   transform.position = Vector3.Lerp(visualStartPosition, visualTargetPosition, curvedProgress);

   if (movementProgress >= 1f) {
    transform.position = visualTargetPosition;
    isMoving = false;
    OnMovementComplete?.Invoke(gridPosition);
   }
  }

#if UNITY_EDITOR
  void OnDrawGizmosSelected() {
   Vector3 groundWorldPosition = transform.position + groundPointOffset;
   Gizmos.color = Color.green;
   Gizmos.DrawLine(transform.position, groundWorldPosition);
   Gizmos.DrawWireSphere(groundWorldPosition, 0.1f);
   UnityEditor.Handles.Label(groundWorldPosition + Vector3.up * 0.2f, "Ground Point");

   if (Application.isPlaying && GridPositionManager.Instance != null) {
    Gizmos.color = Color.yellow;
    Vector3 gridCenter = GridPositionManager.Instance.GetCellCenter(gridPosition);
    Gizmos.DrawSphere(gridCenter, 0.08f);
   }
  }
#endif

  pub void SetPosition(GridPosition newPosition, bool instant = false) {
   if (GridPositionManager.Instance != null && !GridPositionManager.Instance.IsPositionValid(newPosition)) {
    Debug.LogWarning($"[GridEntity] Blocked attempt to move '{gameObject.name}' to invalid position {newPosition}. Movement cancelled.");
    return;
   }

   if (instant) {
    isPositionLocked = true;
    Position = newPosition;
    visualStartPosition = transform.position;
    visualTargetPosition = transform.position;
    movementProgress = 1f;
    isMoving = false;
    OnPositionChanged?.Invoke(previousGridPosition, newPosition);
   }
   else {
    isPositionLocked = false;
    if (!isMoving) {
     visualStartPosition = transform.position;
    }

    Position = newPosition; // This will update gridPosition and previousGridPosition

    if (GridPositionManager.Instance != null) {
     Vector3 groundTargetPosition = GridPositionManager.Instance.GridToWorld(gridPosition);
     visualTargetPosition = groundTargetPosition - groundPointOffset + visualOffset;
    }

    movementProgress = 0f;
    if (!isMoving) {
     isMoving = true;
     OnMovementStart?.Invoke();
    }
    OnPositionChanged?.Invoke(previousGridPosition, newPosition);
   }
  }

  pub void SetSpeedMultiplier(float multiplier) {
   this.speedMultiplier = multiplier;
  }

  pub void SnapToGrid() {
   if (GridPositionManager.Instance == null) return;

   Vector3 groundWorldPos = transform.position + groundPointOffset;
   GridPosition currentGridPos = GridPositionManager.Instance.WorldToGrid(groundWorldPos);

   isPositionLocked = false;
   SetPosition(currentGridPos, true); // This will now use the instant path but we must move the transform.
   transform.position = GridPositionManager.Instance.GridToWorld(currentGridPos) - groundPointOffset + visualOffset;
   visualStartPosition = transform.position;
   visualTargetPosition = transform.position;
  }

  pub void MoveInDirection(GridPosition direction) {
   SetPosition(gridPosition + direction);
  }

  pub bool CanMoveTo(GridPosition targetPosition) {
   return GridPositionManager.Instance?.IsPositionValid(targetPosition) ?? false;
  }

  pub void CompleteMovement() {
   if (isMoving) {
    transform.position = visualTargetPosition;
    movementProgress = 1f;
    isMoving = false;
    isPositionLocked = false;
    OnMovementComplete?.Invoke(gridPosition);
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ticks\GridPosition.cs

﻿// Assets/Scripts/Ticks/GridPosition.cs

namespace WegoSystem {
 pub struct GridPosition : IEquatable<GridPosition> {
  pub int x;
  pub int y;

  pub GridPosition(int x, int y) {
   this.x = x;
   this.y = y;
  }

  pub GridPosition(Vector3Int vector3Int) {
   this.x = vector3Int.x;
   this.y = vector3Int.y;
  }

  pub GridPosition(Vector2Int vector2Int) {
   this.x = vector2Int.x;
   this.y = vector2Int.y;
  }

  pub stat GridPosition operator +(GridPosition a, GridPosition b) {
   return new GridPosition(a.x + b.x, a.y + b.y);
  }

  pub stat GridPosition operator -(GridPosition a, GridPosition b) {
   return new GridPosition(a.x - b.x, a.y - b.y);
  }

  pub stat bool operator ==(GridPosition a, GridPosition b) {
   return a.x == b.x && a.y == b.y;
  }

  pub stat bool operator !=(GridPosition a, GridPosition b) {
   return !(a == b);
  }

  pub Vector3Int ToVector3Int() => new Vector3Int(x, y, 0);
  pub Vector2Int ToVector2Int() => new Vector2Int(x, y);
  pub Vector3 ToWorldPosition(float cellSize = 1f) => new Vector3(x * cellSize, y * cellSize, 0);

  pub stat ro GridPosition Up = new GridPosition(0, 1);
  pub stat ro GridPosition Down = new GridPosition(0, -1);
  pub stat ro GridPosition Left = new GridPosition(-1, 0);
  pub stat ro GridPosition Right = new GridPosition(1, 0);
  pub stat ro GridPosition UpLeft = new GridPosition(-1, 1);
  pub stat ro GridPosition UpRight = new GridPosition(1, 1);
  pub stat ro GridPosition DownLeft = new GridPosition(-1, -1);
  pub stat ro GridPosition DownRight = new GridPosition(1, -1);
  pub stat ro GridPosition Zero = new GridPosition(0, 0);

  pub int ManhattanDistance(GridPosition other) {
   return Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y);
  }

  pub int ChebyshevDistance(GridPosition other) {
   return Mathf.Max(Mathf.Abs(x - other.x), Mathf.Abs(y - other.y));
  }

  pub float EuclideanDistance(GridPosition other) {
   int dx = x - other.x;
   int dy = y - other.y;
   return Mathf.Sqrt(dx * dx + dy * dy);
  }

  pub GridPosition[] GetNeighbors(bool includeDiagonals = false) {
   if (includeDiagonals) {
    return new GridPosition[] {
     this + Up, this + Down, this + Left, this + Right,
     this + UpLeft, this + UpRight, this + DownLeft, this + DownRight
    };
   }
   else {
    return new GridPosition[] {
     this + Up, this + Down, this + Left, this + Right
    };
   }
  }

  pub bool Equals(GridPosition other) {
   return x == other.x && y == other.y;
  }

  pub ovr bool Equals(object obj) {
   return obj is GridPosition other && Equals(other);
  }

  pub ovr int GetHashCode() {
   return HashCode.Combine(x, y);
  }

  pub ovr string ToString() {
   return $"({x}, {y})";
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ticks\GridPositionManager.cs

﻿using System;
using UnityEngine.Tilemaps;
using WegoSystem;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
 pub class GridPositionManager : SingletonMonoBehaviour<GridPositionManager> {
  [Tooltip("The central configuration for map size and properties. This is the single source of truth.")]
  [SerializeField] MapConfiguration mapConfig;

  [SerializeField] TileInteractionManager tileInteractionManager;

  Grid _tilemapGrid;
  Grid TilemapGrid => _tilemapGrid;

  [Header("Gizmos & Debugging")]
  [SerializeField] bool showGridGizmos = true;
  [SerializeField] Color gridColor = new Color(0.5f, 0.5f, 0.5f, 0.3f);
  [SerializeField] bool debugMode = false;

  ro Dictionary<GridPosition, HashSet<GridEntity>> entitiesByPosition = new Dictionary<GridPosition, HashSet<GridEntity>>();
  ro HashSet<GridEntity> allEntities = new HashSet<GridEntity>();

  prot ovr void OnAwake() {
   EnsureInitialized();
  }

  void EnsureInitialized() {
   if (_tilemapGrid != null) return;

   if (mapConfig == null) {
    Debug.LogError("[GridPositionManager] CRITICAL: MapConfiguration is not assigned! Grid system will not function correctly.", this);
   }

   if(debugMode) Debug.Log("[GridPositionManager] Grid reference is null. Initializing now.");
   SyncWithTileGrid();
  }

  pub void Initialize() // This can still be called by other managers if needed. {
   EnsureInitialized();
  }

  pub void SyncWithTileGrid() {
   if (tileInteractionManager != null && tileInteractionManager.interactionGrid != null) {
    this._tilemapGrid = tileInteractionManager.interactionGrid;
    if (debugMode) Debug.Log($"[GridPositionManager] Synced with assigned TileInteractionManager's grid: '{this._tilemapGrid.name}'.");
    return;
   }

   if (TileInteractionManager.Instance != null && TileInteractionManager.Instance.interactionGrid != null) {
    this._tilemapGrid = TileInteractionManager.Instance.interactionGrid;
    tileInteractionManager = TileInteractionManager.Instance;
    if (debugMode) Debug.Log($"[GridPositionManager] Synced with singleton TileInteractionManager.Instance's grid: '{this._tilemapGrid.name}'.");
    return;
   }

   if (_tilemapGrid == null) {
    Debug.LogError("[GridPositionManager] Could not find TileInteractionManager or its grid to sync with! Grid system may be misaligned. Please assign the TileInteractionManager in the Inspector.");
   }
  }

  pub GridPosition WorldToGrid(Vector3 worldPosition) {
   EnsureInitialized(); // Make sure _tilemapGrid is set before using it.
   if (TilemapGrid == null) return GridPosition.Zero;
   Vector3Int cellPos = TilemapGrid.WorldToCell(worldPosition);
   return new GridPosition(cellPos);
  }

  pub Vector3 GridToWorld(GridPosition gridPosition) {
   EnsureInitialized(); // Make sure _tilemapGrid is set before using it.
   if (TilemapGrid == null) return Vector3.zero;
   return TilemapGrid.GetCellCenterWorld(gridPosition.ToVector3Int());
  }

  pub Vector3 GetCellCenter(GridPosition gridPosition) {
   return GridToWorld(gridPosition);
  }

  pub bool IsPositionValid(GridPosition position) {
   if (mapConfig == null) {
    Debug.LogError("[GridPositionManager] MapConfiguration not assigned!");
    return false;
   }
   return position.x >= 0 && position.x < mapConfig.mapSize.x &&
    position.y >= 0 && position.y < mapConfig.mapSize.y;
  }

  pub GridPosition GetMapCenter() {
   if (mapConfig == null) {
    Debug.LogError("[GridPositionManager] MapConfiguration not assigned! Returning fallback center.");
    return new GridPosition(50, 50); // Fallback
   }
   return mapConfig.GetMapCenter();
  }

  pub Vector3 GetMapCenterWorld() {
   return GridToWorld(GetMapCenter());
  }

  pub bool IsPositionOccupied(GridPosition position) {
   if (entitiesByPosition.TryGetValue(position, out var entities)) {
    return entities.Any(entity => entity.isTileOccupant);
   }
   return false;
  }

  pub void RegisterEntity(GridEntity entity) {
   if (entity == null || allEntities.Contains(entity)) return;

   allEntities.Add(entity);
   AddEntityToPosition(entity, entity.Position);

   entity.OnPositionChanged += OnEntityPositionChanged;
  }

  pub void UnregisterEntity(GridEntity entity) {
   if (entity == null || !allEntities.Contains(entity)) return;

   allEntities.Remove(entity);
   RemoveEntityFromPosition(entity, entity.Position);

   entity.OnPositionChanged -= OnEntityPositionChanged;
  }

  void OnEntityPositionChanged(GridPosition oldPosition, GridPosition newPosition) {
   var entity = allEntities.FirstOrDefault(e => e.Position == newPosition && e.PreviousPosition == oldPosition);
   if (entity != null) {
    RemoveEntityFromPosition(entity, oldPosition);
    AddEntityToPosition(entity, newPosition);
   }
  }

  void AddEntityToPosition(GridEntity entity, GridPosition position) {
   if (!entitiesByPosition.ContainsKey(position)) {
    entitiesByPosition[position] = new HashSet<GridEntity>();
   }
   entitiesByPosition[position].Add(entity);
  }

  void RemoveEntityFromPosition(GridEntity entity, GridPosition position) {
   if (entitiesByPosition.ContainsKey(position)) {
    entitiesByPosition[position].Remove(entity);
    if (entitiesByPosition[position].Count == 0) {
     entitiesByPosition.Remove(position);
    }
   }
  }

  pub HashSet<GridEntity> GetEntitiesAt(GridPosition position) {
   return entitiesByPosition.ContainsKey(position)
    ? new HashSet<GridEntity>(entitiesByPosition[position])
    : new HashSet<GridEntity>();
  }

  pub List<GridEntity> GetEntitiesInRadius(GridPosition center, int radius, bool useCircle = true) {
   var result = new List<GridEntity>();

   if (useCircle) {
    var tilesInRadius = GridRadiusUtility.GetTilesInCircle(center, radius);
    foreach (var pos in tilesInRadius) {
     if (entitiesByPosition.ContainsKey(pos)) {
      result.AddRange(entitiesByPosition[pos]);
     }
    }
   }
   else {
    for (int x = -radius; x <= radius; x++) {
     for (int y = -radius; y <= radius; y++) {
      var checkPos = new GridPosition(center.x + x, center.y + y);
      if (checkPos.ManhattanDistance(center) <= radius && entitiesByPosition.ContainsKey(checkPos)) {
       result.AddRange(entitiesByPosition[checkPos]);
      }
     }
    }
   }

   return result;
  }

  pub bool IsPositionWithinRadius(GridPosition position, GridPosition center, int radius, bool useCircle = true) {
   if (useCircle) {
    return GridRadiusUtility.IsWithinCircleRadius(position, center, radius);
   }
   else {
    return position.ManhattanDistance(center) <= radius;
   }
  }

  pub GridEntity GetNearestEntity(GridPosition position, System.Func<GridEntity, bool> predicate = null) {
   GridEntity nearest = null;
   float nearestDistance = float.MaxValue;

   foreach (var entity in allEntities) {
    if (predicate != null && !predicate(entity)) continue;

    float distance = entity.Position.EuclideanDistance(position);
    if (distance < nearestDistance) {
     nearest = entity;
     nearestDistance = distance;
    }
   }
   return nearest;
  }

  pub Grid GetTilemapGrid() {
   EnsureInitialized();
   return TilemapGrid;
  }

  pub List<GridPosition> GetPath(GridPosition start, GridPosition end, bool allowDiagonal = false) {
   var path = new List<GridPosition>();

   if (!IsPositionValid(start) || !IsPositionValid(end)) {
    return path;
   }

   var openSet = new HashSet<GridPosition>();
   var closedSet = new HashSet<GridPosition>();
   var cameFrom = new Dictionary<GridPosition, GridPosition>();
   var gScore = new Dictionary<GridPosition, float>();
   var fScore = new Dictionary<GridPosition, float>();

   openSet.Add(start);
   gScore[start] = 0;
   fScore[start] = HeuristicCost(start, end);

   while (openSet.Count > 0) {
    GridPosition current = GetLowestFScore(openSet, fScore);

    if (current == end) {
     while (cameFrom.ContainsKey(current)) {
      path.Add(current);
      current = cameFrom[current];
     }
     path.Reverse();
     return path;
    }

    openSet.Remove(current);
    closedSet.Add(current);

    foreach (var neighbor in current.GetNeighbors(allowDiagonal)) {
     if (!IsPositionValid(neighbor) || closedSet.Contains(neighbor) || (neighbor != end && IsPositionOccupied(neighbor))) {
      continue;
     }

     float tentativeGScore = gScore[current] + 1; // Assuming cost of 1 per tile

     if (!openSet.Contains(neighbor)) {
      openSet.Add(neighbor);
     }
     else if (gScore.ContainsKey(neighbor) && tentativeGScore >= gScore[neighbor]) {
      continue; // This path is not better
     }

     cameFrom[neighbor] = current;
     gScore[neighbor] = tentativeGScore;
     fScore[neighbor] = gScore[neighbor] + HeuristicCost(neighbor, end);
    }
   }
   return path; // No path found
  }

  float HeuristicCost(GridPosition a, GridPosition b) {
   return a.ManhattanDistance(b);
  }

  GridPosition GetLowestFScore(HashSet<GridPosition> openSet, Dictionary<GridPosition, float> fScore) {
   GridPosition lowest = openSet.First();
   float lowestScore = fScore.ContainsKey(lowest) ? fScore[lowest] : float.MaxValue;

   foreach (var pos in openSet) {
    float score = fScore.ContainsKey(pos) ? fScore[pos] : float.MaxValue;
    if (score < lowestScore) {
     lowest = pos;
     lowestScore = score;
    }
   }
   return lowest;
  }

  pub bool PathExists(GridPosition start, GridPosition end, bool allowDiagonal = false) {
   var path = GetPath(start, end, allowDiagonal);
   return path.Count > 0;
  }

  pub void SnapEntityToGrid(GameObject entity) {
   if (entity == null) return;

   GridEntity gridEntity = entity.GetComponent<GridEntity>();
   if (gridEntity == null) {
    gridEntity = entity.AddComponent<GridEntity>();
   }

   gridEntity.SnapToGrid();

   RegisterEntity(gridEntity);

   if (debugMode) {
    Debug.Log($"[GridPositionManager] Snapped and Registered {entity.name} to grid {gridEntity.Position}");
   }
  }

  pub void SnapAllEntitiesToGrid<T>() where T : Component {
   T[] entities = FindObjectsByType<T>(FindObjectsSortMode.None);
   foreach (var entity in entities) {
    SnapEntityToGrid(entity.gameObject);
   }
   Debug.Log($"[GridPositionManager] Snapped {entities.Length} entities of type {typeof(T).Name} to grid");
  }

  pub stat List<GridPosition> GetTilesInRadius(GridPosition center, int radius, bool useManhattan = true) {
   var result = new List<GridPosition>();

   for (int x = -radius; x <= radius; x++) {
    for (int y = -radius; y <= radius; y++) {
     var checkPos = new GridPosition(center.x + x, center.y + y);

     if (Instance != null && !Instance.IsPositionValid(checkPos)) continue;

     int distance = useManhattan
      ? Mathf.Abs(x) + Mathf.Abs(y)
      : Mathf.Max(Mathf.Abs(x), Mathf.Abs(y));

     if (distance <= radius) {
      result.Add(checkPos);
     }
    }
   }

   return result;
  }

  void OnDrawGizmos() {
   if (!showGridGizmos || mapConfig == null) return;

   EnsureInitialized();
   if(_tilemapGrid == null) return;

   Gizmos.color = gridColor;

   int displaySize = mapConfig.GetAdaptiveGizmoSize();
   int displayWidth = Mathf.Min(displaySize, mapConfig.mapSize.x);
   int displayHeight = Mathf.Min(displaySize, mapConfig.mapSize.y);

   for (int x = 0; x <= displayWidth; x++) {
    Vector3 start = GridToWorld(new GridPosition(x, 0));
    Vector3 end = GridToWorld(new GridPosition(x, displayHeight));
    Gizmos.DrawLine(start, end);
   }

   for (int y = 0; y <= displayHeight; y++) {
    Vector3 start = GridToWorld(new GridPosition(0, y));
    Vector3 end = GridToWorld(new GridPosition(displayWidth, y));
    Gizmos.DrawLine(start, end);
   }

   Gizmos.color = Color.green;
   Vector3 origin = GridToWorld(GridPosition.Zero);
   Gizmos.DrawWireSphere(origin, _tilemapGrid.cellSize.x * 0.2f);

   Gizmos.color = Color.red;
   if (entitiesByPosition != null) {
    foreach (var kvp in entitiesByPosition) {
     if (kvp.Value.Count > 0) {
      Vector3 cellCenter = GridToWorld(kvp.Key);
      Gizmos.DrawWireCube(cellCenter, Vector3.one * _tilemapGrid.cellSize.x * 0.8f);
     }
    }
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ticks\GridRadiusUtility.cs

﻿using UnityEngine;
using WegoSystem;

namespace WegoSystem {
 pub stat class GridRadiusUtility {
  pub stat List<GridPosition> GetTilesInCircle(GridPosition center, int radius, bool filled = true) {
   var result = new List<GridPosition>();

   if (radius <= 0) {
    result.Add(center);
    return result;
   }

   for (int dx = -radius; dx <= radius; dx++) {
    for (int dy = -radius; dy <= radius; dy++) {
     float distance = Mathf.Sqrt(dx * dx + dy * dy);

     if (filled) {
      if (distance <= radius + 0.5f) {
       result.Add(new GridPosition(center.x + dx, center.y + dy));
      }
     } else {
      if (distance >= radius - 0.5f && distance <= radius + 0.5f) {
       result.Add(new GridPosition(center.x + dx, center.y + dy));
      }
     }
    }
   }

   return result;
  }

  pub stat List<GridPosition> GetPerfectCircleTiles(GridPosition center, int radius) {
   var result = new HashSet<GridPosition>();

   if (radius == 0) {
    result.Add(center);
    return new List<GridPosition>(result);
   }

   int x = 0;
   int y = radius;
   int d = 3 - 2 * radius;

   while (x <= y) {
    AddCirclePoints(result, center, x, y);

    if (d < 0) {
     d = d + 4 * x + 6;
    } else {
     d = d + 4 * (x - y) + 10;
     y--;
    }
    x++;
   }

   var filledResult = new List<GridPosition>();
   int minX = center.x - radius;
   int maxX = center.x + radius;

   for (int scanY = center.y - radius; scanY <= center.y + radius; scanY++) {
    bool inside = false;
    int startX = minX;

    for (int scanX = minX; scanX <= maxX; scanX++) {
     var pos = new GridPosition(scanX, scanY);
     if (result.Contains(pos)) {
      if (!inside) {
       inside = true;
       startX = scanX;
      }
     } else if (inside) {
      for (int fillX = startX; fillX < scanX; fillX++) {
       filledResult.Add(new GridPosition(fillX, scanY));
      }
      inside = false;
     }
    }

    if (inside) {
     for (int fillX = startX; fillX <= maxX; fillX++) {
      var pos = new GridPosition(fillX, scanY);
      if (result.Contains(pos) || fillX == maxX) {
       for (int fill = startX; fill <= fillX; fill++) {
        filledResult.Add(new GridPosition(fill, scanY));
       }
       break;
      }
     }
    }
   }

   return filledResult;
  }

  stat void AddCirclePoints(HashSet<GridPosition> result, GridPosition center, int x, int y) {
   result.Add(new GridPosition(center.x + x, center.y + y));
   result.Add(new GridPosition(center.x - x, center.y + y));
   result.Add(new GridPosition(center.x + x, center.y - y));
   result.Add(new GridPosition(center.x - x, center.y - y));
   result.Add(new GridPosition(center.x + y, center.y + x));
   result.Add(new GridPosition(center.x - y, center.y + x));
   result.Add(new GridPosition(center.x + y, center.y - x));
   result.Add(new GridPosition(center.x - y, center.y - x));
  }

  pub stat bool IsWithinCircleRadius(GridPosition position, GridPosition center, int radius) {
   int dx = position.x - center.x;
   int dy = position.y - center.y;
   float distance = Mathf.Sqrt(dx * dx + dy * dy);
   return distance <= radius + 0.5f;
  }

  pub stat List<GridPosition> GetCircleOutline(GridPosition center, int radius) {
   return GetTilesInCircle(center, radius, false);
  }

  pub stat void DebugPrintRadius(GridPosition center, int radius) {
   var tiles = GetTilesInCircle(center, radius);
   var tileSet = new HashSet<GridPosition>(tiles);

   Debug.Log($"Circle pattern for radius {radius}:");

   for (int y = radius; y >= -radius; y--) {
    string line = "";
    for (int x = -radius; x <= radius; x++) {
     var pos = new GridPosition(center.x + x, center.y + y);
     if (pos.Equals(center)) {
      line += "◉ "; // Center
     } else if (tileSet.Contains(pos)) {
      line += "● "; // Included tile
     } else {
      line += "· "; // Not included
     }
    }
    Debug.Log(line);
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ticks\TickConfiguration.cs

﻿using UnityEngine;

namespace WegoSystem {
 pub class TickConfiguration : ScriptableObject {
  [SerializeField] pub float ticksPerRealSecond = 2f;

  [Header("Day/Night Cycle")]
  pub int ticksPerDay = 100;
  pub int dayPhaseTicks = 60;
  pub int nightPhaseTicks = 40;
  pub int transitionTicks = 10;

  [Header("Animal Behavior")]
  pub int animalHungerTickInterval = 3;
  pub int animalThinkingInterval = 3;

  [Header("Movement")]
  pub int movementTicksPerTile = 1;
  pub int movementCooldownTicks = 0;

  pub float GetRealSecondsPerTick() {
   return ticksPerRealSecond > 0 ? 1f / ticksPerRealSecond : 0.5f;
  }

  pub int ConvertSecondsToTicks(float seconds) {
   return Mathf.RoundToInt(seconds * ticksPerRealSecond);
  }

  pub float ConvertTicksToSeconds(int ticks) {
   return ticks / ticksPerRealSecond;
  }

  pub int GetDayProgress(int currentTick) {
   return currentTick % ticksPerDay;
  }

  pub float GetDayProgressNormalized(int currentTick) {
   return (float)(currentTick % ticksPerDay) / ticksPerDay;
  }

  pub void SetTicksPerSecond(float newRate) {
   ticksPerRealSecond = Mathf.Max(0.1f, newRate);
  }

  void OnValidate() {
   ticksPerRealSecond = Mathf.Max(0.1f, ticksPerRealSecond);
   ticksPerDay = Mathf.Max(10, ticksPerDay);
   dayPhaseTicks = Mathf.Max(1, dayPhaseTicks);
   nightPhaseTicks = Mathf.Max(1, nightPhaseTicks);
   transitionTicks = Mathf.Max(1, transitionTicks);
   animalHungerTickInterval = Mathf.Max(1, animalHungerTickInterval);
   animalThinkingInterval = Mathf.Max(1, animalThinkingInterval);
  }

  void ApplySlowPacedPreset() {
   ticksPerRealSecond = 1f;
   ticksPerDay = 200;
   dayPhaseTicks = 120;
   nightPhaseTicks = 80;
   transitionTicks = 20;
   animalHungerTickInterval = 5;
  }

  void ApplyFastPacedPreset() {
   ticksPerRealSecond = 4f;
   ticksPerDay = 50;
   dayPhaseTicks = 30;
   nightPhaseTicks = 20;
   transitionTicks = 5;
   animalHungerTickInterval = 2;
  }

  void ApplyBalancedPreset() {
   ticksPerRealSecond = 2f;
   ticksPerDay = 100;
   dayPhaseTicks = 60;
   nightPhaseTicks = 40;
   transitionTicks = 10;
   animalHungerTickInterval = 3;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\Ticks\TickManager.cs

﻿// Assets/Scripts/Ticks/TickManager.cs

namespace WegoSystem {
 pub interface ITickUpdateable {
  void OnTickUpdate(int currentTick);
 }

 pub class TickManager : SingletonMonoBehaviour<TickManager> {
  [SerializeField] TickConfiguration tickConfig;
  [SerializeField] bool debugMode = false;
  [SerializeField] int currentTick = 0;

  pub int CurrentTick => currentTick;
  pub TickConfiguration Config => tickConfig;

  pub event Action<int> OnTickAdvanced;
  pub event Action<int> OnTickStarted;
  pub event Action<int> OnTickCompleted;

  ro List<ITickUpdateable> tickUpdateables = new List<ITickUpdateable>();
  ro List<ITickUpdateable> pendingAdditions = new List<ITickUpdateable>();
  ro List<ITickUpdateable> pendingRemovals = new List<ITickUpdateable>();
  bool isProcessingTick = false;

  prot ovr void OnAwake() {
   if (tickConfig == null) {
    Debug.LogError("[TickManager] No TickConfiguration assigned! Creating default config.");
    tickConfig = ScriptableObject.CreateInstance<TickConfiguration>();
   }
  }

  void OnDestroy() {
   if (Instance == this) {
   }
  }

  void Update() {
   #if UNITY_EDITOR
   if (debugMode && Input.GetKeyDown(KeyCode.T)) {
    Debug.Log("[TickManager] Debug: Manual tick advance");
    AdvanceTick();
   }
   #endif
  }

  pub void AdvanceTick() {
   AdvanceMultipleTicks(1);
  }

  pub void AdvanceMultipleTicks(int tickCount) {
   if (tickCount <= 0) return;

   for (int i = 0; i < tickCount; i++) {
    currentTick++;
    ProcessTick();
   }
  }

  void ProcessTick() {
   if (debugMode) {
    Debug.Log($"[TickManager] Processing tick {currentTick}");
   }

   OnTickStarted?.Invoke(currentTick);

   ProcessPendingUpdates();

   isProcessingTick = true;
   foreach (var tickUpdateable in tickUpdateables) {
    try {
     tickUpdateable?.OnTickUpdate(currentTick);
    }
    catch (Exception e) {
     Debug.LogError($"[TickManager] Error in tick update: {e.Message}");
    }
   }
   isProcessingTick = false;

   OnTickAdvanced?.Invoke(currentTick);
   OnTickCompleted?.Invoke(currentTick);
  }

  pub void RegisterTickUpdateable(ITickUpdateable updateable) {
   if (updateable == null) return;

   if (isProcessingTick) {
    if (!pendingAdditions.Contains(updateable))
     pendingAdditions.Add(updateable);
   }
   else {
    if (!tickUpdateables.Contains(updateable))
     tickUpdateables.Add(updateable);
   }
  }

  pub void UnregisterTickUpdateable(ITickUpdateable updateable) {
   if (updateable == null) return;

   if (isProcessingTick) {
    if (!pendingRemovals.Contains(updateable))
     pendingRemovals.Add(updateable);
   }
   else {
    tickUpdateables.Remove(updateable);
   }
  }

  void ProcessPendingUpdates() {
   foreach (var updateable in pendingAdditions) {
    if (!tickUpdateables.Contains(updateable))
     tickUpdateables.Add(updateable);
   }
   pendingAdditions.Clear();

   foreach (var updateable in pendingRemovals) {
    tickUpdateables.Remove(updateable);
   }
   pendingRemovals.Clear();
  }

  pub void ResetTicks() {
   currentTick = 0;
   if (debugMode) Debug.Log("[TickManager] Reset tick counter");
  }

  pub int GetTicksSince(int pastTick) {
   return currentTick - pastTick;
  }

  pub bool HasTicksPassed(int lastTick, int tickInterval) {
   return GetTicksSince(lastTick) >= tickInterval;
  }

  pub int GetNextIntervalTick(int tickInterval) {
   return currentTick + tickInterval;
  }

  pub void DebugAdvanceTick() {
   if (Application.isEditor || Debug.isDebugBuild) {
    AdvanceTick();
   }
  }

  pub int GetRegisteredUpdateableCount() {
   return tickUpdateables.Count;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Player\GardenerController.cs

﻿using System.Collections;
using WegoSystem;

namespace WegoSystem {
 pub class GardenerController : MonoBehaviour, IStatusEffectable, ITickUpdateable {
  [Header("Movement")]
  [SerializeField] float multiTickDelay = 0.5f;

  [Header("Animation")]
  [SerializeField] bool useAnimations = true;
  [SerializeField] Animator animator;
  [SerializeField] string runningParameterName = "isRunning";
  [SerializeField] string plantingTriggerName = "plant";

  [Header("Visuals")]
  [SerializeField] SpriteRenderer spriteRenderer;
  [SerializeField] bool flipSpriteWhenMovingLeft = true;
  [SerializeField] bool flipHorizontalDirection = true;

  GridEntity gridEntity;
  StatusEffectManager statusManager;
  StatusEffectUIManager statusEffectUI;
  PlayerHungerSystem hungerSystem;

  GridPosition currentTargetPosition;
  bool isProcessingMovement = false;

  pub GridEntity GridEntity => gridEntity;
  pub StatusEffectManager StatusManager => statusManager;
  pub PlayerHungerSystem HungerSystem => hungerSystem;

  void Awake() {
   gridEntity = GetComponent<GridEntity>();
   if (gridEntity == null) gridEntity = gameObject.AddComponent<GridEntity>();
   statusManager = GetComponent<StatusEffectManager>();
   if (statusManager == null) statusManager = gameObject.AddComponent<StatusEffectManager>();
   hungerSystem = GetComponent<PlayerHungerSystem>();
   if (hungerSystem == null) hungerSystem = gameObject.AddComponent<PlayerHungerSystem>();

   statusEffectUI = GetComponentInChildren<StatusEffectUIManager>(true);
   if (statusEffectUI == null) Debug.LogWarning("[GardenerController] StatusEffectUIManager not found in children. Icons won't display.", this);
   if (spriteRenderer == null) spriteRenderer = GetComponentInChildren<SpriteRenderer>();
   if (spriteRenderer == null) Debug.LogWarning("[GardenerController] SpriteRenderer not found.", gameObject);
   if (animator == null && useAnimations) Debug.LogWarning("[GardenerController] Animator not found.", gameObject);
  }

  void Start() {
   statusManager.Initialize(this);

   if (statusEffectUI != null) {
    statusEffectUI.Initialize(statusManager);
   }

   if (TickManager.Instance != null) {
    TickManager.Instance.RegisterTickUpdateable(this);
   }
   if (gridEntity != null) {
    gridEntity.OnPositionChanged += OnGridPositionChanged;
   }

   StartCoroutine(InitialTileEffectCheck());
  }

  IEnumerator InitialTileEffectCheck() {
   yield return null;
   if (EnvironmentalStatusEffectSystem.Instance != null) {
    EnvironmentalStatusEffectSystem.Instance.CheckAndApplyTileEffects(this);
   }
  }

  void OnDestroy() {
   var tickManager = TickManager.Instance;
   if (tickManager != null) {
    tickManager.UnregisterTickUpdateable(this);
   }

   if (gridEntity != null) {
    gridEntity.OnPositionChanged -= OnGridPositionChanged;
   }
  }

  pub void OnTickUpdate(int currentTick) {
   statusManager?.OnTickUpdate(currentTick);
  }

  void Update() {
   if (RunManager.Instance?.CurrentState == RunState.GrowthAndThreat) {
    HandlePlayerInput();
   }
   if (gridEntity != null && statusManager != null) {
    gridEntity.SetSpeedMultiplier(statusManager.VisualInterpolationSpeedMultiplier);
   }
   UpdateAnimations();
   UpdateSpriteDirection();
  }

  void LateUpdate() {
   transform.position = PixelGridSnapper.SnapToGrid(transform.position);
  }

  void OnGridPositionChanged(GridPosition oldPos, GridPosition newPos) {
   EnvironmentalStatusEffectSystem.Instance?.CheckAndApplyTileEffects(this);
  }

  pub string GetDisplayName() { return "Gardener"; }
  pub void TakeDamage(float amount) { Debug.Log($"Gardener took {amount} damage!"); }
  pub void Heal(float amount) { Debug.Log($"Gardener was healed for {amount}!"); }
  pub void ModifyHunger(float amount) {
   if (hungerSystem != null) {
    hungerSystem.Eat(-amount);
   }
  }

  void HandlePlayerInput() {
   if (gridEntity == null || gridEntity.IsMoving || isProcessingMovement) return;

   GridPosition moveDir = GridPosition.Zero;
   if (Input.GetKeyDown(KeyCode.W) || Input.GetKeyDown(KeyCode.UpArrow)) moveDir = GridPosition.Up;
   else if (Input.GetKeyDown(KeyCode.S) || Input.GetKeyDown(KeyCode.DownArrow)) moveDir = GridPosition.Down;
   else if (Input.GetKeyDown(KeyCode.A) || Input.GetKeyDown(KeyCode.LeftArrow)) moveDir = GridPosition.Left;
   else if (Input.GetKeyDown(KeyCode.D) || Input.GetKeyDown(KeyCode.RightArrow)) moveDir = GridPosition.Right;

   if (moveDir != GridPosition.Zero) {
    TryMove(moveDir);
    return;
   }
  }

  void TryMove(GridPosition direction) {
   if (gridEntity == null) return;
   GridPosition targetPos = gridEntity.Position + direction;
   if (GridPositionManager.Instance != null && PlayerActionManager.Instance != null && TickManager.Instance != null &&
    GridPositionManager.Instance.IsPositionValid(targetPos) &&
    !GridPositionManager.Instance.IsPositionOccupied(targetPos)) {
    Vector3 currentWorldPos = GridPositionManager.Instance.GridToWorld(gridEntity.Position);
    int moveCost = PlayerActionManager.Instance.GetMovementTickCost(currentWorldPos, this);
    if (moveCost > 1) {
     StartCoroutine(ProcessMultiTickMovement(targetPos, moveCost));
    }
    else {
     gridEntity.SetPosition(targetPos);
     currentTargetPosition = targetPos;
     TickManager.Instance.AdvanceTick();
    }
   }
  }

  IEnumerator ProcessMultiTickMovement(GridPosition targetPos, int tickCost) {
   isProcessingMovement = true;
   for (int i = 0; i < tickCost - 1; i++) {
    TickManager.Instance.AdvanceTick();
    yield return new WaitForSeconds(multiTickDelay);
   }
   gridEntity.SetPosition(targetPos);
   currentTargetPosition = targetPos;
   TickManager.Instance.AdvanceTick();
   isProcessingMovement = false;
  }

  void UpdateAnimations() {
   if (!useAnimations || animator == null) return;
   bool isMoving = gridEntity != null && gridEntity.IsMoving;
   animator.SetBool(runningParameterName, isMoving);
  }

  void UpdateSpriteDirection() {
   if (spriteRenderer == null || !flipSpriteWhenMovingLeft || gridEntity == null || !gridEntity.IsMoving) return;
   Vector3 worldTarget = GridPositionManager.Instance.GridToWorld(currentTargetPosition);
   Vector3 currentWorld = transform.position;
   Vector2 directionToCheck = (worldTarget - currentWorld).normalized;
   if (Mathf.Abs(directionToCheck.x) > 0.01f) {
    bool shouldFlip = directionToCheck.x < 0;
    spriteRenderer.flipX = flipHorizontalDirection ? shouldFlip : !shouldFlip;
   }
  }

  pub void Plant() {
   if (useAnimations && animator != null) {
    animator.SetTrigger(plantingTriggerName);
   }
  }

  pub GridPosition GetCurrentGridPosition() {
   return gridEntity?.Position ?? GridPosition.Zero;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\WorldInteraction\Tiles\TileInteractionManager.cs

﻿using System;
using UnityEngine.Tilemaps;
using Abracodabra.UI.Genes;
using skner.DualGrid;
using TMPro;
using WegoSystem;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
 pub class TileInteractionManager : SingletonMonoBehaviour<TileInteractionManager>, ITickUpdateable {
  pub class TileDefinitionMapping {
   pub TileDefinition tileDef;
   pub DualGridTilemapModule tilemapModule;
  }

  pub struct TimedTileState {
   pub TileDefinition tileDef;
   pub int ticksRemaining;
  }

  [Header("Tile Mappings")]
  [Tooltip("Map TileDefinitions to their DualGridTilemapModules. Order affects sorting only, not detection priority.")]
  pub List<TileDefinitionMapping> tileDefinitionMappings;

  [Header("Interaction")]
  pub TileInteractionLibrary interactionLibrary;
  pub Grid interactionGrid;
  pub Camera mainCamera;
  pub Transform player;
  pub float hoverRadius = 3f;

  [Header("Hover Visuals")]
  pub GameObject hoverHighlightObject;
  pub TileHoverColorManager hoverColorManager;
  pub int baseSortingOrder = 0;

  [Header("Debug")]
  pub bool debugLogs = false;
  pub TextMeshProUGUI hoveredTileText;
  pub TextMeshProUGUI currentToolText;

  pub bool IsWithinInteractionRange => isWithinInteractionRange;
  pub Vector3Int? CurrentlyHoveredCell => currentlyHoveredCell;
  pub TileDefinition HoveredTileDef => hoveredTileDef;

  Dictionary<TileDefinition, DualGridTilemapModule> moduleByDefinition;
  ro Dictionary<Vector3Int, TimedTileState> timedCells = new Dictionary<Vector3Int, TimedTileState>();
  Vector3Int? currentlyHoveredCell;
  TileDefinition hoveredTileDef;
  SpriteRenderer hoverSpriteRenderer;
  bool isWithinInteractionRange = false;
  bool refillHappenedThisFrame = false;

  prot ovr void OnAwake() {
   EnsureInitialized();
   CacheHoverSpriteRenderer();
  }

  void EnsureInitialized() {
   if (moduleByDefinition == null) {
    if (debugLogs) Debug.Log("[TileInteractionManager] Dictionaries are null. Initializing now.");
    SetupTilemaps();
   }
  }

  void Start() {
   if (TickManager.Instance != null) {
    TickManager.Instance.RegisterTickUpdateable(this);
   }
  }

  void OnDestroy() {
   if (TickManager.Instance != null) {
    TickManager.Instance.UnregisterTickUpdateable(this);
   }
  }

  pub void OnTickUpdate(int currentTick) {
   UpdateReversionTicks();
  }

  void Update() {
   refillHappenedThisFrame = false;
   HandleTileHover();

   if (RunManager.Instance?.CurrentState == RunState.GrowthAndThreat) {
    CheckAndRefillTool();
   }

   UpdateDebugUI();
  }

  pub TileDefinition FindWhichTileDefinitionAt(Vector3Int cellPos) {
   EnsureInitialized();
   if (tileDefinitionMappings == null) return null;

   TileDefinition highestPriorityTile = null;
   int highestPriority = int.MinValue;

   foreach (var mapping in tileDefinitionMappings) {
    if (mapping?.tileDef == null || mapping.tilemapModule == null) continue;

    if (TileExistsInModule(mapping.tilemapModule, cellPos)) {
     int priority = mapping.tileDef.interactionPriority;

     if (priority > highestPriority) {
      highestPriority = priority;
      highestPriorityTile = mapping.tileDef;
     }
    }
   }

   return highestPriorityTile;
  }

  pub List<TileDefinition> GetAllTilesAt(Vector3Int cellPos) {
   EnsureInitialized();
   var tiles = new List<TileDefinition>();

   if (tileDefinitionMappings == null) return tiles;

   foreach (var mapping in tileDefinitionMappings) {
    if (mapping?.tileDef == null || mapping.tilemapModule == null) continue;

    if (TileExistsInModule(mapping.tilemapModule, cellPos)) {
     tiles.Add(mapping.tileDef);
    }
   }

   tiles.Sort((a, b) => b.interactionPriority.CompareTo(a.interactionPriority));
   return tiles;
  }

  bool TileExistsInModule(DualGridTilemapModule module, Vector3Int cellPos) {
   return module.DataTilemap != null && module.DataTilemap.HasTile(cellPos);
  }

  pub void ApplyToolAction(ToolDefinition toolDef) {
   if (toolDef == null || !currentlyHoveredCell.HasValue) return;

   Vector3Int targetCell = currentlyHoveredCell.Value;

   TileDefinition topTile = FindWhichTileDefinitionAt(targetCell);

   if (topTile == null) {
    if (debugLogs)
     Debug.Log($"[TileInteractionManager] No tile at {targetCell}");
    return;
   }

   if (debugLogs) {
    Debug.Log($"[TileInteractionManager] Applying Tool: '{toolDef.displayName}' at {targetCell}");
    Debug.Log($"[TileInteractionManager] Top tile: '{topTile.displayName}' (Priority: {topTile.interactionPriority})");

    // Show all tiles for debugging
    var allTiles = GetAllTilesAt(targetCell);
    if (allTiles.Count > 1) {
     string tileList = string.Join(", ", allTiles.Select(t => $"{t.displayName}(P:{t.interactionPriority})"));
     Debug.Log($"[TileInteractionManager] All tiles at position: [{tileList}]");
    }
   }

TileInteractionRule rule = interactionLibrary?.rules.FirstOrDefault( r => r != null && r.tool == toolDef && r.fromTile == topTile );

   if (rule != null) {
    if (debugLogs)
     Debug.Log($"[TileInteractionManager] ✓ MATCH! Rule: '{rule.fromTile.displayName}' -> '{(rule.toTile != null ? rule.toTile.displayName : "REMOVE")}'");

    ExecuteTileTransformation(rule, targetCell);
   }
   else {
    if (debugLogs)
     Debug.Log($"[TileInteractionManager] ✗ No rule for '{toolDef.displayName}' on '{topTile.displayName}'. Action blocked by surface tile.");
   }
  }

  void ExecuteTileTransformation(TileInteractionRule rule, Vector3Int targetCell) {
   if (rule.toTile == null) {
    RemoveTile(rule.fromTile, targetCell);
   }
   else {
    if (!rule.toTile.keepBottomTile) {
     RemoveTile(rule.fromTile, targetCell);
    }
    PlaceTile(rule.toTile, targetCell);
   }
  }

  void CheckAndRefillTool() {
   if (!Input.GetMouseButtonDown(0)) return;
   if (ToolSwitcher.Instance == null) return;

   var currentTool = ToolSwitcher.Instance.CurrentTool;
   if (currentTool == null || !currentTool.limitedUses) return;

   if (hoveredTileDef == null) return;

   if (interactionLibrary?.refillRules != null) {
var refillRule = interactionLibrary.refillRules.FirstOrDefault( r => r.toolToRefill == currentTool && r.refillSourceTile == hoveredTileDef );

    if (refillRule != null && isWithinInteractionRange) {
     ToolSwitcher.Instance.RefillCurrentTool();
     refillHappenedThisFrame = true;

     if (debugLogs)
      Debug.Log($"[TileInteractionManager] Refilled {currentTool.displayName} from '{hoveredTileDef.displayName}'");

     if (PlayerActionManager.Instance != null) {
      PlayerActionManager.Instance.ExecutePlayerAction(PlayerActionType.Interact, currentlyHoveredCell.Value, "Refill");
     }
    }
   }
  }

  pub bool DidRefillThisFrame => refillHappenedThisFrame;

  void UpdateReversionTicks() {
   if (timedCells.Count == 0) return;

   List<Vector3Int> cellsToProcess = timedCells.Keys.ToList();

   foreach (Vector3Int cellPos in cellsToProcess) {
    if (timedCells.TryGetValue(cellPos, out TimedTileState state)) {
     state.ticksRemaining--;

     if (state.ticksRemaining <= 0) {
      TileDefinition actualTile = FindWhichTileDefinitionAt(cellPos);

      if (actualTile == state.tileDef) {
       if (debugLogs)
        Debug.Log($"[TileInteractionManager] Reverting tile '{state.tileDef.displayName}' at {cellPos}");

       RemoveTile(state.tileDef, cellPos);

       if (state.tileDef.revertToTile != null) {
        PlaceTile(state.tileDef.revertToTile, cellPos);
       }
      }
      else {
       if (debugLogs)
        Debug.LogWarning($"[TileInteractionManager] State desync at {cellPos}. Expected '{state.tileDef.displayName}', found '{actualTile?.displayName ?? "NULL"}'");
      }

      timedCells.Remove(cellPos);
     }
     else {
      timedCells[cellPos] = state;
     }
    }
   }
  }

  pub void PlaceTile(TileDefinition tileDef, Vector3Int cellPos) {
   EnsureInitialized();
   if (tileDef == null) return;

   if (moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module) && module?.DataTilemap != null) {
    module.DataTilemap.SetTile(cellPos, ScriptableObject.CreateInstance<Tile>());

    if (tileDef.revertAfterTicks > 0) {
     timedCells[cellPos] = new TimedTileState {
      tileDef = tileDef,
      ticksRemaining = tileDef.revertAfterTicks
     };
    }
   }
  }

  pub void RemoveTile(TileDefinition tileDef, Vector3Int cellPos) {
   EnsureInitialized();
   if (tileDef == null) return;

   if (moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module) && module?.DataTilemap != null) {
    module.DataTilemap.SetTile(cellPos, null);
   }

   if (timedCells.TryGetValue(cellPos, out TimedTileState timedState) && timedState.tileDef == tileDef) {
    timedCells.Remove(cellPos);
   }
  }

  void CacheHoverSpriteRenderer() {
   if (hoverHighlightObject != null) {
    hoverSpriteRenderer = hoverHighlightObject.GetComponent<SpriteRenderer>();
   }
  }

  void SetupTilemaps() {
   moduleByDefinition = new Dictionary<TileDefinition, DualGridTilemapModule>();
   if (tileDefinitionMappings == null) return;

   foreach (var mapping in tileDefinitionMappings) {
    if (mapping?.tileDef != null && mapping.tilemapModule != null) {
     if (!moduleByDefinition.ContainsKey(mapping.tileDef)) {
      moduleByDefinition[mapping.tileDef] = mapping.tilemapModule;
     }
     else {
      Debug.LogWarning($"[TileInteractionManager] Duplicate TileDefinition '{mapping.tileDef.displayName}' in mappings.", mapping.tileDef);
     }
    }
   }
  }

  pub void UpdateSortingOrder() {
   if (tileDefinitionMappings == null) return;

   for (int i = 0; i < tileDefinitionMappings.Count; i++) {
    var mapping = tileDefinitionMappings[i];
    if (mapping?.tilemapModule != null) {
     Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
     if (renderTilemapTransform != null) {
      if (renderTilemapTransform.GetComponent<TilemapRenderer>() is TilemapRenderer renderer) {
       renderer.sortingOrder = baseSortingOrder - i;
#if UNITY_EDITOR
       if (!Application.isPlaying) EditorUtility.SetDirty(renderer);
#endif
      }
     }
    }
   }
  }

  pub void UpdateAllColors() {
   if (tileDefinitionMappings == null) return;

   foreach (var mapping in tileDefinitionMappings) {
    if (mapping?.tileDef != null && mapping.tilemapModule != null) {
     Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
     if (renderTilemapTransform != null) {
      if (renderTilemapTransform.GetComponent<Tilemap>() is Tilemap renderTilemap) {
       renderTilemap.color = mapping.tileDef.tintColor;
#if UNITY_EDITOR
       if (!Application.isPlaying) EditorUtility.SetDirty(renderTilemap);
#endif
      }
     }
    }
   }
  }

  void HandleTileHover() {
   if (mainCamera == null || player == null) return;

   Vector3 mouseWorldPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
   mouseWorldPos.z = 0f;
   Vector3Int cellPos = WorldToCell(mouseWorldPos);

   if (player.GetComponent<GridEntity>() is GridEntity playerGrid) {
    int gridRadius = Mathf.CeilToInt(hoverRadius);
    GridPosition playerGridPos = playerGrid.Position;
    GridPosition hoveredGridPos = new GridPosition(cellPos);
    isWithinInteractionRange = GridRadiusUtility.IsWithinCircleRadius(hoveredGridPos, playerGridPos, gridRadius);
   }

   hoveredTileDef = FindWhichTileDefinitionAt(cellPos);
   currentlyHoveredCell = cellPos;

   if (hoverHighlightObject != null) {
    hoverHighlightObject.SetActive(true);
    hoverHighlightObject.transform.position = CellCenterWorld(cellPos);
    hoverHighlightObject.transform.position = PixelGridSnapper.SnapToGrid(hoverHighlightObject.transform.position);
    UpdateHoverHighlightColor(isWithinInteractionRange);
   }
  }

  void UpdateHoverHighlightColor(bool withinRange) {
   if (hoverSpriteRenderer != null && hoverColorManager != null) {
    hoverSpriteRenderer.color = hoverColorManager.GetColorForRange(withinRange);
   }
  }

  void UpdateDebugUI() {
   if (hoveredTileText != null) {
    string tileName = hoveredTileDef != null ? hoveredTileDef.displayName : "None";

    // Also show all tiles at this position for debugging
    if (debugLogs && currentlyHoveredCell.HasValue) {
     var allTiles = GetAllTilesAt(currentlyHoveredCell.Value);
     if (allTiles.Count > 1) {
      string allNames = string.Join(", ", allTiles.Select(t => $"{t.displayName}({t.interactionPriority})"));
      tileName = $"{tileName} [All: {allNames}]";
     }
    }

    hoveredTileText.text = $"Tile: {tileName}";
   }

   if (currentToolText != null && ToolSwitcher.Instance != null) {
    var currentTool = ToolSwitcher.Instance.CurrentTool;
    currentToolText.text = currentTool != null ? $"Tool: {currentTool.displayName}" : "Tool: None";
   }
  }

  pub Vector3Int WorldToCell(Vector3 worldPosition) {
   if (interactionGrid == null) return Vector3Int.zero;
   return interactionGrid.WorldToCell(worldPosition);
  }

  pub Vector3 CellCenterWorld(Vector3Int cellPos) {
   if (interactionGrid == null) return Vector3.zero;
   return interactionGrid.GetCellCenterWorld(cellPos);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\ProceduralGeneration\Editor\ResolutionManagerEditor.cs

﻿using UnityEngine;
using UnityEditor;
using WegoSystem;

namespace WegoSystem.Editor {
 pub class ResolutionManagerEditor : UnityEditor.Editor {
  pub ovr void OnInspectorGUI() {
   DrawDefaultInspector();

   ResolutionManager manager = (ResolutionManager)target;

   EditorGUILayout.Space(10);

   GUIStyle buttonStyle = new GUIStyle(GUI.skin.button);
   buttonStyle.padding = new RectOffset(10, 10, 8, 8);
   buttonStyle.fontSize = 12;

   if (GUILayout.Button("Apply Current Profile in Editor", buttonStyle)) {
    if (manager != null) {
     manager.ApplyProfileInEditor();
     Debug.Log("Applied resolution profile settings in the editor.");
    }
   }

   EditorGUILayout.HelpBox("Press this button to apply the 'Current Profile Index' settings to the Main Camera. This is useful for previewing changes without entering Play mode.", MessageType.Info);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\ProceduralGeneration\MapBoundsVisualizer.cs

﻿using UnityEngine;
using WegoSystem;

namespace WegoSystem.EditorTools {
 pub class MapBoundsVisualizer : MonoBehaviour {
  [Header("References")]
  [SerializeField] MapConfiguration mapConfig;

  [Header("Gizmo Settings")]
  [SerializeField] Color boundsColor = Color.green;
  [SerializeField] Color safeAreaColor = Color.yellow;
  [SerializeField] bool showCameraArea = true;

  void OnDrawGizmos() {
   if (mapConfig == null) return;

   var gridManager = GridPositionManager.Instance;
   if (gridManager == null) {
    gridManager = FindFirstObjectByType<GridPositionManager>();
    if (gridManager == null) return; // If still not found, we cannot proceed.
   }

   var grid = gridManager.GetTilemapGrid();
   if (grid == null) return;

   Vector3 firstCellCenter = grid.GetCellCenterWorld(new Vector3Int(0, 0, 0));
   Vector3 lastCellCenter = grid.GetCellCenterWorld(new Vector3Int(mapConfig.mapSize.x - 1, mapConfig.mapSize.y - 1, 0));

   Vector3 mapWorldCenter = (firstCellCenter + lastCellCenter) / 2f;

   Vector3 mapWorldSize = (lastCellCenter - firstCellCenter) + grid.cellSize;
   mapWorldSize.x = Mathf.Abs(mapWorldSize.x);
   mapWorldSize.y = Mathf.Abs(mapWorldSize.y);

   Gizmos.color = boundsColor;
   Gizmos.DrawWireCube(mapWorldCenter, mapWorldSize);

   Gizmos.color = safeAreaColor;
   float padding = grid.cellSize.x * 2; // 2 tiles padding
   Vector3 safeSize = mapWorldSize - new Vector3(padding * 2, padding * 2, 0);
   if (safeSize.x > 0 && safeSize.y > 0) {
    Gizmos.DrawWireCube(mapWorldCenter, safeSize);
   }

   if (showCameraArea && Camera.main != null) {
    Gizmos.color = Color.blue;
    Camera cam = Camera.main;
    float height = cam.orthographicSize * 2;
    float width = height * cam.aspect;
    Gizmos.DrawWireCube(cam.transform.position, new Vector3(width, height, 0));
   }
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\ProceduralGeneration\MapGenerationProfile.cs

﻿// FILE: Assets/Scripts/ProceduralGeneration/MapGenerationProfile.cs
using WegoSystem.ProceduralGeneration;

pub class BiomeLayer {
 [Tooltip("The primary tile to place for this layer.")]
 pub TileDefinition tile;

 [Tooltip("The upper noise threshold for this layer (0-1). It will be placed if noise is <= this value and > the previous layer's value.")]
 [Range(0f, 1f)]
 pub float noiseThreshold;

 [Tooltip("Check this to place another tile underneath the primary tile.")]
 pub bool placeUnderlayTile = false;

 [Tooltip("The tile to place underneath the primary one. Only used if 'Place Underlay Tile' is checked.")]
 pub TileDefinition underlayTile;

}

namespace WegoSystem.ProceduralGeneration {
 pub class MapGenerationProfile : ScriptableObject {

  pub int worldSeed = 12345;
  pub bool useRandomSeed = true;

  pub NoiseParameters noiseParameters = new NoiseParameters {
   scale = 0.1f,
   octaves = 4,
   persistence = 0.5f,
   lacunarity = 2f
  };

  pub List<BiomeLayer> biomeLayers;

  pub void InitializeSeed() {
   if (useRandomSeed) {
    worldSeed = Random.Range(0, int.MaxValue);
   }
   noiseParameters.seed = worldSeed;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\ProceduralGeneration\ProceduralMapGenerator.cs

﻿using System.Collections.Generic;
using WegoSystem;

namespace WegoSystem.ProceduralGeneration {
 pub class ProceduralMapGenerator : MonoBehaviour {
  [Header("Core Configuration")]
  [Tooltip("The central configuration for map size. This is the primary source of truth for dimensions.")]
  [SerializeField] MapConfiguration mapConfig;

  [Tooltip("Profile containing noise parameters and biome layer definitions.")]
  [SerializeField] MapGenerationProfile profile;

  [Header("Scene References")]
  [Tooltip("Assign the scene's TileInteractionManager here. This is required for placing tiles.")]
  [SerializeField] TileInteractionManager tileManager;

  ro Dictionary<Vector2Int, TileDefinition> tileMap = new Dictionary<Vector2Int, TileDefinition>();

  pub void GenerateMap() {
   if (!ValidateConfiguration()) {
    return;
   }

   profile.InitializeSeed();
   Debug.Log($"Starting map generation with seed: {profile.worldSeed}...");

   ClearMap();

   var sortedLayers = profile.biomeLayers.OrderBy(layer => layer.noiseThreshold).ToList();

   float halfWidth = mapConfig.mapSize.x / 2f;
   float halfHeight = mapConfig.mapSize.y / 2f;

   for (int x = 0; x < mapConfig.mapSize.x; x++) {
    for (int y = 0; y < mapConfig.mapSize.y; y++) {
     float sampleX = x - halfWidth;
     float sampleY = y - halfHeight;
     float noiseValue = profile.noiseParameters.Sample(sampleX, sampleY);

     float normalizedNoise = SimplexNoise.Remap(noiseValue, -1f, 1f, 0f, 1f);

     BiomeLayer chosenLayer = null;
     foreach (var layer in sortedLayers) {
      if (normalizedNoise <= layer.noiseThreshold) {
       chosenLayer = layer;
       break;
      }
     }

     if (chosenLayer != null) {
      var cellPos = new Vector3Int(x, y, 0);

      if (chosenLayer.placeUnderlayTile && chosenLayer.underlayTile != null) {
       tileManager.PlaceTile(chosenLayer.underlayTile, cellPos);
      }

      if (chosenLayer.tile != null) {
       tileManager.PlaceTile(chosenLayer.tile, cellPos);
       tileMap[new Vector2Int(x, y)] = chosenLayer.tile;
      }
     }
    }
   }

   Debug.Log("Map generation complete.");
  }

  pub void ClearMap() {
   if (!ValidateConfiguration(checkMappings: false)) {
    return;
   }

   Debug.Log("Clearing existing map by checking every cell...");

   for (int x = 0; x < mapConfig.mapSize.x; x++) {
    for (int y = 0; y < mapConfig.mapSize.y; y++) {
     var cellPos = new Vector3Int(x, y, 0);

     TileDefinition tileOnTop;
     while ((tileOnTop = tileManager.FindWhichTileDefinitionAt(cellPos)) != null) {
      tileManager.RemoveTile(tileOnTop, cellPos);
     }
    }
   }

   ClearCaches();
   Debug.Log("[ProceduralMapGenerator] Map clear complete.");
  }

  void ClearCaches() {
   tileMap.Clear();
  }

  bool ValidateConfiguration(bool checkMappings = true) {
   if (mapConfig == null) {
    Debug.LogError("[ProceduralMapGenerator] Map Configuration is not assigned!", this);
    return false;
   }
   if (profile == null) {
    Debug.LogError("[ProceduralMapGenerator] Map Generation Profile is not assigned!", this);
    return false;
   }

   if (tileManager == null) {
    tileManager = TileInteractionManager.Instance;
    if (tileManager == null) {
     Debug.LogError("[ProceduralMapGenerator] Tile Interaction Manager is not assigned in the Inspector and could not be found in the scene! Please assign it.", this);
     return false;
    }
   }

   if (checkMappings && (profile.biomeLayers == null || profile.biomeLayers.Count == 0)) {
    Debug.LogError("[ProceduralMapGenerator] The assigned Profile has no Biome Layers defined!", this);
    return false;
   }
   return true;
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\ProceduralGeneration\SimplexNoise.cs

﻿// FILE: Assets/Scripts/ProceduralGeneration/SimplexNoise.cs

namespace WegoSystem.ProceduralGeneration {
 pub stat class SimplexNoise {
  stat ro int[] perm = new int[512];
  stat ro float F2 = 0.5f * (Mathf.Sqrt(3f) - 1f);
  stat ro float G2 = (3f - Mathf.Sqrt(3f)) / 6f;

  stat ro Vector2[] grad2 = {
   new Vector2(1, 1), new Vector2(-1, 1), new Vector2(1, -1), new Vector2(-1, -1),
   new Vector2(1, 0), new Vector2(-1, 0), new Vector2(0, 1), new Vector2(0, -1)
  };

  pub stat void Initialize(int seed) {
   System.Random rand = new System.Random(seed);
   int[] p = new int[256];

   for (int i = 0; i < 256; i++) {
    p[i] = i;
   }

   for (int i = 255; i > 0; i--) {
    int j = rand.Next(i + 1);
    int temp = p[i];
    p[i] = p[j];
    p[j] = temp;
   }

   for (int i = 0; i < 512; i++) {
    perm[i] = p[i & 255];
   }
  }

  pub stat float Generate2D(float x, float y) {
   float s = (x + y) * F2;
   int i = Mathf.FloorToInt(x + s);
   int j = Mathf.FloorToInt(y + s);

   float t = (i + j) * G2;
   float X0 = i - t;
   float Y0 = j - t;
   float x0 = x - X0;
   float y0 = y - Y0;

   int i1, j1;
   if (x0 > y0) {
    i1 = 1; j1 = 0;
   }
   else {
    i1 = 0; j1 = 1;
   }

   float x1 = x0 - i1 + G2;
   float y1 = y0 - j1 + G2;
   float x2 = x0 - 1f + 2f * G2;
   float y2 = y0 - 1f + 2f * G2;

   int ii = i & 255;
   int jj = j & 255;
   int gi0 = perm[ii + perm[jj]] % 8;
   int gi1 = perm[ii + i1 + perm[jj + j1]] % 8;
   int gi2 = perm[ii + 1 + perm[jj + 1]] % 8;

   float n0 = 0f, n1 = 0f, n2 = 0f;

   float t0 = 0.5f - x0 * x0 - y0 * y0;
   if (t0 >= 0) {
    t0 *= t0;
    n0 = t0 * t0 * Dot(grad2[gi0], x0, y0);
   }

   float t1 = 0.5f - x1 * x1 - y1 * y1;
   if (t1 >= 0) {
    t1 *= t1;
    n1 = t1 * t1 * Dot(grad2[gi1], x1, y1);
   }

   float t2 = 0.5f - x2 * x2 - y2 * y2;
   if (t2 >= 0) {
    t2 *= t2;
    n2 = t2 * t2 * Dot(grad2[gi2], x2, y2);
   }

   return 70f * (n0 + n1 + n2);
  }

  pub stat float GenerateOctaves(float x, float y, NoiseParameters parameters) {
   if (parameters.octaves <= 0) return 0f;

   float amplitude = 1f;
   float frequency = 1f;
   float noiseValue = 0f;
   float maxValue = 0f;

   for (int i = 0; i < parameters.octaves; i++) {
    float sampleX = (x + parameters.offset.x) * parameters.scale * frequency;
    float sampleY = (y + parameters.offset.y) * parameters.scale * frequency;

    float octaveValue = Generate2D(sampleX, sampleY);
    noiseValue += octaveValue * amplitude;
    maxValue += amplitude;

    amplitude *= parameters.persistence;
    frequency *= parameters.lacunarity;
   }

   if (maxValue > 0) {
    return noiseValue / maxValue;
   }
   return 0f;
  }

  stat float Dot(Vector2 g, float x, float y) {
   return g.x * x + g.y * y;
  }

  pub stat float Remap(float value, float from1, float to1, float from2, float to2) {
   return from2 + (value - from1) * (to2 - from2) / (to1 - from1);
  }
 }

 pub class NoiseParameters {
  [Header("Basic Settings")]
  [Tooltip("Scale of the noise (smaller = more zoomed in)")]
  [Range(0.001f, 1f)]
  pub float scale = 0.1f;

  [Tooltip("Seed for deterministic generation")]
  pub int seed = 42;

  [Header("Octave Settings")]
  [Tooltip("Number of noise layers (more = more detail)")]
  [Range(1, 8)]
  pub int octaves = 4;

  [Tooltip("Amplitude decrease per octave (smaller = less detail influence)")]
  [Range(0f, 1f)]
  pub float persistence = 0.5f;

  [Tooltip("Frequency increase per octave (higher = more detail frequency)")]
  [Range(1f, 4f)]
  pub float lacunarity = 2f;

  [Header("Offset")]
  [Tooltip("X/Y offset for noise sampling")]
  pub Vector2 offset = Vector2.zero;

  pub NoiseParameters() { }

  pub NoiseParameters(float scale, int octaves, int seed) {
   this.scale = scale;
   this.octaves = octaves;
   this.seed = seed;
  }

  pub float Sample(float x, float y) {
   SimplexNoise.Initialize(seed);
   return SimplexNoise.GenerateOctaves(x, y, this);
  }
 }
}

////////////////////////////////////////////////////////////
// FILE: Assets\Scripts\ProceduralGeneration\Editor\ProceduralMapGeneratorEditor.cs

﻿// FILE: Assets/Scripts/Editor/ProceduralMapGeneratorEditor.cs
using UnityEditor;
using WegoSystem.ProceduralGeneration;

namespace WegoSystem.ProceduralGeneration.Editor {
 pub class ProceduralMapGeneratorEditor : UnityEditor.Editor {
  pub ovr void OnInspectorGUI() {
   DrawDefaultInspector();

   ProceduralMapGenerator generator = (ProceduralMapGenerator)target;

   EditorGUILayout.Space(10);
   EditorGUILayout.LabelField("Controls", EditorStyles.boldLabel);

   if (GUILayout.Button("Generate Map")) {
    generator.GenerateMap();
   }

   if (GUILayout.Button("Clear Map")) {
    generator.ClearMap();
   }
  }
 }
}
