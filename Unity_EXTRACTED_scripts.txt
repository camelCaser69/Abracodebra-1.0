UNITY PROJECT SCRIPTS - COMPRESSED FORMAT
Compression Stats: 475,674 → 319,725 chars (32.8% reduction)
Estimated tokens saved: ~38,987

This document contains extracted Unity 6 (version 6000.0.39f1) C# scripts from my Unity game project.

 When you're tasked with editing: return each changed method in full; if edits touch ≤3 methods list those blocks only, else output the entire script—always copy-paste ready.

 This file is optimized for AI/LLM token efficiency. The following compression is applied:
- Removed: excess whitespace, common using statements, XML docs, attributes
- Preserved: code structure, important comments, logic flow

IMPORTANT FOR AI: When editing/creating scripts from this reference:
1. Re-add standard Unity using statements (System, UnityEngine, etc.)
2. Format with proper indentation and spacing
3. Add back regions and documentation as needed
4. Ensure proper C# code style

Common using statements (add these back when needed):
using System;

[Abracodabra.Genes]
  GeneLibrary (Assets\Scripts\Genes/) L29
  PlantSequenceExecutor (Assets\Scripts\Genes/) L145
  PlantGrowth (Assets\Scripts\PlantSystem\Growth/) L314

[Abracodabra.Genes.Components]
  Creature (Assets\Scripts\Genes\Components/) L469
  Fruit (Assets\Scripts\Genes\Components/) L494
  NutritionComponent (Assets\Scripts\Genes\Components/) L523

[Abracodabra.Genes.Core]
  ActiveGene (Assets\Scripts\Genes\Core/) L535
  ModifierGene (Assets\Scripts\Genes\Core/) L576
  PassiveGene (Assets\Scripts\Genes\Core/) L607
  PayloadGene (Assets\Scripts\Genes\Core/) L631
  PlaceholderGene (Assets\Scripts\Genes\Core/) L676
  SafeGeneLoader (Assets\Scripts\Genes\Core/) L697
  GeneBase (Assets\Scripts\Genes/) L730

[Abracodabra.Genes.Implementations]
  BasicFruitGene (Assets\Scripts\Genes\Implementations\Active/) L792
  CostReductionGene (Assets\Scripts\Genes\Implementations\Modifier/) L870
  GrowthSpeedGene (Assets\Scripts\Genes\Implementations\Passive/) L898
  Creature (Assets\Scripts\Genes\Implementations\Payload/) L939

[Abracodabra.Genes.Runtime]
  PlantGeneRuntimeState (Assets\Scripts\Genes\Runtime/) L1000
  RuntimeGeneInstance (Assets\Scripts\Genes\Runtime/) L1101

[Abracodabra.Genes.Services]
  DeterministicRandom (Assets\Scripts\Genes\Services/) L1200
  GeneEffectPool (Assets\Scripts\Genes\Services/) L1233
  IGeneLibrary (Assets\Scripts\Genes\Services/) L1331

[Abracodabra.Genes.Templates]
  SeedTemplate (Assets\Scripts\Genes\Templates/) L1399

[Abracodabra.UI.Genes]
  GeneSequenceUI (Assets\Scripts\Genes\UI/) L1462
  GeneSlotUI (Assets\Scripts\Genes\UI/) L1597
  SequenceRowUI (Assets\Scripts\Genes\UI/) L1815
  ItemView (Assets\Scripts\PlantSystem\UI/) L1881

[Unknown]
  GameEvent (Assets\Scripts\Core\Events/) L1970
  GameEventListener (Assets\Scripts\Core\Events/) L1997
  IGameEventListener (Assets\Scripts\Core\Events/) L2024
  GameInitializer (Assets\Scripts\Core/) L2032
  InitializationManager (Assets\Scripts\Core/) L2050
  PixelPerfectSetup (Assets\Scripts\Core/) L2080
  SingletonMonoBehaviour (Assets\Scripts\Core/) L2121
  SortableEntity (Assets\Scripts\Core/) L2177
  UIManager (Assets\Scripts\Core/) L2244
  WeatherManager (Assets\Scripts\Core/) L2478
  AnimalBehavior (Assets\Scripts\Ecosystem\Animals/) L2678
  AnimalController (Assets\Scripts\Ecosystem\Animals/) L2731
  AnimalDefinition (Assets\Scripts\Ecosystem\Animals/) L3010
  AnimalLibrary (Assets\Scripts\Ecosystem\Animals/) L3096
  AnimalMovement (Assets\Scripts\Ecosystem\Animals/) L3105
  AnimalNeeds (Assets\Scripts\Ecosystem\Animals/) L3493
  AnimalSpawnData (Assets\Scripts\Ecosystem\Animals/) L3640
  AnimalThoughtLibrary (Assets\Scripts\Ecosystem\Animals/) L3653
  FireflyController (Assets\Scripts\Ecosystem\Effects/) L3690
  FireflyDefinition (Assets\Scripts\Ecosystem\Effects/) L4000
  FireflyManager (Assets\Scripts\Ecosystem\Effects/) L4031
  PoopController (Assets\Scripts\Ecosystem\Environment/) L4295
  ScentDefinition (Assets\Scripts\Ecosystem\Environment/) L4388
  ScentLibrary (Assets\Scripts\Ecosystem\Environment/) L4403
  ScentSource (Assets\Scripts\Ecosystem\Environment/) L4422
  DietPreferenceSimplified (Assets\Scripts\Ecosystem\Food/) L4506
  FoodItem (Assets\Scripts\Ecosystem\Food/) L4582
  FoodType (Assets\Scripts\Ecosystem\Food/) L4648
  EcosystemManager (Assets\Scripts\Ecosystem\Management/) L4661
  FloraManager (Assets\Scripts\Ecosystem\Management/) L4683
  WaveManager (Assets\Scripts\Ecosystem\Management/) L4702
  WaveSpawnEntry (Assets\Scripts\Ecosystem\Spawning/) L5007
  EnvironmentalStatusEffectSystem (Assets\Scripts\Ecosystem\Status Effects/) L5036
  IStatusEffectable (Assets\Scripts\Ecosystem\Status Effects/) L5174
  StatusEffect (Assets\Scripts\Ecosystem\Status Effects/) L5192
  StatusEffectIconUI (Assets\Scripts\Ecosystem\Status Effects/) L5230
  StatusEffectInstance (Assets\Scripts\Ecosystem\Status Effects/) L5278
  StatusEffectManager (Assets\Scripts\Ecosystem\Status Effects/) L5296
  StatusEffectUIManager (Assets\Scripts\Ecosystem\Status Effects/) L5422
  ThoughtBubbleController (Assets\Scripts\Ecosystem\UI/) L5533
  ThoughtTrigger (Assets\Scripts\Ecosystem\UI/) L5580
  RadiusPatternTesterEditor (Assets\Scripts\Editor/) L5593
  TileDefinitionEditor (Assets\Scripts\Editor/) L5654
  TileInteractionManagerEditor (Assets\Scripts\Editor/) L5674
  WaveDefinitionEditor (Assets\Scripts\Editor/) L5709
  WaveManagerEditor (Assets\Scripts\Editor/) L5846
  GeneLibraryLoader (Assets\Scripts\Genes\Core/) L6021
  ITriggerTarget (Assets\Scripts\PlantSystem\Data/) L6047
  LeafData (Assets\Scripts\PlantSystem\Data/) L6055
  NodeExecutor (Assets\Scripts\PlantSystem\Execution/) L6070
  PlantCell (Assets\Scripts\PlantSystem\Growth/) L6113
  PlantCellManager (Assets\Scripts\PlantSystem\Growth/) L6134
  PlantEnergySystem (Assets\Scripts\PlantSystem\Growth/) L6248
  PlantGrowthLogic (Assets\Scripts\PlantSystem\Growth/) L6307
  PlantVisualManager (Assets\Scripts\PlantSystem\Growth/) L6351
  InventoryBarController (Assets\Scripts\PlantSystem\UI/) L6414
  InventoryBarItem (Assets\Scripts\PlantSystem\UI/) L6584
  InventoryColorManager (Assets\Scripts\PlantSystem\UI/) L6656
  InventoryGridController (Assets\Scripts\PlantSystem\UI/) L6716
  OutlinePartController (Assets\Scripts\PlantSystem\Visual/) L6829
  PlantOutlineController (Assets\Scripts\PlantSystem\Visual/) L6935
  PlantShadowController (Assets\Scripts\PlantSystem\Visual/) L7083
  ShadowPartController (Assets\Scripts\PlantSystem\Visual/) L7181
  GridDebugVisualizer (Assets\Scripts\Ticks/) L7282
  GridSnapStartup (Assets\Scripts\Ticks/) L7521
  TickDebugMonitor (Assets\Scripts\Ticks/) L7588
  TooltipTrigger (Assets\Scripts\UI\Tooltips/) L7624
  ITooltipDataProvider (Assets\Scripts\UI\Tooltips/) L7682
  ColorExtensions (Assets\Scripts\UI\Utilities/) L7913
  PrefabOrigin (Assets\Scripts\UI\Utilities/) L7924
  NightColorPostProcess (Assets\Scripts\Visual\Effects/) L7953
  RuntimeCircleDrawer (Assets\Scripts\Visual\Effects/) L8049
  WaterReflection (Assets\Scripts\Visual\Effects/) L8154
  WaterReflectionManager (Assets\Scripts\Visual\Effects/) L8551
  PlantGrowthModifierManager (Assets\Scripts\WorldInteraction\Placement/) L8587
  PlantPlacementManager (Assets\Scripts\WorldInteraction\Placement/) L8753
  PlayerTileInteractor (Assets\Scripts\WorldInteraction\Placement/) L8833
  GardenerController (Assets\Scripts\WorldInteraction\Player/) L8944
  HarvestableTag (Assets\Scripts\WorldInteraction\Player/) L9118
  HarvestedItem (Assets\Scripts\WorldInteraction\Player/) L9126
  HungerUI (Assets\Scripts\WorldInteraction\Player/) L9155
  PlayerActionManager (Assets\Scripts\WorldInteraction\Player/) L9202
  PlayerHungerSystem (Assets\Scripts\WorldInteraction\Player/) L9360
  TileDefinition (Assets\Scripts\WorldInteraction\Tiles/) L9422
  TileHoverColorManager (Assets\Scripts\WorldInteraction\Tiles/) L9462
  ToolRefillRule (Assets\Scripts\WorldInteraction\Tiles/) L9486
  TileInteractionManager (Assets\Scripts\WorldInteraction\Tiles/) L9506
  TileInteractionRule (Assets\Scripts\WorldInteraction\Tiles/) L9819
  ToolDefinition (Assets\Scripts\WorldInteraction\Tools/) L9831
  ToolSwitcher (Assets\Scripts\WorldInteraction\Tools/) L9866
  ToolType (Assets\Scripts\WorldInteraction\Tools/) L10041

[WegoSystem]
  RunManager (Assets\Scripts\Core/) L10052
  GridEntity (Assets\Scripts\Ticks/) L10188
  GridPosition (Assets\Scripts\Ticks/) L10345
  GridPositionManager (Assets\Scripts\Ticks/) L10446
  GridRadiusUtility (Assets\Scripts\Ticks/) L10783
  TickConfiguration (Assets\Scripts\Ticks/) L10927
  ITickUpdateable (Assets\Scripts\Ticks/) L11010

[for]
  FaunaManager (Assets\Scripts\Ecosystem\Management/) L11162

[namespace]
  GeneEventBus (Assets\Scripts\Genes\Services/) L11387

================================================================================
SCRIPTS
================================================================================

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\GeneLibrary.cs

﻿// REWORKED FILE: Assets/Scripts/Genes/GeneLibrary.cs
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Core;

namespace Abracodabra.Genes {
pub cls GeneLibrary : ScriptableObject, IGeneLibrary {
pub stat GeneLibrary Instance { get; set; }

pub void SetActiveInstance() {
if (Instance != null && Instance != this) {
Debug.LogWarning("An existing GeneLibrary instance was already active. It is being overwritten.", this);
}
Instance = this;
Initialize();
}

pub List<PassiveGene> passiveGenes = new List<PassiveGene>();
pub List<ActiveGene> activeGenes = new List<ActiveGene>();
pub List<ModifierGene> modifierGenes = new List<ModifierGene>();
pub List<PayloadGene> payloadGenes = new List<PayloadGene>();

pub List<GeneBase> starterGenes = new List<GeneBase>();
pub PlaceholderGene placeholderGene;

Dictionary<string, GeneBase> _guidLookup;
Dictionary<string, GeneBase> _nameLookup;

void Initialize() {
BuildLookupCaches();
}

void BuildLookupCaches() {
_guidLookup = new Dictionary<string, GeneBase>();
_nameLookup = new Dictionary<string, GeneBase>();

foreach (var gene in GetAllGenes()) {
if (gene == null) continue;
if (!string.IsNullOrEmpty(gene.GUID) && !_guidLookup.ContainsKey(gene.GUID))
_guidLookup[gene.GUID] = gene;
if (!string.IsNullOrEmpty(gene.geneName) && !_nameLookup.ContainsKey(gene.geneName))
_nameLookup[gene.geneName] = gene;
}
}

pub IEnumerable<GeneBase> GetAllGenes() {
foreach (var g in passiveGenes) if (g != null) yield ret g;
foreach (var g in activeGenes) if (g != null) yield ret g;
foreach (var g in modifierGenes) if (g != null) yield ret g;
foreach (var g in payloadGenes) if (g != null) yield ret g;
}

pub GeneBase GetGeneByGUID(string guid) {
if (string.IsNullOrEmpty(guid)) ret null;
if (_guidLookup == null) BuildLookupCaches();
ret _guidLookup.TryGetValue(guid, out var gene) ? gene : null;
}

pub GeneBase GetGeneByName(string name) {
if (string.IsNullOrEmpty(name)) ret null;
if (_nameLookup == null) BuildLookupCaches();
ret _nameLookup.TryGetValue(name, out var gene) ? gene : null;
}

pub GeneBase GetPlaceholderGene() {
if (placeholderGene == null) {
Debug.LogError("PlaceholderGene is not assigned in the GeneLibrary asset!");
placeholderGene = ScriptableObject.CreateInstance<PlaceholderGene>();
placeholderGene.name = "RUNTIME_PLACEHOLDER";
}
ret placeholderGene;
}

pub List<GeneBase> GetGenesOfCategory(GeneCategory category) {
switch (category) {
case GeneCategory.Passive: ret passiveGenes.Cast<GeneBase>().ToList();
case GeneCategory.Active: ret activeGenes.Cast<GeneBase>().ToList();
case GeneCategory.Modifier: ret modifierGenes.Cast<GeneBase>().ToList();
case GeneCategory.Payload: ret payloadGenes.Cast<GeneBase>().ToList();
default: ret new List<GeneBase>();
}
}

#if UNITY_EDITOR
void AutoPopulate() {
passiveGenes.Clear();
activeGenes.Clear();
modifierGenes.Clear();
payloadGenes.Clear();

string[] guids = UnityEditor.AssetDatabase.FindAssets("t:GeneBase");
foreach (string guid in guids) {
string path = UnityEditor.AssetDatabase.GUIDToAssetPath(guid);
GeneBase gene = UnityEditor.AssetDatabase.LoadAssetAtPath<GeneBase>(path);

if (gene is PlaceholderGene) continue;

if (gene is PassiveGene p)
passiveGenes.Add(p);
else if (gene is ActiveGene a)
activeGenes.Add(a);
else if (gene is ModifierGene m)
modifierGenes.Add(m);
else if (gene is PayloadGene pay)
payloadGenes.Add(pay);
}

UnityEditor.EditorUtility.SetDirty(this);
Debug.Log($"Auto-populated library: {passiveGenes.Count} passive, {activeGenes.Count} active, {modifierGenes.Count} modifier, {payloadGenes.Count} payload genes.");
}
#endif
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\PlantSequenceExecutor.cs

﻿// File: Assets/Scripts/Genes/PlantSequenceExecutor.cs
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;

namespace Abracodabra.Genes {
pub cls PlantSequenceExecutor : MonoBehaviour {
pub PlantGrowth plantGrowth;
pub PlantGeneRuntimeState runtimeState;

pub float tickInterval = 1f;
pub bool isPaused = false;

Coroutine executionCoroutine;
IGeneEventBus eventBus;
IDeterministicRandom random;

void Awake() {
eventBus = GeneServices.Get<IGeneEventBus>();
random = GeneServices.Get<IDeterministicRandom>();
}

void Start() {
if (plantGrowth == null)
plantGrowth = GetComponent<PlantGrowth>();
}

pub void InitializeWithTemplate(SeedTemplate template) {
runtimeState = template.CreateRuntimeState();
ApplyPassiveGenes();
StartExecution();
}

void ApplyPassiveGenes() {
if (runtimeState == null) return;

foreach (var instance in runtimeState.passiveInstances) {
var passive = instance.GetGene<PassiveGene>();
if (passive != null && passive.MeetsRequirements(plantGrowth)) {
passive.ApplyToPlant(plantGrowth, instance);
Debug.Log($"Applied passive gene: {passive.geneName} to {plantGrowth.name}");
}
}
}

pub void StartExecution() {
if (executionCoroutine != null)
StopCoroutine(executionCoroutine);

executionCoroutine = StartCoroutine(ExecutionLoop());
}

IEnumerator ExecutionLoop() {
yield ret null;

while (true) {
yield ret new WaitForSeconds(tickInterval);

if (isPaused || runtimeState == null || runtimeState.template == null || plantGrowth == null)
continue;

var energySystem = plantGrowth.EnergySystem;
if (energySystem == null)
continue;

if (runtimeState.rechargeTicksRemaining > 0) {
runtimeState.rechargeTicksRemaining--;
continue;
}

if (TryExecuteCurrentSlot()) {
runtimeState.currentPosition++;

if (runtimeState.currentPosition >= runtimeState.activeSequence.Count) {
OnSequenceComplete();
}
}
}
}

bool TryExecuteCurrentSlot() {
if (runtimeState.currentPosition >= runtimeState.activeSequence.Count)
ret false;

var slot = runtimeState.activeSequence[runtimeState.currentPosition];
if (!slot.HasContent) ret true; // Skip empty slots and advance

var activeGene = slot.activeInstance.GetGene<ActiveGene>();
if (activeGene == null) {
Debug.LogError("Active gene instance has a null gene reference!", this);
ret true; // Skip broken slots
}

float energyCost = slot.GetEnergyCost();
var energySystem = plantGrowth.EnergySystem;

if (!energySystem.HasEnergy(energyCost)) {
eventBus?.Publish(new GeneValidationFailedEvent {
GeneId = activeGene.GUID,
Reason = $"Insufficient energy. Has {energySystem.CurrentEnergy}, needs {energyCost}."
});
ret false; // Not enough energy, try again next tick
}

var context = new ActiveGeneContext {
plant = plantGrowth,
activeInstance = slot.activeInstance,
modifiers = slot.modifierInstances,
payloads = slot.payloadInstances,
sequencePosition = runtimeState.currentPosition,
executor = this,
random = random
};

foreach (var modInstance in slot.modifierInstances) {
modInstance.GetGene<ModifierGene>()?.PreExecution(context);
}

slot.isExecuting = true;
activeGene.Execute(context);
energySystem.SpendEnergy(energyCost);

foreach (var modInstance in slot.modifierInstances) {
modInstance.GetGene<ModifierGene>()?.PostExecution(context);
}

eventBus?.Publish(new GeneExecutedEvent {
Gene = activeGene,
SequencePosition = runtimeState.currentPosition,
Success = true,
EnergyCost = energyCost
});

StartCoroutine(ClearExecutionFlag(slot));

ret true;
}

IEnumerator ClearExecutionFlag(RuntimeSequenceSlot slot) {
yield ret new WaitForSeconds(0.5f);
slot.isExecuting = false;
}

void OnSequenceComplete() {
var energySystem = plantGrowth.EnergySystem;

eventBus?.Publish(new SequenceCompletedEvent {
TotalSlotsExecuted = runtimeState.activeSequence.Count,
TotalEnergyUsed = energySystem.MaxEnergy - energySystem.CurrentEnergy
});

runtimeState.currentPosition = 0;
runtimeState.rechargeTicksRemaining = runtimeState.template.baseRechargeTime;
}

pub void PauseExecution() => isPaused = true;
pub void ResumeExecution() => isPaused = false;

void OnDestroy() {
if (executionCoroutine != null)
StopCoroutine(executionCoroutine);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantGrowth.cs

﻿// REWORKED FILE: Assets/Scripts/PlantSystem/Growth/PlantGrowth.cs
using WegoSystem;
using Abracodabra.Genes;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Core;

namespace Abracodabra.Genes {
pub enum PlantState {
Initializing,
Growing,
Mature
}

pub cls PlantGrowth : MonoBehaviour, ITickUpdateable {
pub stat ro List<PlantGrowth> AllActivePlants = new List<PlantGrowth>();

pub SeedTemplate seedTemplate;
pub PlantGeneRuntimeState geneRuntimeState { get; set; }
pub PlantSequenceExecutor sequenceExecutor { get; set; }

pub PlantCellManager CellManager { get; set; }
pub PlantGrowthLogic GrowthLogic { get; set; }
pub PlantEnergySystem EnergySystem { get; set; }
pub PlantVisualManager VisualManager { get; set; }

[SerializeField] pub float cellSpacing = 0.08f;
[SerializeField] GameObject seedCellPrefab;
[SerializeField] GameObject stemCellPrefab;
[SerializeField] GameObject leafCellPrefab;
[SerializeField] GameObject berryCellPrefab;
[SerializeField] PlantShadowController shadowController;
[SerializeField] PlantOutlineController outlineController;
[SerializeField] GameObject outlinePartPrefab;
[SerializeField] bool enableOutline = true;

pub float growthSpeedMultiplier = 1f;
pub float energyGenerationMultiplier = 1f;
pub float energyStorageMultiplier = 1f;
pub float fruitYieldMultiplier = 1f;
pub float poopAbsorptionRadius = 3f;
pub float poopAbsorptionEfficiency = 1f;
pub int minHeight = 3;
pub int maxHeight = 5;
pub int leafDensity = 2;
pub int leafGap = 1;

pub PlantState CurrentState { get; set; } = PlantState.Initializing;

void Awake() {
AllActivePlants.Add(this);
CellManager = new PlantCellManager(this, seedCellPrefab, stemCellPrefab, leafCellPrefab, berryCellPrefab, cellSpacing);
GrowthLogic = new PlantGrowthLogic(this);
EnergySystem = new PlantEnergySystem(this);
VisualManager = new PlantVisualManager(this, shadowController, null, outlineController, outlinePartPrefab, enableOutline);
}

void OnDestroy() {
AllActivePlants.Remove(this);
var tickManager = TickManager.Instance;
if (tickManager != null) { tickManager.UnregisterTickUpdateable(this); }
}

pub void InitializeFromTemplate(SeedTemplate template) {
if (template == null) {
Debug.LogError($"Cannot initialize plant on '{gameObject.name}': Provided SeedTemplate is null.", this);
Destroy(gameObject);
return;
}

this.seedTemplate = template;
geneRuntimeState = template.CreateRuntimeState();

EnergySystem.MaxEnergy = geneRuntimeState.maxEnergy * energyStorageMultiplier;
EnergySystem.CurrentEnergy = EnergySystem.MaxEnergy;

GrowthLogic.PhotosynthesisEfficiencyPerLeaf = template.energyRegenRate * energyGenerationMultiplier;
GrowthLogic.TargetStemLength = minHeight; // Will be modified by passive genes

sequenceExecutor = GetComponent<PlantSequenceExecutor>();
if (sequenceExecutor == null) {
sequenceExecutor = gameObject.AddComponent<PlantSequenceExecutor>();
}

sequenceExecutor.plantGrowth = this;
sequenceExecutor.InitializeWithTemplate(template);

GrowthLogic.CalculateAndApplyPassiveStats();

CellManager.SpawnCellVisual(PlantCellType.Seed, Vector2Int.zero);

CurrentState = PlantState.Growing;

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}

Debug.Log($"Plant '{gameObject.name}' initialized from template '{template.templateName}'. State: {CurrentState}");
}

pub void OnTickUpdate(int currentTick) {
EnergySystem.OnTickUpdate();

if (CurrentState == PlantState.Growing && CellManager.cells.Count < maxHeight * 2) {
if (Random.value < 0.1f * growthSpeedMultiplier) {
GrowSomething();
}
}
}

void GrowSomething() {
int currentHeight = CellManager.cells.Count(c => c.Value == PlantCellType.Stem);
if (currentHeight < maxHeight) {
CellManager.SpawnCellVisual(PlantCellType.Stem, new Vector2Int(0, currentHeight + 1));

if (currentHeight % leafGap == 0) {
for (int i = 0; i < leafDensity; i++) {
int xOffset = (i % 2 == 0) ? -1 : 1;
var leafPos = new Vector2Int(xOffset, currentHeight + 1);
var leafObj = CellManager.SpawnCellVisual(PlantCellType.Leaf, leafPos);

if (leafObj != null) {
leafObj.tag = "FruitSpawn";
}
}
}
}
else {
CurrentState = PlantState.Mature;
}
}

pub void HandleBeingEaten(AnimalController eater, PlantCell eatenCell) {
Debug.Log($"{eater.SpeciesName} ate cell at {eatenCell.GridCoord} on plant {name}");
}

pub void ReportCellDestroyed(Vector2Int coord) {
CellManager?.ReportCellDestroyed(coord);
}

pub GameObject GetCellGameObjectAt(Vector2Int coord) {
ret CellManager?.GetCellGameObjectAt(coord);
}

pub Transform[] GetFruitSpawnPoints() {
ret GetComponentsInChildren<Transform>()
.Where(t => t.CompareTag("FruitSpawn"))
.ToArray();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Components\Creature.cs

﻿// File: Assets/Scripts/Genes/Components/Creature.cs

namespace Abracodabra.Genes.Components {
pub cls Creature : MonoBehaviour {
pub void Feed(float amount) {
Debug.Log($"{name} was fed for {amount} nutrition points.", this);
var animalNeeds = GetComponent<AnimalNeeds>();
if (animalNeeds != null) {
animalNeeds.ModifyHunger(-amount); // Negative amount to reduce hunger
}
}

pub void Heal(float amount) {
Debug.Log($"{name} was healed for {amount} HP.", this);
var animalNeeds = GetComponent<AnimalNeeds>();
if (animalNeeds != null) {
animalNeeds.Heal(amount);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Components\Fruit.cs

﻿// File: Assets/Scripts/Genes/Components/Fruit.cs
using Abracodabra.Genes.Core;

namespace Abracodabra.Genes.Components {
pub cls Fruit : MonoBehaviour {
pub PlantGrowth SourcePlant { get; set; }
pub float GrowthTime { get; set; }

pub void LaunchImmediate(Vector2 force) {
var rb = GetComponent<Rigidbody2D>() ?? gameObject.AddComponent<Rigidbody2D>();
rb.AddForce(force, ForceMode2D.Impulse);
}

pub void StartGrowing() {
Debug.Log($"Fruit '{gameObject.name}' has started growing for {GrowthTime}s.", this);
}

pub void AddVisualEffect(Color color) {
var renderer = GetComponent<SpriteRenderer>();
if (renderer != null) {
renderer.color = Color.Lerp(renderer.color, color, 0.5f);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Components\NutritionComponent.cs

﻿// File: Assets/Scripts/Genes/Components/NutritionComponent.cs

namespace Abracodabra.Genes.Components {
pub cls NutritionComponent : MonoBehaviour {
pub float nutritionValue;
pub float healAmount;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\ActiveGene.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
pub abs cls ActiveGene : GeneBase {
pub ovr GeneCategory Category => GeneCategory.Active;

pub float baseEnergyCost = 20f;
pub ActiveGeneSlotConfig slotConfig = new ActiveGeneSlotConfig();
pub bool canExecuteEmpty = false;

pub float executionDelay = 0f;
pub bool requiresTarget = false;

pub virt bool IsValidConfiguration(List<ModifierGene> modifiers, List<PayloadGene> payloads) {
if (!canExecuteEmpty && payloads.Count == 0)
ret false;
ret true;
}

pub virt bool CanExecuteNow(PlantGrowth plant, float availableEnergy) {
ret availableEnergy >= baseEnergyCost;
}

pub float GetFinalEnergyCost(List<RuntimeGeneInstance> modifiers) {
float cost = baseEnergyCost;
foreach (var modInstance in modifiers) {
var modifier = modInstance.GetGene<ModifierGene>();
if (modifier != null)
cost = modifier.ModifyEnergyCost(cost, modInstance);
}
ret Mathf.Max(0, cost);
}

pub abs void Execute(ActiveGeneContext context);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\ModifierGene.cs

﻿// File: Assets/Scripts/Genes/Core/ModifierGene.cs
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
pub abs cls ModifierGene : GeneBase {
pub ovr GeneCategory Category => GeneCategory.Modifier;

pub ModifierType modifierType;
pub float power = 1f;

pub virt float ModifyEnergyCost(float baseCost, RuntimeGeneInstance instance) => baseCost;
pub virt void PreExecution(ActiveGeneContext context) { }
pub virt void PostExecution(ActiveGeneContext context) { }
pub virt bool ModifyTriggerCondition(ActiveGene gene, PlantGrowth plant) => true;

pub ovr bool CanAttachTo(GeneBase other) {
ret other.Category == GeneCategory.Active;
}
}

pub enum ModifierType {
Cost,       // Affects energy consumption
Trigger,    // Changes when active executes
Behavior,   // Multi-cast, spread, etc.
Condition   // Adds requirements
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\PassiveGene.cs

﻿// File: Assets/Scripts/Genes/Core/PassiveGene.cs
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
pub abs cls PassiveGene : GeneBase {
pub ovr GeneCategory Category => GeneCategory.Passive;

pub bool stacksAdditively = true;
pub float baseValue = 1f;
pub int maxStacks = -1; // -1 for unlimited

pub abs void ApplyToPlant(PlantGrowth plant, RuntimeGeneInstance instance);

pub abs string GetStatModificationText();

pub virt bool MeetsRequirements(PlantGrowth plant) => true;

pub virt bool IsCompatibleWith(PassiveGene other) => true;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\PayloadGene.cs

﻿// File: Assets/Scripts/Genes/Core/PayloadGene.cs
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Components; // FIX: Added using statement for Fruit

namespace Abracodabra.Genes.Core {
pub abs cls PayloadGene : GeneBase {
pub ovr GeneCategory Category => GeneCategory.Payload;

pub PayloadType payloadType;
pub float basePotency = 1f;

pub abs void ApplyPayload(PayloadContext context);

pub virt void ConfigureFruit(Fruit fruit, RuntimeGeneInstance instance) { }

pub virt void ApplyToTarget(GameObject target, RuntimeGeneInstance instance) { }

pub ovr bool CanAttachTo(GeneBase other) {
ret other.Category == GeneCategory.Active;
}

pub float GetFinalPotency(RuntimeGeneInstance instance) {
if (instance == null) ret basePotency;
ret basePotency * instance.GetValue("potency_multiplier", 1f);
}
}

pub enum PayloadType {
Substance,  // Damage/status effects
Nutrition,  // Healing/hunger
Special     // Unique effects
}

pub cls PayloadContext {
pub GameObject target;
pub PlantGrowth source;
pub ActiveGene parentGene;
pub RuntimeGeneInstance payloadInstance;
pub float effectMultiplier = 1f;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\PlaceholderGene.cs

﻿// NEW FILE: Assets/Scripts/Genes/Core/PlaceholderGene.cs
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
pub cls PlaceholderGene : PassiveGene {
pub ovr void ApplyToPlant(PlantGrowth plant, RuntimeGeneInstance instance) {
}

pub ovr string GetStatModificationText() {
ret "Missing Gene";
}

pub ovr string GetTooltip(GeneTooltipContext context) {
ret "This gene could not be loaded. It may have been deleted or renamed.";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\SafeGeneLoader.cs

﻿// File: Assets/Scripts/Genes/Core/SafeGeneLoader.cs
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Core {
pub stat cls SafeGeneLoader {
pub stat GeneBase LoadGeneWithFallback(string guid, string fallbackName = null) {
var library = GeneServices.Get<IGeneLibrary>();
if (library == null) {
Debug.LogError("Gene Library service not available! Cannot load gene.");
ret null;
}

var gene = library.GetGeneByGUID(guid);
if (gene != null) ret gene;

if (!string.IsNullOrEmpty(fallbackName)) {
gene = library.GetGeneByName(fallbackName);
if (gene != null) {
Debug.LogWarning($"Gene with GUID '{guid}' not found, but a gene with the fallback name '{fallbackName}' was loaded instead. The original asset may have been deleted or its GUID changed.");
ret gene;
}
}

Debug.LogError($"Could not find gene with GUID '{guid}' or fallback name '{fallbackName}'. Returning placeholder.");
ret library.GetPlaceholderGene();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\GeneBase.cs

﻿// File: Assets/Scripts/Genes/Core/GeneBase.cs
using Abracodabra.Genes.Runtime; // For RuntimeGeneInstance in context

namespace Abracodabra.Genes.Core {
pub abs cls GeneBase : ScriptableObject, ITooltipDataProvider {
pub string geneName;
pub string description;
pub Sprite icon;
pub int tier = 1;

pub Color geneColor = Color.white;
pub GameObject effectPrefab;

string _persistentGUID;
int _version = 1;

pub string GUID {
get {
#if UNITY_EDITOR
if (string.IsNullOrEmpty(_persistentGUID)) {
_persistentGUID = System.Guid.NewGuid().ToString();
UnityEditor.EditorUtility.SetDirty(this);
}
#endif
ret _persistentGUID;
}
}

pub int Version => _version;
pub abs GeneCategory Category { get; }

pub abs string GetTooltip(GeneTooltipContext context);
pub string GetTooltipTitle() => geneName;
pub string GetTooltipDescription() => $"Tier {tier} {Category} Gene";
pub string GetTooltipDetails(object source = null) {
if (source is GeneTooltipContext context) {
ret GetTooltip(context);
}
ret description;
}

pub virt bool CanAttachTo(GeneBase other) => false;
pub virt void MigrateFromVersion(int oldVersion, GeneInstanceData instanceData) { }
}

pub enum GeneCategory {
Passive,
Active,
Modifier,
Payload
}

pub cls GeneTooltipContext {
pub PlantGrowth plant; // The plant the gene is on
pub bool showAdvanced; // Show detailed stats
pub RuntimeGeneInstance instance; // The specific instance with its current values
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Implementations\Active\BasicFruitGene.cs

﻿// File: Assets/Scripts/Genes/Implementations/Active/BasicFruitGene.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Components;

namespace Abracodabra.Genes.Implementations {
pub cls BasicFruitGene : ActiveGene {
pub GameObject fruitPrefab;
pub float growthTime = 2f;
pub int fruitCount = 1;
pub float launchForce = 5f;

pub ovr void Execute(ActiveGeneContext context) {
if (fruitPrefab == null) {
Debug.LogError($"BasicFruitGene '{geneName}' is missing its fruitPrefab!", this);
return;
}

var effectPool = GeneServices.Get<IGeneEffectPool>();
Transform[] fruitPoints = context.plant.GetFruitSpawnPoints();

if (fruitPoints.Length == 0) {
Debug.LogWarning($"Plant '{context.plant.name}' has no spawn points tagged 'FruitSpawn'. Cannot spawn fruit.", context.plant);
return;
}

bool isInstant = false;
foreach (var modInstance in context.modifiers) {
if (modInstance.GetGene<ModifierGene>()?.modifierType == ModifierType.Trigger) {
isInstant = true;
break;
}
}

int count = Mathf.Min(fruitCount, fruitPoints.Length);
for (int i = 0; i < count; i++) {
GameObject fruitObj = effectPool != null
? effectPool.GetEffect(fruitPrefab, fruitPoints[i].position, Quaternion.identity)
: Instantiate(fruitPrefab, fruitPoints[i].position, Quaternion.identity);

Fruit fruit = fruitObj.GetComponent<Fruit>();
if (fruit != null) {
ConfigureFruit(fruit, context);

if (isInstant) {
float angle = context.random.Range(0f, 360f);
Vector2 direction = Quaternion.Euler(0, 0, angle) * Vector2.up;
fruit.LaunchImmediate(direction.normalized * launchForce);
}
else {
fruit.StartGrowing();
}
}
}
}

void ConfigureFruit(Fruit fruit, ActiveGeneContext context) {
fruit.SourcePlant = context.plant;
fruit.GrowthTime = growthTime;

foreach (var payloadInstance in context.payloads) {
payloadInstance.GetGene<PayloadGene>()?.ConfigureFruit(fruit, payloadInstance);
}
}

pub ovr string GetTooltip(GeneTooltipContext context) {
ret $"{description}\n\n" +
$"Grows <b>{fruitCount}</b> fruit(s).\n" +
$"Growth Time: <b>{growthTime}s</b>\n" +
$"Energy Cost: <b>{baseEnergyCost}⚡</b>\n" +
$"Slots: <b>{slotConfig.modifierSlots}</b> Modifiers, <b>{slotConfig.payloadSlots}</b> Payloads";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Implementations\Modifier\CostReductionGene.cs

﻿// File: Assets/Scripts/Genes/Implementations/Modifier/CostReductionGene.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Implementations {
pub cls CostReductionGene : ModifierGene {
pub float costMultiplier = 0.75f; // i.e., 25% reduction

pub CostReductionGene() {
modifierType = ModifierType.Cost;
}

pub ovr float ModifyEnergyCost(float baseCost, RuntimeGeneInstance instance) {
float finalMultiplier = costMultiplier * instance.GetValue("efficiency", 1f);
ret baseCost * finalMultiplier;
}

pub ovr string GetTooltip(GeneTooltipContext context) {
float reduction = (1f - costMultiplier) * 100f;
ret $"{description}\n\n" +
$"Reduces the attached Active Gene's energy cost by <b>{reduction:F0}%</b>.";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Implementations\Passive\GrowthSpeedGene.cs

﻿// File: Assets/Scripts/Genes/Implementations/Passive/GrowthSpeedGene.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Implementations {
pub cls GrowthSpeedGene : PassiveGene {
pub float growthMultiplier = 1.5f;

pub ovr void ApplyToPlant(PlantGrowth plant, RuntimeGeneInstance instance) {
if (plant == null) return;

float finalMultiplier = growthMultiplier * instance.GetValue("power_multiplier", 1f);

plant.growthSpeedMultiplier *= finalMultiplier;

Debug.Log($"Applied Growth Speed Gene: {finalMultiplier}x modifier to {plant.name}. Total multiplier now: {plant.growthSpeedMultiplier}");
}

pub ovr string GetStatModificationText() {
float percentage = (growthMultiplier - 1f) * 100f;
ret percentage >= 0
? $"+{percentage:F0}% Growth Speed"
: $"{percentage:F0}% Growth Speed";
}

pub ovr string GetTooltip(GeneTooltipContext context) {
float finalMultiplier = growthMultiplier;
if (context.instance != null) {
finalMultiplier *= context.instance.GetValue("power_multiplier", 1f);
}

ret $"{description}\n\n" +
$"<b>Effect:</b> {GetStatModificationText()}\n" +
"Reduces the time required for the plant to reach maturity.";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Implementations\Payload\NutritiousPayload.cs

﻿// File: Assets/Scripts/Genes/Implementations/Payload/NutritiousPayload.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Components;

namespace Abracodabra.Genes.Implementations {
pub cls Creature : MonoBehaviour {
pub void Feed(float amount) { Debug.Log($"{name} was fed for {amount} nutrition."); }
pub void Heal(float amount) { Debug.Log($"{name} was healed for {amount} HP."); }
}

pub cls NutritionComponent : MonoBehaviour {
pub float nutritionValue;
pub float healAmount;
}

pub cls NutritiousPayload : PayloadGene {
pub float nutritionValue = 10f;
pub float healAmount = 5f;

pub NutritiousPayload() {
payloadType = PayloadType.Nutrition;
}

pub ovr void ApplyPayload(PayloadContext context) {
ApplyToTarget(context.target, context.payloadInstance);
}

pub ovr void ConfigureFruit(Fruit fruit, RuntimeGeneInstance instance) {
var nutrition = fruit.gameObject.GetComponent<NutritionComponent>() ?? fruit.gameObject.AddComponent<NutritionComponent>();
nutrition.nutritionValue = nutritionValue * GetFinalPotency(instance);
nutrition.healAmount = healAmount;

fruit.AddVisualEffect(geneColor);
}

pub ovr void ApplyToTarget(GameObject target, RuntimeGeneInstance instance) {
var creature = target.GetComponent<Creature>();
if (creature != null) {
float finalNutrition = nutritionValue * GetFinalPotency(instance);
creature.Feed(finalNutrition);
creature.Heal(healAmount);
}
}

pub ovr string GetTooltip(GeneTooltipContext context) {
float potency = 1f;
if (context.instance != null) {
potency = GetFinalPotency(context.instance);
}

ret $"{description}\n\n" +
$"Adds <b>{nutritionValue * potency:F0}</b> nutrition to the fruit.\n" +
$"Heals for <b>{healAmount:F0}</b> HP when consumed.";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Runtime\PlantGeneRuntimeState.cs

﻿// REWORKED FILE: Assets/Scripts/Genes/Runtime/PlantGeneRuntimeState.cs
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Core;

namespace Abracodabra.Genes.Runtime {
pub cls PlantGeneRuntimeState {
pub SeedTemplate template;

pub List<RuntimeGeneInstance> passiveInstances = new List<RuntimeGeneInstance>();
pub List<RuntimeSequenceSlot> activeSequence = new List<RuntimeSequenceSlot>();

[NonSerialized] pub int currentPosition = 0;
[NonSerialized] pub int rechargeTicksRemaining = 0;
[NonSerialized] pub bool isExecuting = false;
[NonSerialized] pub float currentEnergy;
[NonSerialized] pub float maxEnergy;

pub void InitializeFromTemplate() {
if (template == null) return;
passiveInstances.Clear();
foreach (var entry in template.passiveGenes) {
if (entry.gene == null) continue;
var instance = new RuntimeGeneInstance(entry.gene);
instance.SetValue("power_multiplier", entry.powerMultiplier);
passiveInstances.Add(instance);
}

activeSequence.Clear();
foreach (var slotTemplate in template.activeSequence) {
var slot = new RuntimeSequenceSlot();
slot.InitializeFromTemplate(slotTemplate);
activeSequence.Add(slot);
}

maxEnergy = template.maxEnergy;
currentEnergy = maxEnergy;
}

pub void Reset() {
currentPosition = 0;
rechargeTicksRemaining = 0;
isExecuting = false;
currentEnergy = maxEnergy;
}

pub float CalculateTotalEnergyCost() {
float total = 0;
foreach (var slot in activeSequence) {
if (slot.HasContent) {
total += slot.GetEnergyCost();
}
}
ret total;
}
}

pub cls RuntimeSequenceSlot {
pub RuntimeGeneInstance activeInstance;
pub List<RuntimeGeneInstance> modifierInstances = new List<RuntimeGeneInstance>();
pub List<RuntimeGeneInstance> payloadInstances = new List<RuntimeGeneInstance>();

[NonSerialized] pub bool isHighlighted;
[NonSerialized] pub bool isExecuting;

pub bool HasContent => activeInstance != null;

pub void InitializeFromTemplate(SequenceSlotTemplate template) {
if (template.activeGene != null)
activeInstance = new RuntimeGeneInstance(template.activeGene);

modifierInstances.Clear();
foreach (var mod in template.modifiers) {
if (mod == null) continue;
modifierInstances.Add(new RuntimeGeneInstance(mod));
}

payloadInstances.Clear();
foreach (var payload in template.payloads) {
if (payload == null) continue;
payloadInstances.Add(new RuntimeGeneInstance(payload));
}
}

pub float GetEnergyCost() {
var active = activeInstance?.GetGene<ActiveGene>();
if (active == null) ret 0;

ret active.GetFinalEnergyCost(modifierInstances);
}

pub void Clear() {
activeInstance = null;
modifierInstances.Clear();
payloadInstances.Clear();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Runtime\RuntimeGeneInstance.cs

﻿// File: Assets/Scripts/Genes/Runtime/RuntimeGeneInstance.cs
using Abracodabra.Genes.Core;

namespace Abracodabra.Genes.Runtime {
pub cls RuntimeGeneInstance : ISerializationCallbackReceiver {
[SerializeField] string geneGUID;
[SerializeField] string geneName; // Fallback for missing genes
[SerializeField] GeneInstanceData instanceData;

[NonSerialized] GeneBase cachedGene;

pub RuntimeGeneInstance(GeneBase sourceGene) {
if (sourceGene == null) {
Debug.LogError("Cannot create RuntimeGeneInstance from a null sourceGene!");
return;
}

geneGUID = sourceGene.GUID;
geneName = sourceGene.geneName;
instanceData = new GeneInstanceData();
cachedGene = sourceGene;
}

pub T GetGene<T>() where T : GeneBase {
if (cachedGene == null)
LoadGene();
ret cachedGene as T;
}

pub GeneBase GetGene() {
if (cachedGene == null)
LoadGene();
ret cachedGene;
}

void LoadGene() {
cachedGene = SafeGeneLoader.LoadGeneWithFallback(geneGUID, geneName);
if (cachedGene != null) {
if (instanceData.version < cachedGene.Version) {
cachedGene.MigrateFromVersion(instanceData.version, instanceData);
instanceData.version = cachedGene.Version;
}
}
}

pub float GetValue(string key, float defaultValue = 0f) {
ret instanceData.GetValue(key, defaultValue);
}

pub void SetValue(string key, float value) {
instanceData.SetValue(key, value);
}

pub void ModifyValue(string key, float delta) {
instanceData.ModifyValue(key, delta);
}

pub void OnBeforeSerialize() {
if (cachedGene != null) {
geneGUID = cachedGene.GUID;
geneName = cachedGene.geneName;

if (instanceData.version < cachedGene.Version) {
instanceData.version = cachedGene.Version;
}
}
}

pub void OnAfterDeserialize() {
cachedGene = null;
}
}

pub cls GeneInstanceData {
pub int version = 1;
pub Dictionary<string, float> values = new Dictionary<string, float>();
pub int stackCount = 1;
pub float powerMultiplier = 1f;

pub float GetValue(string key, float defaultValue = 0f) {
ret values.TryGetValue(key, out float value) ? value : defaultValue;
}

pub void SetValue(string key, float value) {
values[key] = value;
}

pub void ModifyValue(string key, float delta) {
if (values.ContainsKey(key))
values[key] += delta;
else
values[key] = delta;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Services\DeterministicRandom.cs

﻿// File: Assets/Scripts/Genes/Services/DeterministicRandom.cs

namespace Abracodabra.Genes.Services {
pub cls DeterministicRandom : IDeterministicRandom {
System.Random rng;
int currentSeed;

pub DeterministicRandom(int seed) {
SetSeed(seed);
}

pub void SetSeed(int seed) {
currentSeed = seed;
rng = new System.Random(seed);
}

pub float Range(float min, float max) {
ret (float)(rng.NextDouble() * (max - min) + min);
}

pub int Range(int min, int max) {
ret rng.Next(min, max);
}

pub void Reset() {
rng = new System.Random(currentSeed);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Services\GeneEffectPool.cs

﻿// File: Assets/Scripts/Genes/Services/GeneEffectPool.cs

namespace Abracodabra.Genes.Services {
pub cls GeneEffectPool : MonoBehaviour, IGeneEffectPool {
stat GeneEffectPool _instance;
pub stat GeneEffectPool Instance {
get {
if (_instance == null) {
var go = new GameObject("GeneEffectPool");
_instance = go.AddComponent<GeneEffectPool>();
DontDestroyOnLoad(go);
}
ret _instance;
}
}

Dictionary<GameObject, Queue<GameObject>> pools = new Dictionary<GameObject, Queue<GameObject>>();
Transform poolContainer;

void Awake() {
poolContainer = new GameObject("PooledEffects").transform;
poolContainer.SetParent(transform);
}

pub GameObject GetEffect(GameObject prefab, Vector3 position, Quaternion rotation) {
if (prefab == null) ret null;

if (!pools.ContainsKey(prefab))
pools[prefab] = new Queue<GameObject>();

GameObject effect;
if (pools[prefab].Count > 0) {
effect = pools[prefab].Dequeue();
effect.transform.SetPositionAndRotation(position, rotation);
effect.SetActive(true);
}
else {
effect = Instantiate(prefab, position, rotation);
var poolable = effect.AddComponent<PoolableEffect>();
poolable.sourcePrefab = prefab;
poolable.pool = this;
}

ret effect;
}

pub void ReturnEffect(GameObject effect, GameObject sourcePrefab) {
if (effect == null || sourcePrefab == null) return;

effect.SetActive(false);
effect.transform.SetParent(poolContainer);

if (!pools.ContainsKey(sourcePrefab))
pools[sourcePrefab] = new Queue<GameObject>();

pools[sourcePrefab].Enqueue(effect);
}

pub void PrewarmPool(GameObject prefab, int count) {
if (prefab == null || count <= 0) return;
var list = new List<GameObject>();
for (int i = 0; i < count; i++) {
var obj = GetEffect(prefab, Vector3.zero, Quaternion.identity);
list.Add(obj);
}

foreach (var obj in list) {
var poolable = obj.GetComponent<PoolableEffect>();
if (poolable != null)
ReturnEffect(obj, poolable.sourcePrefab);
}
}
}

pub cls PoolableEffect : MonoBehaviour {
pub GameObject sourcePrefab;
pub GeneEffectPool pool;
pub float lifetime = 2f;

void OnEnable() {
if (lifetime > 0)
Invoke(nameof(ReturnToPool), lifetime);
}

void OnDisable() {
CancelInvoke();
}

pub void ReturnToPool() {
if (pool != null && sourcePrefab != null)
pool.ReturnEffect(gameObject, sourcePrefab);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Services\GeneServices.cs

﻿// REWORKED FILE: Assets/Scripts/Genes/Services/GeneServices.cs
using Abracodabra.Genes.Core; // FIX: Added missing using statement for GeneBase

namespace Abracodabra.Genes.Services {
pub stat cls GeneServices {
stat Dictionary<Type, object> services = new Dictionary<Type, object>();
stat bool isInitialized = false;

pub stat void Initialize() {
if (isInitialized) return;

Register<IGeneEventBus>(new GeneEventBus());
Register<IDeterministicRandom>(new DeterministicRandom(DateTime.Now.Millisecond));

isInitialized = true;
Debug.Log("Core Gene Services initialized (EventBus, Random).");
}

pub stat void Register<T>(T service) where T : class {
services[typeof(T)] = service;
}

pub stat T Get<T>() where T : class {
if (!isInitialized) {
Debug.LogError("GeneServices not initialized! Call Initialize() first.");
ret null;
}

if (services.TryGetValue(typeof(T), out object service))
ret (T)service;

Debug.LogError($"Service {typeof(T)} not registered!");
ret null;
}

pub stat void Reset() {
services.Clear();
isInitialized = false;
}
}

pub ifc IGeneLibrary {
GeneBase GetGeneByGUID(string guid);
GeneBase GetGeneByName(string name);
GeneBase GetPlaceholderGene();
}

pub ifc IGeneEventBus {
void Subscribe<T>(Action<T> handler) where T : class;
void Unsubscribe<T>(Action<T> handler) where T : class;
void Publish<T>(T message) where T : class;
}

pub ifc IGeneEffectPool {
GameObject GetEffect(GameObject prefab, Vector3 position, Quaternion rotation);
void ReturnEffect(GameObject effect, GameObject sourcePrefab);
}

pub ifc IDeterministicRandom {
float Range(float min, float max);
int Range(int min, int max);
void SetSeed(int seed);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Templates\SeedTemplate.cs

﻿// File: Assets/Scripts/Genes/Templates/SeedTemplate.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.Genes.Templates {
pub cls SeedTemplate : ScriptableObject {
pub string templateName;
pub string description;
pub Sprite icon;

pub List<GeneTemplateEntry> passiveGenes = new List<GeneTemplateEntry>();
pub List<SequenceSlotTemplate> activeSequence = new List<SequenceSlotTemplate>();

pub int baseRechargeTime = 3;
pub float energyRegenRate = 10f;
pub float maxEnergy = 100f;

pub bool isUnlocked = true;
pub List<string> unlockRequirements = new List<string>();

pub bool IsValid() {
if (activeSequence.Count == 0) ret false;

foreach (var slot in activeSequence) {
if (slot.activeGene == null) ret false;
if (!slot.Validate()) ret false;
}

ret true;
}

pub PlantGeneRuntimeState CreateRuntimeState() {
var state = new PlantGeneRuntimeState();
state.template = this;
state.InitializeFromTemplate();
ret state;
}
}

pub cls GeneTemplateEntry {
pub GeneBase gene;
pub float powerMultiplier = 1f;
}

pub cls SequenceSlotTemplate {
pub ActiveGene activeGene;
pub List<ModifierGene> modifiers = new List<ModifierGene>();
pub List<PayloadGene> payloads = new List<PayloadGene>();

pub bool Validate() {
if (activeGene == null) ret false;

if (modifiers.Count > activeGene.slotConfig.modifierSlots) ret false;
if (payloads.Count > activeGene.slotConfig.payloadSlots) ret false;

ret activeGene.IsValidConfiguration(modifiers, payloads);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\UI\GeneSequenceUI.cs

﻿// REWORKED FILE: Assets/Scripts/UI/Genes/GeneSequenceUI.cs
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Core;
using Abracodabra.Genes; // FIX: Added missing using statement for PlantSequenceExecutor

namespace Abracodabra.UI.Genes {
pub cls GeneSequenceUI : MonoBehaviour {
pub Transform passiveGenesContainer;
pub Transform activeSequenceContainer;
pub GameObject sequenceRowPrefab;
pub GameObject passiveSlotPrefab;

pub TMPro.TextMeshProUGUI energyCostText;
pub TMPro.TextMeshProUGUI currentEnergyText;
pub TMPro.TextMeshProUGUI rechargeTimeText;
pub Slider rechargeProgress;
pub TMPro.TextMeshProUGUI validationMessage;

pub int maxPassiveSlots = 6;
pub int maxSequenceLength = 5;

PlantGeneRuntimeState runtimeState;
List<GeneSlotUI> passiveSlots = new List<GeneSlotUI>();
List<SequenceRowUI> sequenceRows = new List<SequenceRowUI>();
PlantSequenceExecutor executor;

void Start() {
InitializeUI();
}

void InitializeUI() {
for (int i = 0; i < maxPassiveSlots; i++) {
GameObject slotObj = Instantiate(passiveSlotPrefab, passiveGenesContainer);
GeneSlotUI slot = slotObj.GetComponent<GeneSlotUI>();
slot.acceptedCategory = GeneCategory.Passive;
slot.slotIndex = i;
passiveSlots.Add(slot);
}

for (int i = 0; i < maxSequenceLength; i++) {
GameObject rowObj = Instantiate(sequenceRowPrefab, activeSequenceContainer);
SequenceRowUI row = rowObj.GetComponent<SequenceRowUI>();
row.Initialize(i, this);
sequenceRows.Add(row);
}
}

pub void LoadRuntimeState(PlantGeneRuntimeState state) {
runtimeState = state;
if (state == null) return;

for (int i = 0; i < passiveSlots.Count; i++) {
if (i < state.passiveInstances.Count)
passiveSlots[i].SetGeneInstance(state.passiveInstances[i]);
else
passiveSlots[i].ClearSlot();
}

for (int i = 0; i < sequenceRows.Count; i++) {
if (i < state.activeSequence.Count)
sequenceRows[i].LoadSlot(state.activeSequence[i]);
else
sequenceRows[i].ClearRow();
}

UpdateDisplay();
}

pub void OnActiveGeneChanged(int rowIndex, ActiveGene gene) {
if (rowIndex >= 0 && rowIndex < sequenceRows.Count) {
sequenceRows[rowIndex].UpdateAttachmentSlots(gene);
}
UpdateDisplay();
}

pub ActiveGene GetActiveGeneForRow(int rowIndex) {
if (rowIndex >= 0 && rowIndex < sequenceRows.Count) {
ret sequenceRows[rowIndex].GetActiveGene();
}
ret null;
}

void UpdateDisplay() {
if (runtimeState == null) return;

float totalCost = runtimeState.CalculateTotalEnergyCost();
if(energyCostText != null) energyCostText.text = $"Cost: {totalCost:F0}⚡/cycle";
if(currentEnergyText != null) currentEnergyText.text = $"Energy: {runtimeState.currentEnergy:F0}/{runtimeState.maxEnergy:F0}";
if(rechargeTimeText != null) rechargeTimeText.text = $"Recharge: {runtimeState.template.baseRechargeTime} ticks";

bool isValid = ValidateConfiguration();
if(validationMessage != null) validationMessage.gameObject.SetActive(!isValid);
}

bool ValidateConfiguration() {
if (runtimeState == null) ret false;

bool hasActiveGene = false;
foreach (var slot in runtimeState.activeSequence) {
if (slot.HasContent) {
hasActiveGene = true;
break;
}
}

if (!hasActiveGene) {
if (validationMessage != null) validationMessage.text = "Sequence requires at least one Active Gene.";
ret false;
}

ret true;
}

pub void ConnectToExecutor(PlantSequenceExecutor exec) {
executor = exec;
}

void Update() {
if (executor != null && runtimeState != null && runtimeState.template != null) {
if (rechargeProgress != null && runtimeState.template.baseRechargeTime > 0) {
float progress = 1f - (runtimeState.rechargeTicksRemaining / (float)runtimeState.template.baseRechargeTime);
rechargeProgress.value = progress;
}

if (currentEnergyText != null) {
currentEnergyText.text = $"Energy: {runtimeState.currentEnergy:F0}/{runtimeState.maxEnergy:F0}";
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\UI\GeneSlotUI.cs

﻿// REWORKED FILE: Assets/Scripts/UI/Genes/GeneSlotUI.cs
using UnityEngine.EventSystems;
using System.Collections; // FIX: Added missing using statement for IEnumerator
using Abracodabra.Genes.Services;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.UI.Genes {
pub cls GeneSlotUI : MonoBehaviour, IDropHandler, IPointerEnterHandler, IPointerExitHandler, IBeginDragHandler, IDragHandler, IEndDragHandler {
pub GeneCategory acceptedCategory;
pub int slotIndex;
pub bool isLocked = false;
pub bool isDraggable = true;

pub Image slotBackground;
pub Image geneIcon;
pub TMPro.TextMeshProUGUI geneName;
pub GameObject emptyIndicator;
pub GameObject lockedOverlay;
pub GameObject invalidDropOverlay;
pub GameObject executingEffect;

pub Color normalColor = Color.white;
pub Color highlightColor = Color.yellow;
pub Color invalidColor = Color.red;
pub Color executingColor = Color.cyan;

RuntimeGeneInstance currentInstance;
GeneSequenceUI parentSequence;
IGeneEventBus eventBus;

GameObject draggedVisual;
Canvas canvas;

void Awake() {
parentSequence = GetComponentInParent<GeneSequenceUI>();
canvas = GetComponentInParent<Canvas>();
}

void Start() {
eventBus = GeneServices.Get<IGeneEventBus>();
if (eventBus == null) {
Debug.LogError("GeneEventBus service not found!", this);
}
}

void OnDestroy() {
eventBus?.Unsubscribe<GeneExecutedEvent>(OnGeneExecuted);
}

void OnEnable() {
eventBus?.Subscribe<GeneExecutedEvent>(OnGeneExecuted);
}

void OnDisable() {
eventBus?.Unsubscribe<GeneExecutedEvent>(OnGeneExecuted);
}

pub void SetGeneInstance(RuntimeGeneInstance instance) {
currentInstance = instance;
UpdateVisuals();

if (acceptedCategory == GeneCategory.Active && parentSequence != null) {
parentSequence.OnActiveGeneChanged(slotIndex, instance?.GetGene<ActiveGene>());
}
}

pub RuntimeGeneInstance GetGeneInstance() => currentInstance;

pub void ClearSlot() {
SetGeneInstance(null);
}

void UpdateVisuals() {
bool isEmpty = currentInstance == null;

if(emptyIndicator != null) emptyIndicator.SetActive(isEmpty);
if(geneIcon != null) geneIcon.gameObject.SetActive(!isEmpty);
if(geneName != null) geneName.gameObject.SetActive(!isEmpty);

if (!isEmpty) {
var gene = currentInstance.GetGene();
if (gene != null) {
if (geneIcon != null) geneIcon.sprite = gene.icon;
if (geneName != null) geneName.text = gene.geneName;
if (slotBackground != null) slotBackground.color = gene.geneColor;
}
}
else {
if (slotBackground != null) slotBackground.color = normalColor;
}

if(lockedOverlay != null) lockedOverlay.SetActive(isLocked);
}

pub void OnBeginDrag(PointerEventData eventData) {
if (!isDraggable || currentInstance == null || isLocked) {
eventData.pointerDrag = null; // Prevent drag
return;
}
CreateDragVisual();
}

pub void OnDrag(PointerEventData eventData) {
if (draggedVisual != null) {
draggedVisual.transform.position = eventData.position;
}
}

pub void OnEndDrag(PointerEventData eventData) {
if (draggedVisual != null) {
Destroy(draggedVisual);
draggedVisual = null;
}
}

pub void OnDrop(PointerEventData eventData) {
if (isLocked) return;

GeneSlotUI sourceSlot = eventData.pointerDrag?.GetComponent<GeneSlotUI>();
if (sourceSlot == null || sourceSlot == this) return;

var draggedInstance = sourceSlot.GetGeneInstance();
if (draggedInstance == null) return;

if (!CanAcceptGene(draggedInstance.GetGene())) {
ShowInvalidDropFeedback();
return;
}

var previousInstanceInThisSlot = currentInstance;
SetGeneInstance(draggedInstance);
sourceSlot.SetGeneInstance(previousInstanceInThisSlot);
}

bool CanAcceptGene(GeneBase gene) {
if (gene == null) ret false;
if (gene.Category != acceptedCategory) ret false;

if (acceptedCategory == GeneCategory.Modifier || acceptedCategory == GeneCategory.Payload) {
var parentActive = parentSequence?.GetActiveGeneForRow(slotIndex);
if (parentActive == null) ret false;
ret gene.CanAttachTo(parentActive);
}

ret true;
}

pub void OnPointerEnter(PointerEventData eventData) {
if (isLocked || slotBackground == null) return;

if (eventData.pointerDrag != null) {
var sourceSlot = eventData.pointerDrag.GetComponent<GeneSlotUI>();
if (sourceSlot != null) {
var gene = sourceSlot.GetGeneInstance()?.GetGene();
bool canAccept = gene != null && CanAcceptGene(gene);
slotBackground.color = canAccept ? highlightColor : invalidColor;
if (invalidDropOverlay != null) invalidDropOverlay.SetActive(!canAccept);
}
}
}

pub void OnPointerExit(PointerEventData eventData) {
UpdateVisuals();
if (invalidDropOverlay != null) invalidDropOverlay.SetActive(false);
}

void CreateDragVisual() {
if (canvas == null) return;
draggedVisual = new GameObject("DragVisual");
draggedVisual.transform.SetParent(canvas.transform, false);
draggedVisual.transform.SetAsLastSibling();

var image = draggedVisual.AddComponent<Image>();
image.sprite = geneIcon.sprite;
image.color = new Color(1, 1, 1, 0.7f);
image.raycastTarget = false;

var rect = draggedVisual.GetComponent<RectTransform>();
rect.sizeDelta = new Vector2(64, 64); // Or match source rect
}

void ShowInvalidDropFeedback() {
StartCoroutine(FlashColor(invalidColor));
}

IEnumerator FlashColor(Color flashColor) {
if (slotBackground == null) yield break;
Color originalColor = slotBackground.color;
slotBackground.color = flashColor;
yield ret new WaitForSeconds(0.3f);
slotBackground.color = originalColor;
UpdateVisuals();
}

void OnGeneExecuted(GeneExecutedEvent evt) {
if (currentInstance != null && currentInstance.GetGene()?.GUID == evt.Gene.GUID) {
ShowExecuting();
}
}

pub void ShowExecuting() {
if (executingEffect != null) executingEffect.SetActive(true);
if (slotBackground != null) slotBackground.color = executingColor;
Invoke(nameof(HideExecuting), 0.5f);
}

pub void HideExecuting() {
if (executingEffect != null) executingEffect.SetActive(false);
UpdateVisuals();
}
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\UI\SequenceRowUI.cs

﻿// File: Assets/Scripts/UI/Genes/SequenceRowUI.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.UI.Genes {
pub cls SequenceRowUI : MonoBehaviour {
pub GeneSlotUI modifierSlot;
pub GeneSlotUI activeSlot;
pub GeneSlotUI payloadSlot;

int rowIndex;
GeneSequenceUI parentSequence;

pub void Initialize(int index, GeneSequenceUI parent) {
rowIndex = index;
parentSequence = parent;

if (modifierSlot != null) {
modifierSlot.acceptedCategory = GeneCategory.Modifier;
modifierSlot.slotIndex = index;
}
if (activeSlot != null) {
activeSlot.acceptedCategory = GeneCategory.Active;
activeSlot.slotIndex = index;
}
if (payloadSlot != null) {
payloadSlot.acceptedCategory = GeneCategory.Payload;
payloadSlot.slotIndex = index;
}
}

pub void LoadSlot(RuntimeSequenceSlot slotData) {
activeSlot?.SetGeneInstance(slotData.activeInstance);
modifierSlot?.SetGeneInstance(slotData.modifierInstances.Count > 0 ? slotData.modifierInstances[0] : null);
payloadSlot?.SetGeneInstance(slotData.payloadInstances.Count > 0 ? slotData.payloadInstances[0] : null);
UpdateAttachmentSlots(GetActiveGene());
}

pub void ClearRow() {
modifierSlot?.ClearSlot();
activeSlot?.ClearSlot();
payloadSlot?.ClearSlot();
UpdateAttachmentSlots(null);
}

pub ActiveGene GetActiveGene() {
ret activeSlot?.GetGeneInstance()?.GetGene<ActiveGene>();
}

pub void UpdateAttachmentSlots(ActiveGene activeGene) {
bool hasActive = activeGene != null;
if (modifierSlot != null) {
modifierSlot.isLocked = !hasActive;
modifierSlot.gameObject.SetActive(hasActive && activeGene.slotConfig.modifierSlots > 0);
}
if (payloadSlot != null) {
payloadSlot.isLocked = !hasActive;
payloadSlot.gameObject.SetActive(hasActive && activeGene.slotConfig.payloadSlots > 0);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\ItemView.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/UI/ItemView.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;
using Abracodabra.Genes.Runtime;

namespace Abracodabra.UI.Genes {
pub cls ItemView : MonoBehaviour {
[SerializeField] Image thumbnailImage;
[SerializeField] Image backgroundImage;
[SerializeField] Sprite fallbackThumbnail;

GeneBase _gene;
RuntimeGeneInstance _runtimeInstance;
ToolDefinition _toolDefinition;
SeedTemplate _seedTemplate;

GeneSlotUI _parentSlot;
Color _originalBackgroundColor;

void Awake() {
_parentSlot = GetComponent<GeneSlotUI>();
}

pub void InitializeAsGene(RuntimeGeneInstance instance) {
_runtimeInstance = instance;
_gene = instance.GetGene();
_toolDefinition = null;
_seedTemplate = null;
SetupVisuals();
}

pub void InitializeAsTool(ToolDefinition toolDef) {
_runtimeInstance = null;
_gene = null;
_toolDefinition = toolDef;
_seedTemplate = null;
SetupVisuals();
}

pub void InitializeAsSeed(SeedTemplate seed) {
_runtimeInstance = null;
_gene = null;
_toolDefinition = null;
_seedTemplate = seed;
SetupVisuals();
}

void SetupVisuals() {
Sprite spriteToShow = fallbackThumbnail;
Color tintColor = Color.white;
_originalBackgroundColor = Color.gray;

if (_gene != null) {
spriteToShow = _gene.icon ?? fallbackThumbnail;
tintColor = _gene.geneColor;
_originalBackgroundColor = _gene.geneColor;
}
else if (_toolDefinition != null) {
spriteToShow = _toolDefinition.icon ?? fallbackThumbnail;
tintColor = _toolDefinition.iconTint;
_originalBackgroundColor = Color.gray; // Placeholder for tool color
}
else if (_seedTemplate != null) {
spriteToShow = _seedTemplate.icon ?? fallbackThumbnail;
tintColor = Color.white;
_originalBackgroundColor = Color.green; // Placeholder for seed color
}

if (thumbnailImage != null) {
thumbnailImage.sprite = spriteToShow;
thumbnailImage.color = tintColor;
thumbnailImage.enabled = (thumbnailImage.sprite != null);
}

if (backgroundImage != null) {
backgroundImage.color = _originalBackgroundColor;
}
}

pub GeneBase GetGene() => _gene;
pub RuntimeGeneInstance GetRuntimeInstance() => _runtimeInstance;
pub ToolDefinition GetToolDefinition() => _toolDefinition;
pub SeedTemplate GetSeedTemplate() => _seedTemplate;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\Events\GameEvent.cs

﻿// Assets/Scripts/Core/Events/GameEvent.cs

pub cls GameEvent : ScriptableObject {
ro List<IGameEventListener> _listeners = new List<IGameEventListener>();

pub void Raise() {
for (int i = _listeners.Count - 1; i >= 0; i--) {
_listeners[i].OnEventRaised();
}
}

pub void RegisterListener(IGameEventListener listener) {
if (!_listeners.Contains(listener)) {
_listeners.Add(listener);
}
}

pub void UnregisterListener(IGameEventListener listener) {
if (_listeners.Contains(listener)) {
_listeners.Remove(listener);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\Events\GameEventListener.cs

﻿// Assets/Scripts/Core/Events/GameEventListener.cs

pub cls GameEventListener : MonoBehaviour, IGameEventListener {
[SerializeField] GameEvent gameEvent;

[SerializeField] UnityEvent response;

void OnEnable() {
if (gameEvent != null) {
gameEvent.RegisterListener(this);
}
}

void OnDisable() {
if (gameEvent != null) {
gameEvent.UnregisterListener(this);
}
}

pub void OnEventRaised() {
response.Invoke();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\Events\IGameEventListener.cs

﻿// Assets/Scripts/Core/Events/IGameEventListener.cs
pub ifc IGameEventListener {
void OnEventRaised();
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\GameInitializer.cs

﻿// REWORKED FILE: Assets/Scripts/Core/GameInitializer.cs
using Abracodabra.Genes.Services;

pub cls GameInitializer : MonoBehaviour {
stat void InitializeServices() {
GeneServices.Initialize();
}

void Awake() {
if (GeneEffectPool.Instance == null) {
Debug.LogError("GeneEffectPool instance could not be created.");
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\InitializationManager.cs

﻿// Assets/Scripts/Core/InitializationManager.cs
using WegoSystem;

pub cls InitializationManager : SingletonMonoBehaviour<InitializationManager> {
[SerializeField] GameEvent onCoreSystemsInitialized;
[SerializeField] GameEvent onGameManagersInitialized;
[SerializeField] GameEvent onGameplaySystemsInitialized;

IEnumerator Start() {
Debug.Log("[InitializationManager] Starting initialization sequence...");

Debug.Log("[InitializationManager] Phase 1: Initializing Core Systems...");
onCoreSystemsInitialized.Raise();
yield ret null; // Wait one frame

Debug.Log("[InitializationManager] Phase 2: Initializing Game Managers...");
onGameManagersInitialized.Raise();
yield ret null; // Wait one frame

Debug.Log("[InitializationManager] Phase 3: Initializing Gameplay Systems & UI...");
onGameplaySystemsInitialized.Raise();
yield ret null; // Wait one frame

Debug.Log("[InitializationManager] All systems initialized successfully.");
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\PixelPerfectSetup.cs

﻿using UnityEngine;
using UnityEngine.U2D;

pub cls PixelPerfectSetup : MonoBehaviour {
[SerializeField] int referenceResolutionX = 320; // Your base game width
[SerializeField] int referenceResolutionY = 180; // Your base game height

[SerializeField] int pixelsPerUnit = 6; // Since 1 game pixel = 6x6 real pixels

PixelPerfectCamera pixelPerfectCamera;
Camera cam;

void Awake() {
cam = GetComponent<Camera>();
pixelPerfectCamera = GetComponent<PixelPerfectCamera>();

SetupPixelPerfectCamera();
}

void SetupPixelPerfectCamera() {
pixelPerfectCamera.assetsPPU = pixelsPerUnit;
pixelPerfectCamera.refResolutionX = referenceResolutionX;
pixelPerfectCamera.refResolutionY = referenceResolutionY;
pixelPerfectCamera.upscaleRT = true;
pixelPerfectCamera.pixelSnapping = true;
pixelPerfectCamera.cropFrameX = false;
pixelPerfectCamera.cropFrameY = false;
pixelPerfectCamera.stretchFill = false;

Debug.Log($"[PixelPerfectSetup] Configured for {referenceResolutionX}x{referenceResolutionY} at {pixelsPerUnit} PPU");
}

void Start() {
float expectedCameraSize = (float)referenceResolutionY / (2f * pixelsPerUnit);
Debug.Log($"[PixelPerfectSetup] Expected camera orthographic size: {expectedCameraSize}");
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\SingletonMonoBehaviour.cs

﻿// Assets/Scripts/Core/SingletonMonoBehaviour.cs

pub abs cls SingletonMonoBehaviour<T> : MonoBehaviour where T : MonoBehaviour {
stat T _instance;
stat ro object _lock = new object();
stat bool _applicationIsQuitting = false;

pub stat T Instance {
get {
if (_applicationIsQuitting) {
ret null;
}

lock (_lock) {
if (_instance == null) {
_instance = FindFirstObjectByType<T>();

if (_instance == null && Application.isPlaying) {
Debug.LogWarning($"[Singleton] Instance of '{typeof(T).Name}' not found. A new one will be created.");
GameObject singletonObject = new GameObject();
_instance = singletonObject.AddComponent<T>();
singletonObject.name = $"[Singleton] {typeof(T).Name}";
}
}
ret _instance;
}
}
}

pub stat bool HasInstance => _instance != null;

prot virt void Awake() {
if (_instance == null) {
_instance = this as T;
transform.SetParent(null);
DontDestroyOnLoad(gameObject);
}
else if (_instance != this) {
Debug.LogWarning($"[Singleton] Another instance of '{typeof(T).Name}' already exists. Destroying duplicate on '{gameObject.name}'.", gameObject);
Destroy(gameObject);
return;
}

OnAwake();
}

prot virt void OnAwake() { }

prot virt void OnApplicationQuit() {
_applicationIsQuitting = true;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\SortableEntity.cs

﻿using UnityEngine;

pub cls SortableEntity : MonoBehaviour {
[SerializeField] float sortingLayerYOffset = 0f;

[SerializeField] bool useParentYCoordinate = false;

pub bool debugSorting = false;

SpriteRenderer spriteRenderer;

void Awake() {
spriteRenderer = GetComponent<SpriteRenderer>();

if (spriteRenderer == null)
spriteRenderer = GetComponentInChildren<SpriteRenderer>();

if (spriteRenderer == null) {
Debug.LogWarning($"[SortableEntity] No SpriteRenderer found on {gameObject.name}");
}
}

void Start() {
UpdateSortingOrder();
}

void LateUpdate() {
UpdateSortingOrder();
}

pub void UpdateSortingOrder() {
if (spriteRenderer == null) return;

float yPositionForSorting = useParentYCoordinate && transform.parent != null
? transform.parent.position.y
: transform.position.y;

int sortOrder = CalculateSortOrder(yPositionForSorting);
spriteRenderer.sortingOrder = sortOrder;

if (debugSorting) {
Debug.Log($"[SortableEntity] {gameObject.name} - Y: {yPositionForSorting}, Offset: {sortingLayerYOffset}, Sort Order: {sortOrder}");
}
}

int CalculateSortOrder(float yPosition) {
ret Mathf.RoundToInt(-(yPosition + sortingLayerYOffset) * 1000f);
}

pub int GetCurrentSortOrder() {
if (spriteRenderer == null) ret 0;
ret spriteRenderer.sortingOrder;
}

pub void SetSortingOrder(int order) {
if (spriteRenderer != null)
spriteRenderer.sortingOrder = order;
}

pub void SetUseParentYCoordinate(bool value) {
useParentYCoordinate = value;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\UIManager.cs

﻿// Reworked File: Assets/Scripts/Core/UIManager.cs
using TMPro;
using WegoSystem;

pub cls UIManager : MonoBehaviour {
pub stat UIManager Instance { get; set; }

[SerializeField] GameObject planningPanel;
[SerializeField] GameObject growthAndThreatPanel;
[SerializeField] GameObject geneSequenceUIPanel; // Reworked reference

[SerializeField] Button startGrowthPhaseButton;
[SerializeField] Button startNewPlanningPhaseButton;
[SerializeField] Button endPlanningPhaseButton;
[SerializeField] Button advanceTickButton;

[SerializeField] GameObject wegoControlPanel;
[SerializeField] TextMeshProUGUI currentPhaseText;
[SerializeField] TextMeshProUGUI tickCounterText;
[SerializeField] TextMeshProUGUI persistentTickCounterText;
[SerializeField] TextMeshProUGUI phaseProgressText;

RunManager runManager;
TickManager tickManager;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

pub void Initialize() {
runManager = RunManager.Instance;
tickManager = TickManager.Instance;

if (runManager == null) {
Debug.LogError("[UIManager] RunManager.Instance not found! UI will not fn correctly.");
return;
}

runManager.OnRunStateChanged += HandleRunStateChanged;
runManager.OnPhaseChanged += HandlePhaseChanged;
runManager.OnRoundChanged += HandleRoundChanged;

if (tickManager != null) {
tickManager.OnTickAdvanced += HandleTickAdvanced;
}

SetupButtons();

HandleRunStateChanged(runManager.CurrentState);
UpdatePhaseDisplay();
UpdateTickDisplay();
}

void OnDestroy() {
if (runManager != null) {
runManager.OnRunStateChanged -= HandleRunStateChanged;
runManager.OnPhaseChanged -= HandlePhaseChanged;
runManager.OnRoundChanged -= HandleRoundChanged;
}

if (tickManager != null) {
tickManager.OnTickAdvanced -= HandleTickAdvanced;
}
}

void SetupButtons() {
startGrowthPhaseButton?.onClick.AddListener(OnStartGrowthPhaseClicked);
startNewPlanningPhaseButton?.onClick.AddListener(OnStartNewPlanningPhaseClicked);
endPlanningPhaseButton?.onClick.AddListener(OnEndPlanningPhaseClicked);
advanceTickButton?.onClick.AddListener(OnAdvanceTickClicked);
}

void HandleRunStateChanged(RunState newState) {
if (planningPanel != null)
planningPanel.SetActive(newState == RunState.Planning);

if (growthAndThreatPanel != null)
growthAndThreatPanel.SetActive(newState == RunState.GrowthAndThreat);

if (geneSequenceUIPanel != null)
geneSequenceUIPanel.SetActive(newState == RunState.Planning);

if (InventoryGridController.Instance != null) {
InventoryGridController.Instance.gameObject.SetActive(newState == RunState.Planning);
}

if (newState == RunState.GrowthAndThreat) {
if (InventoryBarController.Instance != null)
StartCoroutine(ShowInventoryBarDelayed());
}
else {
InventoryBarController.Instance?.HideBar();
}

UpdateButtonStates(newState);
}

void HandlePhaseChanged(GamePhase oldPhase, GamePhase newPhase) {
UpdatePhaseDisplay();
UpdateButtonStates(runManager.CurrentState);
}

void HandleRoundChanged(int newRound) { }

void HandleTickAdvanced(int currentTick) {
UpdateTickDisplay();
UpdatePhaseProgressDisplay();
}

void UpdatePhaseDisplay() {
if (currentPhaseText != null && runManager != null) {
currentPhaseText.text = $"Phase: {runManager.CurrentPhase}";
}
}

void UpdateTickDisplay() {
if (tickManager == null) return;
string tickInfo = $"Tick: {tickManager.CurrentTick}";
if (tickCounterText != null) tickCounterText.text = tickInfo;
if (persistentTickCounterText != null) persistentTickCounterText.text = tickInfo;
}

void UpdatePhaseProgressDisplay() {
if (phaseProgressText != null && runManager != null) {
phaseProgressText.text = $"Phase Ticks: {runManager.CurrentPhaseTicks}";
}
}

void UpdateButtonStates(RunState state) {
bool isPlanning = (state == RunState.Planning);
bool isPlanningPhase = (runManager?.CurrentPhase == GamePhase.Planning);

if (startGrowthPhaseButton != null)
startGrowthPhaseButton.interactable = isPlanning && isPlanningPhase;

if (startNewPlanningPhaseButton != null)
startNewPlanningPhaseButton.interactable = !isPlanning;

if (endPlanningPhaseButton != null)
endPlanningPhaseButton.interactable = isPlanning && isPlanningPhase;

if (advanceTickButton != null)
advanceTickButton.interactable = !isPlanningPhase;
}

void OnStartGrowthPhaseClicked() {
runManager?.StartGrowthAndThreatPhase();
}

void OnStartNewPlanningPhaseClicked() {
runManager?.StartNewPlanningPhase();
}

void OnEndPlanningPhaseClicked() {
runManager?.EndPlanningPhase();
}

void OnAdvanceTickClicked() {
tickManager?.DebugAdvanceTick();
}

IEnumerator ShowInventoryBarDelayed() {
yield ret null; // Wait one frame for everything to initialize
InventoryBarController.Instance?.ShowBar();
}

pub void ShowNotification(string message, float duration = 3f) {
StartCoroutine(ShowNotificationCoroutine(message, duration));
}

IEnumerator ShowNotificationCoroutine(string message, float duration) {
GameObject notification = new GameObject("Notification");
notification.transform.SetParent(transform, false);

var canvasGroup = notification.AddComponent<CanvasGroup>();
var rectTransform = notification.AddComponent<RectTransform>();
var image = notification.AddComponent<Image>();
var text = new GameObject("Text").AddComponent<TextMeshProUGUI>();
text.transform.SetParent(notification.transform, false);

rectTransform.anchorMin = new Vector2(0.5f, 0.8f);
rectTransform.anchorMax = new Vector2(0.5f, 0.8f);
rectTransform.sizeDelta = new Vector2(300, 60);

image.color = new Color(0, 0, 0, 0.8f);
text.text = message;
text.color = Color.white;
text.alignment = TextAlignmentOptions.Center;
text.fontSize = 16;
text.rectTransform.sizeDelta = rectTransform.sizeDelta;

float elapsedTime = 0f;
while (elapsedTime < 0.5f) {
canvasGroup.alpha = elapsedTime / 0.5f;
elapsedTime += Time.deltaTime;
yield ret null;
}
canvasGroup.alpha = 1f;

yield ret new WaitForSeconds(duration - 1f);

elapsedTime = 0f;
while (elapsedTime < 0.5f) {
canvasGroup.alpha = 1f - (elapsedTime / 0.5f);
elapsedTime += Time.deltaTime;
yield ret null;
}

Destroy(notification);
}

void Update() {
if (Input.GetKeyDown(KeyCode.Space)) {
if (runManager?.CurrentPhase == GamePhase.Planning) {
OnEndPlanningPhaseClicked();
}
else {
Debug.Log("[UIManager] Time only advances through player actions!");
}
}

if (Input.GetKeyDown(KeyCode.R) && (Application.isEditor || Debug.isDebugBuild)) {
runManager?.ForcePhase(GamePhase.Planning);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\WeatherManager.cs

﻿// Assets/Scripts/Core/WeatherManager.cs
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using WegoSystem;

pub cls WeatherManager : MonoBehaviour, ITickUpdateable {
pub stat WeatherManager Instance { get; set; }

pub enum CyclePhase { Day, TransitionToNight, Night, TransitionToDay }

pub bool dayNightCycleEnabled = true;
pub AnimationCurve transitionCurve = AnimationCurve.Linear(0, 0, 1, 1);
pub float sunIntensity = 1f;

pub float fixedSunIntensity = 1f;
pub SpriteRenderer fadeSprite;
pub float minAlpha = 0f;
pub float maxAlpha = 1f;

pub bool IsPaused { get; set; } = false;

int currentPhaseTicks = 0;
int totalPhaseTicksTarget = 0;

pub CyclePhase CurrentPhase => currentPhase;
pub event Action<CyclePhase> OnPhaseChanged;

CyclePhase currentPhase = CyclePhase.Day;

pub float CurrentTotalPhaseTime => totalPhaseTicksTarget * (TickManager.Instance?.Config?.GetRealSecondsPerTick() ?? 0.5f);
pub float CurrentPhaseTimer => (totalPhaseTicksTarget - currentPhaseTicks) * (TickManager.Instance?.Config?.GetRealSecondsPerTick() ?? 0.5f);

pub float GetPhaseProgress() {
if (totalPhaseTicksTarget <= 0) ret 0f;
ret (float)currentPhaseTicks / totalPhaseTicksTarget;
}

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

pub void Initialize() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}

EnterPhase(CyclePhase.Day, true);
}

void OnDestroy() {
var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}
}

pub void OnTickUpdate(int currentTick) {
if (!dayNightCycleEnabled || IsPaused) return;

currentPhaseTicks++;

if (currentPhaseTicks >= totalPhaseTicksTarget) {
AdvanceToNextPhase();
}

UpdateSunIntensity();
}

void Update() {
UpdateFadeSprite();
}

void UpdateSunIntensity() {
if (TickManager.Instance?.Config != null) {
float dayProgress = TickManager.Instance.Config.GetDayProgressNormalized(TickManager.Instance.CurrentTick);

CyclePhase newPhase = currentPhase;

if (dayProgress < 0.4f) {
newPhase = CyclePhase.Day;
sunIntensity = 1f;
}
else if (dayProgress < 0.5f) {
newPhase = CyclePhase.TransitionToNight;
float transitionProgress = (dayProgress - 0.4f) / 0.1f;
sunIntensity = Mathf.Lerp(1f, 0f, transitionCurve.Evaluate(transitionProgress));
}
else if (dayProgress < 0.9f) {
newPhase = CyclePhase.Night;
sunIntensity = 0f;
}
else {
newPhase = CyclePhase.TransitionToDay;
float transitionProgress = (dayProgress - 0.9f) / 0.1f;
sunIntensity = Mathf.Lerp(0f, 1f, transitionCurve.Evaluate(transitionProgress));
}

if (newPhase != currentPhase) {
EnterPhase(newPhase, true);
}
}
}

void AdvanceToNextPhase() {
CyclePhase nextPhase = currentPhase;
switch (currentPhase) {
case CyclePhase.Day: nextPhase = CyclePhase.TransitionToNight; break;
case CyclePhase.TransitionToNight: nextPhase = CyclePhase.Night; break;
case CyclePhase.Night: nextPhase = CyclePhase.TransitionToDay; break;
case CyclePhase.TransitionToDay: nextPhase = CyclePhase.Day; break;
}
EnterPhase(nextPhase);
}

void EnterPhase(CyclePhase nextPhase, bool forceEvent = false) {
CyclePhase previousPhase = currentPhase;
currentPhase = nextPhase;

if (TickManager.Instance?.Config != null) {
var config = TickManager.Instance.Config;
switch (nextPhase) {
case CyclePhase.Day:
totalPhaseTicksTarget = config.dayPhaseTicks;
break;
case CyclePhase.Night:
totalPhaseTicksTarget = config.nightPhaseTicks;
break;
case CyclePhase.TransitionToNight:
case CyclePhase.TransitionToDay:
totalPhaseTicksTarget = config.transitionTicks;
break;
}
currentPhaseTicks = 0;
}

if (previousPhase != currentPhase || forceEvent) {
if (Debug.isDebugBuild) Debug.Log($"[WeatherManager] Phase Changed To: {currentPhase}");
OnPhaseChanged?.Invoke(currentPhase);
}
}

void UpdateFadeSprite() {
if (fadeSprite != null) {
float alpha = Mathf.Lerp(maxAlpha, minAlpha, sunIntensity);
Color c = fadeSprite.color;
c.a = alpha;
fadeSprite.color = c;
}
}

pub void PauseCycleAtDay() {
Debug.Log("[WeatherManager] PauseCycleAtDay called.");
IsPaused = true;
currentPhase = CyclePhase.Day;
currentPhaseTicks = 0;
totalPhaseTicksTarget = TickManager.Instance?.Config?.dayPhaseTicks ?? 60;
sunIntensity = 1.0f;
UpdateFadeSprite();
OnPhaseChanged?.Invoke(CyclePhase.Day);
}

pub void ResumeCycle() {
Debug.Log("[WeatherManager] ResumeCycle called.");
IsPaused = false;

currentPhaseTicks = 0;
EnterPhase(CyclePhase.Day, true);
}

pub void PauseCycle() {
Debug.Log("[WeatherManager] PauseCycle called.");
IsPaused = true;
}

pub int GetCurrentPhaseTicks() {
ret currentPhaseTicks;
}

pub int GetTotalPhaseTicksTarget() {
ret totalPhaseTicksTarget;
}

pub void ForcePhase(CyclePhase phase) {
if (Application.isEditor || Debug.isDebugBuild) {
EnterPhase(phase, true);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalBehavior.cs

﻿// REWORKED FILE: Assets/Scripts/Ecosystem/Animals/AnimalBehavior.cs
using WegoSystem;

pub cls AnimalBehavior : MonoBehaviour {
[SerializeField] Transform poopSpawnPoint;
[SerializeField] List<GameObject> poopPrefabs;
AnimalController controller;
AnimalDefinition definition;
bool isEating = false;
bool isPooping = false;
bool hasPooped = true;
GameObject currentEatingTarget = null;
int eatRemainingTicks = 0;
int poopDelayTick = 0;
int currentPoopCooldownTick = 0;
pub bool IsEating => isEating;
pub bool IsPooping => isPooping;
pub bool CanAct => !isEating && !isPooping && !controller.IsDying;

pub void Initialize(AnimalController controller, AnimalDefinition definition) { this.controller = controller; this.definition = definition; hasPooped = true; }
pub void OnTickUpdate(int currentTick) { if (isEating) { eatRemainingTicks--; if (eatRemainingTicks <= 0) { FinishEating(); } } if (poopDelayTick > 0) { poopDelayTick--; } if (currentPoopCooldownTick > 0) { currentPoopCooldownTick--; } if (!hasPooped && poopDelayTick <= 0 && currentPoopCooldownTick <= 0 && CanAct) { TryPoop(); } }
pub void StartEating(GameObject food) { if (food == null || !CanAct) return; FoodItem foodItem = food.GetComponent<FoodItem>(); if (foodItem == null || foodItem.foodType == null || !definition.diet.CanEat(foodItem.foodType)) { return; } controller.Movement.ClearMovementPlan(); isEating = true; currentEatingTarget = food; eatRemainingTicks = definition.eatDurationTicks; if (controller.CanShowThought()) { controller.ShowThought(ThoughtTrigger.Eating); } }

void FinishEating() {
isEating = false;
if (currentEatingTarget == null) return;

FoodItem foodItem = currentEatingTarget.GetComponent<FoodItem>();
if (foodItem != null) {
controller.Needs.Eat(foodItem);

var plantCell = currentEatingTarget.GetComponent<PlantCell>();
if (plantCell != null && plantCell.ParentPlantGrowth != null) {
plantCell.ParentPlantGrowth.HandleBeingEaten(this.controller, plantCell);
}

Destroy(currentEatingTarget);

hasPooped = false;
poopDelayTick = Random.Range(definition.minPoopDelayTicks, definition.maxPoopDelayTicks);
}

currentEatingTarget = null;
}

void TryPoop() { if (!CanAct) return; isPooping = true; currentPoopCooldownTick = definition.poopCooldownTicks; SpawnPoop(); hasPooped = true; isPooping = false; if (controller.CanShowThought()) { controller.ShowThought(ThoughtTrigger.Pooping); } }
void SpawnPoop() { if (poopPrefabs == null || poopPrefabs.Count == 0) return; int index = Random.Range(0, poopPrefabs.Count); GameObject prefab = poopPrefabs[index]; if (prefab == null) return; Transform spawnTransform = poopSpawnPoint != null ? poopSpawnPoint : transform; GameObject poopObj = Instantiate(prefab, spawnTransform.position, Quaternion.identity); if (GridPositionManager.Instance != null) { GridPositionManager.Instance.SnapEntityToGrid(poopObj); } }
pub void CancelCurrentAction() { isEating = false; eatRemainingTicks = 0; currentEatingTarget = null; isPooping = false; }
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalController.cs

﻿// Assets/Scripts/Ecosystem/Animals/AnimalController.cs
using TMPro;
using WegoSystem;

pub cls AnimalController : MonoBehaviour, ITickUpdateable, IStatusEffectable, ITriggerTarget {
[SerializeField] pub AnimalDefinition definition;

[SerializeField] GameObject thoughtBubblePrefab;
[SerializeField] Transform bubbleSpawnTransform;
[SerializeField] Animator animator;

[SerializeField] TextMeshProUGUI hpText;
[SerializeField] TextMeshProUGUI hungerText;
[SerializeField] KeyCode showStatsKey = KeyCode.LeftAlt;

AnimalMovement movement;
AnimalNeeds needs;
AnimalBehavior behavior;
GridEntity gridEntity;
SpriteRenderer spriteRenderer;
StatusEffectManager statusManager;
StatusEffectUIManager statusEffectUI;

bool isDying = false;
float deathFadeTimer = 0f;
float deathFadeDuration = 1f;
int thoughtCooldownTick = 0;

pub GridEntity GridEntity => gridEntity;
pub StatusEffectManager StatusManager => statusManager;
pub AnimalDefinition Definition => definition;
pub AnimalMovement Movement => movement;
pub AnimalNeeds Needs => needs;
pub AnimalBehavior Behavior => behavior;
pub bool IsDying => isDying;
pub string SpeciesName => definition != null ? definition.animalName : "Uninitialized";

void Awake() {
CacheComponents();
ValidateComponents();
}

void Start() {
InitializeAnimal();

if (TickManager.Instance == null) {
Debug.LogError($"[{GetType().Name}] TickManager not found! Disabling component.", this);
enabled = false;
return;
}

TickManager.Instance.RegisterTickUpdateable(this);

if (gridEntity != null) {
gridEntity.OnPositionChanged += OnGridPositionChanged;
}
}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
if (gridEntity != null) {
gridEntity.OnPositionChanged -= OnGridPositionChanged;
}
}

void Update() {
if (!enabled) return;
if (isDying && deathFadeTimer > 0) {
deathFadeTimer -= Time.deltaTime;
UpdateDeathFade();
if (deathFadeTimer <= 0) Destroy(gameObject);
return;
}
bool showStats = Input.GetKey(showStatsKey);
SetStatsTextVisibility(showStats);
UpdateSpriteFlipping();
movement.UpdateVisuals();
}

pub void OnTickUpdate(int currentTick) {
if (!enabled || definition == null) return;
if (!isDying && needs != null && needs.CurrentHealth <= 0) {
StartDying();
return;
}
if (isDying) return;

needs.OnTickUpdate(currentTick);
behavior.OnTickUpdate(currentTick);
movement.OnTickUpdate(currentTick);
statusManager.OnTickUpdate(currentTick);

if (gridEntity != null && statusManager != null) {
gridEntity.SetSpeedMultiplier(statusManager.VisualSpeedMultiplier);
}

if (thoughtCooldownTick > 0) thoughtCooldownTick--;
UpdateAnimations();
}

void OnGridPositionChanged(GridPosition oldPos, GridPosition newPos) {
}

pub string GetDisplayName() { ret SpeciesName; }
pub void Heal(float amount) { if (needs != null) needs.Heal(amount); }
pub void ModifyHunger(float amount) { if (needs != null) needs.ModifyHunger(amount); }

pub void TakeDamage(float amount) {
if (isDying) return;
float finalDamage = amount;
if (statusManager != null) {
finalDamage *= statusManager.DamageResistanceMultiplier;
}
needs.TakeDamage(finalDamage);
}

void CacheComponents() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) gridEntity = gameObject.AddComponent<GridEntity>();
movement = GetComponent<AnimalMovement>();
if (movement == null) movement = gameObject.AddComponent<AnimalMovement>();
needs = GetComponent<AnimalNeeds>();
if (needs == null) needs = gameObject.AddComponent<AnimalNeeds>();
behavior = GetComponent<AnimalBehavior>();
if (behavior == null) behavior = gameObject.AddComponent<AnimalBehavior>();
spriteRenderer = GetComponentInChildren<SpriteRenderer>();
statusManager = GetComponent<StatusEffectManager>();
if (statusManager == null) statusManager = gameObject.AddComponent<StatusEffectManager>();
statusEffectUI = GetComponentInChildren<StatusEffectUIManager>(true);
if (statusEffectUI == null) Debug.LogWarning($"StatusEffectUIManager not found on a child of {gameObject.name}. Icons will not display.", this);
}

void ValidateComponents() {
if (definition == null) { Debug.LogError($"[{gameObject.name}] Missing AnimalDefinition!", this); enabled = false; return; }
if (definition.diet == null) { Debug.LogError($"[{gameObject.name}] AnimalDefinition missing diet!", this); enabled = false; return; }
}

void InitializeAnimal() {
movement.Initialize(this, definition);
needs.Initialize(this, definition);
behavior.Initialize(this, definition);
statusManager.Initialize(this);

if (statusEffectUI != null) {
statusEffectUI.Initialize(statusManager);
}

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
Debug.Log($"[AnimalController] {gameObject.name} snapped to grid position {gridEntity.Position}");
}
}

void StartDying() {
if (isDying) return;
isDying = true;

if (TickManager.Instance?.Config != null) {
deathFadeDuration = definition.deathFadeTicks / TickManager.Instance.Config.ticksPerRealSecond;
}
else {
deathFadeDuration = definition.deathFadeTicks * 0.5f;
}
deathFadeTimer = deathFadeDuration;

Debug.Log($"[AnimalController] {SpeciesName} is dying! Duration: {deathFadeDuration}s");

if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
movement.StopAllMovement();
behavior.CancelCurrentAction();

if (movement != null) movement.enabled = false;
if (behavior != null) behavior.enabled = false;
if (needs != null) needs.enabled = false;
}

void UpdateDeathFade() {
if (spriteRenderer == null) return;

float fadeProgress = 1f - (deathFadeTimer / deathFadeDuration);
Color color = spriteRenderer.color;
color.a = Mathf.Lerp(1f, 0f, fadeProgress);
spriteRenderer.color = color;
}

pub void ShowThought(ThoughtTrigger trigger) {
if (!CanShowThought()) return;

thoughtCooldownTick = definition.thoughtCooldownTicks;
if (definition.thoughtLibrary == null || thoughtBubblePrefab == null) return;

string message = "";
switch (trigger) {
case ThoughtTrigger.Hungry:
message = definition.thoughtLibrary?.hungryThoughts?.Length > 0 ? definition.thoughtLibrary.hungryThoughts[Random.Range(0, definition.thoughtLibrary.hungryThoughts.Length)] : "";
break;
case ThoughtTrigger.Eating:
message = definition.thoughtLibrary?.eatingThoughts?.Length > 0 ? definition.thoughtLibrary.eatingThoughts[Random.Range(0, definition.thoughtLibrary.eatingThoughts.Length)] : "";
break;
case ThoughtTrigger.HealthLow:
message = definition.thoughtLibrary?.healthLowThoughts?.Length > 0 ? definition.thoughtLibrary.healthLowThoughts[Random.Range(0, definition.thoughtLibrary.healthLowThoughts.Length)] : "";
break;
case ThoughtTrigger.Fleeing:
message = definition.thoughtLibrary?.fleeingThoughts?.Length > 0 ? definition.thoughtLibrary.fleeingThoughts[Random.Range(0, definition.thoughtLibrary.fleeingThoughts.Length)] : "";
break;
case ThoughtTrigger.Pooping:
message = definition.thoughtLibrary?.poopingThoughts?.Length > 0 ? definition.thoughtLibrary.poopingThoughts[Random.Range(0, definition.thoughtLibrary.poopingThoughts.Length)] : "";
break;
}

if (!string.IsNullOrEmpty(message)) {
Transform spawnT = bubbleSpawnTransform != null ? bubbleSpawnTransform : transform;
GameObject bubble = Instantiate(thoughtBubblePrefab, spawnT.position, Quaternion.identity);
ThoughtBubbleController controller = bubble.GetComponent<ThoughtBubbleController>();
if (controller != null) {
controller.Initialize(message, spawnT, 3f);
}
}
}

pub bool CanShowThought() {
ret thoughtCooldownTick <= 0 && !isDying;
}

void UpdateAnimations() {
if (animator == null) return;

bool isMoving = gridEntity != null && gridEntity.IsMoving;
bool isEating = behavior != null && behavior.IsEating;

animator.SetBool("isMoving", isMoving);
animator.SetBool("isEating", isEating);
animator.SetBool("isDying", isDying);
}

void UpdateSpriteFlipping() {
if (spriteRenderer == null || movement == null) return;

Vector2 moveDirection = movement.GetLastMoveDirection();
if (Mathf.Abs(moveDirection.x) > 0.01f) {
spriteRenderer.flipX = moveDirection.x < 0;
}
}

void SetStatsTextVisibility(bool visible) {
if (hpText != null) hpText.gameObject.SetActive(visible);
if (hungerText != null) hungerText.gameObject.SetActive(visible);

if (visible) {
UpdateUI();
}
}

pub void UpdateUI() {
if (needs == null) return;

if (hpText != null) {
hpText.text = $"{Mathf.CeilToInt(needs.CurrentHealth)}/{Mathf.CeilToInt(definition.maxHealth)}";
}
if (hungerText != null) {
hungerText.text = $"{Mathf.CeilToInt(needs.CurrentHunger)}/{Mathf.CeilToInt(definition.diet.maxHunger)}";
}
}

pub void SetSeekingScreenCenter(Vector2 target, Vector2 minBounds, Vector2 maxBounds) {
movement.SetSeekingScreenCenter(target, minBounds, maxBounds);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalDefinition.cs

﻿using System.Collections.Generic;

pub cls AnimalDefinition : ScriptableObject {
pub string animalName = "DefaultAnimal";
pub GameObject prefab;

pub float maxHealth = 10f;

pub float movementSpeed = 2f;

pub AnimalDiet diet;

pub int thinkingTickInterval = 3;

pub int searchRadiusTiles = 5;

pub int eatDistanceTiles = 1;

pub int eatDurationTicks = 3;

pub int wanderPauseTickChance = 30;

pub int minWanderMoveTicks = 2;

pub int maxWanderMoveTicks = 6;

pub int minWanderPauseTicks = 1;

pub int maxWanderPauseTicks = 4;

pub int starvationDamageTickInterval = 4;

pub float damagePerStarvationTick = 2f;

pub Color damageFlashColor = Color.red;

pub int damageFlashTicks = 1;

pub int deathFadeTicks = 3;

pub int minPoopDelayTicks = 10;

pub int maxPoopDelayTicks = 20;

pub int poopCooldownTicks = 2;

pub float poopColorVariation = 0.1f;

pub AnimalThoughtLibrary thoughtLibrary;

pub int thoughtCooldownTicks = 10;

pub List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();

pub List<ScentDefinition> repellentScentDefinitions = new List<ScentDefinition>();

void OnValidate() {
maxHealth = Mathf.Max(1f, maxHealth);
movementSpeed = Mathf.Max(0.1f, movementSpeed);

thinkingTickInterval = Mathf.Max(1, thinkingTickInterval);
searchRadiusTiles = Mathf.Max(1, searchRadiusTiles);
eatDistanceTiles = Mathf.Max(1, eatDistanceTiles);
eatDurationTicks = Mathf.Max(1, eatDurationTicks);

minWanderMoveTicks = Mathf.Max(1, minWanderMoveTicks);
maxWanderMoveTicks = Mathf.Max(minWanderMoveTicks, maxWanderMoveTicks);
minWanderPauseTicks = Mathf.Max(1, minWanderPauseTicks);
maxWanderPauseTicks = Mathf.Max(minWanderPauseTicks, maxWanderPauseTicks);

starvationDamageTickInterval = Mathf.Max(1, starvationDamageTickInterval);
damagePerStarvationTick = Mathf.Max(0.1f, damagePerStarvationTick);
deathFadeTicks = Mathf.Max(1, deathFadeTicks);
damageFlashTicks = Mathf.Max(1, damageFlashTicks);

minPoopDelayTicks = Mathf.Max(1, minPoopDelayTicks);
maxPoopDelayTicks = Mathf.Max(minPoopDelayTicks, maxPoopDelayTicks);
poopCooldownTicks = Mathf.Max(1, poopCooldownTicks);

thoughtCooldownTicks = Mathf.Max(1, thoughtCooldownTicks);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalLibrary.cs

﻿using UnityEngine;

pub cls AnimalLibrary : ScriptableObject {
pub List<AnimalDefinition> animals;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalMovement.cs

﻿using System.Collections.Generic;
using WegoSystem;

pub cls AnimalMovement : MonoBehaviour {
[SerializeField] bool showPathfindingDebugLine = false;

AnimalController controller;
AnimalDefinition definition;
GridEntity gridEntity;
LineRenderer pathDebugLine;

List<GridPosition> currentPath = new List<GridPosition>();
int currentPathIndex = 0;
GameObject currentTargetFood = null;
bool hasPlannedAction = false;
int wanderPauseTicks = 0;
int lastThinkTick = 0;

bool isSeekingScreenCenter = false;
Vector2 screenCenterTarget;
Vector2 minBounds;
Vector2 maxBounds;

Vector2 lastMoveDirection;

pub bool HasTarget => currentTargetFood != null || hasPlannedAction;
pub GameObject CurrentTargetFood => currentTargetFood;

pub void Initialize(AnimalController controller, AnimalDefinition definition) {
this.controller = controller;
this.definition = definition;
this.gridEntity = controller.GridEntity;

SetupDebugLineRenderer();
}

pub void OnTickUpdate(int currentTick) {
if (!enabled || controller.IsDying || controller.Behavior.IsEating || controller.Behavior.IsPooping) return;

if (wanderPauseTicks > 0) {
wanderPauseTicks--;
return;
}

if (currentTick - lastThinkTick >= definition.thinkingTickInterval) {
MakeMovementDecision();
lastThinkTick = currentTick;
}

if (hasPlannedAction && !gridEntity.IsMoving) {
ExecutePlannedMovement();
}
}

pub void UpdateVisuals() {
UpdatePathDebugLine();
}

void MakeMovementDecision() {
if (gridEntity.IsMoving) return;

if (isSeekingScreenCenter) {
HandleScreenCenterSeeking();
return;
}

if (controller.Needs.IsHungry) {
PlanFoodSeeking();
}
else {
PlanWandering();
}
}

void PlanFoodSeeking() {
if (GridDebugVisualizer.Instance != null && Debug.isDebugBuild) {
GridDebugVisualizer.Instance.VisualizeAnimalSearchRadius(controller, gridEntity.Position, definition.searchRadiusTiles);
}

if (controller.CanShowThought()) {
controller.ShowThought(ThoughtTrigger.Hungry);
}

GameObject nearestFood = FindNearestFood();
if (nearestFood != null) {
SetTargetFood(nearestFood);
}
else {
PlanWandering();
}
}

GameObject FindNearestFood() {
if (definition.diet == null) ret null;

GameObject foodFromGrid = FindFoodInGrid();
if (foodFromGrid != null) ret foodFromGrid;

ret FindFoodByCollider();
}

GameObject FindFoodInGrid() {
var entitiesInRadius = GridPositionManager.Instance.GetEntitiesInRadius(
gridEntity.Position,
definition.searchRadiusTiles,
true
);

GameObject bestFood = null;
float bestScore = -1f;

foreach (var entity in entitiesInRadius) {
if (entity == null || entity.gameObject == this.gameObject) continue;

FoodItem foodItem = entity.GetComponent<FoodItem>();
if (foodItem != null && foodItem.foodType != null && definition.diet.CanEat(foodItem.foodType)) {
var pref = definition.diet.GetPreference(foodItem.foodType);
if (pref == null) continue;

GridPosition foodGroundPos = GetFoodGroundPosition(entity.gameObject);
float distance = gridEntity.Position.ManhattanDistance(foodGroundPos);

float score = pref.preferencePriority / (1f + distance);

if (score > bestScore) {
bestScore = score;
bestFood = entity.gameObject;
}
}
}

ret bestFood;
}

GameObject FindFoodByCollider() {
Vector3 worldPos = transform.position;
float tileSize = GridPositionManager.Instance.GetTilemapGrid()?.cellSize.x ?? 1f;
float searchRadius = definition.searchRadiusTiles * tileSize;

Collider2D[] colliders = Physics2D.OverlapCircleAll(worldPos, searchRadius);

GameObject bestFood = null;
float bestScore = -1f;

foreach (var collider in colliders) {
if (collider.gameObject == this.gameObject) continue;

FoodItem foodItem = collider.GetComponent<FoodItem>();
if (foodItem != null && foodItem.foodType != null && definition.diet.CanEat(foodItem.foodType)) {
var pref = definition.diet.GetPreference(foodItem.foodType);
if (pref == null) continue;

float distance = Vector3.Distance(worldPos, collider.transform.position);
float score = pref.preferencePriority / (1f + distance);

if (score > bestScore) {
bestScore = score;
bestFood = collider.gameObject;
}
}
}

ret bestFood;
}

GridPosition GetFoodGroundPosition(GameObject food) {
GridEntity foodEntity = food.GetComponent<GridEntity>();
if (foodEntity != null) {
ret foodEntity.Position;
}

Vector3 foodWorldPos = food.transform.position;
ret GridPositionManager.Instance.WorldToGrid(foodWorldPos);
}

void SetTargetFood(GameObject food) {
currentTargetFood = food;
GridPosition foodGroundPos = GetFoodGroundPosition(food);

List<GridPosition> path = GridPositionManager.Instance.GetPath(gridEntity.Position, foodGroundPos, false);
if (path != null && path.Count > 0) {
currentPath = path;
currentPathIndex = 0;
hasPlannedAction = true;
}
else {
currentTargetFood = null;
}
}

void PlanWandering() {
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(controller);
}
ClearPathDebugLine();

currentPath.Clear();
currentTargetFood = null;

if (Random.Range(0, 100) < definition.wanderPauseTickChance) {
wanderPauseTicks = Random.Range(definition.minWanderPauseTicks, definition.maxWanderPauseTicks);
hasPlannedAction = false;
return;
}

GridPosition currentPos = gridEntity.Position;
GridPosition[] directions = {
GridPosition.Up, GridPosition.Down,
GridPosition.Left, GridPosition.Right
};

for (int i = 0; i < directions.Length; i++) {
int randomIndex = Random.Range(i, directions.Length);
GridPosition temp = directions[i];
directions[i] = directions[randomIndex];
directions[randomIndex] = temp;
}

foreach (var dir in directions) {
GridPosition targetPos = currentPos + dir;
if (IsValidMove(targetPos)) {
currentPath.Clear();
currentPath.Add(targetPos);
currentPathIndex = 0;
hasPlannedAction = true;
return;
}
}

hasPlannedAction = false;
}

void ExecutePlannedMovement() {
if (!hasPlannedAction || gridEntity.IsMoving) return;

if (currentTargetFood != null) {
GridPosition foodPos = GetFoodGroundPosition(currentTargetFood);
int distance = gridEntity.Position.ManhattanDistance(foodPos);

if (distance <= definition.eatDistanceTiles) {
controller.Behavior.StartEating(currentTargetFood);
ClearMovementPlan();
return;
}
}

if (currentPath != null && currentPath.Count > 0 && currentPathIndex < currentPath.Count) {
GridPosition nextPosition = currentPath[currentPathIndex];

if (TryMoveTo(nextPosition)) {
currentPathIndex++;

if (currentPathIndex >= currentPath.Count) {
ClearMovementPlan();
}
}
else {
if (currentTargetFood != null) {
SetTargetFood(currentTargetFood); // Re-path to the same food
}
else {
ClearMovementPlan(); // Or just clear if it was a wander
}
}
}
else {
hasPlannedAction = false;
}
}

bool TryMoveTo(GridPosition targetPos) {
if (!IsValidMove(targetPos))
ret false;

Vector3 currentWorld = transform.position;
Vector3 targetWorld = GridPositionManager.Instance.GridToWorld(targetPos);
lastMoveDirection = (targetWorld - currentWorld).normalized;

gridEntity.SetPosition(targetPos);
ret true;
}

bool IsValidMove(GridPosition pos) {
if (GridPositionManager.Instance == null) ret false;

if (!GridPositionManager.Instance.IsPositionValid(pos)) ret false;

if (GridPositionManager.Instance.IsPositionOccupied(pos)) {
if (currentTargetFood != null) {
GridPosition foodPos = GetFoodGroundPosition(currentTargetFood);
if (pos == foodPos) ret true;
}
ret false;
}

ret true;
}

void HandleScreenCenterSeeking() {
Vector2 currentPos = transform.position;
bool centerWithinBounds = currentPos.x >= minBounds.x && currentPos.x <= maxBounds.x &&
currentPos.y >= minBounds.y && currentPos.y <= maxBounds.y;

if (centerWithinBounds) {
isSeekingScreenCenter = false;
hasPlannedAction = false;
}
else {
GridPosition targetGridPos = GridPositionManager.Instance.WorldToGrid(screenCenterTarget);
currentPath = GridPositionManager.Instance.GetPath(gridEntity.Position, targetGridPos, false);
currentPathIndex = 0;
hasPlannedAction = currentPath.Count > 0;
}
}

pub void SetSeekingScreenCenter(Vector2 target, Vector2 minBounds, Vector2 maxBounds) {
isSeekingScreenCenter = true;
screenCenterTarget = target;
this.minBounds = minBounds;
this.maxBounds = maxBounds;
}

pub void StopAllMovement() {
ClearMovementPlan();
wanderPauseTicks = 0;
isSeekingScreenCenter = false;
}

pub void ClearMovementPlan() {
currentPath.Clear();
currentPathIndex = 0;
currentTargetFood = null;
hasPlannedAction = false;
ClearPathDebugLine();

if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(controller);
}
}

pub Vector2 GetLastMoveDirection() {
ret lastMoveDirection;
}

void SetupDebugLineRenderer() {
if (!showPathfindingDebugLine) return;

GameObject lineObj = new GameObject("PathDebugLine");
lineObj.transform.SetParent(transform);
pathDebugLine = lineObj.AddComponent<LineRenderer>();
pathDebugLine.startWidth = 0.05f;
pathDebugLine.endWidth = 0.05f;
pathDebugLine.material = new Material(Shader.Find("Sprites/Default"));
pathDebugLine.startColor = Color.yellow;
pathDebugLine.endColor = Color.red;
pathDebugLine.sortingOrder = 100;
}

void UpdatePathDebugLine() {
if (!showPathfindingDebugLine || pathDebugLine == null || currentPath == null || currentPath.Count == 0) {
if (pathDebugLine != null) pathDebugLine.positionCount = 0;
return;
}

List<Vector3> positions = new List<Vector3>();

Vector3 groundPosition = GridPositionManager.Instance.GridToWorld(gridEntity.Position);
positions.Add(groundPosition);

for (int i = currentPathIndex; i < currentPath.Count; i++) {
Vector3 worldPos = GridPositionManager.Instance.GridToWorld(currentPath[i]);
positions.Add(worldPos);
}

pathDebugLine.positionCount = positions.Count;
pathDebugLine.SetPositions(positions.ToArray());
}

void ClearPathDebugLine() {
if (pathDebugLine != null) {
pathDebugLine.positionCount = 0;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalNeeds.cs

﻿// Assets/Scripts/Ecosystem/Animals/AnimalNeeds.cs
using WegoSystem;

pub cls AnimalNeeds : MonoBehaviour {
AnimalController controller;
AnimalDefinition definition;
AnimalDiet diet;
SpriteRenderer spriteRenderer;

float currentHealth;
float currentHunger;

int hungerTick = 0;
int starvationTick = 0;

float flashRemainingTime = 0f;
float flashDurationSeconds = 0.2f;
bool isFlashing = false;
Color originalColor;

pub float CurrentHealth => currentHealth;
pub float CurrentHunger => currentHunger;
pub bool IsHungry => currentHunger >= diet.hungerThreshold;
pub bool IsStarving => currentHunger >= diet.maxHunger;

pub void Initialize(AnimalController controller, AnimalDefinition definition) {
this.controller = controller;
this.definition = definition;
this.diet = definition.diet;

spriteRenderer = GetComponentInChildren<SpriteRenderer>();
if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}

if (TickManager.Instance?.Config != null) {
flashDurationSeconds = definition.damageFlashTicks / TickManager.Instance.Config.ticksPerRealSecond;
}

currentHealth = definition.maxHealth;
currentHunger = 0f;
}

pub void OnTickUpdate(int currentTick) {
UpdateHunger();
UpdateStarvation();
}

void UpdateHunger() {
if (TickManager.Instance?.Config == null || diet == null) return;

hungerTick++;
if (hungerTick >= TickManager.Instance.Config.animalHungerTickInterval) {
hungerTick = 0;

currentHunger += diet.hungerIncreaseRate;
currentHunger = Mathf.Min(currentHunger, diet.maxHunger);

controller.UpdateUI();
}
}

void UpdateStarvation() {
if (!IsStarving) {
starvationTick = 0;
return;
}

starvationTick++;
if (starvationTick >= definition.starvationDamageTickInterval) {
starvationTick = 0;
ApplyStarvationDamage();
}
}

void Update() {
if (!isFlashing || spriteRenderer == null) return;

flashRemainingTime -= Time.deltaTime;

if (flashRemainingTime <= 0) {
spriteRenderer.color = originalColor;
isFlashing = false;
}
else {
float t = (flashRemainingTime / flashDurationSeconds);
spriteRenderer.color = Color.Lerp(originalColor, definition.damageFlashColor, t);
}
}

pub void TakeDamage(float amount) {
currentHealth -= amount;
currentHealth = Mathf.Clamp(currentHealth, 0f, definition.maxHealth);

StartDamageFlash();
controller.UpdateUI();

if (currentHealth <= definition.maxHealth * 0.3f && controller.CanShowThought()) {
controller.ShowThought(ThoughtTrigger.HealthLow);
}
}

void ApplyStarvationDamage() {
currentHealth -= definition.damagePerStarvationTick;
currentHealth = Mathf.Clamp(currentHealth, 0f, definition.maxHealth);

StartDamageFlash();
controller.UpdateUI();

Debug.Log($"[AnimalNeeds] {controller.SpeciesName} taking starvation damage. Health: {currentHealth}");
}

pub void Eat(FoodItem foodItem) {
if (foodItem == null || foodItem.foodType == null || diet == null) return;

float satiationGain = diet.GetSatiationValue(foodItem.foodType);
currentHunger -= satiationGain;
currentHunger = Mathf.Max(0f, currentHunger);

controller.UpdateUI();

Debug.Log($"[AnimalNeeds] {controller.SpeciesName} ate {foodItem.foodType.foodName}. Hunger: {currentHunger}/{diet.maxHunger}");
}

pub void Heal(float amount) {
currentHealth += amount;
currentHealth = Mathf.Clamp(currentHealth, 0f, definition.maxHealth);
controller.UpdateUI();
}

pub void ModifyHunger(float amount) {
currentHunger += amount;
currentHunger = Mathf.Clamp(currentHunger, 0f, diet.maxHunger);
controller.UpdateUI();
}

void StartDamageFlash() {
if (spriteRenderer == null) return;

isFlashing = true;
flashRemainingTime = flashDurationSeconds;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalSpawnData.cs

﻿using UnityEngine;

pub cls AnimalSpawnData {
pub AnimalDefinition animalDefinition;
pub float spawnRateMultiplier = 1f;
pub int maximumSpawned = 0;

pub float spawnTimer = 0f;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Animals\AnimalThoughtLibrary.cs

﻿using UnityEngine;

pub cls AnimalThoughtLibrary : ScriptableObject {
pub string[] hungryThoughts = new string[] {
"I'm hungry!",
"Need food...",
"Where's the food?"
};

pub string[] eatingThoughts = new string[] {
"Yum!",
"Delicious!",
"Nom nom nom"
};

pub string[] healthLowThoughts = new string[] {
"I don't feel good...",
"Help me!",
"Ouch!"
};

pub string[] fleeingThoughts = new string[] {
"Run away!",
"Scary!",
"Help!"
};

pub string[] poopingThoughts = new string[] {
"Nature calls!",
"Gotta go!",
"..."
};
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Effects\FireflyController.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes;
using UnityEngine.Rendering.Universal;
using WegoSystem;

pub cls FireflyController : MonoBehaviour, ITickUpdateable {
[SerializeField] FireflyDefinition definition;

[SerializeField] Light2D glowLight;
[SerializeField] Light2D groundLight;
[SerializeField] SpriteRenderer spriteRenderer;
[SerializeField] TrailRenderer trailRenderer;
[SerializeField] ParticleSystem glowParticles;

[SerializeField] float groundLightRadiusMultiplier = 2.5f;

GridEntity gridEntity;

int lifetimeTicks;
int lastMovementTick = 0;

float currentLifetimeSeconds = 0f;
float maxLifetimeSeconds = 0f;

Vector3 currentTileCenter;
Vector3 localTargetPosition;
float currentLocalSpeed;

float baseGlowIntensity;
float currentGlowIntensity;
float baseGroundLightIntensity;
float baseGroundLightOuterRadius;
float glowFlickerTime;
Color originalColor;

pub bool IsAlive { get; set; } = true;
pub Transform AttractionTarget { get; set; }

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
Debug.LogError($"[FireflyController] Firefly prefab is missing the required GridEntity component!", this);
enabled = false;
return;
}

if (glowLight != null) {
baseGlowIntensity = glowLight.intensity;
currentGlowIntensity = glowLight.intensity;
}

if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}

if (groundLight != null) {
baseGroundLightIntensity = groundLight.intensity;
baseGroundLightOuterRadius = groundLight.pointLightOuterRadius;
}
}

void Start() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

void OnDestroy() {
var tickManager = TickManager.Instance;
if (tickManager != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}

if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
}

pub void Initialize() {
if (FireflyManager.Instance?.defaultFireflyDefinition == null || gridEntity == null) {
Debug.LogError("[FireflyController] Initialization failed: Missing definition or GridEntity!", this);
enabled = false;
return;
}

definition = FireflyManager.Instance.defaultFireflyDefinition;

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
currentTileCenter = GridPositionManager.Instance.GridToWorld(gridEntity.Position);
}

lifetimeTicks = Random.Range(definition.minLifetimeTicks, definition.maxLifetimeTicks + 1);
currentLocalSpeed = Random.Range(definition.minLocalSpeed, definition.maxLocalSpeed);

SetRandomLocalTarget();

if (glowParticles != null) {
glowParticles.Play();
}

if (TickManager.Instance?.Config != null) {
maxLifetimeSeconds = lifetimeTicks / TickManager.Instance.Config.ticksPerRealSecond;
}
else {
maxLifetimeSeconds = lifetimeTicks * 0.5f;
}
}

pub void OnTickUpdate(int currentTick) {
if (!IsAlive) return;

currentLifetimeSeconds += Time.deltaTime;
if (currentLifetimeSeconds >= maxLifetimeSeconds) {
Die();
return;
}

if (currentTick - lastMovementTick >= definition.movementTickInterval) {
UpdateMovement();
lastMovementTick = currentTick;
}

UpdatePhotosynthesisVisualization();
}

void Update() {
if (!IsAlive) return;

UpdateLocalMovement();
UpdateGlowEffect();
UpdateGroundLight();
}

void UpdateMovement() {
FindAttractionTarget();

if (AttractionTarget != null) {
Vector3 attractionDirection = (AttractionTarget.position - currentTileCenter).normalized;
localTargetPosition = currentTileCenter + attractionDirection * Random.Range(0.1f, 0.3f);
}
else {
SetRandomLocalTarget();
}
}

void UpdatePhotosynthesisVisualization() {
if (GridDebugVisualizer.Instance != null && FireflyManager.Instance != null && gridEntity != null) {
int photosynthesisRadius = Mathf.RoundToInt(FireflyManager.Instance.photosynthesisRadius);
if (photosynthesisRadius > 0) {
GridDebugVisualizer.Instance.VisualizeFireflyPhotosynthesisRadius(this, gridEntity.Position, photosynthesisRadius);
}
}
}

void FindAttractionTarget() {
if (definition == null || gridEntity == null) return;

float bestScore = 0f;
Transform bestTarget = null;

GridPosition currentPos = gridEntity.Position;
int searchRadius = definition.tileSearchRadius;

for (int x = currentPos.x - searchRadius; x <= currentPos.x + searchRadius; x++) {
for (int y = currentPos.y - searchRadius; y <= currentPos.y + searchRadius; y++) {
GridPosition checkPos = new GridPosition(x, y);
if (!GridPositionManager.Instance.IsPositionValid(checkPos)) continue;

float distance = Vector2.Distance(currentPos.ToVector2Int(), checkPos.ToVector2Int());
if (distance > searchRadius) continue;

var entitiesAtPosition = GridPositionManager.Instance.GetEntitiesAt(checkPos);
foreach (var entity in entitiesAtPosition) {
var scentSources = entity.GetComponentsInChildren<ScentSource>();
foreach (var source in scentSources) {
if (definition.attractiveScentDefinitions.Contains(source.Definition)) {
float score = definition.scentAttractionWeight / (distance + 1f);
if (score > bestScore) {
bestScore = score;
bestTarget = entity.transform;
}
}
}

var plantGrowth = entity.GetComponent<PlantGrowth>();
if (plantGrowth != null && plantGrowth.CurrentState == PlantState.Growing) {
float score = definition.growingPlantAttraction / (distance + 1f);
if (score > bestScore) {
bestScore = score;
bestTarget = entity.transform;
}
}
}
}
}

AttractionTarget = bestTarget;
}

void SetRandomLocalTarget() {
if (definition == null) return;

Vector2 randomOffset = new Vector2(
Random.Range(-definition.flightBounds.x * 0.5f, definition.flightBounds.x * 0.5f),
Random.Range(definition.flightHeightOffset, definition.flightHeightOffset + definition.flightBounds.y)
);

localTargetPosition = currentTileCenter + (Vector3)randomOffset;
}

void UpdateLocalMovement() {
if (definition == null) return;

transform.position = Vector3.MoveTowards(transform.position, localTargetPosition, currentLocalSpeed * Time.deltaTime);

Vector3 direction = (localTargetPosition - transform.position).normalized;
if (direction.magnitude > 0.1f) {
float targetAngle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
float currentAngle = transform.eulerAngles.z;
float newAngle = Mathf.MoveTowardsAngle(currentAngle, targetAngle, definition.localMovementTurnSpeed * Time.deltaTime);
transform.rotation = Quaternion.AngleAxis(newAngle, Vector3.forward);
}
}

void UpdateGlowEffect() {
if (glowParticles == null) return;

glowFlickerTime += Time.deltaTime * definition.glowFlickerSpeed;
float flicker = Mathf.Sin(glowFlickerTime) * definition.glowFlickerAmount;
currentGlowIntensity = Mathf.Clamp01(baseGlowIntensity + flicker);

var emission = glowParticles.emission;
emission.rateOverTime = currentGlowIntensity * 10f;
}

void UpdateGroundLight() {
if (groundLight == null) return;

groundLight.transform.position = currentTileCenter;

float height = Mathf.Max(0, transform.position.y - currentTileCenter.y);
float maxFlightHeight = definition.flightBounds.y + definition.flightHeightOffset;
float heightT = (maxFlightHeight > 0) ? Mathf.Clamp01(height / maxFlightHeight) : 0f;

float heightBasedIntensity = Mathf.Lerp(baseGroundLightIntensity, baseGroundLightIntensity * 0.5f, heightT); // Dims to 50% at max height
float heightBasedRadiusMultiplier = Mathf.Lerp(1f, groundLightRadiusMultiplier, heightT); // Scales from 1x to the max multiplier
float finalRadius = baseGroundLightOuterRadius * heightBasedRadiusMultiplier;

glowFlickerTime += Time.deltaTime * definition.glowFlickerSpeed;
float flicker = Mathf.Sin(glowFlickerTime) * definition.glowFlickerAmount;

groundLight.intensity = Mathf.Clamp(heightBasedIntensity + flicker, definition.groundLightMinIntensity, 1f);
groundLight.pointLightOuterRadius = finalRadius;
}

void Die() {
IsAlive = false;

if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}

if (FireflyManager.Instance != null) {
FireflyManager.Instance.ReportFireflyDespawned(this);
}

if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}

if (glowParticles != null) {
glowParticles.Stop();
Destroy(gameObject, glowParticles.main.duration);
}
else {
Destroy(gameObject);
}
}

void OnDrawGizmosSelected() {
if (definition == null) return;

float tileSize = 1f;
if (Application.isPlaying && GridPositionManager.Instance?.GetTilemapGrid() != null) {
tileSize = GridPositionManager.Instance.GetTilemapGrid().cellSize.x;
}

Gizmos.color = new Color(1f, 1f, 0f, 0.3f);
Gizmos.DrawWireSphere(transform.position, definition.tileSearchRadius * tileSize);

if (Application.isPlaying && FireflyManager.Instance != null) {
Gizmos.color = new Color(0f, 1f, 0.5f, 0.3f);
Gizmos.DrawWireSphere(transform.position, FireflyManager.Instance.photosynthesisRadius * tileSize);
}

if (Application.isPlaying) {
Vector3 flightBoxCenter = currentTileCenter + new Vector3(0, definition.flightHeightOffset + definition.flightBounds.y / 2f, 0);
Gizmos.color = new Color(0f, 1f, 1f, 0.5f);
Gizmos.DrawWireCube(flightBoxCenter, new Vector3(definition.flightBounds.x, definition.flightBounds.y, 0.1f));

Gizmos.color = Color.yellow;
Gizmos.DrawLine(transform.position, localTargetPosition);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Effects\FireflyDefinition.cs

﻿using System.Collections.Generic;

pub cls FireflyDefinition : ScriptableObject {
pub int movementTickInterval = 5;
pub int tileSearchRadius = 3;

pub Vector2 flightBounds = new Vector2(0.4f, 0.4f);
pub float flightHeightOffset = 0.2f;
pub float localMovementTurnSpeed = 90f;
pub float minLocalSpeed = 0.5f;
pub float maxLocalSpeed = 1.0f;

pub int minLifetimeTicks = 40;
pub int maxLifetimeTicks = 90;
pub float fadeInSeconds = 1.5f;
pub float fadeOutSeconds = 2.5f;
pub float glowFlickerAmount = 0.2f;
pub float glowFlickerSpeed = 5.0f;
[Range(0f, 1f)] pub float groundLightMinIntensity = 0.1f;

pub List<ScentDefinition> attractiveScentDefinitions = new List<ScentDefinition>();
pub float scentAttractionWeight = 2.0f;
pub float growingPlantAttraction = 1.0f;

[HideInInspector] pub bool useSpawnEffect = true;
[HideInInspector] pub int spawnEffectTicks = 3;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Effects\FireflyManager.cs

﻿using System.Collections.Generic;
using WegoSystem;

pub cls FireflyManager : MonoBehaviour, ITickUpdateable {
pub stat FireflyManager Instance { get; set; }

[SerializeField] WeatherManager weatherManager;
[SerializeField] GameObject fireflyPrefab;
[SerializeField] pub FireflyDefinition defaultFireflyDefinition; // Made pub to fix access issue
[SerializeField] Transform fireflyParent;

[SerializeField] int maxFireflies = 50;
[SerializeField] int spawnIntervalTicks = 3;
[SerializeField] [Range(0f, 1f)] float nightThreshold = 0.25f;

[SerializeField] Vector2 spawnCenter = Vector2.zero;
[SerializeField] Vector2 spawnAreaSize = new Vector2(20f, 10f);

pub float photosynthesisRadius = 3f;
pub float photosynthesisIntensityPerFly = 0.05f;
pub float maxPhotosynthesisBonus = 0.5f;

[SerializeField] bool showAttractionLinesRuntime = false;
[SerializeField] Color attractionLineColorRuntime = Color.magenta;
[SerializeField] GameObject lineVisualizerPrefab;
[SerializeField] Transform lineContainer;

List<FireflyController> activeFireflies = new List<FireflyController>();
Dictionary<FireflyController, LineRenderer> activeLineVisualizers = new Dictionary<FireflyController, LineRenderer>();

int spawnTickCounter = 0;
bool isNight = false;

pub bool ShowAttractionLinesRuntime => showAttractionLinesRuntime;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

ValidateReferences();
}

pub void Initialize() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
}

void OnDestroy() {
if (Instance == this) Instance = null;

var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}

CleanupVisualizers();
}

void ValidateReferences() {
if (weatherManager == null) {
Debug.LogError($"[{nameof(FireflyManager)}] WeatherManager not assigned!", this);
enabled = false;
return;
}

if (fireflyPrefab == null) {
Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab not assigned!", this);
enabled = false;
return;
}

if (defaultFireflyDefinition == null) {
Debug.LogError($"[{nameof(FireflyManager)}] Default Firefly Definition not assigned!", this);
enabled = false;
return;
}

FireflyController controller = fireflyPrefab.GetComponent<FireflyController>();
if (controller == null) {
Debug.LogError($"[{nameof(FireflyManager)}] Firefly Prefab missing FireflyController script!", this);
enabled = false;
return;
}

if (fireflyParent == null) {
fireflyParent = transform;
}
}

pub void OnTickUpdate(int currentTick) {
isNight = weatherManager.sunIntensity <= nightThreshold;

if (isNight) {
spawnTickCounter++;
if (spawnTickCounter >= spawnIntervalTicks) {
TrySpawnFirefly();
spawnTickCounter = 0;
}
}
else {
spawnTickCounter = 0;
}

activeFireflies.RemoveAll(f => f == null || !f.IsAlive);
}

void Update() {
UpdateRuntimeLineVisualizers();
}

void TrySpawnFirefly() {
if (activeFireflies.Count >= maxFireflies) return;

GridPosition spawnGridPos = FindValidSpawnPosition();
if (spawnGridPos == GridPosition.Zero) return;

Vector3 spawnWorldPos = GridPositionManager.Instance.GridToWorld(spawnGridPos);

GameObject fireflyGO = Instantiate(fireflyPrefab, spawnWorldPos, Quaternion.identity, fireflyParent);
FireflyController controller = fireflyGO.GetComponent<FireflyController>();

if (controller != null) {
controller.Initialize();
activeFireflies.Add(controller);
}
}

GridPosition FindValidSpawnPosition() {
Vector2 minBounds = spawnCenter - spawnAreaSize * 0.5f;
Vector2 maxBounds = spawnCenter + spawnAreaSize * 0.5f;

GridPosition minGrid = GridPositionManager.Instance.WorldToGrid(minBounds);
GridPosition maxGrid = GridPositionManager.Instance.WorldToGrid(maxBounds);

for (int i = 0; i < 10; i++) // Try 10 times to find a spot {
int x = Random.Range(minGrid.x, maxGrid.x + 1);
int y = Random.Range(minGrid.y, maxGrid.y + 1);
GridPosition pos = new GridPosition(x, y);

if (GridPositionManager.Instance.IsPositionValid(pos) &&
!GridPositionManager.Instance.IsPositionOccupied(pos)) {
ret pos;
}
}

ret GridPosition.Zero; // Failed to find a spot
}

pub void ReportFireflyDespawned(FireflyController firefly) {
activeFireflies.Remove(firefly);

if (activeLineVisualizers.TryGetValue(firefly, out LineRenderer line)) {
if (line != null) Destroy(line.gameObject);
activeLineVisualizers.Remove(firefly);
}
}

pub int GetNearbyFireflyCount(Vector3 position, float radius) {
int count = 0;
float radiusSq = radius * radius;

for (int i = activeFireflies.Count - 1; i >= 0; i--) {
if (activeFireflies[i] == null) {
activeFireflies.RemoveAt(i);
continue;
}

if ((activeFireflies[i].transform.position - position).sqrMagnitude <= radiusSq) {
count++;
}
}

ret count;
}

void UpdateRuntimeLineVisualizers() {
if (!Application.isPlaying || !showAttractionLinesRuntime) {
CleanupVisualizers();
return;
}

var toRemove = new List<FireflyController>();
foreach (var kvp in activeLineVisualizers) {
if (kvp.Key == null || kvp.Value == null) {
toRemove.Add(kvp.Key);
continue;
}

Transform target = kvp.Key.AttractionTarget;
if (target != null) {
kvp.Value.enabled = true;
kvp.Value.SetPosition(0, kvp.Key.transform.position);
kvp.Value.SetPosition(1, target.position);
kvp.Value.startColor = attractionLineColorRuntime;
kvp.Value.endColor = attractionLineColorRuntime;
}
else {
kvp.Value.enabled = false;
}
}

foreach (var firefly in toRemove) {
if (activeLineVisualizers.TryGetValue(firefly, out var line) && line != null) {
Destroy(line.gameObject);
}
activeLineVisualizers.Remove(firefly);
}

if (lineVisualizerPrefab != null && lineContainer != null) {
foreach (var firefly in activeFireflies) {
if (firefly == null || activeLineVisualizers.ContainsKey(firefly)) continue;

if (firefly.AttractionTarget != null) {
GameObject lineGO = Instantiate(lineVisualizerPrefab, lineContainer);
LineRenderer newLine = lineGO.GetComponent<LineRenderer>();

if (newLine != null) {
newLine.SetPosition(0, firefly.transform.position);
newLine.SetPosition(1, firefly.AttractionTarget.position);
newLine.startColor = attractionLineColorRuntime;
newLine.endColor = attractionLineColorRuntime;
newLine.enabled = true;
activeLineVisualizers.Add(firefly, newLine);
}
else {
Debug.LogError($"Line Visualizer Prefab missing LineRenderer!", lineVisualizerPrefab);
Destroy(lineGO);
}
}
}
}
}

void CleanupVisualizers() {
foreach (var kvp in activeLineVisualizers) {
if (kvp.Value != null) {
Destroy(kvp.Value.gameObject);
}
}
activeLineVisualizers.Clear();
}

void OnDrawGizmosSelected() {
Gizmos.color = new Color(1f, 1f, 0f, 0.3f);
Gizmos.DrawWireCube(spawnCenter, spawnAreaSize);

if (Application.isPlaying) {
Gizmos.color = new Color(0f, 1f, 0.5f, 0.2f);
foreach (var firefly in activeFireflies) {
if (firefly != null) {
Gizmos.DrawWireSphere(firefly.transform.position, photosynthesisRadius);
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\PoopController.cs

﻿using UnityEngine;
using WegoSystem;

pub cls PoopController : MonoBehaviour, ITickUpdateable {
[SerializeField] int lifetimeTicks = 20;

[SerializeField] float fadeRealTimeDuration = 1f;

GridEntity gridEntity;
SpriteRenderer spriteRenderer;
int currentLifetimeTicks;
bool isFading = false;
float fadeTimer = 0f;
Color originalColor;

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = gameObject.AddComponent<GridEntity>();
}
gridEntity.isTileOccupant = false;

spriteRenderer = GetComponent<SpriteRenderer>();
if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
}
else {
Debug.LogError($"[{gameObject.name}] GridPositionManager not found on Awake! Poop will not be registered correctly.");
}
}

void Start() {
currentLifetimeTicks = lifetimeTicks;

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}

}

void OnDestroy() {
if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

void Update() {
if (isFading && fadeTimer > 0) {
fadeTimer -= Time.deltaTime;
UpdateFade();

if (fadeTimer <= 0) {
Destroy(gameObject);
}
}
}

pub void OnTickUpdate(int currentTick) {
if (isFading) return;

currentLifetimeTicks--;

if (currentLifetimeTicks <= 0) {
StartFading();
}
}

void StartFading() {
isFading = true;
fadeTimer = fadeRealTimeDuration;

if (TickManager.Instance != null) {
TickManager.Instance.UnregisterTickUpdateable(this);
}
}

void UpdateFade() {
if (spriteRenderer == null) return;

float fadeProgress = 1f - (fadeTimer / fadeRealTimeDuration);
Color color = originalColor;
color.a = Mathf.Lerp(1f, 0f, fadeProgress);
spriteRenderer.color = color;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\ScentDefinition.cs

﻿using UnityEngine;

pub cls ScentDefinition : ScriptableObject {
pub string scentID = "default_scent"; // Still useful for debugging/lookup
pub string displayName = "Default Scent";

pub float baseRadius = 1f;
pub float baseStrength = 1f;

pub GameObject particleEffectPrefab;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\ScentLibrary.cs

﻿using UnityEngine;

pub cls ScentLibrary : ScriptableObject {
pub List<ScentDefinition> scents;

pub ScentDefinition GetScentByID(string id) {
if (string.IsNullOrEmpty(id) || scents == null) ret null;
ret scents.FirstOrDefault(s => s != null && s.scentID == id);
}

pub List<ScentDefinition> GetAllDefinitions() {
ret scents?.Where(s => s != null).ToList() ?? new List<ScentDefinition>();
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Environment\ScentSource.cs

﻿using Abracodabra.Genes;
using WegoSystem;

pub cls ScentSource : MonoBehaviour {
[SerializeField] ScentDefinition definition;
[SerializeField] float radiusModifier = 0f;
[SerializeField] float strengthModifier = 0f;

pub ScentDefinition Definition => definition;
pub float EffectiveRadius => definition != null ? Mathf.Max(0f, definition.baseRadius + radiusModifier) : 0f;
pub float EffectiveStrength => definition != null ? Mathf.Max(0f, definition.baseStrength + strengthModifier) : 0f;

GridEntity gridEntity;

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = gameObject.AddComponent<GridEntity>();
}
}

void Start() {
if (GetComponentInParent<PlantGrowth>() == null) {
if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
}
}
}

void Update() {
UpdateRadiusVisualization();
}

void UpdateRadiusVisualization() {
if (GridDebugVisualizer.Instance != null && definition != null && gridEntity != null) {
float effectiveRadius = EffectiveRadius;
if (effectiveRadius > 0.01f) {
int radiusTiles = Mathf.RoundToInt(effectiveRadius);
GridDebugVisualizer.Instance.VisualizeScentRadius(this, gridEntity.Position, radiusTiles);
}
else {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
}
}

pub void SetDefinition(ScentDefinition newDefinition) {
definition = newDefinition;
UpdateRadiusVisualization(); // Update visualization when definition changes
}

pub void SetRadiusModifier(float modifier) {
radiusModifier = modifier;
}

pub void SetStrengthModifier(float modifier) {
strengthModifier = modifier;
}

pub void ApplyModifiers(float radiusMod, float strengthMod) {
radiusModifier += radiusMod;
strengthModifier += strengthMod;
}

void OnDestroy() {
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
}

void OnDisable() {
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius(this);
}
}

void OnEnable() {
UpdateRadiusVisualization();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Food\AnimalDiet.cs

﻿using System.Collections.Generic;

pub cls DietPreferenceSimplified {
pub FoodType foodType;
pub float satiationAmount = 5f;
pub float preferencePriority = 1f;
}

pub cls AnimalDiet : ScriptableObject {
pub List<DietPreferenceSimplified> acceptableFoods = new List<DietPreferenceSimplified>();

pub float maxHunger = 20f;

pub float hungerIncreaseRate = 0.5f;

pub float hungerThreshold = 10f;

pub bool CanEat(FoodType food) {
if (food == null) ret false;
ret acceptableFoods.Any(pref => pref.foodType == food);
}

pub DietPreferenceSimplified GetPreference(FoodType food) {
if (food == null) ret null;
ret acceptableFoods.FirstOrDefault(p => p.foodType == food);
}

pub float GetSatiationValue(FoodType food) {
var pref = GetPreference(food);
ret pref != null ? pref.satiationAmount : 0f;
}

pub GameObject FindBestFood(Collider2D[] nearbyColliders, Vector3 animalPosition) {
GameObject bestTarget = null;
float highestScore = -1f;

foreach (var collider in nearbyColliders) {
if (collider == null) continue;

PoopController poopController = collider.GetComponent<PoopController>();
if (poopController != null) continue;

FoodItem foodItem = collider.GetComponent<FoodItem>();
if (foodItem != null && foodItem.foodType != null && CanEat(foodItem.foodType)) {
DietPreferenceSimplified pref = GetPreference(foodItem.foodType);
if (pref == null) continue;

float distance = Vector3.Distance(animalPosition, collider.transform.position);
float score = pref.preferencePriority / (1f + distance); // Inverse distance weighting

if (score > highestScore) {
highestScore = score;
bestTarget = collider.gameObject;
}
}
}
ret bestTarget;
}

void OnValidate() {
maxHunger = Mathf.Max(1f, maxHunger);
hungerIncreaseRate = Mathf.Max(0.1f, hungerIncreaseRate);
hungerThreshold = Mathf.Clamp(hungerThreshold, 0f, maxHunger);

foreach (var pref in acceptableFoods) {
if (pref != null) {
pref.satiationAmount = Mathf.Max(0.1f, pref.satiationAmount);
pref.preferencePriority = Mathf.Max(0.1f, pref.preferencePriority);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Food\FoodItem.cs

﻿using Abracodabra.Genes;
using WegoSystem;

pub cls FoodItem : MonoBehaviour {
pub FoodType foodType;

bool snapToGridOnStart = true;

GridEntity gridEntity;

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = gameObject.AddComponent<GridEntity>();
}

gridEntity.isTileOccupant = false;
}

void Start() {
if (foodType == null) {
Debug.LogWarning($"FoodItem on GameObject '{gameObject.name}' is missing its FoodType reference!", gameObject);
enabled = false;
return;
}

PlantGrowth parentPlant = GetComponentInParent<PlantGrowth>();
if (parentPlant != null) {
if (gridEntity != null) {
gridEntity.enabled = false;
}
snapToGridOnStart = false;
}

if (snapToGridOnStart && GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(gameObject);
Debug.Log($"[FoodItem] Standalone food '{foodType.foodName}' snapped to grid position {gridEntity.Position}");
}

Collider2D col = GetComponent<Collider2D>();
if (col != null) {
col.isTrigger = true;
}
}

void OnDestroy() {
}

pub bool CanBeEatenBy(AnimalController animal) {
if (animal == null || animal.Definition == null || animal.Definition.diet == null)
ret false;

ret animal.Definition.diet.CanEat(foodType);
}

pub float GetSatiationValueFor(AnimalController animal) {
if (animal == null || animal.Definition == null || animal.Definition.diet == null)
ret 0f;

ret animal.Definition.diet.GetSatiationValue(foodType);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Food\FoodType.cs

﻿using UnityEngine;

pub cls FoodType : ScriptableObject {
pub string foodName = "Default Food";
pub Sprite icon;

pub enum FoodCategory { Plant_Leaf, Plant_Fruit, Plant_Stem, Plant_Seed, Other }
pub FoodCategory category = FoodCategory.Other;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\EcosystemManager.cs

﻿// Assets/Scripts/Ecosystem/Management/EcosystemManager.cs
using WegoSystem;

pub cls EcosystemManager : SingletonMonoBehaviour<EcosystemManager> {
pub Transform animalParent;
pub Transform plantParent;

pub ScentLibrary scentLibrary;

pub bool sortAnimalsBySpecies = true;
pub bool sortPlantsBySpecies = true;

prot ovr void OnAwake() {
if (scentLibrary == null) {
Debug.LogWarning($"[{nameof(EcosystemManager)}] Scent Library not assigned! Scent effects will not work.", this);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\FloraManager.cs

﻿// REWORKED FILE: Assets/Scripts/Ecosystem/Management/FloraManager.cs

pub cls FloraManager : MonoBehaviour {
pub stat FloraManager Instance { get; set; }

[SerializeField] pub float basePhotosynthesisRatePerLeaf = 0.1f;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\WaveManager.cs

﻿// Assets/Scripts/Ecosystem/Management/WaveManager.cs
using TMPro;
using WegoSystem;

pub enum WaveState {
Idle,           // No wave active
Active,         // Wave is currently running
Spawning        // Currently spawning enemies
}

pub cls WaveManager : MonoBehaviour {
pub stat WaveManager Instance { get; set; }

[SerializeField] Camera mainCamera;
[SerializeField] FaunaManager faunaManager;
[SerializeField] List<WaveDefinition> wavesSequence;

[SerializeField] int waveDurationInDays = 1;
[SerializeField] float spawnTimeNormalized = 0.1f;
[SerializeField] bool continuousSpawning = false;

[SerializeField] bool deletePreviousWaveAnimals = true;

[SerializeField] TextMeshProUGUI waveStatusText;
[SerializeField] TextMeshProUGUI timeTrackerText;

WaveState currentState = WaveState.Idle;
WaveDefinition currentWaveDef = null;
int currentWaveIndex = -1;

int waveStartTick = 0;
int waveEndTick = 0;
int waveSpawnTick = 0;
bool hasSpawnedThisWave = false;

Coroutine activeSpawnCoroutine = null;

pub bool IsWaveActive => currentState != WaveState.Idle;
pub bool IsCurrentWaveDefeated() => currentState == WaveState.Idle && currentWaveIndex >= 0;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

ValidateReferences();
}

pub void Initialize() {
if (TickManager.Instance != null) {
TickManager.Instance.OnTickAdvanced += OnTickAdvanced;
Debug.Log("[WaveManager] Initialized and subscribed to TickManager events.");
}
else {
Debug.LogError("[WaveManager] Initialization failed: TickManager not found!");
}
}

void OnDestroy() {
var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.OnTickAdvanced -= OnTickAdvanced;
}
StopAllCoroutines();
}

void ValidateReferences() {
if (faunaManager == null) {
faunaManager = FindAnyObjectByType<FaunaManager>();
if (faunaManager != null) {
Debug.LogWarning("[WaveManager] FaunaManager was not assigned in the Inspector. Found it automatically.", this);
}
}

if (faunaManager == null) {
Debug.LogError("[WaveManager] CRITICAL: FaunaManager is missing and could not be found in the scene! Waves will not spawn.", this);
}

if (wavesSequence == null || wavesSequence.Count == 0)
Debug.LogWarning("[WaveManager] Wave Sequence empty. No waves will spawn.", this);
}

void OnTickAdvanced(int currentTick) {
if (currentState == WaveState.Active) {
if (currentTick >= waveEndTick) {
EndCurrentWave();
}
else if (!hasSpawnedThisWave && currentTick >= waveSpawnTick) {
StartSpawning();
}
else if (continuousSpawning && hasSpawnedThisWave) {
}
}
}

pub void StartWaveForRound(int roundNumber) {
if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat) {
Debug.LogWarning("[WaveManager] Cannot start wave - not in GrowthAndThreat state.");
return;
}

currentWaveIndex = roundNumber - 1;

if (!IsValidWaveIndex(currentWaveIndex)) {
Debug.LogWarning($"[WaveManager] No wave definition for round {roundNumber}");
currentState = WaveState.Idle;
return;
}

currentWaveDef = wavesSequence[currentWaveIndex];
if (currentWaveDef == null) {
Debug.LogError($"[WaveManager] Wave definition at index {currentWaveIndex} is null!");
currentState = WaveState.Idle;
return;
}

StartWave();
}

void StartWave() {
if (deletePreviousWaveAnimals) {
ClearAllActiveAnimals();
}

var config = TickManager.Instance?.Config;
if (config == null) {
Debug.LogError("[WaveManager] No TickConfiguration found!");
return;
}

waveStartTick = TickManager.Instance.CurrentTick;
int waveDurationTicks = config.ticksPerDay * waveDurationInDays;
waveEndTick = waveStartTick + waveDurationTicks;

waveSpawnTick = waveStartTick + Mathf.RoundToInt(waveDurationTicks * spawnTimeNormalized);

hasSpawnedThisWave = false;
currentState = WaveState.Active;

Debug.Log($"[WaveManager] Starting wave '{currentWaveDef.waveName}' " +
$"Duration: {waveDurationTicks} ticks ({waveDurationInDays} days) " +
$"Spawn at tick: {waveSpawnTick}");
}

void StartSpawning() {
if (currentWaveDef == null || faunaManager == null) return;

hasSpawnedThisWave = true;
currentState = WaveState.Spawning;

Debug.Log($"[WaveManager] Beginning spawn for wave '{currentWaveDef.waveName}'");

if (activeSpawnCoroutine != null) {
StopCoroutine(activeSpawnCoroutine);
}

activeSpawnCoroutine = StartCoroutine(ExecuteWaveSpawn());
}

IEnumerator ExecuteWaveSpawn() {
faunaManager.ExecuteSpawnWave(currentWaveDef);

yield ret new WaitForSeconds(1f);

if (currentState == WaveState.Spawning) {
currentState = WaveState.Active;
}

activeSpawnCoroutine = null;
}

void EndCurrentWave() {
Debug.Log($"[WaveManager] Ending wave '{currentWaveDef?.waveName}'");

StopCurrentWaveSpawning();
currentWaveDef = null;
currentState = WaveState.Idle;

if (RunManager.Instance != null) {
RunManager.Instance.StartNewPlanningPhase();
}
}

pub void StopCurrentWaveSpawning() {
if (activeSpawnCoroutine != null) {
StopCoroutine(activeSpawnCoroutine);
activeSpawnCoroutine = null;
}

faunaManager?.StopAllSpawnCoroutines();
}

pub void ResetForNewRound() {
Debug.Log("[WaveManager] Resetting for new round");

StopCurrentWaveSpawning();

if (deletePreviousWaveAnimals) {
ClearAllActiveAnimals();
}

currentWaveDef = null;
currentWaveIndex = -1;
currentState = WaveState.Idle;
hasSpawnedThisWave = false;
waveStartTick = 0;
waveEndTick = 0;
waveSpawnTick = 0;
}

void ClearAllActiveAnimals() {
AnimalController[] animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
int count = 0;

foreach (var animal in animals) {
if (animal != null) {
Destroy(animal.gameObject);
count++;
}
}

Debug.Log($"[WaveManager] Cleared {count} animals");
}

bool IsValidWaveIndex(int index) {
ret wavesSequence != null &&
index >= 0 &&
index < wavesSequence.Count;
}

void Update() {
UpdateUI();
}

void UpdateUI() {
UpdateTimeTracker();
UpdateWaveStatus();
}

void UpdateTimeTracker() {
if (timeTrackerText == null || TickManager.Instance == null) return;

var config = TickManager.Instance.Config;
if (config == null) return;

float dayProgress = config.GetDayProgressNormalized(TickManager.Instance.CurrentTick);
int dayNumber = TickManager.Instance.CurrentTick / config.ticksPerDay + 1;

timeTrackerText.text = $"Day {dayNumber} - {(dayProgress * 100):F0}%";

if (currentState != WaveState.Idle) {
int ticksIntoWave = TickManager.Instance.CurrentTick - waveStartTick;
int totalWaveTicks = waveEndTick - waveStartTick;
float waveProgress = totalWaveTicks > 0 ? (float)ticksIntoWave / totalWaveTicks : 0;
timeTrackerText.text += $" | Wave: {(waveProgress * 100):F0}%";
}
}

void UpdateWaveStatus() {
if (waveStatusText == null) return;

if (RunManager.Instance == null) {
waveStatusText.text = "System Offline";
return;
}

if (RunManager.Instance.CurrentState == RunState.Planning) {
waveStatusText.text = $"Prepare for Round {RunManager.Instance.CurrentRoundNumber}";
}
else if (RunManager.Instance.CurrentState == RunState.GrowthAndThreat) {
if (currentWaveDef != null) {
int ticksRemaining = Mathf.Max(0, waveEndTick - TickManager.Instance.CurrentTick);
string waveName = string.IsNullOrEmpty(currentWaveDef.waveName)
? $"Wave {currentWaveIndex + 1}"
: currentWaveDef.waveName;

string status = currentState == WaveState.Spawning ? " [SPAWNING]" : "";
waveStatusText.text = $"{waveName}{status} - {ticksRemaining} ticks left";
}
else {
waveStatusText.text = "No active wave";
}
}
}

pub Camera GetMainCamera() => mainCamera;

void Debug_ForceEndWave() {
if (Application.isEditor && currentState != WaveState.Idle) {
EndCurrentWave();
}
}

void Debug_ForceSpawn() {
if (Application.isEditor && currentState == WaveState.Active && !hasSpawnedThisWave) {
StartSpawning();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Spawning\WaveDefinition.cs

﻿using UnityEngine;

pub enum WaveSpawnLocationType {
GlobalSpawnArea,
RandomNearPlayer,
Offscreen
}

pub cls WaveSpawnEntry {
pub string description = "Spawn Group";
pub AnimalDefinition animalDefinition;
pub int spawnCount = 1;
[Tooltip("Delay (in seconds) AFTER the designated wave spawn time (e.g. Day 50%) before *this entry* begins spawning.")] // Clarified Tooltip
pub float delayAfterSpawnTime = 0f; // Renamed from delayAfterWaveStart
pub float spawnInterval = 0.5f;
pub WaveSpawnLocationType spawnLocationType = WaveSpawnLocationType.GlobalSpawnArea;
pub float spawnRadius = 5f;
}

pub cls WaveDefinition : ScriptableObject {
pub string waveName = "New Wave";

pub List<WaveSpawnEntry> spawnEntries = new List<WaveSpawnEntry>();

}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\EnvironmentalStatusEffectSystem.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/EnvironmentalStatusEffectSystem.cs
using WegoSystem;

pub cls EnvironmentalStatusEffectSystem : MonoBehaviour, ITickUpdateable {
pub stat EnvironmentalStatusEffectSystem Instance { get; set; }

pub cls TileStatusRule {
pub TileDefinition tile;
pub List<StatusEffect> statusEffectsToApply;
}

pub cls ToolStatusRule {
pub ToolDefinition tool;
pub List<StatusEffect> statusEffectsToApply;
}

pub List<TileStatusRule> tileRules = new List<TileStatusRule>();

pub List<ToolStatusRule> toolRules = new List<ToolStatusRule>(); // <<< NEW

Dictionary<TileDefinition, List<StatusEffect>> tileRuleLookup = new Dictionary<TileDefinition, List<StatusEffect>>();
Dictionary<ToolDefinition, List<StatusEffect>> toolRuleLookup = new Dictionary<ToolDefinition, List<StatusEffect>>(); // <<< NEW
List<IStatusEffectable> allEffectableEntities = new List<IStatusEffectable>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
BuildLookups();
}

pub void Initialize() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
if (PlayerActionManager.Instance != null) {
PlayerActionManager.Instance.OnActionExecuted += HandlePlayerAction;
}
}

void OnDestroy() {
if (Instance == this) Instance = null;

var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}

if (PlayerActionManager.Instance != null) {
PlayerActionManager.Instance.OnActionExecuted -= HandlePlayerAction;
}
}

void BuildLookups() {
tileRuleLookup.Clear();
foreach (var rule in tileRules) {
if (rule.tile != null && rule.statusEffectsToApply != null && rule.statusEffectsToApply.Count > 0) {
tileRuleLookup[rule.tile] = rule.statusEffectsToApply;
}
}

toolRuleLookup.Clear();
foreach (var rule in toolRules) {
if (rule.tool != null && rule.statusEffectsToApply != null && rule.statusEffectsToApply.Count > 0) {
toolRuleLookup[rule.tool] = rule.statusEffectsToApply;
}
}
}

pub void OnTickUpdate(int currentTick) {
RefreshAllEntityTileEffects();
}

void HandlePlayerAction(PlayerActionType actionType, object actionData) {
if (actionType != PlayerActionType.UseTool) return;

var toolData = actionData as PlayerActionManager.ToolActionData;
if (toolData == null) return;

if (toolRuleLookup.TryGetValue(toolData.Tool, out List<StatusEffect> effectsToApply)) {
if (GridPositionManager.Instance == null) return;
GridPosition gridPos = new GridPosition(toolData.GridPosition);
HashSet<GridEntity> entitiesOnTile = GridPositionManager.Instance.GetEntitiesAt(gridPos);

foreach(var entity in entitiesOnTile) {
IStatusEffectable effectable = entity.GetComponent<IStatusEffectable>();
if (effectable != null) {
foreach(var effect in effectsToApply) {
effectable.StatusManager.ApplyStatusEffect(effect);
}
}
}
}
}

void RefreshAllEntityTileEffects() {
var animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
var players = FindObjectsByType<GardenerController>(FindObjectsSortMode.None);

allEffectableEntities.Clear();
foreach (var animal in animals) allEffectableEntities.Add(animal);
foreach (var player in players) allEffectableEntities.Add(player);

foreach(var entity in allEffectableEntities) {
CheckAndApplyTileEffects(entity);
}
}

pub void CheckAndApplyTileEffects(IStatusEffectable entity) {
if (entity == null || TileInteractionManager.Instance == null) return;

Component entityComponent = entity as Component;
if (entityComponent == null || !entityComponent.gameObject.activeInHierarchy) return;

GridPosition currentPos = entity.GridEntity.Position;
TileDefinition currentTile = TileInteractionManager.Instance.FindWhichTileDefinitionAt(currentPos.ToVector3Int());

if (currentTile == null) return;

if (tileRuleLookup.TryGetValue(currentTile, out List<StatusEffect> effectsToApply)) {
foreach (var effect in effectsToApply) {
if (effect != null) {
entity.StatusManager.ApplyStatusEffect(effect);
}
}
}
}

void OnValidate() {
BuildLookups();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\IStatusEffectable.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/IStatusEffectable.cs
using WegoSystem; // For GridEntity

pub ifc IStatusEffectable {
GridEntity GridEntity { get; }

StatusEffectManager StatusManager { get; }

string GetDisplayName();

void TakeDamage(float amount);
void Heal(float amount);
void ModifyHunger(float amount); // Can be left empty for player
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffect.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/StatusEffect.cs

pub cls StatusEffect : ScriptableObject {
pub string effectID = "status_effect";
pub string displayName = "Status Effect";
pub Sprite icon;
pub string unicodeSymbol = "?";
pub Color effectColor = Color.white;

pub bool isPermanent = false;
pub int durationTicks = 10;

pub bool modifyAnimalColor = false;
pub Color animalTintColor = Color.white;
pub GameObject visualEffectPrefab;

pub bool damagePerTick = false;
pub float damageAmount = 0f;

pub bool healPerTick = false;
pub float healAmount = 0f;

pub bool modifyHunger = false;
pub float hungerModifier = 0f;

pub float visualSpeedMultiplier = 1f; // <<< RENAMED

pub float damageResistanceMultiplier = 1f;

pub int additionalMoveTicks = 0;

pub bool canStack = false;
pub int maxStacks = 1;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffectIconUI.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/StatusEffectIconUI.cs
using TMPro;

pub cls StatusEffectIconUI : MonoBehaviour {
Image iconImage;
TextMeshProUGUI iconText;
StatusEffect currentEffect;

pub void Initialize(StatusEffectInstance instance) {
currentEffect = instance.effect;

Transform iconTransform = transform.Find("Icon");
if (iconTransform != null) {
iconTransform.gameObject.SetActive(true);

iconImage = iconTransform.GetComponent<Image>();
iconText = iconTransform.GetComponentInChildren<TextMeshProUGUI>();

if (currentEffect.icon != null) {
if (iconImage != null) {
iconImage.sprite = currentEffect.icon;
iconImage.color = currentEffect.effectColor;
iconImage.enabled = true;
}
if (iconText != null) {
iconText.enabled = false;
}
}
else {
if (iconImage != null) {
iconImage.enabled = false;
}
if (iconText != null) {
iconText.text = currentEffect.unicodeSymbol;
iconText.color = currentEffect.effectColor;
iconText.enabled = true;
}
}
}
else {
Debug.LogError("Could not find child GameObject named 'Icon' in the StatusEffectIcon prefab!", this);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffectInstance.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/StatusEffectInstance.cs

pub cls StatusEffectInstance {
pub StatusEffect effect;
pub int remainingTicks;
pub int stackCount = 1;
pub GameObject visualEffectInstance;

pub StatusEffectInstance(StatusEffect effect) {
this.effect = effect;
this.remainingTicks = effect.durationTicks;
this.stackCount = 1;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffectManager.cs

﻿// Assets/Scripts/Ecosystem/StatusEffects/StatusEffectManager.cs

pub cls StatusEffectManager : MonoBehaviour {
IStatusEffectable owner;
List<StatusEffectInstance> activeEffects = new List<StatusEffectInstance>();
Dictionary<string, StatusEffectInstance> effectLookup = new Dictionary<string, StatusEffectInstance>();

float cachedVisualSpeedMultiplier = 1f; // <<< RENAMED
float cachedDamageResistanceMultiplier = 1f;
int cachedAdditionalMoveTicks = 0;
Color originalColor;
SpriteRenderer spriteRenderer;

pub float VisualSpeedMultiplier => cachedVisualSpeedMultiplier; // <<< RENAMED
pub float DamageResistanceMultiplier => cachedDamageResistanceMultiplier;
pub int AdditionalMoveTicks => cachedAdditionalMoveTicks;

pub void Initialize(IStatusEffectable owner) {
this.owner = owner;

Component ownerComponent = owner as Component;
if (ownerComponent != null) {
spriteRenderer = ownerComponent.GetComponentInChildren<SpriteRenderer>();
if (spriteRenderer != null) {
originalColor = spriteRenderer.color;
}
}
}

pub void OnTickUpdate(int currentTick) {
if (owner == null || (owner as Component) == null) {
Destroy(this);
return;
}

ProcessStatusEffects();
UpdateCachedModifiers();
UpdateVisualEffects();
}

pub void ApplyStatusEffect(StatusEffect effect) {
if (effect == null) return;

if (effectLookup.ContainsKey(effect.effectID)) {
var existing = effectLookup[effect.effectID];
if (effect.canStack && existing.stackCount < effect.maxStacks) {
existing.stackCount++;
existing.remainingTicks = effect.durationTicks;
}
else if (!effect.canStack) {
existing.remainingTicks = effect.durationTicks;
}
}
else {
var instance = new StatusEffectInstance(effect);
activeEffects.Add(instance);
effectLookup[effect.effectID] = instance;

if (effect.visualEffectPrefab != null) {
instance.visualEffectInstance = Instantiate(
effect.visualEffectPrefab,
(owner as Component).transform.position,
Quaternion.identity,
(owner as Component).transform
);
}
Debug.Log($"[StatusEffect] Applied {effect.displayName} to {owner.GetDisplayName()}");
}

UpdateCachedModifiers();
}

pub void RemoveStatusEffect(string effectID) {
if (!effectLookup.ContainsKey(effectID)) return;
var instance = effectLookup[effectID];
if (instance.visualEffectInstance != null) {
Destroy(instance.visualEffectInstance);
}
activeEffects.Remove(instance);
effectLookup.Remove(effectID);
Debug.Log($"[StatusEffect] Removed {instance.effect.displayName} from {owner.GetDisplayName()}");
UpdateCachedModifiers();
}

void ProcessStatusEffects() {
for (int i = activeEffects.Count - 1; i >= 0; i--) {
var instance = activeEffects[i];
var effect = instance.effect;

if (effect.damagePerTick) owner.TakeDamage(effect.damageAmount * instance.stackCount);
if (effect.healPerTick) owner.Heal(effect.healAmount * instance.stackCount);
if (effect.modifyHunger) owner.ModifyHunger(effect.hungerModifier * instance.stackCount);

if (!effect.isPermanent) {
instance.remainingTicks--;
if (instance.remainingTicks <= 0) {
RemoveStatusEffect(effect.effectID);
}
}
}
}

void UpdateCachedModifiers() {
cachedVisualSpeedMultiplier = 1f; // <<< RENAMED
cachedDamageResistanceMultiplier = 1f;
cachedAdditionalMoveTicks = 0;

foreach (var instance in activeEffects) {
var effect = instance.effect;
cachedVisualSpeedMultiplier *= effect.visualSpeedMultiplier; // <<< RENAMED
cachedDamageResistanceMultiplier *= effect.damageResistanceMultiplier;
cachedAdditionalMoveTicks += effect.additionalMoveTicks * instance.stackCount;
}
}

pub bool HasStatusEffect(string effectID) { ret effectLookup.ContainsKey(effectID); }
void UpdateVisualEffects() { if(spriteRenderer==null)return;Color targetColor=originalColor;bool hasColorEffect=false;foreach(var instance in activeEffects){if(instance.effect.modifyAnimalColor){targetColor=instance.effect.animalTintColor;hasColorEffect=true;break;}}
spriteRenderer.color=hasColorEffect?targetColor:originalColor;}
pub List<StatusEffectInstance> GetActiveEffects() { ret new List<StatusEffectInstance>(activeEffects); }
pub void ClearAllEffects() { for(int i=activeEffects.Count-1;i>=0;i--){RemoveStatusEffect(activeEffects[i].effect.effectID);}}
void OnDestroy() { foreach(var instance in activeEffects){if(instance.visualEffectInstance!=null){Destroy(instance.visualEffectInstance);}}}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Status Effects\StatusEffectUIManager.cs

﻿// Assets/Scripts/Ecosystem/Status Effects/StatusEffectUIManager.cs
using TMPro;
using WegoSystem;

pub cls StatusEffectUIManager : MonoBehaviour {
[SerializeField] Transform effectIconContainer;
[SerializeField] GameObject effectIconPrefab;

StatusEffectManager statusManager;
Dictionary<string, StatusEffectIconUI> activeIcons = new Dictionary<string, StatusEffectIconUI>();

pub void Initialize(StatusEffectManager manager) {
statusManager = manager;

if (effectIconPrefab == null) {
CreateDefaultIconPrefab();
}
}

void Update() {
if (statusManager == null || effectIconContainer == null) return;

UpdateStatusIcons();
}

void UpdateStatusIcons() {
var currentEffectInstances = statusManager.GetActiveEffects();
var currentEffectIDs = currentEffectInstances.Select(e => e.effect.effectID).ToList();
var displayedIconIDs = activeIcons.Keys.ToList();

foreach (var id in displayedIconIDs) {
if (!currentEffectIDs.Contains(id)) {
if (activeIcons.TryGetValue(id, out StatusEffectIconUI iconToDestroy)) {
if (iconToDestroy != null) Destroy(iconToDestroy.gameObject);
}
activeIcons.Remove(id);
}
}

foreach (var instance in currentEffectInstances) {
if (!activeIcons.ContainsKey(instance.effect.effectID)) {
CreateEffectIcon(instance);
}
}

for (int i = 0; i < currentEffectInstances.Count; i++) {
string effectID = currentEffectInstances[i].effect.effectID;
if (activeIcons.TryGetValue(effectID, out StatusEffectIconUI iconUI)) {
iconUI.transform.SetSiblingIndex(i);
}
}
}

void CreateEffectIcon(StatusEffectInstance instance) {
if (effectIconPrefab == null) {
Debug.LogError("Effect Icon Prefab is missing!", this);
return;
}

GameObject iconObj = Instantiate(effectIconPrefab, effectIconContainer);
iconObj.SetActive(true);
StatusEffectIconUI iconUI = iconObj.GetComponent<StatusEffectIconUI>();

if (iconUI == null) iconUI = iconObj.AddComponent<StatusEffectIconUI>();

iconUI.Initialize(instance);
activeIcons[instance.effect.effectID] = iconUI;
}

void CreateDefaultIconPrefab() {
float iconSize = 0.32f; // e.g., 0.32 world units
float iconPadding = 0.04f;
float fontSize = 0.2f;

GameObject prefab = new GameObject("StatusEffectIcon");
prefab.AddComponent<RectTransform>().sizeDelta = new Vector2(iconSize, iconSize);
prefab.AddComponent<LayoutElement>();

GameObject bg = new GameObject("Background");
bg.transform.SetParent(prefab.transform, false);
Image bgImage = bg.AddComponent<Image>();
bgImage.color = new Color(0, 0, 0, 0.5f);
bg.GetComponent<RectTransform>().sizeDelta = new Vector2(iconSize, iconSize);

GameObject icon = new GameObject("Icon");
icon.transform.SetParent(prefab.transform, false);
Image iconImage = icon.AddComponent<Image>();
iconImage.enabled = false;
icon.GetComponent<RectTransform>().sizeDelta = new Vector2(iconSize - iconPadding, iconSize - iconPadding);

GameObject unicodeTextGO = new GameObject("UnicodeText");
unicodeTextGO.transform.SetParent(icon.transform, false);
TextMeshProUGUI tmpText = unicodeTextGO.AddComponent<TextMeshProUGUI>();
tmpText.text = "?";
tmpText.fontSize = fontSize; // Use the smaller font size
tmpText.alignment = TextAlignmentOptions.Center;
tmpText.enabled = false;
RectTransform textRect = tmpText.GetComponent<RectTransform>();
textRect.anchorMin = Vector2.zero;
textRect.anchorMax = Vector2.one;
textRect.sizeDelta = Vector2.zero;
textRect.anchoredPosition = Vector2.zero;

effectIconPrefab = prefab;
effectIconPrefab.SetActive(false);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\UI\ThoughtBubbleController.cs

﻿// Assets/Scripts/Ecosystem/UI/ThoughtBubbleController.cs

using TMPro;
using WegoSystem;

pub cls ThoughtBubbleController : MonoBehaviour {
pub TMP_Text messageText;

float lifetimeTicks;
Transform followTarget;
TickManager _tickManagerInstance; // Cached instance

void Start() {
_tickManagerInstance = TickManager.Instance;
if (_tickManagerInstance == null) {
Debug.LogWarning($"[{GetType().Name}] TickManager not found! Lifetime will use a fallback duration.", this);
}
}

pub void Initialize(string message, Transform target, float durationInTicks) {
if (messageText != null)
messageText.text = message;

followTarget = target;
lifetimeTicks = durationInTicks;
}

void Update() {
if (_tickManagerInstance?.Config != null) {
lifetimeTicks -= _tickManagerInstance.Config.ticksPerRealSecond * Time.deltaTime;
}
else {
lifetimeTicks -= 2f * Time.deltaTime;
}

if (lifetimeTicks <= 0f)
Destroy(gameObject);

if (followTarget != null) {
transform.position = followTarget.position;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\UI\ThoughtTrigger.cs

﻿using UnityEngine;

pub enum ThoughtTrigger {
Hungry,
Eating,
HealthLow,
Fleeing,
Pooping,
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\RadiusPatternTester.cs

﻿using UnityEngine;
using WegoSystem;

#if UNITY_EDITOR
using UnityEditor;

pub cls RadiusPatternTesterEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

RadiusPatternTester tester = (RadiusPatternTester)target;

if (GUILayout.Button("Test Radius Pattern")) {
tester.TestRadiusPattern();
}

if (GUILayout.Button("Compare All Patterns")) {
tester.CompareAllPatterns();
}
}
}
#endif

pub cls RadiusPatternTester : MonoBehaviour {
pub int testRadius = 3;

pub void TestRadiusPattern() {
GridRadiusUtility.DebugPrintRadius(GridPosition.Zero, testRadius);
}

pub void CompareAllPatterns() {
Debug.Log("=== RADIUS PATTERN COMPARISON ===");

for (int r = 1; r <= 5; r++) {
Debug.Log($"\n--- Radius {r} ---");

var circleTiles = GridRadiusUtility.GetTilesInCircle(GridPosition.Zero, r);
Debug.Log($"Circle tiles: {circleTiles.Count}");

GridRadiusUtility.DebugPrintRadius(GridPosition.Zero, r);

int manhattanCount = 0;
int chebyshevCount = 0;

for (int x = -r; x <= r; x++) {
for (int y = -r; y <= r; y++) {
if (Mathf.Abs(x) + Mathf.Abs(y) <= r) manhattanCount++;
if (Mathf.Max(Mathf.Abs(x), Mathf.Abs(y)) <= r) chebyshevCount++;
}
}

Debug.Log($"Manhattan (diamond): {manhattanCount} tiles");
Debug.Log($"Chebyshev (square): {chebyshevCount} tiles");
Debug.Log($"Circle (ours): {circleTiles.Count} tiles");
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\TileDefinitionEditor.cs

﻿#if UNITY_EDITOR
using UnityEditor;

pub cls TileDefinitionEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

TileDefinition tileDefinition = (TileDefinition)target;

EditorGUILayout.Space();
if (GUILayout.Button("UPDATE COLOR IN SCENE", GUILayout.Height(30))) {
tileDefinition.UpdateColor();
}
}
}
#endif

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\TileInteractionManagerEditor.cs

﻿#if UNITY_EDITOR
using UnityEditor;

pub cls TileInteractionManagerEditor : Editor {
pub ovr void OnInspectorGUI() {
DrawDefaultInspector();

TileInteractionManager manager = (TileInteractionManager)target;

EditorGUILayout.Space();
EditorGUILayout.BeginHorizontal();

if (GUILayout.Button("UPDATE SORTING ORDER", GUILayout.Height(30))) {
manager.UpdateSortingOrder();
EditorUtility.SetDirty(manager);
}

if (GUILayout.Button("UPDATE ALL COLORS", GUILayout.Height(30))) {
manager.UpdateAllColors();
EditorUtility.SetDirty(manager);
}

EditorGUILayout.EndHorizontal();

EditorGUILayout.HelpBox("Order: First item in list gets highest sorting order value (" +
manager.baseSortingOrder + "). Each subsequent item is " +
(manager.baseSortingOrder - 1) + ", " +
(manager.baseSortingOrder - 2) + ", etc.", MessageType.Info);
}
}
#endif

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\WaveDefinitionEditor.cs

﻿using UnityEngine;
using UnityEditor;
using UnityEditorInternal;

pub cls WaveDefinitionEditor : Editor {
ReorderableList spawnList;
SerializedProperty spawnEntries;

void OnEnable() {
spawnEntries = serializedObject.FindProperty("spawnEntries");

spawnList = new ReorderableList(serializedObject, spawnEntries, true, true, true, true);

spawnList.drawHeaderCallback = (Rect rect) => {
EditorGUI.LabelField(rect, "Spawn Entries");
};

spawnList.elementHeightCallback = (int index) => {
ret EditorGUIUtility.singleLineHeight * 4 + 10;
};

spawnList.drawElementCallback = (Rect rect, int index, bool isActive, bool isFocused) => {
var element = spawnEntries.GetArrayElementAtIndex(index);
rect.y += 2;

float lineHeight = EditorGUIUtility.singleLineHeight;
float spacing = 2;

Rect descRect = new Rect(rect.x, rect.y, rect.width * 0.4f, lineHeight);
Rect animalRect = new Rect(rect.x + rect.width * 0.42f, rect.y, rect.width * 0.58f, lineHeight);

EditorGUI.PropertyField(descRect, element.FindPropertyRelative("description"), GUIContent.none);
EditorGUI.PropertyField(animalRect, element.FindPropertyRelative("animalDefinition"), GUIContent.none);

rect.y += lineHeight + spacing;

Rect countRect = new Rect(rect.x, rect.y, rect.width * 0.3f, lineHeight);
Rect delayRect = new Rect(rect.x + rect.width * 0.32f, rect.y, rect.width * 0.3f, lineHeight);
Rect intervalRect = new Rect(rect.x + rect.width * 0.64f, rect.y, rect.width * 0.36f, lineHeight);

EditorGUI.LabelField(countRect, "Count:");
countRect.x += 40;
countRect.width -= 40;
EditorGUI.PropertyField(countRect, element.FindPropertyRelative("spawnCount"), GUIContent.none);

EditorGUI.LabelField(delayRect, "Delay:");
delayRect.x += 35;
delayRect.width -= 35;
EditorGUI.PropertyField(delayRect, element.FindPropertyRelative("delayAfterSpawnTime"), GUIContent.none);

EditorGUI.LabelField(intervalRect, "Interval:");
intervalRect.x += 45;
intervalRect.width -= 45;
EditorGUI.PropertyField(intervalRect, element.FindPropertyRelative("spawnInterval"), GUIContent.none);

rect.y += lineHeight + spacing;

Rect locTypeRect = new Rect(rect.x, rect.y, rect.width * 0.6f, lineHeight);
Rect radiusRect = new Rect(rect.x + rect.width * 0.62f, rect.y, rect.width * 0.38f, lineHeight);

EditorGUI.PropertyField(locTypeRect, element.FindPropertyRelative("spawnLocationType"), GUIContent.none);

EditorGUI.LabelField(radiusRect, "Radius:");
radiusRect.x += 45;
radiusRect.width -= 45;
EditorGUI.PropertyField(radiusRect, element.FindPropertyRelative("spawnRadius"), GUIContent.none);
};

spawnList.onAddCallback = (ReorderableList list) => {
var index = list.serializedProperty.arraySize;
list.serializedProperty.arraySize++;
list.index = index;

var element = list.serializedProperty.GetArrayElementAtIndex(index);
element.FindPropertyRelative("description").stringValue = "New Spawn Entry";
element.FindPropertyRelative("spawnCount").intValue = 1;
element.FindPropertyRelative("delayAfterSpawnTime").floatValue = 0f;
element.FindPropertyRelative("spawnInterval").floatValue = 0.5f;
element.FindPropertyRelative("spawnRadius").floatValue = 5f;
};
}

pub ovr void OnInspectorGUI() {
serializedObject.Update();

WaveDefinition waveDef = (WaveDefinition)target;

EditorGUILayout.LabelField("Wave Definition", EditorStyles.boldLabel);
EditorGUILayout.Space();

EditorGUILayout.BeginHorizontal();
EditorGUILayout.LabelField("Wave Name:", GUILayout.Width(80));
SerializedProperty waveNameProp = serializedObject.FindProperty("waveName");
waveNameProp.stringValue = EditorGUILayout.TextField(waveNameProp.stringValue);
EditorGUILayout.EndHorizontal();

EditorGUILayout.Space();

int totalEnemies = 0;
float totalDuration = 0;

foreach (WaveSpawnEntry entry in waveDef.spawnEntries) {
if (entry != null) {
totalEnemies += entry.spawnCount;
totalDuration = Mathf.Max(totalDuration,
entry.delayAfterSpawnTime + (entry.spawnCount - 1) * entry.spawnInterval);
}
}

EditorGUILayout.HelpBox(
$"Total Enemies: {totalEnemies}\n" +
$"Spawn Duration: ~{totalDuration:F1} seconds",
MessageType.Info
);

EditorGUILayout.Space();

spawnList.DoLayoutList();

serializedObject.ApplyModifiedProperties();

EditorGUILayout.Space();

if (GUILayout.Button("Clear All Entries")) {
if (EditorUtility.DisplayDialog("Clear All Entries",
"Are you sure you want to remove all spawn entries?",
"Clear", "Cancel")) {
waveDef.spawnEntries.Clear();
EditorUtility.SetDirty(waveDef);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Editor\WaveManagerEditor.cs

﻿using UnityEngine;
using UnityEditor;
using WegoSystem;

pub cls WaveManagerEditor : Editor {
SerializedProperty waveDurationInDays;
SerializedProperty spawnTimeNormalized;
SerializedProperty continuousSpawning;
SerializedProperty deletePreviousWaveAnimals;
SerializedProperty wavesSequence;

bool showTimingSettings = true;
bool showWaveSequence = true;
bool showDebugInfo = false;

void OnEnable() {
waveDurationInDays = serializedObject.FindProperty("waveDurationInDays");
spawnTimeNormalized = serializedObject.FindProperty("spawnTimeNormalized");
continuousSpawning = serializedObject.FindProperty("continuousSpawning");
deletePreviousWaveAnimals = serializedObject.FindProperty("deletePreviousWaveAnimals");
wavesSequence = serializedObject.FindProperty("wavesSequence");
}

pub ovr void OnInspectorGUI() {
serializedObject.Update();

WaveManager waveManager = (WaveManager)target;

EditorGUILayout.LabelField("Wave Manager", EditorStyles.boldLabel);
EditorGUILayout.Space();

DrawPropertiesExcluding(serializedObject,
"waveDurationInDays",
"spawnTimeNormalized",
"continuousSpawning",
"deletePreviousWaveAnimals",
"wavesSequence"
);

EditorGUILayout.Space();

showTimingSettings = EditorGUILayout.BeginFoldoutHeaderGroup(showTimingSettings, "Wave Timing Settings");
if (showTimingSettings) {
EditorGUI.indentLevel++;

EditorGUILayout.BeginHorizontal();
EditorGUILayout.PropertyField(waveDurationInDays, new GUIContent("Wave Duration (Days)"));
EditorGUILayout.EndHorizontal();

if (Application.isPlaying && TickManager.Instance?.Config != null) {
var config = TickManager.Instance.Config;
int totalTicks = config.ticksPerDay * waveDurationInDays.intValue;
EditorGUILayout.HelpBox($"Wave will last {totalTicks} ticks", MessageType.Info);
}

EditorGUILayout.Space();

float spawnPercent = spawnTimeNormalized.floatValue * 100f;
EditorGUILayout.LabelField($"Spawn Start: {spawnPercent:F0}% into wave");
spawnTimeNormalized.floatValue = EditorGUILayout.Slider("Spawn Time", spawnTimeNormalized.floatValue, 0f, 1f);

DrawTimingBar(spawnTimeNormalized.floatValue);

EditorGUILayout.Space();

EditorGUILayout.PropertyField(continuousSpawning, new GUIContent("Continuous Spawning", "If enabled, enemies spawn throughout the wave"));

EditorGUI.indentLevel--;
}
EditorGUILayout.EndFoldoutHeaderGroup();

EditorGUILayout.Space();

EditorGUILayout.PropertyField(deletePreviousWaveAnimals, new GUIContent("Clear Previous Wave", "Delete all animals when starting a new wave"));

EditorGUILayout.Space();

showWaveSequence = EditorGUILayout.BeginFoldoutHeaderGroup(showWaveSequence, "Wave Sequence");
if (showWaveSequence) {
EditorGUI.indentLevel++;

if (wavesSequence.arraySize == 0) {
EditorGUILayout.HelpBox("No waves defined! Add wave definitions to the sequence.", MessageType.Warning);
}

for (int i = 0; i < wavesSequence.arraySize; i++) {
EditorGUILayout.BeginHorizontal();

var element = wavesSequence.GetArrayElementAtIndex(i);
var waveDef = element.objectReferenceValue as WaveDefinition;

string label = $"Round {i + 1}";
if (waveDef != null && !string.IsNullOrEmpty(waveDef.waveName)) {
label += $": {waveDef.waveName}";
}

EditorGUILayout.PropertyField(element, new GUIContent(label));

if (GUILayout.Button("X", GUILayout.Width(20))) {
wavesSequence.DeleteArrayElementAtIndex(i);
break;
}

EditorGUILayout.EndHorizontal();
}

EditorGUILayout.BeginHorizontal();
GUILayout.FlexibleSpace();
if (GUILayout.Button("Add Wave", GUILayout.Width(100))) {
wavesSequence.InsertArrayElementAtIndex(wavesSequence.arraySize);
}
EditorGUILayout.EndHorizontal();

EditorGUI.indentLevel--;
}
EditorGUILayout.EndFoldoutHeaderGroup();

EditorGUILayout.Space();

if (Application.isPlaying) {
showDebugInfo = EditorGUILayout.BeginFoldoutHeaderGroup(showDebugInfo, "Runtime Debug");
if (showDebugInfo) {
EditorGUI.indentLevel++;

EditorGUILayout.LabelField("Status", waveManager.IsWaveActive ? "Wave Active" : "Idle");

if (waveManager.IsWaveActive && TickManager.Instance != null) {
EditorGUILayout.Space();
DrawRuntimeWaveProgress(waveManager);
}

EditorGUILayout.Space();

EditorGUILayout.BeginHorizontal();
if (GUILayout.Button("Force End Wave")) {
waveManager.SendMessage("Debug_ForceEndWave", SendMessageOptions.DontRequireReceiver);
}
if (GUILayout.Button("Force Spawn")) {
waveManager.SendMessage("Debug_ForceSpawn", SendMessageOptions.DontRequireReceiver);
}
EditorGUILayout.EndHorizontal();

EditorGUI.indentLevel--;
}
EditorGUILayout.EndFoldoutHeaderGroup();
}

serializedObject.ApplyModifiedProperties();
}

void DrawTimingBar(float spawnTime) {
Rect rect = GUILayoutUtility.GetRect(0, 20, GUILayout.ExpandWidth(true));

EditorGUI.DrawRect(rect, new Color(0.2f, 0.2f, 0.2f));

Rect waveRect = new Rect(rect.x, rect.y, rect.width, rect.height);
EditorGUI.DrawRect(waveRect, new Color(0.3f, 0.5f, 0.3f));

float spawnX = rect.x + (rect.width * spawnTime);
Rect spawnRect = new Rect(spawnX - 2, rect.y, 4, rect.height);
EditorGUI.DrawRect(spawnRect, Color.yellow);

GUI.Label(new Rect(rect.x, rect.y, 50, rect.height), "Start", EditorStyles.miniLabel);
GUI.Label(new Rect(rect.x + rect.width - 30, rect.y, 30, rect.height), "End", EditorStyles.miniLabel);
GUI.Label(new Rect(spawnX - 25, rect.y - 20, 50, 20), "Spawn", EditorStyles.centeredGreyMiniLabel);
}

void DrawRuntimeWaveProgress(WaveManager waveManager) {
EditorGUILayout.HelpBox("Wave progress visualization requires exposing runtime data", MessageType.Info);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Core\GeneLibraryLoader.cs

﻿// REWORKED FILE: Assets/Scripts/Core/GeneLibraryLoader.cs
using Abracodabra.Genes;
using Abracodabra.Genes.Services;

pub cls GeneLibraryLoader : MonoBehaviour {
[SerializeField] GeneLibrary geneLibraryAsset;

void Awake() {
GeneServices.Initialize();

if (geneLibraryAsset == null) {
Debug.LogError("CRITICAL: The GeneLibrary Asset is not assigned in the GeneLibraryLoader component! The gene system will not work.", this);
return;
}

geneLibraryAsset.SetActiveInstance();

GeneServices.Register<IGeneLibrary>(geneLibraryAsset);

Debug.Log("GeneLibrary instance was successfully set, initialized, and registered by GeneLibraryLoader.");
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\ITriggerTarget.cs

﻿// Assets/Scripts/PlantSystem/Execution/ITriggerTarget.cs

pub ifc ITriggerTarget {
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Data\LeafData.cs

﻿using UnityEngine;

pub struct LeafData {
pub Vector2Int GridCoord;
pub bool IsActive; // True if the leaf exists, false if it was eaten

pub LeafData(Vector2Int coord, bool isActive = true) {
GridCoord = coord;
IsActive = isActive;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Execution\NodeExecutor.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/Execution/NodeExecutor.cs

using Abracodabra.Genes;
using WegoSystem;
using Abracodabra.Genes.Templates;

pub cls NodeExecutor : MonoBehaviour {
[SerializeField] GameObject plantPrefab;

pub GameObject SpawnPlantFromTemplate(SeedTemplate seedTemplate, Vector3 plantingPosition, Transform parentTransform) {
if (seedTemplate == null) {
Debug.LogError("[NodeExecutor] Cannot spawn plant: Provided SeedTemplate is null!");
ret null;
}

if (plantPrefab == null) {
Debug.LogError("[NodeExecutor] Plant prefab not assigned!");
ret null;
}

GameObject plantObj = Instantiate(plantPrefab, plantingPosition, Quaternion.identity, parentTransform);

if (GridPositionManager.Instance != null) {
GridPositionManager.Instance.SnapEntityToGrid(plantObj);
}

PlantGrowth growthComponent = plantObj.GetComponent<PlantGrowth>();
if (growthComponent != null) {
growthComponent.InitializeFromTemplate(seedTemplate);
Debug.Log($"[NodeExecutor] Plant spawned from seed template '{seedTemplate.templateName}'");
ret plantObj;
}
else {
Debug.LogError($"[NodeExecutor] Plant prefab is missing the required PlantGrowth component!");
Destroy(plantObj);
ret null;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantCell.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/Growth/PlantCell.cs

using Abracodabra.Genes;

pub enum PlantCellType { Seed, Stem, Leaf, Flower, Fruit }

pub cls PlantCell : MonoBehaviour {
[HideInInspector] pub PlantGrowth ParentPlantGrowth;
[HideInInspector] pub Vector2Int GridCoord;
[HideInInspector] pub PlantCellType CellType;

void OnDestroy() {
if (ParentPlantGrowth != null) {
ParentPlantGrowth.ReportCellDestroyed(GridCoord);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantCellManager.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/Growth/PlantCellManager.cs
using Abracodabra.Genes;
using WegoSystem;

pub cls PlantCellManager {
ro PlantGrowth plant;
ro GameObject seedCellPrefab;
ro GameObject stemCellPrefab;
ro GameObject leafCellPrefab;
ro GameObject berryCellPrefab;
ro float cellSpacing;

pub ro Dictionary<Vector2Int, PlantCellType> cells = new Dictionary<Vector2Int, PlantCellType>();
ro List<GameObject> activeCellGameObjects = new List<GameObject>();

pub List<LeafData> LeafDataList { get; } = new List<LeafData>();
pub GameObject RootCellInstance { get; set; }

pub PlantCellManager(PlantGrowth plant, GameObject seedPrefab, GameObject stemPrefab, GameObject leafPrefab, GameObject berryPrefab, float spacing) {
this.plant = plant;
this.seedCellPrefab = seedPrefab;
this.stemCellPrefab = stemPrefab;
this.leafCellPrefab = leafPrefab;
this.berryCellPrefab = berryPrefab;
this.cellSpacing = spacing;
}

pub void ReportCellDestroyed(Vector2Int coord) {
if (cells.TryGetValue(coord, out PlantCellType cellType)) {
if (cellType == PlantCellType.Leaf) {
for (int i = 0; i < LeafDataList.Count; i++) {
if (LeafDataList[i].GridCoord == coord) {
LeafDataList[i] = new LeafData(coord, false);
break;
}
}
}

cells.Remove(coord);
activeCellGameObjects.RemoveAll(go => go == null || (go.GetComponent<PlantCell>()?.GridCoord == coord));

plant.VisualManager.OutlineController?.OnPlantCellRemoved(coord);
}
}

pub void ClearAllVisuals() {
foreach (GameObject cellGO in new List<GameObject>(activeCellGameObjects)) {
if (cellGO != null) {
Object.Destroy(cellGO);
}
}
activeCellGameObjects.Clear();
cells.Clear();
RootCellInstance = null;
}

pub GameObject SpawnCellVisual(PlantCellType cellType, Vector2Int coords) {
if (cells.ContainsKey(coords)) {
Debug.LogWarning($"[{plant.gameObject.name}] Trying to spawn {cellType} at already occupied coordinate {coords}.");
ret GetCellGameObjectAt(coords);
}

GameObject prefab = GetPrefabForType(cellType);
if (prefab == null) ret null;

Vector2 worldPos = (Vector2)plant.transform.position + ((Vector2)coords * cellSpacing);
GameObject instance = Object.Instantiate(prefab, worldPos, Quaternion.identity, plant.transform);
instance.name = $"{plant.gameObject.name}_{cellType}_{coords.x}_{coords.y}";

if (cellType != PlantCellType.Seed) {
if (instance.TryGetComponent<GridEntity>(out var partGridEntity)) {
Object.Destroy(partGridEntity);
}
}

var cellComp = instance.GetComponent<PlantCell>() ?? instance.AddComponent<PlantCell>();
cellComp.ParentPlantGrowth = plant;
cellComp.GridCoord = coords;
cellComp.CellType = cellType;

cells[coords] = cellType;
activeCellGameObjects.Add(instance);

if (cellType == PlantCellType.Leaf) {
LeafDataList.Add(new LeafData(coords, true));
instance.tag = "FruitSpawn";
}

plant.VisualManager.RegisterShadowForCell(instance, cellType.ToString());
plant.VisualManager.RegisterOutlineForCell(instance, cellType.ToString());

ret instance;
}

GameObject GetPrefabForType(PlantCellType cellType) {
switch (cellType) {
case PlantCellType.Seed: ret seedCellPrefab;
case PlantCellType.Stem: ret stemCellPrefab;
case PlantCellType.Leaf: ret leafCellPrefab;
case PlantCellType.Fruit: ret berryCellPrefab;
default:
Debug.LogError($"[{plant.gameObject.name}] No prefab assigned for PlantCellType.{cellType}!");
ret null;
}
}

pub bool HasCellAt(Vector2Int coord) => cells.ContainsKey(coord);
pub GameObject GetCellGameObjectAt(Vector2Int coord) => activeCellGameObjects.FirstOrDefault(go => go != null && go.GetComponent<PlantCell>()?.GridCoord == coord);
pub int GetActiveLeafCount() => LeafDataList.Count(leaf => leaf.IsActive);
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantEnergySystem.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/Growth/PlantEnergySystem.cs

using Abracodabra.Genes;
using WegoSystem;

pub cls PlantEnergySystem {
ro PlantGrowth plant;

pub float CurrentEnergy { get; set; }
pub float MaxEnergy { get; set; }
pub float BaseEnergyPerLeaf { get; set; } = 0.1f; // Base rate from template

ro FireflyManager fireflyManagerInstance;

pub PlantEnergySystem(PlantGrowth plant) {
this.plant = plant;
this.fireflyManagerInstance = FireflyManager.Instance;
}

pub void OnTickUpdate() {
if (plant.GrowthLogic == null || MaxEnergy <= 0) return;

int leafCount = plant.CellManager.GetActiveLeafCount();
if (leafCount <= 0) return;

float sunlight = WeatherManager.Instance != null ? WeatherManager.Instance.sunIntensity : 1f;

float fireflyBonusRate = 0f;
if (fireflyManagerInstance != null) {
int nearbyFlyCount = fireflyManagerInstance.GetNearbyFireflyCount(plant.transform.position, fireflyManagerInstance.photosynthesisRadius);
fireflyBonusRate = Mathf.Min(
nearbyFlyCount * fireflyManagerInstance.photosynthesisIntensityPerFly,
fireflyManagerInstance.maxPhotosynthesisBonus
);
}

float effectiveRate = BaseEnergyPerLeaf * plant.energyGenerationMultiplier;
float totalPhotosynthesisRatePerLeaf = (effectiveRate * sunlight) + fireflyBonusRate;
float energyThisTick = totalPhotosynthesisRatePerLeaf * leafCount;

CurrentEnergy = Mathf.Clamp(CurrentEnergy + energyThisTick, 0f, MaxEnergy);
}

pub void SpendEnergy(float amount) {
CurrentEnergy = Mathf.Max(0f, CurrentEnergy - amount);
}

pub void AddEnergy(float amount) {
CurrentEnergy = Mathf.Clamp(CurrentEnergy + amount, 0f, MaxEnergy);
}

pub bool HasEnergy(float amount) {
ret CurrentEnergy >= amount;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantGrowthLogic.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/Growth/PlantGrowthLogic.cs

using Abracodabra.Genes;
using WegoSystem;
using Abracodabra.Genes.Core;

pub cls PlantGrowthLogic {
ro PlantGrowth plant;

pub int TargetStemLength { get; set; }
pub int GrowthTicksPerStage { get; set; }
pub float PhotosynthesisEfficiencyPerLeaf { get; set; }

pub PlantGrowthLogic(PlantGrowth plant) {
this.plant = plant;
}

pub void CalculateAndApplyPassiveStats() {
if (plant.geneRuntimeState == null) {
Debug.LogError($"[{plant.gameObject.name}] CalculateAndApplyStats called with null geneRuntimeState!");
return;
}

foreach (var instance in plant.geneRuntimeState.passiveInstances) {
var passiveGene = instance.GetGene<PassiveGene>();
if (passiveGene != null) {
passiveGene.ApplyToPlant(plant, instance);
}
}

if (plant.EnergySystem != null) {
plant.EnergySystem.BaseEnergyPerLeaf = PhotosynthesisEfficiencyPerLeaf;
}

Debug.Log($"[{plant.gameObject.name}] Final stats after passives: " +
$"GrowthSpeed={plant.growthSpeedMultiplier}x, " +
$"EnergyGen={plant.energyGenerationMultiplier}x, " +
$"Height={plant.minHeight}-{plant.maxHeight}");
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Growth\PlantVisualManager.cs

﻿// REWORKED FILE: Assets/Scripts/PlantSystem/Growth/PlantVisualManager.cs

using Abracodabra.Genes;
using TMPro;

pub cls PlantVisualManager {
ro PlantGrowth plant;
ro PlantShadowController shadowController;
ro GameObject shadowPartPrefab;
ro bool enableOutline;
pub PlantOutlineController OutlineController { get; set; }
ro GameObject outlinePartPrefab;
ro TMP_Text energyText;

pub PlantVisualManager(PlantGrowth plant, PlantShadowController shadowController, GameObject shadowPartPrefab, PlantOutlineController outlineController, GameObject outlinePartPrefab, bool enableOutline) {
this.plant = plant;
this.shadowController = shadowController;
this.shadowPartPrefab = shadowPartPrefab;
this.OutlineController = outlineController;
this.outlinePartPrefab = outlinePartPrefab;
this.enableOutline = enableOutline;
this.energyText = plant.GetComponentInChildren<TMP_Text>(true);
}

pub void RegisterShadowForCell(GameObject cellInstance, string cellTypeName) {
if (shadowController != null && shadowPartPrefab != null && cellInstance != null && cellInstance.TryGetComponent<SpriteRenderer>(out var partRenderer)) {
shadowController.RegisterPlantPart(partRenderer, shadowPartPrefab);
}
}

pub void RegisterOutlineForCell(GameObject cellInstance, string cellTypeName) {
if (enableOutline && OutlineController != null && cellInstance != null && cellInstance.TryGetComponent<SpriteRenderer>(out var partRenderer)) {
OutlineController.RegisterPlantPart(partRenderer, outlinePartPrefab);
}
}

pub void UpdateUI() {
if (energyText == null) return;

if (plant.CurrentState == PlantState.Growing || plant.CurrentState == PlantState.Initializing) {
UpdateGrowthPercentageUI();
}
else {
UpdateEnergyUI();
}
}

void UpdateGrowthPercentageUI() {
energyText.text = "Growing...";
}

void UpdateEnergyUI() {
if (energyText == null || plant.EnergySystem == null) return;
float currentEnergy = plant.EnergySystem.CurrentEnergy;
float maxEnergy = plant.EnergySystem.MaxEnergy;
energyText.text = $"{currentEnergy:F1}/{maxEnergy:F0}";
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryBarController.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/UI/InventoryBarController.cs
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Templates;
using Abracodabra.UI.Genes; // For ItemView

pub cls InventoryBarController : MonoBehaviour {
pub stat InventoryBarController Instance { get; set; }

[SerializeField] int slotsPerRow = 10;
[SerializeField] InventoryGridController inventoryGridController;
[SerializeField] Transform cellContainer;
[SerializeField] GameObject selectionHighlight;
[SerializeField] GameObject inventoryItemViewPrefab; // Prefab with just ItemView and visuals

List<GameObject> barSlots = new List<GameObject>();
int selectedSlot = 0;

pub InventoryBarItem SelectedItem { get; set; }
pub event System.Action<InventoryBarItem> OnSelectionChanged;

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;
selectedSlot = 0;
}

void Start() {
if (inventoryGridController != null) {
inventoryGridController.OnInventoryChanged += HandleInventoryChanged;
}
SetupBarCells();
gameObject.SetActive(false); // Start hidden
}

void OnDestroy() {
if (inventoryGridController != null) {
inventoryGridController.OnInventoryChanged -= HandleInventoryChanged;
}
}

void HandleInventoryChanged() {
if (gameObject.activeInHierarchy) {
UpdateBarDisplay();
UpdateSelection();
}
}

void Update() {
if (!gameObject.activeInHierarchy) return;
HandleNumberKeyInput();
}

pub void ShowBar() {
RefreshBar();
gameObject.SetActive(true);
}

pub void HideBar() {
gameObject.SetActive(false);
if (selectionHighlight != null) selectionHighlight.SetActive(false);
UniversalTooltipManager.Instance?.HideTooltip();
}

void RefreshBar() {
if (selectedSlot < 0 && slotsPerRow > 0) selectedSlot = 0;
UpdateBarDisplay();
UpdateSelection();
}

void SetupBarCells() {
foreach (Transform child in cellContainer) Destroy(child.gameObject);
barSlots.Clear();

GridLayoutGroup gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
gridLayout.constraintCount = slotsPerRow;

for (int i = 0; i < slotsPerRow; i++) {
GameObject cellGO = new GameObject($"BarCell_{i}", typeof(RectTransform), typeof(Image));
cellGO.transform.SetParent(cellContainer, false);
barSlots.Add(cellGO);
}
}

void UpdateBarDisplay() {
foreach (var slot in barSlots) {
foreach (Transform child in slot.transform) {
Destroy(child.gameObject);
}
}

if (inventoryGridController == null) return;

var allGenes = inventoryGridController.GetAllGenes();

for (int i = 0; i < Mathf.Min(allGenes.Count, slotsPerRow); i++) {
if (i >= barSlots.Count) break;

var gene = allGenes[i];
if (gene == null) continue;

GameObject itemVisual = new GameObject("ItemVisual");
itemVisual.transform.SetParent(barSlots[i].transform, false);

var itemImage = itemVisual.AddComponent<Image>();
var geneBase = gene.GetGene();
if (geneBase != null && geneBase.icon != null) {
itemImage.sprite = geneBase.icon;
itemImage.color = geneBase.geneColor;
}

var barItem = itemVisual.AddComponent<InventoryBarItemComponent>();
barItem.runtimeInstance = gene;
barItem.slotIndex = i;
}
}

void HandleNumberKeyInput() {
for (int i = 1; i <= 9; i++) {
if (Input.GetKeyDown(KeyCode.Alpha0 + i)) {
SelectSlot(i - 1);
return;
}
}
if (Input.GetKeyDown(KeyCode.Alpha0)) {
SelectSlot(9);
}
}

void SelectSlot(int slotIndex) {
if (slotIndex < 0 || slotIndex >= slotsPerRow) return;

if (slotIndex < barSlots.Count) {
var slot = barSlots[slotIndex];
var itemComponent = slot.GetComponentInChildren<InventoryBarItemComponent>();

if (itemComponent != null && itemComponent.runtimeInstance != null) {
SelectedItem = InventoryBarItem.FromGene(itemComponent.runtimeInstance, slot);
selectedSlot = slotIndex;
}
else {
SelectedItem = null;
selectedSlot = -1;
}
}

UpdateSelection();
}

pub cls InventoryBarItemComponent : MonoBehaviour {
pub RuntimeGeneInstance runtimeInstance;
pub int slotIndex;
}

void UpdateSelection() {
SelectedItem = null; // Placeholder

if (selectionHighlight != null) {
selectionHighlight.SetActive(SelectedItem != null);
if (SelectedItem != null) {
selectionHighlight.transform.SetParent(barSlots[selectedSlot].transform, false);
}
}

OnSelectionChanged?.Invoke(SelectedItem);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryBarItem.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/UI/InventoryBarItem.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Templates;

pub cls InventoryBarItem {
pub enum ItemType { Gene, Seed, Tool }

pub ItemType Type { get; set; }
pub RuntimeGeneInstance GeneInstance { get; set; }
pub SeedTemplate SeedTemplate { get; set; }
pub ToolDefinition ToolDefinition { get; set; }
pub GameObject ViewGameObject { get; set; } // The UI object in the inventory

pub stat InventoryBarItem FromGene(RuntimeGeneInstance instance, GameObject viewObj = null) {
if (instance == null) ret null;
ret new InventoryBarItem {
Type = ItemType.Gene,
GeneInstance = instance,
ViewGameObject = viewObj
};
}

pub stat InventoryBarItem FromSeed(SeedTemplate seed, GameObject viewObj = null) {
if (seed == null) ret null;
ret new InventoryBarItem {
Type = ItemType.Seed,
SeedTemplate = seed,
ViewGameObject = viewObj
};
}

pub stat InventoryBarItem FromTool(ToolDefinition tool, GameObject viewObj = null) {
if (tool == null) ret null;
ret new InventoryBarItem {
Type = ItemType.Tool,
ToolDefinition = tool,
ViewGameObject = viewObj
};
}

pub string GetDisplayName() {
switch (Type) {
case ItemType.Gene: ret GeneInstance?.GetGene()?.geneName ?? "Unknown Gene";
case ItemType.Seed: ret SeedTemplate?.templateName ?? "Unknown Seed";
case ItemType.Tool: ret ToolDefinition?.displayName ?? "Unknown Tool";
default: ret "Invalid Item";
}
}

pub Sprite GetIcon() {
switch (Type) {
case ItemType.Gene: ret GeneInstance?.GetGene()?.icon;
case ItemType.Seed: ret SeedTemplate?.icon;
case ItemType.Tool: ret ToolDefinition?.icon;
default: ret null;
}
}

pub bool IsValid() {
switch (Type) {
case ItemType.Gene: ret GeneInstance?.GetGene() != null;
case ItemType.Seed: ret SeedTemplate != null;
case ItemType.Tool: ret ToolDefinition != null;
default: ret false;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryColorManager.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/UI/InventoryColorManager.cs
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Templates;

pub cls InventoryColorManager : MonoBehaviour {
pub stat InventoryColorManager Instance { get; set; }

[SerializeField] Color toolCellColor = new Color(0.5f, 0.5f, 0.5f, 1f);
[SerializeField] Color seedCellColor = new Color(0.8f, 1f, 0.8f, 1f);
[SerializeField] Color passiveGeneCellColor = new Color(0.8f, 0.8f, 1f, 1f);
[SerializeField] Color activeGeneCellColor = new Color(1f, 0.8f, 0.8f, 1f);
[SerializeField] Color modifierGeneCellColor = new Color(1f, 1f, 0.7f, 1f); // Yellowish
[SerializeField] Color payloadGeneCellColor = new Color(1f, 0.7f, 1f, 1f);
[SerializeField] Color defaultCellColor = new Color(0.9f, 0.9f, 0.9f, 1f);

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;
}

pub Color GetCellColorForItem(GeneBase gene, SeedTemplate seed, ToolDefinition tool) {
switch (GetItemCategory(gene, seed, tool)) {
case ItemCategory.Tool: ret toolCellColor;
case ItemCategory.Seed: ret seedCellColor;
case ItemCategory.PassiveGene: ret passiveGeneCellColor;
case ItemCategory.ActiveGene: ret activeGeneCellColor;
case ItemCategory.ModifierGene: ret modifierGeneCellColor;
case ItemCategory.PayloadGene: ret payloadGeneCellColor;
default: ret defaultCellColor;
}
}

pub enum ItemCategory {
Tool,
Seed,
PassiveGene,
ActiveGene,
ModifierGene,
PayloadGene,
Default
}

pub ItemCategory GetItemCategory(GeneBase gene, SeedTemplate seed, ToolDefinition tool) {
if (tool != null) ret ItemCategory.Tool;
if (seed != null) ret ItemCategory.Seed;
if (gene != null) {
switch (gene.Category) {
case GeneCategory.Passive: ret ItemCategory.PassiveGene;
case GeneCategory.Active: ret ItemCategory.ActiveGene;
case GeneCategory.Modifier: ret ItemCategory.ModifierGene;
case GeneCategory.Payload: ret ItemCategory.PayloadGene;
}
}
ret ItemCategory.Default;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\UI\InventoryGridController.cs

﻿// Reworked File: Assets/Scripts/PlantSystem/UI/InventoryGridController.cs
using Abracodabra.Genes;
using Abracodabra.Genes.Core;
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Templates;
using Abracodabra.UI.Genes;

pub cls InventoryGridController : MonoBehaviour {
pub stat InventoryGridController Instance { get; set; }

[SerializeField][Min(1)] int inventoryRows = 2;
[SerializeField][Min(1)] int inventoryColumns = 8;
[SerializeField] Vector2 cellSize = new Vector2(64f, 64f);
[SerializeField] float cellMargin = 10f;

[SerializeField] GameObject geneSlotPrefab; // IMPORTANT: Must have GeneSlotUI component
[SerializeField] Transform cellContainer;
[SerializeField] GeneLibrary geneLibrary; // To populate initial genes

List<GeneSlotUI> inventorySlots = new List<GeneSlotUI>();

pub event System.Action OnInventoryChanged;

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;
}

void Start() {
if (cellContainer == null) Debug.LogError("InventoryGridController: Cell Container not assigned!", this);
if (geneSlotPrefab == null) Debug.LogError("InventoryGridController: Gene Slot Prefab not assigned!", this);
if (geneLibrary == null) geneLibrary = GeneLibrary.Instance;

CreateInventoryCells();
PopulateInitialInventory();
}

void CreateInventoryCells() {
foreach (Transform child in cellContainer) Destroy(child.gameObject);
inventorySlots.Clear();

GridLayoutGroup gridLayout = cellContainer.GetComponent<GridLayoutGroup>();
if (gridLayout == null) {
Debug.LogError("InventoryGridController: Cell Container MUST have a GridLayoutGroup component.", this);
return;
}

gridLayout.cellSize = cellSize;
gridLayout.spacing = new Vector2(cellMargin, cellMargin);
gridLayout.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
gridLayout.constraintCount = inventoryColumns;

int totalCells = inventoryRows * inventoryColumns;
for (int i = 0; i < totalCells; i++) {
GameObject cellGO = Instantiate(geneSlotPrefab, cellContainer);
GeneSlotUI slotUI = cellGO.GetComponent<GeneSlotUI>();
if (slotUI != null) {
slotUI.slotIndex = i;
inventorySlots.Add(slotUI);
}
else {
Debug.LogError($"The provided Gene Slot Prefab for the inventory is missing the 'GeneSlotUI' component!", geneSlotPrefab);
}
}
}

void PopulateInitialInventory() {
if (geneLibrary == null) return;

foreach (var gene in geneLibrary.starterGenes) {
if (gene != null) {
AddGeneToInventory(gene);
}
}
}

pub bool AddGeneToInventory(GeneBase gene) {
if (gene == null) ret false;

GeneSlotUI emptySlot = inventorySlots.FirstOrDefault(slot => slot.GetGeneInstance() == null);
if (emptySlot == null) {
Debug.LogWarning("Inventory is full! Cannot add new gene.");
ret false;
}

var runtimeInstance = new RuntimeGeneInstance(gene);
emptySlot.SetGeneInstance(runtimeInstance);

OnInventoryChanged?.Invoke();
ret true;
}

pub void RemoveGeneFromInventory(RuntimeGeneInstance instance) {
if (instance == null) return;

GeneSlotUI slot = inventorySlots.FirstOrDefault(s => s.GetGeneInstance() == instance);
if (slot != null) {
slot.ClearSlot();
OnInventoryChanged?.Invoke();
}
}

pub List<RuntimeGeneInstance> GetAllGenes() {
ret inventorySlots
.Where(s => s.GetGeneInstance() != null)
.Select(s => s.GetGeneInstance())
.ToList();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\OutlinePartController.cs

﻿// REWORKED FILE: Assets/Scripts/PlantSystem/Visual/OutlinePartController.cs

using Abracodabra.Genes;

pub cls OutlinePartController : MonoBehaviour {
SpriteRenderer outlineRenderer;
Transform cachedTransform;
SpriteRenderer sourcePlantPartRenderer;

pub Vector2Int gridCoord;

void Awake() {
outlineRenderer = GetComponent<SpriteRenderer>();
cachedTransform = transform;

if (outlineRenderer != null) {
outlineRenderer.drawMode = SpriteDrawMode.Simple;
outlineRenderer.enabled = false;
}
}

pub void Initialize(SpriteRenderer sourceRenderer, Vector2Int myCoord, PlantOutlineController controller) {
if (sourceRenderer == null || controller == null) { Destroy(gameObject); return; }

sourcePlantPartRenderer = sourceRenderer;
gridCoord = myCoord;

outlineRenderer.sortingLayerID = controller.OutlineSortingLayer;
outlineRenderer.sortingOrder = controller.OutlineSortingOrder;
outlineRenderer.color = controller.OutlineColor;

cachedTransform.SetParent(controller.transform, true);

float spacing = 0.08f; // Fallback
var plant = controller.GetComponentInParent<PlantGrowth>();
if (plant != null) {
}
cachedTransform.localPosition = (Vector2)myCoord * spacing;

outlineRenderer.enabled = IsSourceRendererValid() &&
sourcePlantPartRenderer.enabled &&
sourcePlantPartRenderer.sprite != null;

SyncSpriteAndTransform();
}

void LateUpdate() {
if (outlineRenderer == null || !outlineRenderer.enabled) return;

if (!IsSourceRendererValid()) {
SetVisibility(false);
return;
}

if (!sourcePlantPartRenderer.enabled || sourcePlantPartRenderer.sprite == null) {
SetVisibility(false);
return;
}

SyncSpriteAndTransform();
}

pub bool IsSourceRendererValid() {
if (sourcePlantPartRenderer == null) ret false;
if (!sourcePlantPartRenderer.gameObject.activeInHierarchy) ret false;
ret true;
}

pub void UpdateSourceRenderer(SpriteRenderer newSource) {
if (newSource != null) {
sourcePlantPartRenderer = newSource;
SetVisibility(outlineRenderer != null && sourcePlantPartRenderer.enabled && sourcePlantPartRenderer.sprite != null);
SyncSpriteAndTransform();
}
else {
SetVisibility(false);
}
}

pub void SyncSpriteAndTransform() {
if (!IsSourceRendererValid() || outlineRenderer == null) return;
if (outlineRenderer.sprite != sourcePlantPartRenderer.sprite) {
outlineRenderer.sprite = sourcePlantPartRenderer.sprite;
}
cachedTransform.localScale = sourcePlantPartRenderer.transform.localScale;
outlineRenderer.flipX = sourcePlantPartRenderer.flipX;
outlineRenderer.flipY = sourcePlantPartRenderer.flipY;
}

pub void SetVisibility(bool isVisible) {
if (outlineRenderer != null && outlineRenderer.enabled != isVisible) {
outlineRenderer.enabled = isVisible;
}
}

pub void DestroyOutlinePart() {
if (this != null && gameObject != null) {
if (Application.isPlaying) { Destroy(gameObject); }
else { DestroyImmediate(gameObject); }
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\PlantOutlineController.cs

﻿// REWORKED FILE: Assets/Scripts/PlantSystem/Visual/PlantOutlineController.cs
using Abracodabra.Genes;

pub cls PlantOutlineController : MonoBehaviour {
[SerializeField] Color outlineColor = Color.black;
[SerializeField] pub GameObject outlinePartPrefab;
[SerializeField] string outlineSortingLayerName = "Default";
[SerializeField] int outlineSortingOrder = -1;
[SerializeField] bool debugLogging = false;

pub Color OutlineColor => outlineColor;
pub int OutlineSortingLayer => outlineSortingLayerID;
pub int OutlineSortingOrder => outlineSortingOrder;

int outlineSortingLayerID;
PlantGrowth parentPlantGrowth;
Dictionary<Vector2Int, OutlinePartController> outlinePartMap = new Dictionary<Vector2Int, OutlinePartController>();
HashSet<Vector2Int> plantCellCoords = new HashSet<Vector2Int>();

stat ro Vector2Int[] neighborOffsets = {
new Vector2Int(-1, -1), new Vector2Int(0, -1), new Vector2Int(1, -1),
new Vector2Int(-1, 0),                         new Vector2Int(1, 0),
new Vector2Int(-1, 1),  new Vector2Int(0, 1),  new Vector2Int(1, 1)
};

void Awake() {
parentPlantGrowth = GetComponentInParent<PlantGrowth>();
if (parentPlantGrowth == null) {
Debug.LogError($"[{gameObject.name}] Missing PlantGrowth parent!", gameObject);
enabled = false;
return;
}
outlineSortingLayerID = SortingLayer.NameToID(outlineSortingLayerName);
}

pub void RegisterPlantPart(SpriteRenderer plantPartRenderer, GameObject prefab) {
if (plantPartRenderer == null) return;
PlantCell plantCell = plantPartRenderer.GetComponentInParent<PlantCell>();
if (plantCell != null) {
OnPlantCellAdded(plantCell.GridCoord, plantCell.gameObject);
}
}

pub void OnPlantCellAdded(Vector2Int plantCoord, GameObject plantCellGO) {
if (plantCellGO == null) return;

plantCellCoords.Add(plantCoord);
RemoveOutlinePartIfExists(plantCoord);

SpriteRenderer plantRenderer = plantCellGO.GetComponentInChildren<SpriteRenderer>();
if (plantRenderer == null) return;

foreach (var offset in neighborOffsets) {
Vector2Int neighborCoord = plantCoord + offset;
if (!plantCellCoords.Contains(neighborCoord) && !outlinePartMap.ContainsKey(neighborCoord)) {
CreateOutlinePart(neighborCoord, plantRenderer);
}
}
}

pub void OnPlantCellRemoved(Vector2Int plantCoord) {
if (!plantCellCoords.Remove(plantCoord)) return;

if (!outlinePartMap.ContainsKey(plantCoord)) {
SpriteRenderer sourceRenderer = FindValidNeighborRenderer(plantCoord);
if (sourceRenderer != null) {
CreateOutlinePart(plantCoord, sourceRenderer);
}
}

foreach (var offset in neighborOffsets) {
Vector2Int neighborCoord = plantCoord + offset;
if (outlinePartMap.TryGetValue(neighborCoord, out var outlinePart)) {
if (outlinePart == null) {
outlinePartMap.Remove(neighborCoord);
continue;
}
if (!HasPlantNeighbor(neighborCoord)) {
RemoveOutlinePartIfExists(neighborCoord);
}
else if (!outlinePart.IsSourceRendererValid()) {
SpriteRenderer newSource = FindValidNeighborRenderer(neighborCoord);
if (newSource != null) {
outlinePart.UpdateSourceRenderer(newSource);
}
else {
RemoveOutlinePartIfExists(neighborCoord);
}
}
}
}
}

void CreateOutlinePart(Vector2Int coord, SpriteRenderer sourceRenderer) {
if (outlinePartMap.ContainsKey(coord) || sourceRenderer == null || outlinePartPrefab == null) return;

GameObject outlineInstance = Instantiate(outlinePartPrefab, transform);

float spacing = parentPlantGrowth.cellSpacing;
outlineInstance.transform.localPosition = (Vector2)coord * spacing;

var outlineController = outlineInstance.GetComponent<OutlinePartController>();
if (outlineController != null) {
outlineController.Initialize(sourceRenderer, coord, this);
outlinePartMap.Add(coord, outlineController);

if (debugLogging)
Debug.Log($"[{gameObject.name}] Created outline part at {coord}");
}
else {
Debug.LogError("Outline Part Prefab is missing the OutlinePartController script!", outlinePartPrefab);
Destroy(outlineInstance);
}
}

void RemoveOutlinePartIfExists(Vector2Int coord) {
if (outlinePartMap.TryGetValue(coord, out var part)) {
if (part != null) part.DestroyOutlinePart();
outlinePartMap.Remove(coord);
}
}

bool HasPlantNeighbor(Vector2Int coord) {
foreach (var offset in neighborOffsets)
if (plantCellCoords.Contains(coord + offset)) ret true;
ret false;
}

SpriteRenderer FindValidNeighborRenderer(Vector2Int coord) {
foreach (var offset in neighborOffsets) {
Vector2Int neighborCoord = coord + offset;
if (plantCellCoords.Contains(neighborCoord)) {
GameObject plantGO = parentPlantGrowth.GetCellGameObjectAt(neighborCoord);
if (plantGO != null && plantGO.TryGetComponent<SpriteRenderer>(out var renderer)) {
ret renderer;
}
}
}
if (debugLogging)
Debug.LogWarning($"[{gameObject.name}] Could not find any valid neighbor renderer for outline at {coord}");
ret null;
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\PlantShadowController.cs

﻿using UnityEngine;

pub cls PlantShadowController : MonoBehaviour {
[SerializeField] Color shadowColor = new Color(0f, 0f, 0f, 0.5f);
float squashFactor = 0.6f;
float shadowAngleDegrees = 270f; // Default to directly downwards
bool flipShadow = false;

[SerializeField] bool enableDistanceFade = true;
[SerializeField] float fadeStartDistance = 1.5f;
[SerializeField] float fadeEndDistance = 3.0f;
[SerializeField] [Range(0f, 1f)] float minFadeAlpha = 0.0f;

string shadowSortingLayerName = "Default";
int shadowSortingOrder = -1;

int shadowSortingLayerID;

pub Color ShadowColor => shadowColor;
pub int ShadowSortingLayer => shadowSortingLayerID;
pub int ShadowSortingOrder => shadowSortingOrder;

pub bool EnableDistanceFade => enableDistanceFade;
pub float FadeStartDistance => fadeStartDistance;
pub float FadeEndDistance => fadeEndDistance;
pub float MinFadeAlpha => minFadeAlpha;

Vector3 baseLocalScale;
Quaternion baseLocalRotation;
Vector3 baseLocalPosition;

Dictionary<SpriteRenderer, ShadowPartController> shadowPartMap = new Dictionary<SpriteRenderer, ShadowPartController>();

void Awake() {
shadowSortingLayerID = SortingLayer.NameToID(shadowSortingLayerName);
if (shadowSortingLayerID == 0 && shadowSortingLayerName != "Default") {
Debug.LogWarning($"Sorting Layer '{shadowSortingLayerName}' not found. Shadow will use 'Default'.", this);
shadowSortingLayerID = SortingLayer.NameToID("Default");
}

baseLocalScale = transform.localScale;
baseLocalRotation = transform.localRotation;
baseLocalPosition = transform.localPosition;
if (baseLocalPosition != Vector3.zero) {
Debug.LogWarning($"'{gameObject.name}' initial localPosition is not zero ({baseLocalPosition}). Shadow origin might be slightly offset from plant root.", gameObject);
}
}

void LateUpdate() {
transform.localPosition = baseLocalPosition; // Should typically be Vector3.zero

Quaternion angleRotation = Quaternion.Euler(0, 0, shadowAngleDegrees);
transform.localRotation = baseLocalRotation * angleRotation;

Vector3 finalScale = baseLocalScale; // Start with original scale
finalScale.y *= squashFactor;

if (flipShadow) {
finalScale.x *= -1f;
}
transform.localScale = finalScale;

}

pub void RegisterPlantPart(SpriteRenderer plantPartRenderer, GameObject shadowPartPrefab) {
if (plantPartRenderer == null || shadowPartPrefab == null) return;
if (shadowPartMap.ContainsKey(plantPartRenderer)) return;
GameObject shadowInstance = Instantiate(shadowPartPrefab, transform);
ShadowPartController shadowController = shadowInstance.GetComponent<ShadowPartController>();
if (shadowController != null) { shadowController.Initialize(plantPartRenderer, this); shadowPartMap.Add(plantPartRenderer, shadowController); }
else { Debug.LogError($"Shadow Part Prefab '{shadowPartPrefab.name}' missing ShadowPartController.", shadowPartPrefab); Destroy(shadowInstance); }
}

pub void UnregisterPlantPart(SpriteRenderer plantPartRenderer) {
if (plantPartRenderer != null && shadowPartMap.TryGetValue(plantPartRenderer, out ShadowPartController shadowController)) {
if (shadowController != null) { shadowController.OnPlantPartDestroyed(); }
shadowPartMap.Remove(plantPartRenderer);
}
}

void OnDestroy() {
foreach (var kvp in shadowPartMap) {
if (kvp.Value != null) {
if (Application.isPlaying) {
Destroy(kvp.Value.gameObject);
}
else {
DestroyImmediate(kvp.Value.gameObject);
}
}
}
shadowPartMap.Clear(); // Prevent memory leaks from the dictionary itself
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\PlantSystem\Visual\ShadowPartController.cs

﻿using UnityEngine;

pub cls ShadowPartController : MonoBehaviour {
SpriteRenderer shadowRenderer;
Transform cachedTransform;

SpriteRenderer plantPartRenderer;
Transform plantPartTransform;
Transform shadowRootTransform;
PlantShadowController mainShadowController;

void Awake() {
shadowRenderer = GetComponent<SpriteRenderer>();
cachedTransform = transform;

shadowRenderer.drawMode = SpriteDrawMode.Simple;
shadowRenderer.enabled = false;
}

pub void Initialize(SpriteRenderer targetPlantPartRenderer, PlantShadowController controller) {
if (targetPlantPartRenderer == null || controller == null) {
Destroy(gameObject);
return;
}

plantPartRenderer = targetPlantPartRenderer;
plantPartTransform = targetPlantPartRenderer.transform;
mainShadowController = controller;
shadowRootTransform = controller.transform;

shadowRenderer.sortingLayerID = mainShadowController.ShadowSortingLayer;
shadowRenderer.sortingOrder = mainShadowController.ShadowSortingOrder;

cachedTransform.SetParent(shadowRootTransform, true); // Parent first

shadowRenderer.enabled = plantPartRenderer.enabled && plantPartRenderer.sprite != null;
UpdateColorAndFade();
}

void LateUpdate() {
if (plantPartRenderer == null || !plantPartRenderer.enabled || plantPartRenderer.sprite == null || shadowRenderer == null || mainShadowController == null) {
if (shadowRenderer != null)
shadowRenderer.enabled = false;
return;
}

shadowRenderer.enabled = true;
shadowRenderer.sprite = plantPartRenderer.sprite;

Vector3 plantPartPosRelativeToPlantRoot = plantPartTransform.parent.InverseTransformPoint(plantPartTransform.position);
cachedTransform.localPosition = plantPartPosRelativeToPlantRoot;
cachedTransform.localRotation = plantPartTransform.localRotation;
cachedTransform.localScale = plantPartTransform.localScale;

shadowRenderer.flipX = plantPartRenderer.flipX;
shadowRenderer.flipY = plantPartRenderer.flipY;

UpdateColorAndFade();
}

void UpdateColorAndFade() {
if (mainShadowController == null || shadowRenderer == null) return;

Color baseShadowColor = mainShadowController.ShadowColor;
float finalAlpha = baseShadowColor.a; // Start with the controller's base alpha

if (mainShadowController.EnableDistanceFade) {
float distance = Vector3.Distance(cachedTransform.position, shadowRootTransform.position); // Distance from shadow part to shadow root

float fadeStart = mainShadowController.FadeStartDistance;
float fadeEnd = mainShadowController.FadeEndDistance;
float minAlpha = mainShadowController.MinFadeAlpha;

if (distance >= fadeEnd) {
finalAlpha *= minAlpha; // Apply min alpha
}
else if (distance > fadeStart) {
float t = Mathf.InverseLerp(fadeStart, fadeEnd, distance);
float distanceAlphaMultiplier = Mathf.Lerp(1f, minAlpha, t);
finalAlpha *= distanceAlphaMultiplier; // Modulate base alpha
}
}

shadowRenderer.color = new Color(baseShadowColor.r, baseShadowColor.g, baseShadowColor.b, finalAlpha);
}

pub void OnPlantPartDestroyed() {
if (this != null && gameObject != null) {
if (Application.isPlaying) {
Destroy(gameObject);
}
else {
DestroyImmediate(gameObject);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridDebugVisualizer.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes;
using WegoSystem;

pub cls GridDebugVisualizer : MonoBehaviour {
pub stat GridDebugVisualizer Instance { get; set; }

pub enum RadiusType {
AnimalSearch,
PlantPoop,
Scent,
FireflyPhotosynthesis,
ToolUse
}

[SerializeField] bool showRadiusVisualizations = true;
[SerializeField] float tileVisualizationAlpha = 0.3f;
[SerializeField] GameObject tilePrefab;

[SerializeField] pub Color animalSearchRadiusColor = new Color(1f, 0.5f, 0f, 0.3f);
[SerializeField] pub Color plantPoopRadiusColor = new Color(0.6f, 0.4f, 0.2f, 0.3f);
[SerializeField] pub Color scentRadiusColor = new Color(1f, 1f, 0f, 0.3f);
[SerializeField] pub Color fireflyPhotosynthesisColor = new Color(0f, 1f, 0.5f, 0.3f);
[SerializeField] pub Color toolUseRadiusColor = new Color(0f, 0.5f, 1f, 0.3f);

[SerializeField] bool enableAnimalSearchRadius = true;
[SerializeField] bool enablePlantPoopRadius = true;
[SerializeField] bool enableScentRadius = true;
[SerializeField] bool enableFireflyPhotosynthesis = true;
[SerializeField] bool enableToolUseRadius = true;

cls RadiusRequest {
pub GridPosition Center;
pub int Radius;
pub RadiusType Type;
}

ro Dictionary<object, List<GameObject>> oneShotVisualizations = new Dictionary<object, List<GameObject>>();
ro Dictionary<object, RadiusRequest> continuousRequests = new Dictionary<object, RadiusRequest>();
ro Dictionary<object, (GridPosition center, int radius)> lastDrawnState = new Dictionary<object, (GridPosition, int)>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

void OnDestroy() {
ClearAllVisualizations();
if (Instance == this) Instance = null;
}

void Update() {
ProcessContinuousRequests();
}

pub void ShowContinuousRadius(object source, GridPosition center, int radius, RadiusType type) {
if (!showRadiusVisualizations || source == null || !IsTypeEnabled(type)) return;

if (!continuousRequests.ContainsKey(source)) {
continuousRequests.Add(source, new RadiusRequest());
}
continuousRequests[source].Center = center;
continuousRequests[source].Radius = radius;
continuousRequests[source].Type = type;
}

pub void HideContinuousRadius(object source) {
if (source == null) return;

if (continuousRequests.Remove(source)) {
ClearVisualization(source);
}
}

pub void VisualizeRadius(object source, GridPosition center, int radius, Color color, float duration = 0f) {
if (!showRadiusVisualizations || tilePrefab == null) return;

ClearVisualization(source);

var tiles = GridRadiusUtility.GetTilesInCircle(center, radius);
var tileObjects = new List<GameObject>();

foreach (var tile in tiles) {
Vector3 worldPos = GridPositionManager.Instance.GridToWorld(tile);
GameObject tileVis = Instantiate(tilePrefab, worldPos, Quaternion.identity, transform);

SpriteRenderer sr = tileVis.GetComponent<SpriteRenderer>();
if (sr != null) {
Color finalColor = color;
finalColor.a = tileVisualizationAlpha;
sr.color = finalColor;
sr.sortingOrder = -100;
}
tileObjects.Add(tileVis);

if (duration > 0) {
Destroy(tileVis, duration);
}
}

if (duration <= 0) {
oneShotVisualizations[source] = tileObjects;
}
}

pub void ClearVisualization(object source) {
if (oneShotVisualizations.TryGetValue(source, out var tiles)) {
foreach (var tile in tiles) {
if (tile != null) Destroy(tile);
}
oneShotVisualizations.Remove(source);
}
if (lastDrawnState.ContainsKey(source)) {
lastDrawnState.Remove(source);
}
}

pub void VisualizeAnimalSearchRadius(AnimalController animal, GridPosition center, int radius) {
ShowContinuousRadius(animal, center, radius, RadiusType.AnimalSearch);
}

pub void VisualizePlantPoopRadius(PlantGrowth plant, GridPosition center, int radius) {
ShowContinuousRadius(plant, center, radius, RadiusType.PlantPoop);
}

pub void VisualizeScentRadius(ScentSource scentSource, GridPosition center, int radius) {
ShowContinuousRadius(scentSource, center, radius, RadiusType.Scent);
}

pub void VisualizeFireflyPhotosynthesisRadius(FireflyController firefly, GridPosition center, int radius) {
ShowContinuousRadius(firefly, center, radius, RadiusType.FireflyPhotosynthesis);
}

pub void VisualizeToolUseRadius(object tool, GridPosition center, int radius) {
ShowContinuousRadius(tool, center, radius, RadiusType.ToolUse);
}

pub void SetAnimalSearchRadiusEnabled(bool enabled) { enableAnimalSearchRadius = enabled; }
pub void SetPlantPoopRadiusEnabled(bool enabled) { enablePlantPoopRadius = enabled; }
pub void SetScentRadiusEnabled(bool enabled) { enableScentRadius = enabled; }
pub void SetFireflyPhotosynthesisEnabled(bool enabled) { enableFireflyPhotosynthesis = enabled; }
pub void SetToolUseRadiusEnabled(bool enabled) { enableToolUseRadius = enabled; }

pub void SetRadiusVisualizationsEnabled(bool enabled) {
showRadiusVisualizations = enabled;
if (!enabled) {
ClearAllVisualizations();
}
}

pub Color GetColorForType(RadiusType type) {
switch (type) {
case RadiusType.AnimalSearch: ret animalSearchRadiusColor;
case RadiusType.PlantPoop: ret plantPoopRadiusColor;
case RadiusType.Scent: ret scentRadiusColor;
case RadiusType.FireflyPhotosynthesis: ret fireflyPhotosynthesisColor;
case RadiusType.ToolUse: ret toolUseRadiusColor;
default: ret Color.white;
}
}

bool IsTypeEnabled(RadiusType type) {
switch (type) {
case RadiusType.AnimalSearch: ret enableAnimalSearchRadius;
case RadiusType.PlantPoop: ret enablePlantPoopRadius;
case RadiusType.Scent: ret enableScentRadius;
case RadiusType.FireflyPhotosynthesis: ret enableFireflyPhotosynthesis;
case RadiusType.ToolUse: ret enableToolUseRadius;
default: ret true;
}
}

void ProcessContinuousRequests() {
if (!showRadiusVisualizations || tilePrefab == null) return;

List<object> sourcesToRemove = new List<object>();
foreach (var drawnSource in lastDrawnState.Keys) {
if (!continuousRequests.ContainsKey(drawnSource)) {
sourcesToRemove.Add(drawnSource);
}
}
foreach (var source in sourcesToRemove) {
ClearVisualization(source);
}

foreach (var kvp in continuousRequests) {
object source = kvp.Key;
RadiusRequest request = kvp.Value;

if (!IsTypeEnabled(request.Type)) {
if (lastDrawnState.ContainsKey(source)) {
ClearVisualization(source);
}
continue;
}

bool needsRedraw = false;
if (lastDrawnState.TryGetValue(source, out var lastState)) {
if (lastState.center != request.Center || lastState.radius != request.Radius) {
needsRedraw = true;
}
}
else {
needsRedraw = true;
}

if (needsRedraw) {
Color color = GetColorForType(request.Type);
VisualizeRadius(source, request.Center, request.Radius, color, 0);
lastDrawnState[source] = (request.Center, request.Radius);
}
}
}

void ClearAllVisualizations() {
foreach (var kvp in oneShotVisualizations) {
foreach (var tile in kvp.Value) {
if (tile != null) Destroy(tile);
}
}
oneShotVisualizations.Clear();
continuousRequests.Clear();
lastDrawnState.Clear();
}

pub bool IsRadiusVisualizationEnabled => showRadiusVisualizations;
pub bool IsAnimalSearchRadiusEnabled => enableAnimalSearchRadius;
pub bool IsPlantPoopRadiusEnabled => enablePlantPoopRadius;
pub bool IsScentRadiusEnabled => enableScentRadius;
pub bool IsFireflyPhotosynthesisEnabled => enableFireflyPhotosynthesis;
pub bool IsToolUseRadiusEnabled => enableToolUseRadius;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridSnapStartup.cs

﻿// Assets\Scripts\Core\GridSnapStartup.cs

using Abracodabra.Genes;
using WegoSystem;

pub cls GridSnapStartup : MonoBehaviour {
[SerializeField] bool snapAllAnimals = true;
[SerializeField] bool snapAllPlants = true;
[SerializeField] bool snapPlayer = true;
[SerializeField] bool debugLog = true;

void Awake() {
if (GridPositionManager.Instance == null) {
Debug.LogError("[GridSnapStartup] GridPositionManager not found! Cannot snap entities.");
return;
}
}

void Start() {
PerformGridSnapping();
}

void PerformGridSnapping() {
int snappedCount = 0;

if (snapPlayer) {
GardenerController[] gardeners = FindObjectsByType<GardenerController>(FindObjectsSortMode.None);
foreach (var gardener in gardeners) {
GridPositionManager.Instance.SnapEntityToGrid(gardener.gameObject);
snappedCount++;
}
}

if (snapAllAnimals) {
AnimalController[] animals = FindObjectsByType<AnimalController>(FindObjectsSortMode.None);
foreach (var animal in animals) {
GridPositionManager.Instance.SnapEntityToGrid(animal.gameObject);
snappedCount++;
}
}

if (snapAllPlants) {
PlantGrowth[] plants = FindObjectsByType<PlantGrowth>(FindObjectsSortMode.None);
foreach (var plant in plants) {
GridPositionManager.Instance.SnapEntityToGrid(plant.gameObject);
snappedCount++;
}
}

if (debugLog) {
Debug.Log($"[GridSnapStartup] Snapped {snappedCount} entities to grid on startup");
}
}

void SnapAllEntitiesNow() {
if (GridPositionManager.Instance == null) {
Debug.LogError("GridPositionManager not found in scene!");
return;
}

PerformGridSnapping();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\TickDebugMonitor.cs

﻿// REWORKED FILE: Assets/Scripts/Ticks/TickDebugMonitor.cs
using TMPro;
using WegoSystem;
using Abracodabra.Genes;

pub cls TickDebugMonitor : MonoBehaviour {
[SerializeField] GameObject monitorPanel;
[SerializeField] TextMeshProUGUI tickCounterText;
[SerializeField] TextMeshProUGUI animalCountText;
[SerializeField] TextMeshProUGUI plantCountText;
[SerializeField] KeyCode toggleKey = KeyCode.F3;

void Update() {
if (Input.GetKeyDown(toggleKey)) {
monitorPanel.SetActive(!monitorPanel.activeSelf);
}

if (monitorPanel.activeSelf) {
UpdateDisplay();
}
}

void UpdateDisplay() {
if (TickManager.Instance == null) return;

tickCounterText.text = $"Tick: {TickManager.Instance.CurrentTick}";
animalCountText.text = $"Animals: {FindObjectsByType<AnimalController>(FindObjectsSortMode.None).Length}";

plantCountText.text = $"Plants: {PlantGrowth.AllActivePlants.Count}";

}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Tooltips\TooltipTrigger.cs

﻿// Reworked File: Assets/Scripts/UI/Tooltips/TooltipTrigger.cs
using UnityEngine.EventSystems;
using Abracodabra.UI.Genes; // For ItemView
using Abracodabra.Genes.Core; // For GeneTooltipContext

pub cls TooltipTrigger : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler {
ItemView _itemView;
bool _isShowingTooltip = false;

void Awake() {
_itemView = GetComponent<ItemView>();
}

pub void OnPointerEnter(PointerEventData eventData) {
if (UniversalTooltipManager.Instance == null || _isShowingTooltip || _itemView == null) return;
ShowTooltip();
}

pub void OnPointerExit(PointerEventData eventData) {
if (UniversalTooltipManager.Instance == null || !_isShowingTooltip) return;
HideTooltip();
}

void ShowTooltip() {
ITooltipDataProvider provider = null;
GeneTooltipContext context = new GeneTooltipContext();

if (_itemView.GetGene() != null) {
provider = _itemView.GetGene();
context.instance = _itemView.GetRuntimeInstance();
}
else if (_itemView.GetToolDefinition() != null) {
provider = _itemView.GetToolDefinition();
}
else if (_itemView.GetSeedTemplate() != null) {
}

if (provider != null) {
UniversalTooltipManager.Instance.ShowTooltip(provider, transform, context);
_isShowingTooltip = true;
}
}

void HideTooltip() {
UniversalTooltipManager.Instance?.HideTooltip();
_isShowingTooltip = false;
}

void OnDisable() {
if (_isShowingTooltip) {
HideTooltip();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Tooltips\UniversalTooltipManager.cs

﻿using UnityEngine;
using TMPro;

pub ifc ITooltipDataProvider {
string GetTooltipTitle();
string GetTooltipDescription();
string GetTooltipDetails(object source = null);
}

pub cls UniversalTooltipManager : MonoBehaviour {
pub stat UniversalTooltipManager Instance { get; set; }

[SerializeField] GameObject tooltipPanel;
[SerializeField] TextMeshProUGUI titleText;
[SerializeField] TextMeshProUGUI descriptionText;
[SerializeField] TextMeshProUGUI detailsText;
[SerializeField] Image backgroundImage;
[SerializeField] CanvasGroup canvasGroup;
[SerializeField] VerticalLayoutGroup layoutGroup;

[SerializeField] float fadeDuration = 0.15f;
[SerializeField] bool moveTooltipWithMouse = true;
[SerializeField] Vector2 mouseFollowOffset = new Vector2(15f, -15f);

[SerializeField] Color backgroundColor = new Color(0.1f, 0.1f, 0.1f, 0.95f);
[SerializeField] Color titleColor = Color.white;
[SerializeField] Color descriptionColor = new Color(0.8f, 0.8f, 0.8f, 1f);
[SerializeField] Color detailsColor = new Color(0.7f, 0.7f, 0.7f, 1f);
[SerializeField] int titleFontSize = 18;
[SerializeField] int descriptionFontSize = 14;
[SerializeField] int detailsFontSize = 12;

Coroutine _fadeCoroutine;
object _currentTarget;
bool _isVisible = false;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

if (!ValidateReferences()) {
enabled = false;
return;
}

SetupTooltipPanel();
if (tooltipPanel != null) tooltipPanel.SetActive(false);
if (canvasGroup != null) canvasGroup.alpha = 0f;
_isVisible = false;
}

void Update() {
if (_isVisible && IsTargetNullOrDestroyed(_currentTarget)) {
HideTooltip();
}
}

pub void ShowTooltip(ITooltipDataProvider provider, Transform anchor = null, object source = null) {
if (provider == null) return;

if (_isVisible && ReferenceEquals(_currentTarget, provider)) return;

_currentTarget = provider;

string title = provider.GetTooltipTitle();
string description = provider.GetTooltipDescription();
string details = provider.GetTooltipDetails(source);

ShowTooltipInternal(title, description, details, anchor);
}

pub void HideTooltip() {
_currentTarget = null;
if (tooltipPanel == null || canvasGroup == null) return;

if (_fadeCoroutine != null) {
StopCoroutine(_fadeCoroutine);
}

if (fadeDuration > 0f && gameObject.activeInHierarchy) {
_fadeCoroutine = StartCoroutine(FadeTooltip(false));
}
else {
canvasGroup.alpha = 0f;
if (tooltipPanel != null) tooltipPanel.SetActive(false);
_isVisible = false;
}
}

void ShowTooltipInternal(string title, string description, string details, Transform itemAnchor) {
if (tooltipPanel == null || canvasGroup == null) return;

if (_fadeCoroutine != null) {
StopCoroutine(_fadeCoroutine);
}

if (titleText != null) {
titleText.text = title;
titleText.gameObject.SetActive(!string.IsNullOrEmpty(title));
}
if (descriptionText != null) {
descriptionText.text = description;
descriptionText.gameObject.SetActive(!string.IsNullOrEmpty(description));
}
if (detailsText != null) {
detailsText.text = details;
detailsText.gameObject.SetActive(!string.IsNullOrEmpty(details));
}

tooltipPanel.SetActive(true);
if (layoutGroup != null) {
LayoutRebuilder.ForceRebuildLayoutImmediate(layoutGroup.GetComponent<RectTransform>());
}

if (moveTooltipWithMouse) {
PositionTooltipWithMouse();
}

if (fadeDuration > 0f) {
_fadeCoroutine = StartCoroutine(FadeTooltip(true));
}
else {
canvasGroup.alpha = 1f;
_isVisible = true;
}
}

void PositionTooltipWithMouse() {
var tooltipRect = tooltipPanel.GetComponent<RectTransform>();
var rootCanvas = tooltipPanel.GetComponentInParent<Canvas>()?.rootCanvas;

if (tooltipRect == null || rootCanvas == null || !Input.mousePresent) return;

Vector2 targetScreenPos = Input.mousePosition;
targetScreenPos += mouseFollowOffset; // Apply user offset

var panelRect = tooltipRect.rect;
targetScreenPos.x = Mathf.Clamp(targetScreenPos.x, 0, Screen.width - panelRect.width);
targetScreenPos.y = Mathf.Clamp(targetScreenPos.y, 0, Screen.height - panelRect.height);

var parentRect = tooltipRect.parent as RectTransform;
if (parentRect == null) return;

Camera renderCamera = (rootCanvas.renderMode == RenderMode.ScreenSpaceOverlay) ? null : rootCanvas.worldCamera;
if (RectTransformUtility.ScreenPointToLocalPointInRectangle(parentRect, targetScreenPos, renderCamera, out var localPos)) {
tooltipRect.localPosition = localPos;
}
}

IEnumerator FadeTooltip(bool fadeIn) {
if (canvasGroup == null) yield break;

float elapsed = 0f;
float startAlpha = canvasGroup.alpha;
float targetAlpha = fadeIn ? 1f : 0f;

if (fadeIn) _isVisible = true;

if (fadeIn && tooltipPanel != null && !tooltipPanel.activeSelf)
tooltipPanel.SetActive(true);

while (elapsed < fadeDuration) {
elapsed += Time.unscaledDeltaTime;
float t = (fadeDuration > 0) ? elapsed / fadeDuration : 1f;
canvasGroup.alpha = Mathf.Lerp(startAlpha, targetAlpha, t);
yield ret null;
}

canvasGroup.alpha = targetAlpha;

if (!fadeIn) {
if (tooltipPanel != null) tooltipPanel.SetActive(false);
_isVisible = false;
}
}

bool IsTargetNullOrDestroyed(object target) {
if (target is UnityEngine.Object unityObject) {
ret unityObject == null;
}
ret System.Object.ReferenceEquals(target, null);
}

void SetupTooltipPanel() {
if (canvasGroup != null) {
canvasGroup.alpha = 0f;
canvasGroup.interactable = false;
canvasGroup.blocksRaycasts = false;
}
if (backgroundImage != null) backgroundImage.color = backgroundColor;
ApplyTextStyles();
}

void ApplyTextStyles() {
if (titleText != null) { titleText.color = titleColor; titleText.fontSize = titleFontSize; titleText.fontStyle = FontStyles.Bold; }
if (descriptionText != null) { descriptionText.color = descriptionColor; descriptionText.fontSize = descriptionFontSize; }
if (detailsText != null) { detailsText.color = detailsColor; detailsText.fontSize = detailsFontSize; }
}

bool ValidateReferences() {
if (tooltipPanel == null) { Debug.LogError("[UniversalTooltipManager] Tooltip Panel not assigned!"); ret false; }

if (canvasGroup == null) canvasGroup = tooltipPanel.GetComponent<CanvasGroup>() ?? tooltipPanel.AddComponent<CanvasGroup>();
if (layoutGroup == null) layoutGroup = tooltipPanel.GetComponent<VerticalLayoutGroup>();
if (backgroundImage == null) backgroundImage = tooltipPanel.GetComponent<Image>();
if (titleText == null) titleText = FindTextComponent("Title");
if (descriptionText == null) descriptionText = FindTextComponent("Description");
if (detailsText == null) detailsText = FindTextComponent("Details");

if (titleText == null) { Debug.LogError("[UniversalTooltipManager] Missing required title text component!"); ret false; }

ret true;
}

TextMeshProUGUI FindTextComponent(string nameContains) {
if (tooltipPanel == null) ret null;
foreach (var text in tooltipPanel.GetComponentsInChildren<TextMeshProUGUI>(true)) {
if (text.name.ToLower().Contains(nameContains.ToLower()))
ret text;
}
ret null;
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Utilities\ColorExtensions.cs

﻿using UnityEngine;

pub stat cls ColorExtensions {
pub stat Color WithAlpha(this Color c, float alpha) {
ret new Color(c.r, c.g, c.b, alpha);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\UI\Utilities\PrefabOrigin.cs

﻿// Assets/Scripts/Utility/PrefabOrigin.cs

pub cls PrefabOrigin : MonoBehaviour {
pub Transform originTransform;

void Awake() {
if (originTransform == null) {
Debug.LogError($"[PrefabOrigin] The 'Origin Transform' is not assigned on '{gameObject.name}'. The script cannot function.", this);
Destroy(this); // Destroy self if not configured
return;
}

if (!originTransform.IsChildOf(transform)) {
Debug.LogError($"[PrefabOrigin] The assigned 'Origin Transform' ('{originTransform.name}') is not a child of '{gameObject.name}'. The script cannot function.", this);
Destroy(this); // Destroy self if configuration is invalid
return;
}

Vector3 worldOffset = transform.TransformVector(originTransform.localPosition);

transform.position -= worldOffset;

Destroy(this);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\NightColorPostProcess.cs

﻿using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

pub cls NightColorPostProcess : MonoBehaviour {
pub WeatherManager weatherManager;

pub Volume globalVolume;

pub Color dayColorFilter = Color.white;
pub Color nightColorFilter = new Color(0.75f, 0.8f, 1f, 1f);

pub float dayPostExposure = 0f;
pub float nightPostExposure = -0.5f;

pub float daySaturation = 0f;
pub float nightSaturation = -50f;

pub float dayFilmGrainIntensity = 0.1f;
pub float nightFilmGrainIntensity = 0.5f;

pub float dayVignetteIntensity = 0.2f;
pub float nightVignetteIntensity = 0.5f;

pub float dayVignetteSmoothness = 0.2f;
pub float nightVignetteSmoothness = 0.3f;

[SerializeField] float transitionSmoothingSpeed = 5f;

ColorAdjustments colorAdjustments;
FilmGrain filmGrain;
Vignette vignette;

float smoothedSunIntensity;

void Start() {
if (!weatherManager) {
Debug.LogError($"[{nameof(NightColorPostProcess)}] WeatherManager not assigned!", this);
enabled = false; // Disable script if core references are missing
return;
}
if (!globalVolume) {
Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume not assigned!", this);
enabled = false;
return;
}
if (globalVolume.profile == null) {
Debug.LogError($"[{nameof(NightColorPostProcess)}] Global Volume has no profile assigned!", this);
enabled = false;
return;
}

if (!globalVolume.profile.TryGet<ColorAdjustments>(out colorAdjustments)) {
Debug.LogWarning($"[{nameof(NightColorPostProcess)}] ColorAdjustments ovr not found in Volume profile.", this);
}
if (!globalVolume.profile.TryGet<FilmGrain>(out filmGrain)) {
Debug.LogWarning($"[{nameof(NightColorPostProcess)}] FilmGrain ovr not found in Volume profile.", this);
}
if (!globalVolume.profile.TryGet<Vignette>(out vignette)) {
Debug.LogWarning($"[{nameof(NightColorPostProcess)}] Vignette ovr not found in Volume profile.", this);
}

smoothedSunIntensity = weatherManager.sunIntensity;
}

void Update() {
if (colorAdjustments == null && filmGrain == null && vignette == null)
return; // Nothing to update if no overrides were found

if (weatherManager != null) {
smoothedSunIntensity = Mathf.Lerp(smoothedSunIntensity, weatherManager.sunIntensity, transitionSmoothingSpeed * Time.deltaTime);
}

float sun = Mathf.Clamp01(smoothedSunIntensity); // Use the smoothed value
float t = 1f - sun;  // t=0 at day, t=1 at night

if (colorAdjustments != null) {
colorAdjustments.colorFilter.value = Color.Lerp(dayColorFilter, nightColorFilter, t);
colorAdjustments.postExposure.value = Mathf.Lerp(dayPostExposure, nightPostExposure, t);
colorAdjustments.saturation.value = Mathf.Lerp(daySaturation, nightSaturation, t);
}

if (filmGrain != null) {
filmGrain.intensity.value = Mathf.Lerp(dayFilmGrainIntensity, nightFilmGrainIntensity, t);
}

if (vignette != null) {
vignette.intensity.value = Mathf.Lerp(dayVignetteIntensity, nightVignetteIntensity, t);
vignette.smoothness.value = Mathf.Lerp(dayVignetteSmoothness, nightVignetteSmoothness, t);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\RuntimeCircleDrawer.cs

﻿using UnityEngine;

pub cls RuntimeCircleDrawer : MonoBehaviour {
pub int segments = 30; // Number of line segments to approximate the circle
pub float radius = 1.0f;
pub float lineWidth = 0.02f;
pub Color color = Color.yellow;
pub Material lineMaterial; // Assign the same material used for firefly lines, or a specific one

LineRenderer lineRenderer;
bool needsRedraw = true; // Flag to force redraw on first UpdateCircle call or when params change
float currentRadius = -1f; // Store current values to detect changes
Color currentColor = Color.clear;

void Awake() {
lineRenderer = GetComponent<LineRenderer>();
if (lineRenderer == null) { // Should not happen with RequireComponent
Debug.LogError($"[{gameObject.name}] RuntimeCircleDrawer: Missing required LineRenderer component!");
enabled = false; // Disable script if component missing
return;
}
ConfigureLineRendererDefaults();
lineRenderer.enabled = false; // Start hidden
}

void ConfigureLineRendererDefaults() {
lineRenderer.useWorldSpace = false; // Draw relative to this object's transform
lineRenderer.loop = true; // Connect the last point to the first
lineRenderer.startWidth = lineWidth;
lineRenderer.endWidth = lineWidth;

if (lineMaterial != null && lineRenderer.material == null) {
lineRenderer.material = lineMaterial;
}

SpriteRenderer parentSprite = GetComponentInParent<SpriteRenderer>();
if (parentSprite != null) {
lineRenderer.sortingLayerName = parentSprite.sortingLayerName;
lineRenderer.sortingOrder = parentSprite.sortingOrder + 1; // Draw slightly in front
} else {
lineRenderer.sortingLayerName = "Default";
lineRenderer.sortingOrder = 1;
}
}

pub void UpdateCircle(float newRadius, Color newColor) {
bool radiusChanged = !Mathf.Approximately(currentRadius, newRadius);
bool colorChanged = currentColor != newColor;

if (!needsRedraw && !radiusChanged && !colorChanged) {
if (!lineRenderer.enabled) lineRenderer.enabled = true;
return; // No change needed
}

currentRadius = newRadius;
radius = newRadius; // Update pub field for potential inspector viewing
currentColor = newColor;
color = newColor; // Update pub field

lineRenderer.startColor = currentColor;
lineRenderer.endColor = currentColor;

if (colorChanged && Debug.isDebugBuild) {
Debug.Log($"[RuntimeCircleDrawer] Updated color to: {newColor}", gameObject);
}

DrawCircle(); // Recalculate points
lineRenderer.enabled = true; // Ensure it's visible
needsRedraw = false; // Mark as drawn
}

pub void HideCircle() {
if (lineRenderer != null && lineRenderer.enabled) {
lineRenderer.enabled = false;
needsRedraw = true; // Needs redraw next time it's shown
}
}

void DrawCircle() {
if (lineRenderer == null || segments <= 2 || radius <= 0f) {
lineRenderer.positionCount = 0; // Clear points if invalid params
return;
};

if (lineRenderer.positionCount != segments + 1) {
lineRenderer.positionCount = segments + 1;
}

float angleStep = 360f / segments;
Vector3[] points = new Vector3[segments + 1];

for (int i = 0; i <= segments; i++) {
float currentAngle = Mathf.Deg2Rad * (i * angleStep);
float x = Mathf.Cos(currentAngle) * radius;
float y = Mathf.Sin(currentAngle) * radius;
points[i] = new Vector3(x, y, 0); // Z is 0 for local space relative to transform
}

lineRenderer.SetPositions(points);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\WaterReflection.cs

﻿using UnityEngine;
using UnityEngine.Tilemaps;
#if UNITY_EDITOR
using UnityEditor;
#endif

pub cls WaterReflection : MonoBehaviour {
pub cls OverrideSettings {
pub bool reflectionOpacity = false;
pub bool reflectionTint = false;
pub bool gradientFadeBaseMaterial = false;
pub bool sortingOrderOffset = false;
pub bool useWaterMasking = false;
pub bool waterTilemapTag = false;
pub bool showDebugInfo = false;
}
[SerializeField] OverrideSettings overrides;

[SerializeField] bool useParentAsReference = false; // This remains a local setting

[SerializeField] float yOffset = -1f; // This remains a local setting

[SerializeField] [Range(0f, 1f)] float localReflectionOpacity = 0.5f;

[SerializeField] Color localReflectionTint = Color.white;

[SerializeField] bool enableDistanceFade = true; // This remains local as it depends on material
[SerializeField] float fadeStartDistance = 0.0f; // Local
[SerializeField] float fadeEndDistance = 1.0f; // Local
[SerializeField] [Range(0f, 1f)] float minFadeAlpha = 0.0f; // Local
[SerializeField] Material localGradientFadeBaseMaterial;

[SerializeField] int localSortingOrderOffset = -1;

[SerializeField] bool localUseWaterMasking = true;
[SerializeField] string localWaterTilemapTag = "Water";

[SerializeField] bool localShowDebugInfo = false;

SpriteRenderer originalRenderer;
Animator originalAnimator;
GameObject reflectionObject;
SpriteRenderer reflectionRenderer;
Animator reflectionAnimator;
Material reflectionMaterialInstance; // Instanced material for this reflection

float _actualReflectionOpacity;
Color _actualReflectionTint;
Material _actualGradientFadeBaseMaterial;
int _actualSortingOrderOffset;
bool _actualUseWaterMasking;
string _actualWaterTilemapTag;
bool _actualShowDebugInfo;

Sprite lastSprite;
Color lastOriginalColor;
bool lastFlipX, lastFlipY;
bool lastEnabled;
Vector3 lastScale;
Vector3 lastPosition;
float lastParentY;

void Awake() {
_actualReflectionOpacity = localReflectionOpacity;
_actualReflectionTint = localReflectionTint;
_actualGradientFadeBaseMaterial = localGradientFadeBaseMaterial;
_actualSortingOrderOffset = localSortingOrderOffset;
_actualUseWaterMasking = localUseWaterMasking;
_actualWaterTilemapTag = localWaterTilemapTag;
_actualShowDebugInfo = localShowDebugInfo;

originalRenderer = GetComponent<SpriteRenderer>();
originalAnimator = GetComponent<Animator>();

if (originalRenderer == null) {
if (_actualShowDebugInfo) Debug.LogError($"[WaterReflection] No SpriteRenderer found on {gameObject.name}! Component disabled.", this);
enabled = false;
return;
}

if (useParentAsReference && transform.parent == null) {
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] 'Use Parent As Reference' is true on {gameObject.name}, but it has no parent. Will use self as reference.", this);
useParentAsReference = false;
}

if (Application.isPlaying) {
if (enableDistanceFade && _actualGradientFadeBaseMaterial == null) {
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection Awake] '{gameObject.name}': 'Enable Distance Fade' is true, but no 'Gradient Fade Base Material' (local or global) is assigned/found. Distance fade will not use the custom shader.", this);
}
}

CreateReflectionObject();

if (_actualUseWaterMasking) {
SetupWaterMaskingInteraction();
}
}

void ResolveSettings() {
if (WaterReflectionManager.Instance != null) {
_actualReflectionOpacity = overrides.reflectionOpacity ? localReflectionOpacity : WaterReflectionManager.Instance.defaultReflectionOpacity;
_actualReflectionTint = overrides.reflectionTint ? localReflectionTint : WaterReflectionManager.Instance.defaultReflectionTint;
_actualGradientFadeBaseMaterial = overrides.gradientFadeBaseMaterial ? localGradientFadeBaseMaterial : WaterReflectionManager.Instance.defaultGradientFadeMaterial;
_actualSortingOrderOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : WaterReflectionManager.Instance.defaultSortingOrderOffset;
_actualUseWaterMasking = overrides.useWaterMasking ? localUseWaterMasking : WaterReflectionManager.Instance.defaultUseWaterMasking;
_actualWaterTilemapTag = overrides.waterTilemapTag && !string.IsNullOrEmpty(localWaterTilemapTag) ? localWaterTilemapTag : WaterReflectionManager.Instance.defaultWaterTilemapTag;
_actualShowDebugInfo = overrides.showDebugInfo ? localShowDebugInfo : WaterReflectionManager.Instance.globalShowDebugInfo;
}
else // Fallback if no manager in scene {
_actualReflectionOpacity = localReflectionOpacity;
_actualReflectionTint = localReflectionTint;
_actualGradientFadeBaseMaterial = localGradientFadeBaseMaterial;
_actualSortingOrderOffset = localSortingOrderOffset;
_actualUseWaterMasking = localUseWaterMasking;
_actualWaterTilemapTag = localWaterTilemapTag;
_actualShowDebugInfo = localShowDebugInfo;
if (Application.isPlaying) Debug.LogWarning("[WaterReflection] WaterReflectionManager not found in scene. Using local settings for all reflections.", this);
}
}

void Start() {
ResolveSettings(); // Now resolve settings after all Awake() calls are completed
UpdateReflectionVisuals();
UpdateReflectionTransform();
CacheCurrentState();
}

void LateUpdate() {
if (originalRenderer == null || reflectionObject == null) {
if (reflectionObject != null) reflectionObject.SetActive(false);
return;
}
UpdateReflectionTransform();
if (HasVisualStateChanged()) {
UpdateReflectionVisuals();
CacheCurrentState();
}
}

void CreateReflectionObject() {
reflectionObject = new GameObject($"{gameObject.name}_Reflection");
reflectionObject.transform.SetParent(transform.parent, false);
reflectionObject.transform.SetSiblingIndex(transform.GetSiblingIndex() + 1);

reflectionRenderer = reflectionObject.AddComponent<SpriteRenderer>();
reflectionRenderer.sortingLayerName = originalRenderer.sortingLayerName;
reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + _actualSortingOrderOffset; // Use resolved
reflectionRenderer.drawMode = originalRenderer.drawMode;

if (enableDistanceFade && _actualGradientFadeBaseMaterial != null) // Use resolved {
reflectionMaterialInstance = new Material(_actualGradientFadeBaseMaterial);
reflectionRenderer.material = reflectionMaterialInstance;
if (_actualShowDebugInfo && Application.isPlaying) Debug.Log($"[{gameObject.name}] Instantiated gradient material for reflection using '{_actualGradientFadeBaseMaterial.name}'.", this);
}
else {
reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
if (enableDistanceFade && _actualGradientFadeBaseMaterial == null && _actualShowDebugInfo && Application.isPlaying) {
Debug.Log($"[{gameObject.name}] Using sharedMaterial for reflection as no gradientFadeBaseMaterial (local or global) was resolved during CreateReflectionObject.", this);
}
}

if (originalAnimator != null) {
reflectionAnimator = reflectionObject.AddComponent<Animator>();
reflectionAnimator.runtimeAnimatorController = originalAnimator.runtimeAnimatorController;
}
SortableEntity originalSortable = GetComponent<SortableEntity>();
if (originalSortable != null) {
reflectionObject.AddComponent<SortableEntity>();
}
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Created reflection for {gameObject.name}", this);
}

void UpdateReflectionTransform() {
if (reflectionObject == null || originalRenderer == null) return;
Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
Vector3 originalWorldPos = transform.position;
Vector3 reflectionWorldPos = originalWorldPos;
float referenceYForOffset = referenceTransform.position.y;
reflectionWorldPos.y = referenceYForOffset + yOffset - (originalWorldPos.y - referenceYForOffset);
reflectionObject.transform.position = reflectionWorldPos;
reflectionObject.transform.rotation = transform.rotation;
reflectionObject.transform.localScale = transform.localScale;
Vector3 currentLocalScale = reflectionObject.transform.localScale;
currentLocalScale.y *= -1;
reflectionObject.transform.localScale = currentLocalScale;
}

void UpdateReflectionVisuals() {
if (reflectionRenderer == null || originalRenderer == null) return;

reflectionRenderer.sprite = originalRenderer.sprite;
reflectionRenderer.flipX = originalRenderer.flipX;
reflectionRenderer.flipY = originalRenderer.flipY;

Color baseOriginalSpriteColor = originalRenderer.color;
Color finalReflectionTintedColor = baseOriginalSpriteColor * _actualReflectionTint; // Use resolved
float finalCombinedAlpha = baseOriginalSpriteColor.a * _actualReflectionOpacity; // Use resolved
reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);

if (enableDistanceFade && reflectionMaterialInstance != null) {
Transform referenceTransform = (useParentAsReference && transform.parent != null) ? transform.parent : transform;
float waterSurfaceY = referenceTransform.position.y;
reflectionMaterialInstance.SetFloat("_FadeStart", fadeStartDistance);
reflectionMaterialInstance.SetFloat("_FadeEnd", fadeEndDistance);
reflectionMaterialInstance.SetFloat("_MinAlpha", minFadeAlpha);
reflectionMaterialInstance.SetFloat("_OriginalY", waterSurfaceY);
Color materialBaseColor = _actualReflectionTint; // Use resolved
materialBaseColor.a = _actualReflectionOpacity * baseOriginalSpriteColor.a; // Use resolved
reflectionMaterialInstance.SetColor("_Color", materialBaseColor);
}
else if (!enableDistanceFade && reflectionMaterialInstance != null) {
reflectionRenderer.sharedMaterial = originalRenderer.sharedMaterial;
Destroy(reflectionMaterialInstance);
reflectionMaterialInstance = null;
}

reflectionRenderer.enabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;

if (reflectionAnimator != null && originalAnimator != null) {
reflectionAnimator.enabled = originalAnimator.enabled;
if (originalAnimator.runtimeAnimatorController != null && originalAnimator.parameterCount > 0) {
foreach (AnimatorControllerParameter param in originalAnimator.parameters) {
try {
switch (param.type) {
case AnimatorControllerParameterType.Bool:
reflectionAnimator.SetBool(param.name, originalAnimator.GetBool(param.name));
break;
case AnimatorControllerParameterType.Float:
reflectionAnimator.SetFloat(param.name, originalAnimator.GetFloat(param.name));
break;
case AnimatorControllerParameterType.Int:
reflectionAnimator.SetInteger(param.name, originalAnimator.GetInteger(param.name));
break;
}
} catch (System.Exception e) {
if(_actualShowDebugInfo) Debug.LogWarning($"Failed to sync animator param '{param.name}': {e.Message}", reflectionAnimator);
}
}
}
}
}

bool HasVisualStateChanged() {
if (originalRenderer == null) ret false;
bool parentYChanged = false;
if (useParentAsReference && transform.parent != null) {
parentYChanged = !Mathf.Approximately(lastParentY, transform.parent.position.y);
}
ret lastSprite != originalRenderer.sprite ||
!ColorsApproximatelyEqual(lastOriginalColor, originalRenderer.color) ||
lastFlipX != originalRenderer.flipX ||
lastFlipY != originalRenderer.flipY ||
lastEnabled != (originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy) ||
lastScale != transform.localScale ||
lastPosition != transform.position ||
parentYChanged;
}

void CacheCurrentState() {
if (originalRenderer == null) return;
lastSprite = originalRenderer.sprite;
lastOriginalColor = originalRenderer.color;
lastFlipX = originalRenderer.flipX;
lastFlipY = originalRenderer.flipY;
lastEnabled = originalRenderer.enabled && originalRenderer.gameObject.activeInHierarchy;
lastScale = transform.localScale;
lastPosition = transform.position;
if (useParentAsReference && transform.parent != null) {
lastParentY = transform.parent.position.y;
}
}

bool ColorsApproximatelyEqual(Color c1, Color c2, float tolerance = 0.001f) {
ret Mathf.Abs(c1.r - c2.r) < tolerance &&
Mathf.Abs(c1.g - c2.g) < tolerance &&
Mathf.Abs(c1.b - c2.b) < tolerance &&
Mathf.Abs(c1.a - c2.a) < tolerance;
}

void SetupWaterMaskingInteraction() {
if (!_actualUseWaterMasking || reflectionRenderer == null) return; // Use resolved
GameObject waterTilemapGO = FindWaterTilemapByTag(); // FindWaterTilemapByTag will use resolved tag
if (waterTilemapGO == null) {
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Water tilemap for masking not found on {gameObject.name} using tag '{_actualWaterTilemapTag}'. Masking disabled.", this);
return;
}
SpriteMask maskComponent = waterTilemapGO.GetComponent<SpriteMask>();
if (maskComponent == null) {
maskComponent = waterTilemapGO.AddComponent<SpriteMask>();
maskComponent.sprite = null;
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Added SpriteMask to water tilemap '{waterTilemapGO.name}' for object '{gameObject.name}'.", waterTilemapGO);
}
reflectionRenderer.maskInteraction = SpriteMaskInteraction.VisibleInsideMask;
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Reflection of '{gameObject.name}' will be masked by '{waterTilemapGO.name}'.", this);
}

GameObject FindWaterTilemapByTag() {
if (string.IsNullOrEmpty(_actualWaterTilemapTag)) ret FindWaterTilemapFallback();
GameObject taggedWater = GameObject.FindGameObjectWithTag(_actualWaterTilemapTag);
if (taggedWater != null && taggedWater.GetComponent<Tilemap>() != null) {
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Found water tilemap by tag '{_actualWaterTilemapTag}': {taggedWater.name} for {gameObject.name}", this);
ret taggedWater;
}
if (taggedWater != null && taggedWater.GetComponent<Tilemap>() == null && _actualShowDebugInfo) {
Debug.LogWarning($"[WaterReflection] GameObject '{taggedWater.name}' (tag '{_actualWaterTilemapTag}') has no Tilemap component!", this);
}
ret FindWaterTilemapFallback();
}

GameObject FindWaterTilemapFallback() {
if (TileInteractionManager.Instance != null) {
var mappings = TileInteractionManager.Instance.tileDefinitionMappings;
if (mappings != null) {
foreach (var mapping in mappings) {
if (mapping?.tileDef != null && mapping.tilemapModule != null && mapping.tileDef.isWaterTile) {
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null && renderTilemapTransform.GetComponent<Tilemap>() != null) {
if (_actualShowDebugInfo) Debug.Log($"[WaterReflection] Auto-detected water tilemap via TIM: {renderTilemapTransform.name} for {gameObject.name}", this);
ret renderTilemapTransform.gameObject;
}
}
}
}
}
if (_actualShowDebugInfo) Debug.LogWarning($"[WaterReflection] Could not auto-detect water tilemap via TileInteractionManager for {gameObject.name}.", this);
ret null;
}

void OnDestroy() {
if (reflectionObject != null) {
if (Application.isPlaying) Destroy(reflectionObject);
else DestroyImmediate(reflectionObject);
}
if (reflectionMaterialInstance != null) {
if (Application.isPlaying) Destroy(reflectionMaterialInstance);
else DestroyImmediate(reflectionMaterialInstance);
}
}

void OnValidate() {
#if UNITY_EDITOR
EditorApplication.delayCall -= EditorUpdatePreview; // Remove previous requests to avoid stacking
EditorApplication.delayCall += EditorUpdatePreview; // Add a new request
#endif
}

#if UNITY_EDITOR
void EditorUpdatePreview() {
if (this == null || gameObject == null) // The object could be destroyed before the call {
return;
}

if (Application.isEditor && !Application.isPlaying) {
if (localShowDebugInfo) {
bool localMaterialNeeded = enableDistanceFade && (!overrides.gradientFadeBaseMaterial || localGradientFadeBaseMaterial == null);
bool globalMaterialMightBeUsed = enableDistanceFade && !overrides.gradientFadeBaseMaterial && localGradientFadeBaseMaterial == null;

if (localMaterialNeeded && !globalMaterialMightBeUsed) // Warn if local ovr is on but local material missing {
Debug.LogWarning($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true and 'Override Gradient Material' is true, but 'Local Gradient Fade Base Material' is not assigned. Assign local material or uncheck override.", this);
}
else if (globalMaterialMightBeUsed) // Inform that global will be used if local isn't set {
Debug.Log($"[WaterReflection OnValidate] '{gameObject.name}': 'Enable Distance Fade' is true. If 'Local Gradient Fade Base Material' remains unassigned and ovr is false, the global default from WaterReflectionManager will be used in Play mode.", this);
}
}

if (reflectionRenderer != null && originalRenderer != null) {
Color previewTint = overrides.reflectionTint ? localReflectionTint : Color.white; // Default to white if no manager
float previewOpacity = overrides.reflectionOpacity ? localReflectionOpacity : 0.5f;
int previewSortOffset = overrides.sortingOrderOffset ? localSortingOrderOffset : -1;

reflectionRenderer.sprite = originalRenderer.sprite;
reflectionRenderer.flipX = originalRenderer.flipX;
reflectionRenderer.flipY = originalRenderer.flipY;
reflectionRenderer.sortingOrder = originalRenderer.sortingOrder + previewSortOffset;
Color baseOriginalSpriteColor = originalRenderer.color;
Color finalReflectionTintedColor = baseOriginalSpriteColor * previewTint;
float finalCombinedAlpha = baseOriginalSpriteColor.a * previewOpacity;
reflectionRenderer.color = new Color(finalReflectionTintedColor.r, finalReflectionTintedColor.g, finalReflectionTintedColor.b, finalCombinedAlpha);
UpdateReflectionTransform(); // Keep transform updated
}
}
}
#endif

pub void SetLocalReflectionOpacity(float opacity) // Example of changing a local-only value {
localReflectionOpacity = Mathf.Clamp01(opacity);
if (overrides.reflectionOpacity) // Only re-resolve and update if this local value is being used {
ResolveSettings();
if (Application.isPlaying && originalRenderer != null) UpdateReflectionVisuals();
}
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\Visual\Effects\WaterReflectionManager.cs

﻿using UnityEngine;

pub cls WaterReflectionManager : MonoBehaviour {
pub stat WaterReflectionManager Instance { get; set; }

pub Material defaultGradientFadeMaterial;

[Range(0f, 1f)] pub float defaultReflectionOpacity = 0.5f;

pub Color defaultReflectionTint = Color.white;

pub int defaultSortingOrderOffset = -1;

pub bool defaultUseWaterMasking = true;

pub string defaultWaterTilemapTag = "Water";

pub bool globalShowDebugInfo = false;

void Awake() {
if (Instance != null && Instance != this) {
Debug.LogWarning($"[WaterReflectionManager] Duplicate instance found on {gameObject.name}. Destroying self.", gameObject);
Destroy(gameObject);
return;
}
Instance = this;

if (defaultGradientFadeMaterial == null) {
Debug.LogWarning("[WaterReflectionManager] Default Gradient Fade Material is not assigned. Distance fade may not work correctly for reflections that don't have their own material specified.", this);
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Placement\PlantGrowthModifierManager.cs

﻿using System.Collections.Generic;
using Abracodabra.Genes;
using WegoSystem;

pub cls PlantGrowthModifierManager : MonoBehaviour, ITickUpdateable {
pub stat PlantGrowthModifierManager Instance { get; set; }

pub cls TileGrowthModifier {
pub TileDefinition tileDefinition;
pub float growthSpeedMultiplier = 1.0f;
pub float energyRechargeMultiplier = 1.0f;
}

pub float defaultGrowthSpeedMultiplier = 1.0f;
pub float defaultEnergyRechargeMultiplier = 1.0f;

pub List<TileGrowthModifier> tileModifiers = new List<TileGrowthModifier>();

[SerializeField] TileInteractionManager tileInteractionManager;
[SerializeField] bool showDebugMessages = true;
[SerializeField] bool showTileChangeMessages = true;

Dictionary<string, TileGrowthModifier> modifierLookup = new Dictionary<string, TileGrowthModifier>();
Dictionary<PlantGrowth, TileDefinition> plantTiles = new Dictionary<PlantGrowth, TileDefinition>();

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;

BuildModifierLookup();
}

pub void Initialize() {
if (tileInteractionManager == null) {
tileInteractionManager = TileInteractionManager.Instance;
if (tileInteractionManager == null && showDebugMessages) {
Debug.LogWarning("PlantGrowthModifierManager: TileInteractionManager not found!");
}
}

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
else {
Debug.LogError("[PlantGrowthModifierManager] TickManager not found! Modifiers will not update.");
}
}

void OnDestroy() {
var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}
}

pub void OnTickUpdate(int currentTick) {
UpdateAllPlantTiles();
}

void UpdateAllPlantTiles() {
if (tileInteractionManager == null) return;

List<PlantGrowth> plantsToCheck = new List<PlantGrowth>(plantTiles.Keys);

foreach (PlantGrowth plant in plantsToCheck) {
if (plant == null) {
plantTiles.Remove(plant);
continue;
}

Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);

if (plantTiles.TryGetValue(plant, out TileDefinition previousTileDef) && currentTileDef != previousTileDef) {
plantTiles[plant] = currentTileDef;

if (showTileChangeMessages) {
string previousTileName = previousTileDef != null ? previousTileDef.displayName : "None";
string currentTileName = currentTileDef != null ? currentTileDef.displayName : "None";
Debug.Log($"Plant '{plant.name}' tile changed: {previousTileName} -> {currentTileName}");
}
}
}
}

void BuildModifierLookup() {
modifierLookup.Clear();
foreach (var modifier in tileModifiers) {
if (modifier.tileDefinition != null && !string.IsNullOrEmpty(modifier.tileDefinition.displayName) && !modifierLookup.ContainsKey(modifier.tileDefinition.displayName)) {
modifierLookup.Add(modifier.tileDefinition.displayName, modifier);
}
}
}

pub void RegisterPlantTile(PlantGrowth plant, TileDefinition tileDef) {
if (plant == null) return;
plantTiles[plant] = tileDef;

if (showDebugMessages) {
string tileName = tileDef != null ? tileDef.displayName : "Unknown Tile";
Debug.Log($"Registered plant {plant.name} on tile {tileName}");
}
}

pub void UnregisterPlant(PlantGrowth plant) {
if (plant != null) {
plantTiles.Remove(plant);
}
}

pub float GetGrowthSpeedMultiplier(PlantGrowth plant) {
if (plant == null) ret defaultGrowthSpeedMultiplier;

if (!plantTiles.ContainsKey(plant)) {
RegisterNewPlant(plant); // Auto-register if not found
}

if (plantTiles.TryGetValue(plant, out TileDefinition tileDef) && tileDef != null) {
if (modifierLookup.TryGetValue(tileDef.displayName, out TileGrowthModifier modifier)) {
ret modifier.growthSpeedMultiplier;
}
}

ret defaultGrowthSpeedMultiplier;
}

pub float GetEnergyRechargeMultiplier(PlantGrowth plant) {
if (plant == null) ret defaultEnergyRechargeMultiplier;

if (!plantTiles.ContainsKey(plant)) {
RegisterNewPlant(plant); // Auto-register if not found
}

if (plantTiles.TryGetValue(plant, out TileDefinition tileDef) && tileDef != null) {
if (modifierLookup.TryGetValue(tileDef.displayName, out TileGrowthModifier modifier)) {
ret modifier.energyRechargeMultiplier;
}
}

ret defaultEnergyRechargeMultiplier;
}

void RegisterNewPlant(PlantGrowth plant) {
if (plant == null || tileInteractionManager == null) return;

Vector3Int gridPosition = tileInteractionManager.WorldToCell(plant.transform.position);
TileDefinition currentTileDef = tileInteractionManager.FindWhichTileDefinitionAt(gridPosition);
plantTiles[plant] = currentTileDef;

if (showDebugMessages) {
string tileName = currentTileDef != null ? currentTileDef.displayName : "Unknown Tile";
Debug.Log($"Auto-registered new plant {plant.name} on tile {tileName}");
}
}

void OnValidate() {
BuildModifierLookup();
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Placement\PlantPlacementManager.cs

﻿// REWORKED FILE: Assets/Scripts/WorldInteraction/Placement/PlantPlacementManager.cs
using Abracodabra.Genes.Templates;

pub cls PlantPlacementManager : MonoBehaviour {
pub stat PlantPlacementManager Instance { get; set; }

[SerializeField] Transform plantParent;
[SerializeField] TileInteractionManager tileInteractionManager;
[SerializeField] NodeExecutor nodeExecutor;
[SerializeField] float spawnRadius = 0.25f; // FIX: This will now be used
[SerializeField] List<TileDefinition> invalidPlantingTiles = new List<TileDefinition>();

HashSet<TileDefinition> invalidTilesSet = new HashSet<TileDefinition>();
Dictionary<Vector3Int, GameObject> plantsByGridPosition = new Dictionary<Vector3Int, GameObject>();

void Awake() {
if (Instance != null && Instance != this) { Destroy(gameObject); return; }
Instance = this;
RebuildInvalidTilesSet();
}

pub void Initialize() {
if (plantParent == null && EcosystemManager.Instance != null) plantParent = EcosystemManager.Instance.animalParent;
if (tileInteractionManager == null) tileInteractionManager = TileInteractionManager.Instance;
if (nodeExecutor == null) nodeExecutor = FindFirstObjectByType<NodeExecutor>();
}

void RebuildInvalidTilesSet() {
invalidTilesSet = new HashSet<TileDefinition>(invalidPlantingTiles.Where(t => t != null));
}

pub bool IsPositionOccupied(Vector3Int gridPosition) {
CleanupDestroyedPlants();
ret plantsByGridPosition.ContainsKey(gridPosition);
}

pub bool IsTileValidForPlanting(TileDefinition tileDef) {
ret tileDef != null && !invalidTilesSet.Contains(tileDef);
}

void CleanupDestroyedPlants() {
var keysToRemove = plantsByGridPosition.Where(kvp => kvp.Value == null).Select(kvp => kvp.Key).ToList();
foreach (var key in keysToRemove) {
plantsByGridPosition.Remove(key);
}
}

pub bool TryPlantSeedFromInventory(InventoryBarItem seedItem, Vector3Int gridPosition, Vector3 worldPosition) {
if (seedItem == null || seedItem.Type != InventoryBarItem.ItemType.Seed) ret false;
if (IsPositionOccupied(gridPosition)) ret false;

TileDefinition tileDef = tileInteractionManager?.FindWhichTileDefinitionAt(gridPosition);
if (!IsTileValidForPlanting(tileDef)) ret false;

if (nodeExecutor == null) {
Debug.LogError("Cannot plant: NodeExecutor reference is missing in PlantPlacementManager.");
ret false;
}

Vector3 finalPlantingPosition = GetRandomizedPlantingPosition(worldPosition);
SeedTemplate templateToPlant = seedItem.SeedTemplate;
GameObject plantGO = nodeExecutor.SpawnPlantFromTemplate(templateToPlant, finalPlantingPosition, plantParent);

if (plantGO == null) ret false;

plantsByGridPosition[gridPosition] = plantGO;
ret true;
}

Vector3 GetRandomizedPlantingPosition(Vector3 centerPosition) {
if (spawnRadius <= 0f) ret centerPosition;

Vector2 randomOffset = Random.insideUnitCircle * spawnRadius;
ret centerPosition + new Vector3(randomOffset.x, randomOffset.y, 0);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Placement\PlayerTileInteractor.cs

﻿// REWORKED FILE: Assets/Scripts/WorldInteraction/Placement/PlayerTileInteractor.cs
using WegoSystem;

pub sealed cls PlayerTileInteractor : MonoBehaviour {
[SerializeField] InventoryBarController inventoryBar;
[SerializeField] TileInteractionManager tileInteractionManager;
[SerializeField] Transform playerTransform;
[SerializeField] bool showDebug = false;

bool pendingLeftClick;
bool pendingRightClick;

void Awake() {
if (playerTransform == null) playerTransform = transform;
}

void Start() {
FindSingletons();
}

void Update() {
if (RunManager.Instance?.CurrentState != RunState.GrowthAndThreat) return;
if (Input.GetMouseButtonDown(0)) pendingLeftClick = true;
if (Input.GetMouseButtonDown(1)) pendingRightClick = true;
}

void LateUpdate() {
if (pendingLeftClick) {
pendingLeftClick = false;
HandleLeftClick();
}
if (pendingRightClick) {
pendingRightClick = false;
HandleRightClick();
}
}

void HandleRightClick() {
if (!EnsureManagers()) return;

InventoryBarItem selected = inventoryBar.SelectedItem;
if (selected == null || !selected.IsValid()) return;

if (selected.Type == InventoryBarItem.ItemType.Gene) {
var itemData = new HarvestedItem(selected.GeneInstance);
if (!itemData.IsConsumable()) return;

GardenerController player = playerTransform.GetComponent<GardenerController>();
if (player == null || player.HungerSystem == null) return;

player.HungerSystem.Eat(itemData.GetNutritionValue());

System.Action onSuccess = () => {
InventoryGridController.Instance.RemoveGeneFromInventory(selected.GeneInstance);
inventoryBar.ShowBar(); // Refresh the bar
};

PlayerActionManager.Instance.ExecutePlayerAction(PlayerActionType.Interact,
tileInteractionManager.WorldToCell(playerTransform.position), "Eating", onSuccess);
}
}

void HandleLeftClick() {
if (!EnsureManagers()) return;

InventoryBarItem selected = inventoryBar.SelectedItem;
if (selected == null || !selected.IsValid()) {
if (showDebug) Debug.Log("[PlayerTileInteractor] Left-click ignored: No valid item selected.");
return;
}

Vector3 mouseW = Camera.main.ScreenToWorldPoint(Input.mousePosition);
Vector3Int cellPos = tileInteractionManager.WorldToCell(mouseW);
Vector3 cellCenter = tileInteractionManager.interactionGrid.GetCellCenterWorld(cellPos);

if (Vector2.Distance(playerTransform.position, cellCenter) > tileInteractionManager.hoverRadius) {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Left-click ignored: Target cell {cellPos} is out of range.");
return;
}

if (showDebug) Debug.Log($"[PlayerTileInteractor] Attempting action '{selected.Type}' with item '{selected.GetDisplayName()}' at {cellPos}.");

switch (selected.Type) {
case InventoryBarItem.ItemType.Tool:
PlayerActionManager.Instance.ExecutePlayerAction(PlayerActionType.UseTool, cellPos, selected.ToolDefinition);
break;

case InventoryBarItem.ItemType.Seed:
System.Action onSuccess = () => {
if (showDebug) Debug.Log($"[PlayerTileInteractor] Successfully planted '{selected.GetDisplayName()}'. Removing from inventory.");
inventoryBar.ShowBar();
};
PlayerActionManager.Instance.ExecutePlayerAction(PlayerActionType.PlantSeed, cellPos, selected, onSuccess);
break;
}
}

bool EnsureManagers() {
if (tileInteractionManager == null || inventoryBar == null) FindSingletons();
ret tileInteractionManager != null && inventoryBar != null;
}

void FindSingletons() {
if (inventoryBar == null) inventoryBar = InventoryBarController.Instance;
if (tileInteractionManager == null) tileInteractionManager = TileInteractionManager.Instance;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\GardenerController.cs

﻿// Assets/Scripts/WorldInteraction/Player/GardenerController.cs

using WegoSystem;

pub cls GardenerController : MonoBehaviour, IStatusEffectable, ITickUpdateable {
[SerializeField] float multiTickDelay = 0.5f;

[SerializeField] bool useAnimations = true;
[SerializeField] Animator animator;
[SerializeField] string runningParameterName = "isRunning";
[SerializeField] string plantingTriggerName = "plant";

[SerializeField] SpriteRenderer spriteRenderer;
[SerializeField] bool flipSpriteWhenMovingLeft = true;
[SerializeField] bool flipHorizontalDirection = true;

GridEntity gridEntity;
StatusEffectManager statusManager;
StatusEffectUIManager statusEffectUI;
PlayerHungerSystem hungerSystem;

GridPosition currentTargetPosition;
bool isProcessingMovement = false;

pub GridEntity GridEntity => gridEntity;
pub StatusEffectManager StatusManager => statusManager;
pub PlayerHungerSystem HungerSystem => hungerSystem;

void Awake() {
gridEntity = GetComponent<GridEntity>();
if (gridEntity == null) gridEntity = gameObject.AddComponent<GridEntity>();
statusManager = GetComponent<StatusEffectManager>();
if (statusManager == null) statusManager = gameObject.AddComponent<StatusEffectManager>();
hungerSystem = GetComponent<PlayerHungerSystem>();
if (hungerSystem == null) hungerSystem = gameObject.AddComponent<PlayerHungerSystem>();

statusEffectUI = GetComponentInChildren<StatusEffectUIManager>(true);
if (statusEffectUI == null) Debug.LogWarning("[GardenerController] StatusEffectUIManager not found in children. Icons won't display.", this);
if (spriteRenderer == null) spriteRenderer = GetComponentInChildren<SpriteRenderer>();
if (spriteRenderer == null) Debug.LogWarning("[GardenerController] SpriteRenderer not found.", gameObject);
if (animator == null && useAnimations) Debug.LogWarning("[GardenerController] Animator not found.", gameObject);
}

void Start() {
statusManager.Initialize(this);

if (statusEffectUI != null) {
statusEffectUI.Initialize(statusManager);
}

if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
if (gridEntity != null) {
gridEntity.OnPositionChanged += OnGridPositionChanged;
}
}

void OnDestroy() {
var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}

if (gridEntity != null) {
gridEntity.OnPositionChanged -= OnGridPositionChanged;
}
}

pub void OnTickUpdate(int currentTick) {
statusManager?.OnTickUpdate(currentTick);
}

void Update() {
if (RunManager.Instance?.CurrentState == RunState.GrowthAndThreat) {
HandlePlayerInput();
}
if (gridEntity != null && statusManager != null) {
gridEntity.SetSpeedMultiplier(statusManager.VisualSpeedMultiplier);
}
UpdateAnimations();
UpdateSpriteDirection();
}

void OnGridPositionChanged(GridPosition oldPos, GridPosition newPos) {
EnvironmentalStatusEffectSystem.Instance?.CheckAndApplyTileEffects(this);
}

pub string GetDisplayName() { ret "Gardener"; }
pub void TakeDamage(float amount) { Debug.Log($"Gardener took {amount} damage!"); }
pub void Heal(float amount) { Debug.Log($"Gardener was healed for {amount}!"); }
pub void ModifyHunger(float amount) {
if (hungerSystem != null) {
hungerSystem.Eat(-amount);
}
}

void HandlePlayerInput() {
if (gridEntity == null || gridEntity.IsMoving || isProcessingMovement) return;

GridPosition moveDir = GridPosition.Zero;
if (Input.GetKeyDown(KeyCode.W) || Input.GetKeyDown(KeyCode.UpArrow)) moveDir = GridPosition.Up;
else if (Input.GetKeyDown(KeyCode.S) || Input.GetKeyDown(KeyCode.DownArrow)) moveDir = GridPosition.Down;
else if (Input.GetKeyDown(KeyCode.A) || Input.GetKeyDown(KeyCode.LeftArrow)) moveDir = GridPosition.Left;
else if (Input.GetKeyDown(KeyCode.D) || Input.GetKeyDown(KeyCode.RightArrow)) moveDir = GridPosition.Right;

if (moveDir != GridPosition.Zero) {
TryMove(moveDir);
return;
}
}

void TryMove(GridPosition direction) {
if (gridEntity == null) return;
GridPosition targetPos = gridEntity.Position + direction;
if (GridPositionManager.Instance != null && PlayerActionManager.Instance != null && TickManager.Instance != null &&
GridPositionManager.Instance.IsPositionValid(targetPos) &&
!GridPositionManager.Instance.IsPositionOccupied(targetPos)) {
Vector3 currentWorldPos = GridPositionManager.Instance.GridToWorld(gridEntity.Position);
int moveCost = PlayerActionManager.Instance.GetMovementTickCost(currentWorldPos, this);
if (moveCost > 1) {
StartCoroutine(ProcessMultiTickMovement(targetPos, moveCost));
}
else {
gridEntity.SetPosition(targetPos);
currentTargetPosition = targetPos;
TickManager.Instance.AdvanceTick();
}
}
}

IEnumerator ProcessMultiTickMovement(GridPosition targetPos, int tickCost) {
isProcessingMovement = true;
for (int i = 0; i < tickCost - 1; i++) {
TickManager.Instance.AdvanceTick();
yield ret new WaitForSeconds(multiTickDelay);
}
gridEntity.SetPosition(targetPos);
currentTargetPosition = targetPos;
TickManager.Instance.AdvanceTick();
isProcessingMovement = false;
}

void UpdateAnimations() {
if (!useAnimations || animator == null) return;
bool isMoving = gridEntity != null && gridEntity.IsMoving;
animator.SetBool(runningParameterName, isMoving);
}

void UpdateSpriteDirection() {
if (spriteRenderer == null || !flipSpriteWhenMovingLeft || gridEntity == null || !gridEntity.IsMoving) return;
Vector3 worldTarget = GridPositionManager.Instance.GridToWorld(currentTargetPosition);
Vector3 currentWorld = transform.position;
Vector2 directionToCheck = (worldTarget - currentWorld).normalized;
if (Mathf.Abs(directionToCheck.x) > 0.01f) {
bool shouldFlip = directionToCheck.x < 0;
spriteRenderer.flipX = flipHorizontalDirection ? shouldFlip : !shouldFlip;
}
}

pub void Plant() {
if (useAnimations && animator != null) {
animator.SetTrigger(plantingTriggerName);
}
}

pub GridPosition GetCurrentGridPosition() {
ret gridEntity?.Position ?? GridPosition.Zero;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\HarvestableTag.cs

﻿using UnityEngine;

pub cls HarvestableTag : MonoBehaviour {
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\HarvestedItem.cs

﻿// Reworked File: Assets/Scripts/WorldInteraction/Player/HarvestedItem.cs
using Abracodabra.Genes.Runtime;
using Abracodabra.Genes.Implementations; // For NutritionComponent

pub cls HarvestedItem {
pub RuntimeGeneInstance HarvestedGeneInstance { get; set; }

pub HarvestedItem(RuntimeGeneInstance instance) {
HarvestedGeneInstance = instance;
}

pub float GetNutritionValue() {
if (HarvestedGeneInstance == null) ret 0f;

if (HarvestedGeneInstance.GetGene() is NutritiousPayload nutritiousGene) {
ret nutritiousGene.nutritionValue;
}

ret 0f; // Default if not a nutritious gene
}

pub bool IsConsumable() {
ret GetNutritionValue() > 0;
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\HungerUI.cs

﻿using UnityEngine;
using TMPro;

pub cls HungerUI : MonoBehaviour {
[SerializeField] PlayerHungerSystem playerHungerSystem;
[SerializeField] Slider hungerSlider;
[SerializeField] TextMeshProUGUI hungerText;

void Start() {
if (playerHungerSystem == null) {
GardenerController player = FindAnyObjectByType<GardenerController>();
if (player != null) {
playerHungerSystem = player.GetComponent<PlayerHungerSystem>();
}
}

if (playerHungerSystem != null) {
playerHungerSystem.OnHungerChanged += UpdateUI;
UpdateUI(playerHungerSystem.CurrentHunger, playerHungerSystem.MaxHunger);
}
else {
Debug.LogError("[HungerUI] PlayerHungerSystem reference not found! UI will not update.", this);
gameObject.SetActive(false);
}
}

void OnDestroy() {
if (playerHungerSystem != null) {
playerHungerSystem.OnHungerChanged -= UpdateUI;
}
}

void UpdateUI(float currentHunger, float maxHunger) {
if (hungerSlider != null) {
hungerSlider.maxValue = maxHunger;
hungerSlider.value = currentHunger;
}

if (hungerText != null) {
hungerText.text = $"{Mathf.CeilToInt(currentHunger)} / {Mathf.CeilToInt(maxHunger)}";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\PlayerActionManager.cs

﻿// Reworked File: Assets/Scripts/WorldInteraction/Player/PlayerActionManager.cs
using System.Collections; // FIX: Added missing using statement
using WegoSystem;
using Abracodabra.Genes;

pub enum PlayerActionType {
Move,
UseTool,
PlantSeed,
Harvest,
Interact
}

pub cls PlayerActionManager : MonoBehaviour {
pub stat PlayerActionManager Instance { get; set; }

pub cls ToolActionData {
pub ToolDefinition Tool;
pub Vector3Int GridPosition;
}

[SerializeField] bool debugMode = true;
[SerializeField] int tickCostPerAction = 1;
[SerializeField] float multiTickActionDelay = 0.5f;

pub event Action<PlayerActionType, object> OnActionExecuted;
pub event Action<string> OnActionFailed;

void Awake() {
if (Instance != null && Instance != this) Destroy(gameObject);
Instance = this;
}

pub bool ExecutePlayerAction(PlayerActionType actionType, Vector3Int gridPosition, object actionData = null, Action onSuccessCallback = null) {
if (debugMode) Debug.Log($"[PlayerActionManager] Executing {actionType} at {gridPosition}");

bool success = false;
int tickCost = tickCostPerAction;
object eventPayload = actionData;

var toolDefForCheck = actionData as ToolDefinition;
if (actionType == PlayerActionType.UseTool && toolDefForCheck != null && toolDefForCheck.toolType == ToolType.HarvestPouch) {
actionType = PlayerActionType.Harvest;
}

switch (actionType) {
case PlayerActionType.UseTool:
var toolDef = actionData as ToolDefinition;
success = ExecuteToolUse(gridPosition, toolDef);
if (success) {
eventPayload = new ToolActionData { Tool = toolDef, GridPosition = gridPosition };
}
break;

case PlayerActionType.PlantSeed:
tickCost = 2; // Planting takes longer
var seedItem = actionData as InventoryBarItem;
Func<bool> plantAction = () => ExecutePlantSeed(gridPosition, seedItem);
StartCoroutine(ExecuteDelayedAction(plantAction, tickCost, onSuccessCallback, actionType, actionData));
ret true; // Return early, coroutine handles the rest

case PlayerActionType.Harvest:
success = ExecuteHarvest(gridPosition);
break;

case PlayerActionType.Interact:
success = ExecuteInteraction(gridPosition, actionData);
break;
}

if (success) {
AdvanceGameTick(tickCost);
onSuccessCallback?.Invoke();
OnActionExecuted?.Invoke(actionType, eventPayload);
}
else {
OnActionFailed?.Invoke($"{actionType} failed at {gridPosition}");
}
ret success;
}

bool ExecuteToolUse(Vector3Int gridPosition, ToolDefinition tool) {
if (tool == null) ret false;
TileInteractionManager.Instance?.ApplyToolAction(tool);
ret true; // Assume success for now
}

bool ExecutePlantSeed(Vector3Int gridPosition, InventoryBarItem seedItem) {
if (seedItem == null || seedItem.Type != InventoryBarItem.ItemType.Seed) ret false;
ret PlantPlacementManager.Instance?.TryPlantSeedFromInventory(seedItem, gridPosition, TileInteractionManager.Instance.interactionGrid.GetCellCenterWorld(gridPosition)) ?? false;
}

bool ExecuteHarvest(Vector3Int gridPosition) {
var plantEntity = GridPositionManager.Instance?.GetEntitiesAt(new GridPosition(gridPosition))
.FirstOrDefault(e => e.GetComponent<PlantGrowth>() != null);

if (plantEntity == null) {
if (debugMode) Debug.Log($"Harvest failed: No plant found at {gridPosition}");
ret false;
}

var plant = plantEntity.GetComponent<PlantGrowth>();
if (plant == null) ret false;

Debug.LogWarning("PlayerActionManager.ExecuteHarvest needs to be updated to handle returned items from PlantGrowth.");
bool wasHarvested = true; // Placeholder

if(wasHarvested) {
}

ret wasHarvested;
}

bool ExecuteInteraction(Vector3Int gridPosition, object interactionData) {
if (debugMode) Debug.Log($"[PlayerActionManager] Interaction at {gridPosition}");
ret true;
}

IEnumerator ExecuteDelayedAction(Func<bool> action, int tickCost, Action onSuccessCallback, PlayerActionType actionType, object actionData) {
for (int i = 0; i < tickCost - 1; i++) {
TickManager.Instance.AdvanceTick();
yield ret new WaitForSeconds(multiTickActionDelay);
}

bool success = action.Invoke();
TickManager.Instance.AdvanceTick();

if (success) {
onSuccessCallback?.Invoke();
OnActionExecuted?.Invoke(actionType, actionData);
}
else {
OnActionFailed?.Invoke("Delayed action failed");
}
}

pub int GetMovementTickCost(Vector3 worldPosition, Component movingEntity = null) {
int totalCost = tickCostPerAction;
if (movingEntity != null) {
IStatusEffectable effectable = movingEntity.GetComponent<IStatusEffectable>();
if (effectable != null) {
totalCost += effectable.StatusManager.AdditionalMoveTicks;
}
}
ret totalCost;
}

void AdvanceGameTick(int tickCount = 1) {
if (TickManager.Instance == null) return;
for (int i = 0; i < tickCount; i++) {
TickManager.Instance.AdvanceTick();
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Player\PlayerHungerSystem.cs

﻿using System;
using WegoSystem;

pub cls PlayerHungerSystem : MonoBehaviour, ITickUpdateable {
[SerializeField] float maxHunger = 100f;
[SerializeField] float startingHunger = 100f;
[SerializeField] float hungerDepletionPerTick = 0.1f; // Default: 1 hunger per 10 ticks

pub float CurrentHunger { get; set; }
pub float MaxHunger => maxHunger;

pub event Action<float, float> OnHungerChanged; // current, max
pub event Action OnStarvation;

bool hasStarved = false;

void Start() {
CurrentHunger = startingHunger;
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(this);
}
else {
Debug.LogError("[PlayerHungerSystem] TickManager not found! Hunger will not deplete.");
}
}

void OnDestroy() {
var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}
}

pub void OnTickUpdate(int currentTick) {
if (hasStarved) return;

CurrentHunger -= hungerDepletionPerTick;
CurrentHunger = Mathf.Max(0, CurrentHunger);

OnHungerChanged?.Invoke(CurrentHunger, maxHunger);

if (CurrentHunger <= 0) {
hasStarved = true;
OnStarvation?.Invoke();
Debug.LogWarning("Player has starved to death!");
}
}

pub void Eat(float nutritionValue) {
if (hasStarved || nutritionValue <= 0) return;

CurrentHunger += nutritionValue;
CurrentHunger = Mathf.Clamp(CurrentHunger, 0, maxHunger);

Debug.Log($"Player ate food. Restored {nutritionValue} hunger. Current hunger: {CurrentHunger}/{maxHunger}");
OnHungerChanged?.Invoke(CurrentHunger, maxHunger);
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileDefinition.cs

﻿using UnityEngine;
using UnityEngine.Tilemaps;

pub cls TileDefinition : ScriptableObject {
pub string displayName;    // e.g. "Grass", "Dirt", "Wet Dirt"

pub Color tintColor = Color.white;

pub int revertAfterTicks = 0;  // Changed from float revertAfterSeconds

pub TileDefinition revertToTile;

pub bool keepBottomTile = false;

pub bool isWaterTile = false;

#if UNITY_EDITOR
pub void UpdateColor() {
var manager = UnityEngine.Object.FindAnyObjectByType<TileInteractionManager>();
if (manager == null) return;

foreach (var mapping in manager.tileDefinitionMappings) {
if (mapping.tileDef == this && mapping.tilemapModule != null) {
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
if (renderTilemap != null) {
renderTilemap.color = tintColor;
UnityEditor.EditorUtility.SetDirty(renderTilemap);
}
}
}
}
}
#endif
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileHoverColorManager.cs

﻿using UnityEngine;

pub cls TileHoverColorManager : ScriptableObject {
Color withinRangeColor = new Color(1f, 1f, 1f, 0.8f);

Color outsideRangeColor = new Color(1f, 1f, 1f, 0.3f);

pub Color WithinRangeColor => withinRangeColor;
pub Color OutsideRangeColor => outsideRangeColor;

pub Color GetColorForRange(bool isWithinRange) {
ret isWithinRange ? withinRangeColor : outsideRangeColor;
}

void OnValidate() {
if (withinRangeColor.a < outsideRangeColor.a) {
Debug.LogWarning("[TileHoverColorManager] Within range alpha should typically be higher than outside range alpha for better visibility.");
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileInteractionLibrary.cs

﻿using System.Collections.Generic;
using System; // Needed for [Serializable]

[Serializable] // Make it visible in the Inspector
pub cls ToolRefillRule {
pub ToolDefinition toolToRefill;

pub TileDefinition refillSourceTile;
}

pub cls TileInteractionLibrary : ScriptableObject {
pub List<TileInteractionRule> rules; // Existing transformation rules

[Header("Tool Refill Rules")] // <<< NEW HEADER
pub List<ToolRefillRule> refillRules; // <<< NEW LIST FOR REFILLS
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileInteractionManager.cs

﻿// Assets/Scripts/WorldInteraction/Tiles/TileInteractionManager.cs
using UnityEngine.Tilemaps;
using skner.DualGrid;
using TMPro;
using WegoSystem;
#if UNITY_EDITOR
using UnityEditor;
#endif

pub cls TileInteractionManager : SingletonMonoBehaviour<TileInteractionManager>, ITickUpdateable {
pub cls TileDefinitionMapping {
pub TileDefinition tileDef;
pub DualGridTilemapModule tilemapModule;
}

pub struct TimedTileState {
pub TileDefinition tileDef;
pub int ticksRemaining;
}

pub List<TileDefinitionMapping> tileDefinitionMappings;
pub TileInteractionLibrary interactionLibrary;
pub Grid interactionGrid;
pub Camera mainCamera;
pub Transform player;

pub float hoverRadius = 3f;

pub GameObject hoverHighlightObject;
pub TileHoverColorManager hoverColorManager;
pub int baseSortingOrder = 0;

pub bool debugLogs = false;
pub TextMeshProUGUI hoveredTileText;
pub TextMeshProUGUI currentToolText;

Dictionary<TileDefinition, DualGridTilemapModule> moduleByDefinition;
Dictionary<DualGridTilemapModule, TileDefinition> definitionByModule;
Vector3Int? currentlyHoveredCell;
TileDefinition hoveredTileDef;
Dictionary<Vector3Int, TimedTileState> timedCells = new Dictionary<Vector3Int, TimedTileState>();
SpriteRenderer hoverSpriteRenderer;
bool isWithinInteractionRange = false;

prot ovr void OnAwake() {
SetupTilemaps();
CacheHoverSpriteRenderer();
}

void Start() {
if (TickManager.Instance != null) TickManager.Instance.RegisterTickUpdateable(this);
}

void OnDestroy() {
var tickManager = TickManager.Instance;
if (tickManager != null) {
tickManager.UnregisterTickUpdateable(this);
}

}

void OnDisable() {
if (GridDebugVisualizer.Instance != null) {
GridDebugVisualizer.Instance.HideContinuousRadius("player_tool_use");
}
}

pub void OnTickUpdate(int currentTick) {
UpdateReversionTicks();
}

pub void ApplyToolAction(ToolDefinition toolDef) {
if (toolDef == null || !currentlyHoveredCell.HasValue) return;

Vector3Int targetCell = currentlyHoveredCell.Value;

TileDefinition currentTileDef = FindWhichTileDefinitionAt(targetCell);
if (currentTileDef == null) return;

if (debugLogs) Debug.Log($"[TileInteractionManager] Checking tile interactions for Tool='{toolDef.toolType}' on Tile='{currentTileDef.displayName}'");

if (interactionLibrary?.refillRules != null && ToolSwitcher.Instance != null && ToolSwitcher.Instance.CurrentTool == toolDef) {
foreach (var refillRule in interactionLibrary.refillRules) {
if (refillRule != null && refillRule.toolToRefill == toolDef && refillRule.refillSourceTile == currentTileDef) {
ToolSwitcher.Instance.RefillCurrentTool();
return; // Refill action was performed, we are done.
}
}
}

if (interactionLibrary?.rules != null) {
TileInteractionRule rule = interactionLibrary.rules.FirstOrDefault(r => r != null && r.tool == toolDef && r.fromTile == currentTileDef);
if (rule != null) {
if (rule.toTile != null) {
if (!rule.toTile.keepBottomTile) RemoveTile(currentTileDef, targetCell);
PlaceTile(rule.toTile, targetCell);
}
else {
RemoveTile(currentTileDef, targetCell);
}
}
}
}

void CacheHoverSpriteRenderer() {
if (hoverHighlightObject != null) {
hoverSpriteRenderer = hoverHighlightObject.GetComponent<SpriteRenderer>();
if (hoverSpriteRenderer == null) {
Debug.LogWarning("[TileInteractionManager] hoverHighlightObject has no SpriteRenderer component. Color management will not work.", this);
}
}
}

void SetupTilemaps() {
moduleByDefinition = new Dictionary<TileDefinition, DualGridTilemapModule>();
definitionByModule = new Dictionary<DualGridTilemapModule, TileDefinition>();
if (tileDefinitionMappings == null) {
if (debugLogs) Debug.LogWarning("[TileInteractionManager SetupTilemaps] No mappings defined.");
return;
}
foreach (var mapping in tileDefinitionMappings) {
if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) {
Debug.LogWarning("[TileInteractionManager SetupTilemaps] Null or incomplete mapping found. Skipping.");
continue;
}
if (!moduleByDefinition.ContainsKey(mapping.tileDef)) {
moduleByDefinition[mapping.tileDef] = mapping.tilemapModule;
definitionByModule[mapping.tilemapModule] = mapping.tileDef;
}
else {
Debug.LogWarning($"[TileInteractionManager SetupTilemaps] Duplicate TileDefinition '{mapping.tileDef.displayName}' found in mappings.", mapping.tileDef);
}
}
}

pub void UpdateSortingOrder() {
if (tileDefinitionMappings == null) return;
for (int i = 0; i < tileDefinitionMappings.Count; i++) {
var mapping = tileDefinitionMappings[i];
if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) continue;
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
TilemapRenderer renderer = renderTilemapTransform.GetComponent<TilemapRenderer>();
if (renderer != null) {
renderer.sortingOrder = baseSortingOrder - i;
#if UNITY_EDITOR
if (!Application.isPlaying) EditorUtility.SetDirty(renderer);
#endif
}
}
}
}

pub void UpdateAllColors() {
if (tileDefinitionMappings == null) return;
foreach (var mapping in tileDefinitionMappings) {
if (mapping == null || mapping.tileDef == null || mapping.tilemapModule == null) continue;
Transform renderTilemapTransform = mapping.tilemapModule.transform.Find("RenderTilemap");
if (renderTilemapTransform != null) {
Tilemap renderTilemap = renderTilemapTransform.GetComponent<Tilemap>();
if (renderTilemap != null) {
renderTilemap.color = mapping.tileDef.tintColor;
#if UNITY_EDITOR
if (!Application.isPlaying) EditorUtility.SetDirty(renderTilemap);
#endif
}
}
}
}

void Update() {
HandleTileHover();
UpdateDebugUI();
}

void UpdateReversionTicks() {
if (timedCells.Count == 0) return;
List<Vector3Int> cellsToRevert = null;
foreach (var kvp in timedCells.ToList()) {
Vector3Int cellPos = kvp.Key;
TimedTileState state = kvp.Value;
if (state.tileDef == null) { timedCells.Remove(cellPos); continue; }
state.ticksRemaining--;
if (state.ticksRemaining <= 0) {
if (cellsToRevert == null) cellsToRevert = new List<Vector3Int>();
cellsToRevert.Add(cellPos);
}
else {
timedCells[cellPos] = state;
}
}
if (cellsToRevert != null) {
foreach (var cellPos in cellsToRevert) {
if (timedCells.TryGetValue(cellPos, out TimedTileState stateToRevert)) {
timedCells.Remove(cellPos);
RemoveTile(stateToRevert.tileDef, cellPos);
if (stateToRevert.tileDef.revertToTile != null) {
PlaceTile(stateToRevert.tileDef.revertToTile, cellPos);
}
}
}
}
}

pub void PlaceTile(TileDefinition tileDef, Vector3Int cellPos) {
if (tileDef == null) return;
if (!moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module)) return;
if (module?.DataTilemap != null) {
module.DataTilemap.SetTile(cellPos, ScriptableObject.CreateInstance<Tile>());
if (tileDef.revertAfterTicks > 0) {
timedCells[cellPos] = new TimedTileState { tileDef = tileDef, ticksRemaining = tileDef.revertAfterTicks };
}
}
}

pub void RemoveTile(TileDefinition tileDef, Vector3Int cellPos) {
if (tileDef == null) return;
if (!moduleByDefinition.TryGetValue(tileDef, out DualGridTilemapModule module)) return;
if (module?.DataTilemap != null) {
module.DataTilemap.SetTile(cellPos, null);
}
if (timedCells.TryGetValue(cellPos, out TimedTileState timedState) && timedState.tileDef == tileDef) {
timedCells.Remove(cellPos);
}
}

pub TileDefinition FindWhichTileDefinitionAt(Vector3Int cellPos) {
TileDefinition foundDef = null;
foreach (var mapping in tileDefinitionMappings) {
if (mapping?.tileDef != null && mapping.tilemapModule?.DataTilemap != null && mapping.tileDef.keepBottomTile) {
if (mapping.tilemapModule.DataTilemap.HasTile(cellPos)) { foundDef = mapping.tileDef; break; }
}
}
if (foundDef == null) {
foreach (var kvp in definitionByModule) {
if (kvp.Key?.DataTilemap != null && kvp.Value != null && !kvp.Value.keepBottomTile) {
if (kvp.Key.DataTilemap.HasTile(cellPos)) { foundDef = kvp.Value; break; }
}
}
}
ret foundDef;
}

void HandleTileHover() {
if (mainCamera == null || player == null) return;
Vector3 mouseWorldPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
mouseWorldPos.z = 0f;
Vector3Int cellPos = WorldToCell(mouseWorldPos);

GridEntity playerGrid = player.GetComponent<GridEntity>();
if (playerGrid == null) return;

int gridRadius = Mathf.CeilToInt(hoverRadius);
GridPosition playerGridPos = playerGrid.Position;
GridPosition hoveredGridPos = new GridPosition(cellPos.x, cellPos.y);

isWithinInteractionRange = GridRadiusUtility.IsWithinCircleRadius(hoveredGridPos, playerGridPos, gridRadius);

hoveredTileDef = FindWhichTileDefinitionAt(cellPos);
currentlyHoveredCell = cellPos;

if (hoverHighlightObject != null) {
hoverHighlightObject.SetActive(true);
hoverHighlightObject.transform.position = CellCenterWorld(cellPos);
UpdateHoverHighlightColor(isWithinInteractionRange);
}
}

void UpdateHoverHighlightColor(bool withinRange) {
if (hoverSpriteRenderer != null && hoverColorManager != null) {
hoverSpriteRenderer.color = hoverColorManager.GetColorForRange(withinRange);
}
}

void UpdateDebugUI() {
if (hoveredTileText != null) {
string tileName = hoveredTileDef != null ? hoveredTileDef.displayName : "None";
if (currentlyHoveredCell.HasValue && timedCells.TryGetValue(currentlyHoveredCell.Value, out TimedTileState timedState)) {
tileName += $" [{timedState.ticksRemaining}t]";
}
string rangeIndicator = isWithinInteractionRange ? " [IN RANGE]" : " [OUT OF RANGE]";
hoveredTileText.text = $"Hover: {tileName}{rangeIndicator}";
}
if (currentToolText != null) {
if (InventoryBarController.Instance?.SelectedItem != null) {
currentToolText.text = $"Selected: {InventoryBarController.Instance.SelectedItem.GetDisplayName()}";
}
else {
currentToolText.text = "Nothing Selected";
}
}
}

pub Vector3Int WorldToCell(Vector3 worldPos) {
if (interactionGrid != null) ret interactionGrid.WorldToCell(worldPos);
Debug.LogWarning("[WorldToCell] No valid interactionGrid found.");
ret Vector3Int.zero;
}

Vector3 CellCenterWorld(Vector3Int cellPos) {
if (interactionGrid != null) ret interactionGrid.GetCellCenterWorld(cellPos);
Debug.LogWarning("[CellCenterWorld] No valid interactionGrid found.");
ret Vector3.zero;
}

pub bool IsWithinInteractionRange => isWithinInteractionRange;
pub Vector3Int? CurrentlyHoveredCell => currentlyHoveredCell;
pub TileDefinition HoveredTileDef => hoveredTileDef;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tiles\TileInteractionRule.cs

﻿using System;

pub cls TileInteractionRule {
pub ToolDefinition tool;

pub TileDefinition fromTile;
pub TileDefinition toTile;
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tools\ToolDefinition.cs

﻿using UnityEngine;
using System.Text;

pub cls ToolDefinition : ScriptableObject, ITooltipDataProvider {

pub ToolType toolType;
pub string displayName;

pub Sprite icon;
pub Color iconTint = Color.white;

pub bool limitedUses = false;
pub int initialUses = 10;

pub bool autoAddToInventory = true;

pub string GetTooltipTitle() {
ret displayName ?? "Unknown Tool";
}

pub string GetTooltipDescription() {
ret $"Tool Type: {toolType}";
}

pub string GetTooltipDetails(object source = null) {
var sb = new StringBuilder();
sb.Append(limitedUses ? $"<b>Uses:</b> {initialUses}" : "<b>Uses:</b> Unlimited");
ret sb.ToString().TrimEnd();
}

}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tools\ToolSwitcher.cs

﻿using System;

pub cls ToolSwitcher : MonoBehaviour {
pub stat ToolSwitcher Instance { get; set; }

pub ToolDefinition[] toolDefinitions;

int currentIndex = 0;

pub ToolDefinition CurrentTool { get; set; } = null;
pub int CurrentRemainingUses { get; set; } = -1; // -1 for unlimited

pub event Action<ToolDefinition> OnToolChanged;
pub event Action<int> OnUsesChanged;

void Awake() {
if (Instance != null && Instance != this) {
Destroy(gameObject);
return;
}
Instance = this;
}

void Start() {
InitializeToolState(true); // Initialize and fire events
}

void OnDestroy() {
if (Instance == this) {
Instance = null;
}
}

void Update() {
if (toolDefinitions == null || toolDefinitions.Length == 0) return;

bool toolChanged = false;
int previousIndex = currentIndex;

if (Input.GetKeyDown(KeyCode.Q)) {
currentIndex--;
if (currentIndex < 0)
currentIndex = toolDefinitions.Length - 1;
toolChanged = true;
}
else if (Input.GetKeyDown(KeyCode.E)) {
currentIndex++;
if (currentIndex >= toolDefinitions.Length)
currentIndex = 0;
toolChanged = true;
}

if (toolChanged) {
if (currentIndex >= 0 && currentIndex < toolDefinitions.Length && toolDefinitions[currentIndex] != null) {
InitializeToolState(false); // Update state for the new tool and fire events
}
else {
Debug.LogError($"[ToolSwitcher Update] Attempted to switch to an invalid/NULL tool definition at index {currentIndex}. Reverting.");
currentIndex = previousIndex; // Revert to the last valid index
}
}
}

void InitializeToolState(bool isInitialSetup) {
ToolDefinition previousTool = CurrentTool; // Store previous tool for change check
int previousUses = CurrentRemainingUses; // Store previous uses

if (toolDefinitions == null || toolDefinitions.Length == 0 || currentIndex < 0 || currentIndex >= toolDefinitions.Length || toolDefinitions[currentIndex] == null) {
CurrentTool = null;
CurrentRemainingUses = -1; // No tool = unlimited uses conceptually
}
else {
CurrentTool = toolDefinitions[currentIndex];
if (CurrentTool.limitedUses) {
CurrentRemainingUses = CurrentTool.initialUses;
}
else {
CurrentRemainingUses = -1; // Mark as unlimited
}
}

LogToolChange("[ToolSwitcher InitializeToolState]"); // Log the state after update

bool toolActuallyChanged = previousTool != CurrentTool;
bool usesActuallyChanged = previousUses != CurrentRemainingUses;

if (isInitialSetup || toolActuallyChanged) {
Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnToolChanged for tool: {CurrentTool?.displayName ?? "NULL"}");
OnToolChanged?.Invoke(CurrentTool);
}
if (isInitialSetup || usesActuallyChanged || toolActuallyChanged) // Fire uses changed if tool changed too (to reset UI) {
Debug.Log($"[ToolSwitcher InitializeToolState] Firing OnUsesChanged with value: {CurrentRemainingUses}");
OnUsesChanged?.Invoke(CurrentRemainingUses);
}
}

pub void SelectToolByDefinition(ToolDefinition toolDef) {
if (toolDef == null || toolDefinitions == null) return;

for (int i = 0; i < toolDefinitions.Length; i++) {
if (toolDefinitions[i] == toolDef) {
currentIndex = i;
InitializeToolState(false);
Debug.Log($"[ToolSwitcher] Externally selected tool: {toolDef.displayName} at index {i}");
return;
}
}

Debug.LogWarning($"[ToolSwitcher] Tool '{toolDef.displayName}' not found in definitions array");
}

pub void RefillCurrentTool() {
if (CurrentTool == null) {
Debug.LogWarning("[ToolSwitcher RefillCurrentTool] Cannot refill: No tool selected.");
return;
}

if (!CurrentTool.limitedUses) {
Debug.LogWarning($"[ToolSwitcher RefillCurrentTool] Cannot refill tool '{CurrentTool.displayName}': It has unlimited uses.");
return;
}

if (CurrentRemainingUses == CurrentTool.initialUses) {
if(Debug.isDebugBuild) Debug.Log($"[ToolSwitcher RefillCurrentTool] Tool '{CurrentTool.displayName}' is already full ({CurrentRemainingUses} uses).");
return;
}

int previousUses = CurrentRemainingUses;
CurrentRemainingUses = CurrentTool.initialUses;

Debug.Log($"[ToolSwitcher RefillCurrentTool] Refilled tool '{CurrentTool.displayName}' to {CurrentRemainingUses} uses (was {previousUses}).");

OnUsesChanged?.Invoke(CurrentRemainingUses);
}

pub bool TryConsumeUse() {
if (CurrentTool == null) {
Debug.LogWarning("[ToolSwitcher TryConsumeUse] Cannot consume use: No tool selected.");
ret false; // Cannot use a non-existent tool
}

if (!CurrentTool.limitedUses || CurrentRemainingUses == -1) {
ret true;
}

if (CurrentRemainingUses > 0) {
CurrentRemainingUses--;
Debug.Log($"[ToolSwitcher TryConsumeUse] Consumed use for '{CurrentTool.displayName}'. Remaining: {CurrentRemainingUses}");
OnUsesChanged?.Invoke(CurrentRemainingUses); // Notify listeners
ret true;
}
else {
Debug.Log($"[ToolSwitcher TryConsumeUse] Tool '{CurrentTool.displayName}' is out of uses (0 remaining).");
ret false;
}
}

void LogToolChange(string prefix = "[ToolSwitcher]") {
string toolName = (CurrentTool != null && !string.IsNullOrEmpty(CurrentTool.displayName))
? CurrentTool.displayName
: "(none)";
string usesSuffix = "";
if (CurrentTool != null && CurrentTool.limitedUses && CurrentRemainingUses >= 0) {
usesSuffix = $" ({CurrentRemainingUses}/{CurrentTool.initialUses})";
}
else if (CurrentTool != null && !CurrentTool.limitedUses) {
}

Debug.Log($"{prefix} Switched tool to: {toolName}{usesSuffix} (Index: {currentIndex})");
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\WorldInteraction\Tools\ToolType.cs

﻿pub enum ToolType {
None,
Hoe,
WateringCan,
SeedPouch,
HarvestPouch // <<< NEW
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Core\RunManager.cs

﻿// Assets/Scripts/Core/RunManager.cs
using WegoSystem;

namespace WegoSystem {
pub enum RunState {
Planning,
GrowthAndThreat
}

pub enum GamePhase {
Planning,
Execution
}

pub cls RunManager : SingletonMonoBehaviour<RunManager> {

[SerializeField] RunState currentState = RunState.Planning;
[SerializeField] GamePhase currentPhase = GamePhase.Planning;
[SerializeField] int currentRoundNumber = 1;
[SerializeField] int currentPhaseTicks = 0;

pub RunState CurrentState => currentState;
pub GamePhase CurrentPhase => currentPhase;
pub int CurrentRoundNumber => currentRoundNumber;
pub int CurrentPhaseTicks => currentPhaseTicks;

pub event Action<RunState> OnRunStateChanged;
pub event Action<GamePhase, GamePhase> OnPhaseChanged;
pub event Action<int> OnRoundChanged;

prot ovr void OnAwake() {
SetState(RunState.Planning, true);
}

pub void Initialize() {
if (TickManager.Instance != null) {
TickManager.Instance.RegisterTickUpdateable(new PhaseTickHandler(this));
}
else {
Debug.LogError("[RunManager] Initialization failed: TickManager not found!");
}
}

void SetState(RunState newState, bool force = false) {
if (currentState == newState && !force) return;

currentState = newState;
Debug.Log($"[RunManager] State changed to: {currentState}");

switch (currentState) {
case RunState.Planning:
WeatherManager.Instance?.PauseCycleAtDay();
SetPhase(GamePhase.Planning);
break;

case RunState.GrowthAndThreat:
WeatherManager.Instance?.ResumeCycle();
WaveManager.Instance?.StartWaveForRound(currentRoundNumber);
SetPhase(GamePhase.Execution);
break;
}

OnRunStateChanged?.Invoke(currentState);
}

void SetPhase(GamePhase newPhase) {
if (currentPhase == newPhase) return;

GamePhase oldPhase = currentPhase;
currentPhase = newPhase;
currentPhaseTicks = 0;

Debug.Log($"[RunManager] Phase changed: {oldPhase} -> {newPhase}");
OnPhaseChanged?.Invoke(oldPhase, newPhase);
}

pub void StartGrowthAndThreatPhase() {
if (currentState == RunState.Planning) {
Debug.Log($"[RunManager] Starting Growth & Threat for Round {currentRoundNumber}");
SetState(RunState.GrowthAndThreat);
}
}

pub void EndPlanningPhase() {
if (currentState == RunState.Planning && currentPhase == GamePhase.Planning) {
SetPhase(GamePhase.Execution);
StartGrowthAndThreatPhase();
}
}

pub void StartNewPlanningPhase() {
Debug.Log("[RunManager] Starting new planning phase");

if (currentState != RunState.Planning) {
if (WaveManager.Instance != null && WaveManager.Instance.IsCurrentWaveDefeated()) {
StartNewRound();
}
else {
SetState(RunState.Planning);
}
}
}

void StartNewRound() {
currentRoundNumber++;
Debug.Log($"[RunManager] Starting new round: {currentRoundNumber}");

WaveManager.Instance?.ResetForNewRound();
SetState(RunState.Planning);

OnRoundChanged?.Invoke(currentRoundNumber);
}

cls PhaseTickHandler : ITickUpdateable {
RunManager manager;

pub PhaseTickHandler(RunManager manager) {
this.manager = manager;
}

pub void OnTickUpdate(int currentTick) {
manager.currentPhaseTicks++;
}
}

pub void ForcePhase(GamePhase phase) {
if (Application.isEditor || Debug.isDebugBuild) {
SetPhase(phase);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridEntity.cs

﻿// Assets/Scripts/Ticks/GridEntity.cs

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
pub cls GridEntity : MonoBehaviour {
pub bool isTileOccupant = true;

GridPosition gridPosition;

[SerializeField] Vector3 groundPointOffset = Vector3.zero;
[SerializeField] Vector3 visualOffset = Vector3.zero;
[SerializeField] float visualInterpolationSpeed = 5f;
[SerializeField] AnimationCurve movementCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

GridPosition previousGridPosition;
Vector3 visualStartPosition;
Vector3 visualTargetPosition;
float movementProgress = 1f;
bool isMoving = false;
float speedMultiplier = 1f;

pub GridPosition Position {
get => gridPosition;
set {
if (gridPosition != value) {
previousGridPosition = gridPosition;
gridPosition = value;
OnGridPositionChanged();
}
}
}

pub GridPosition PreviousPosition => previousGridPosition;
pub bool IsMoving => isMoving;
pub float MovementProgress => movementProgress;
pub Vector3 GroundWorldPosition => transform.position + groundPointOffset;

pub event Action<GridPosition, GridPosition> OnPositionChanged;
pub event Action<GridPosition> OnMovementComplete;
pub event Action OnMovementStart;

prot virt void Start() {
visualStartPosition = transform.position;
visualTargetPosition = transform.position;
previousGridPosition = gridPosition;
}

prot virt void OnDestroy() {
var gridManager = GridPositionManager.Instance;
if (gridManager != null) {
gridManager.UnregisterEntity(this);
}
}

prot virt void Update() {
if (movementProgress < 1f) {
movementProgress += Time.deltaTime * visualInterpolationSpeed * speedMultiplier;
movementProgress = Mathf.Clamp01(movementProgress);

float curvedProgress = movementCurve.Evaluate(movementProgress);
transform.position = Vector3.Lerp(visualStartPosition, visualTargetPosition, curvedProgress);

if (movementProgress >= 1f) {
transform.position = visualTargetPosition;
isMoving = false;
OnMovementComplete?.Invoke(gridPosition);
}
}
}

#if UNITY_EDITOR
void OnDrawGizmosSelected() {
Vector3 groundWorldPosition = transform.position + groundPointOffset;
Gizmos.color = Color.green;
Gizmos.DrawLine(transform.position, groundWorldPosition);
Gizmos.DrawWireSphere(groundWorldPosition, 0.1f);
UnityEditor.Handles.Label(groundWorldPosition + Vector3.up * 0.2f, "Ground Point");

if (Application.isPlaying && GridPositionManager.Instance != null) {
Gizmos.color = Color.yellow;
Vector3 gridCenter = GridPositionManager.Instance.GetCellCenter(gridPosition);
Gizmos.DrawSphere(gridCenter, 0.08f);
}
}
#endif

prot virt void OnGridPositionChanged() {
visualStartPosition = transform.position;

if (GridPositionManager.Instance != null) {
Vector3 groundTargetPosition = GridPositionManager.Instance.GridToWorld(gridPosition);
visualTargetPosition = groundTargetPosition - groundPointOffset + visualOffset;
}

movementProgress = 0f;

if (!isMoving) {
isMoving = true;
OnMovementStart?.Invoke();
}

OnPositionChanged?.Invoke(previousGridPosition, gridPosition);
}

pub void SetPosition(GridPosition newPosition, bool instant = false) {
Position = newPosition; // This invokes OnGridPositionChanged which sets up the tween

if (instant) {
if (GridPositionManager.Instance == null) return;

Vector3 groundTargetPosition = GridPositionManager.Instance.GridToWorld(Position);
transform.position = groundTargetPosition - groundPointOffset + visualOffset;

visualStartPosition = transform.position;
visualTargetPosition = transform.position;
movementProgress = 1f;
isMoving = false;
}
}

pub void SetSpeedMultiplier(float multiplier) {
this.speedMultiplier = multiplier;
}

pub void SnapToGrid() {
if (GridPositionManager.Instance == null) return;

Vector3 groundWorldPos = transform.position + groundPointOffset;
GridPosition currentGridPos = GridPositionManager.Instance.WorldToGrid(groundWorldPos);
SetPosition(currentGridPos, true);
}

pub void MoveInDirection(GridPosition direction) {
SetPosition(gridPosition + direction);
}

pub bool CanMoveTo(GridPosition targetPosition) {
ret GridPositionManager.Instance?.IsPositionValid(targetPosition) ?? false;
}

pub void CompleteMovement() {
if (isMoving) {
transform.position = visualTargetPosition;
movementProgress = 1f;
isMoving = false;
OnMovementComplete?.Invoke(gridPosition);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridPosition.cs

﻿// Assets/Scripts/Ticks/GridPosition.cs

namespace WegoSystem {
pub struct GridPosition : IEquatable<GridPosition> {
pub int x;
pub int y;

pub GridPosition(int x, int y) {
this.x = x;
this.y = y;
}

pub GridPosition(Vector3Int vector3Int) {
this.x = vector3Int.x;
this.y = vector3Int.y;
}

pub GridPosition(Vector2Int vector2Int) {
this.x = vector2Int.x;
this.y = vector2Int.y;
}

pub stat GridPosition operator +(GridPosition a, GridPosition b) {
ret new GridPosition(a.x + b.x, a.y + b.y);
}

pub stat GridPosition operator -(GridPosition a, GridPosition b) {
ret new GridPosition(a.x - b.x, a.y - b.y);
}

pub stat bool operator ==(GridPosition a, GridPosition b) {
ret a.x == b.x && a.y == b.y;
}

pub stat bool operator !=(GridPosition a, GridPosition b) {
ret !(a == b);
}

pub Vector3Int ToVector3Int() => new Vector3Int(x, y, 0);
pub Vector2Int ToVector2Int() => new Vector2Int(x, y);
pub Vector3 ToWorldPosition(float cellSize = 1f) => new Vector3(x * cellSize, y * cellSize, 0);

pub stat ro GridPosition Up = new GridPosition(0, 1);
pub stat ro GridPosition Down = new GridPosition(0, -1);
pub stat ro GridPosition Left = new GridPosition(-1, 0);
pub stat ro GridPosition Right = new GridPosition(1, 0);
pub stat ro GridPosition UpLeft = new GridPosition(-1, 1);
pub stat ro GridPosition UpRight = new GridPosition(1, 1);
pub stat ro GridPosition DownLeft = new GridPosition(-1, -1);
pub stat ro GridPosition DownRight = new GridPosition(1, -1);
pub stat ro GridPosition Zero = new GridPosition(0, 0);

pub int ManhattanDistance(GridPosition other) {
ret Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y);
}

pub int ChebyshevDistance(GridPosition other) {
ret Mathf.Max(Mathf.Abs(x - other.x), Mathf.Abs(y - other.y));
}

pub float EuclideanDistance(GridPosition other) {
int dx = x - other.x;
int dy = y - other.y;
ret Mathf.Sqrt(dx * dx + dy * dy);
}

pub GridPosition[] GetNeighbors(bool includeDiagonals = false) {
if (includeDiagonals) {
ret new GridPosition[] {
this + Up, this + Down, this + Left, this + Right,
this + UpLeft, this + UpRight, this + DownLeft, this + DownRight
};
}
else {
ret new GridPosition[] {
this + Up, this + Down, this + Left, this + Right
};
}
}

pub bool Equals(GridPosition other) {
ret x == other.x && y == other.y;
}

pub ovr bool Equals(object obj) {
ret obj is GridPosition other && Equals(other);
}

pub ovr int GetHashCode() {
ret HashCode.Combine(x, y);
}

pub ovr string ToString() {
ret $"({x}, {y})";
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridPositionManager.cs

﻿// Assets/Scripts/Ticks/GridPositionManager.cs
using UnityEngine.Tilemaps;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace WegoSystem {
pub cls GridPositionManager : SingletonMonoBehaviour<GridPositionManager> {
[SerializeField] TileInteractionManager tileInteractionManager;

Grid _tilemapGrid;

Grid TilemapGrid => _tilemapGrid;

[SerializeField] Vector2Int gridBounds = new Vector2Int(100, 100);

[SerializeField] bool showGridGizmos = true;
[SerializeField] Color gridColor = new Color(0.5f, 0.5f, 0.5f, 0.3f);
[SerializeField] int gizmoGridSize = 20;
[SerializeField] bool debugMode = false;

ro Dictionary<GridPosition, HashSet<GridEntity>> entitiesByPosition = new Dictionary<GridPosition, HashSet<GridEntity>>();
ro HashSet<GridEntity> allEntities = new HashSet<GridEntity>();

void OnDestroy() {
if (Instance == this) {
}
}

pub void Initialize() {
SyncWithTileGrid();
}

pub void SyncWithTileGrid() {
if (tileInteractionManager != null && tileInteractionManager.interactionGrid != null) {
this._tilemapGrid = tileInteractionManager.interactionGrid;
if (debugMode) Debug.Log($"[GridPositionManager] Synced with assigned TileInteractionManager's grid: '{this._tilemapGrid.name}'.");
return;
}

if (TileInteractionManager.Instance != null && TileInteractionManager.Instance.interactionGrid != null) {
this._tilemapGrid = TileInteractionManager.Instance.interactionGrid;
tileInteractionManager = TileInteractionManager.Instance;
if (debugMode) Debug.Log($"[GridPositionManager] Synced with singleton TileInteractionManager.Instance's grid: '{this._tilemapGrid.name}'.");
return;
}

if (_tilemapGrid == null) {
Debug.LogError("[GridPositionManager] Could not find TileInteractionManager or its grid to sync with! Grid system may be misaligned. Please assign the TileInteractionManager in the Inspector.");
}
}

pub GridPosition WorldToGrid(Vector3 worldPosition) {
if (TilemapGrid == null) ret GridPosition.Zero;
Vector3Int cellPos = TilemapGrid.WorldToCell(worldPosition);
ret new GridPosition(cellPos);
}

pub Vector3 GridToWorld(GridPosition gridPosition) {
if (TilemapGrid == null) ret Vector3.zero;
ret TilemapGrid.GetCellCenterWorld(gridPosition.ToVector3Int());
}

pub Vector3 GetCellCenter(GridPosition gridPosition) {
ret GridToWorld(gridPosition);
}

pub bool IsPositionValid(GridPosition position) {
ret position.x >= -gridBounds.x / 2 && position.x < gridBounds.x / 2 &&
position.y >= -gridBounds.y / 2 && position.y < gridBounds.y / 2;
}

pub bool IsPositionOccupied(GridPosition position) {
if (entitiesByPosition.TryGetValue(position, out var entities)) {
ret entities.Any(entity => entity.isTileOccupant);
}
ret false;
}

pub void RegisterEntity(GridEntity entity) {
if (entity == null || allEntities.Contains(entity)) return;

allEntities.Add(entity);
AddEntityToPosition(entity, entity.Position);

entity.OnPositionChanged += OnEntityPositionChanged;
}

pub void UnregisterEntity(GridEntity entity) {
if (entity == null || !allEntities.Contains(entity)) return;

allEntities.Remove(entity);
RemoveEntityFromPosition(entity, entity.Position);

entity.OnPositionChanged -= OnEntityPositionChanged;
}

void OnEntityPositionChanged(GridPosition oldPosition, GridPosition newPosition) {
var entity = allEntities.FirstOrDefault(e => e.Position == newPosition && e.PreviousPosition == oldPosition);
if (entity != null) {
RemoveEntityFromPosition(entity, oldPosition);
AddEntityToPosition(entity, newPosition);
}
}

void AddEntityToPosition(GridEntity entity, GridPosition position) {
if (!entitiesByPosition.ContainsKey(position)) {
entitiesByPosition[position] = new HashSet<GridEntity>();
}
entitiesByPosition[position].Add(entity);
}

void RemoveEntityFromPosition(GridEntity entity, GridPosition position) {
if (entitiesByPosition.ContainsKey(position)) {
entitiesByPosition[position].Remove(entity);
if (entitiesByPosition[position].Count == 0) {
entitiesByPosition.Remove(position);
}
}
}

pub HashSet<GridEntity> GetEntitiesAt(GridPosition position) {
ret entitiesByPosition.ContainsKey(position)
? new HashSet<GridEntity>(entitiesByPosition[position])
: new HashSet<GridEntity>();
}

pub List<GridEntity> GetEntitiesInRadius(GridPosition center, int radius, bool useCircle = true) {
var result = new List<GridEntity>();

if (useCircle) {
var tilesInRadius = GridRadiusUtility.GetTilesInCircle(center, radius);
foreach (var pos in tilesInRadius) {
if (entitiesByPosition.ContainsKey(pos)) {
result.AddRange(entitiesByPosition[pos]);
}
}
} else {
for (int x = -radius; x <= radius; x++) {
for (int y = -radius; y <= radius; y++) {
var checkPos = new GridPosition(center.x + x, center.y + y);
if (checkPos.ManhattanDistance(center) <= radius && entitiesByPosition.ContainsKey(checkPos)) {
result.AddRange(entitiesByPosition[checkPos]);
}
}
}
}

ret result;
}

pub bool IsPositionWithinRadius(GridPosition position, GridPosition center, int radius, bool useCircle = true) {
if (useCircle) {
ret GridRadiusUtility.IsWithinCircleRadius(position, center, radius);
} else {
ret position.ManhattanDistance(center) <= radius;
}
}

pub GridEntity GetNearestEntity(GridPosition position, System.Func<GridEntity, bool> predicate = null) {
GridEntity nearest = null;
float nearestDistance = float.MaxValue;

foreach (var entity in allEntities) {
if (predicate != null && !predicate(entity)) continue;

float distance = entity.Position.EuclideanDistance(position);
if (distance < nearestDistance) {
nearest = entity;
nearestDistance = distance;
}
}
ret nearest;
}

pub Grid GetTilemapGrid() {
ret TilemapGrid;
}

pub List<GridPosition> GetPath(GridPosition start, GridPosition end, bool allowDiagonal = false) {
var path = new List<GridPosition>();

if (!IsPositionValid(start) || !IsPositionValid(end)) {
ret path;
}

var openSet = new HashSet<GridPosition>();
var closedSet = new HashSet<GridPosition>();
var cameFrom = new Dictionary<GridPosition, GridPosition>();
var gScore = new Dictionary<GridPosition, float>();
var fScore = new Dictionary<GridPosition, float>();

openSet.Add(start);
gScore[start] = 0;
fScore[start] = HeuristicCost(start, end);

while (openSet.Count > 0) {
GridPosition current = GetLowestFScore(openSet, fScore);

if (current == end) {
while (cameFrom.ContainsKey(current)) {
path.Add(current);
current = cameFrom[current];
}
path.Reverse();
ret path;
}

openSet.Remove(current);
closedSet.Add(current);

foreach (var neighbor in current.GetNeighbors(allowDiagonal)) {
if (!IsPositionValid(neighbor) || closedSet.Contains(neighbor) || (neighbor != end && IsPositionOccupied(neighbor))) {
continue;
}

float tentativeGScore = gScore[current] + 1; // Assuming cost of 1 per tile

if (!openSet.Contains(neighbor)) {
openSet.Add(neighbor);
}
else if (gScore.ContainsKey(neighbor) && tentativeGScore >= gScore[neighbor]) {
continue; // This path is not better
}

cameFrom[neighbor] = current;
gScore[neighbor] = tentativeGScore;
fScore[neighbor] = gScore[neighbor] + HeuristicCost(neighbor, end);
}
}
ret path; // No path found
}

float HeuristicCost(GridPosition a, GridPosition b) {
ret a.ManhattanDistance(b);
}

GridPosition GetLowestFScore(HashSet<GridPosition> openSet, Dictionary<GridPosition, float> fScore) {
GridPosition lowest = openSet.First();
float lowestScore = fScore.ContainsKey(lowest) ? fScore[lowest] : float.MaxValue;

foreach (var pos in openSet) {
float score = fScore.ContainsKey(pos) ? fScore[pos] : float.MaxValue;
if (score < lowestScore) {
lowest = pos;
lowestScore = score;
}
}
ret lowest;
}

pub bool PathExists(GridPosition start, GridPosition end, bool allowDiagonal = false) {
var path = GetPath(start, end, allowDiagonal);
ret path.Count > 0;
}

pub void SnapEntityToGrid(GameObject entity) {
if (entity == null) return;

GridEntity gridEntity = entity.GetComponent<GridEntity>();
if (gridEntity == null) {
gridEntity = entity.AddComponent<GridEntity>();
}

gridEntity.SnapToGrid();

RegisterEntity(gridEntity);

if (debugMode) {
Debug.Log($"[GridPositionManager] Snapped and Registered {entity.name} to grid {gridEntity.Position}");
}
}

pub void SnapAllEntitiesToGrid<T>() where T : Component {
T[] entities = FindObjectsByType<T>(FindObjectsSortMode.None);
foreach (var entity in entities) {
SnapEntityToGrid(entity.gameObject);
}
Debug.Log($"[GridPositionManager] Snapped {entities.Length} entities of type {typeof(T).Name} to grid");
}

pub stat List<GridPosition> GetTilesInRadius(GridPosition center, int radius, bool useManhattan = true) {
var result = new List<GridPosition>();

for (int x = -radius; x <= radius; x++) {
for (int y = -radius; y <= radius; y++) {
var offset = new GridPosition(x, y);
var checkPos = center + offset;

int distance = useManhattan
? Mathf.Abs(x) + Mathf.Abs(y)
: Mathf.Max(Mathf.Abs(x), Mathf.Abs(y));

if (distance <= radius) {
result.Add(checkPos);
}
}
}

ret result;
}

void OnDrawGizmos() {
if (!showGridGizmos || _tilemapGrid == null) return;

Gizmos.color = gridColor;

int halfWidth = gizmoGridSize / 2;
int halfHeight = gizmoGridSize / 2;

for (int x = -halfWidth; x <= halfWidth; x++) {
Vector3 start = GridToWorld(new GridPosition(x, -halfHeight));
Vector3 end = GridToWorld(new GridPosition(x, halfHeight));
Gizmos.DrawLine(start, end);
}

for (int y = -halfHeight; y <= halfHeight; y++) {
Vector3 start = GridToWorld(new GridPosition(-halfWidth, y));
Vector3 end = GridToWorld(new GridPosition(halfWidth, y));
Gizmos.DrawLine(start, end);
}

Gizmos.color = Color.red;
foreach (var kvp in entitiesByPosition) {
if (kvp.Value.Count > 0) {
Vector3 cellCenter = GridToWorld(kvp.Key);
Gizmos.DrawWireCube(cellCenter, Vector3.one * TilemapGrid.cellSize.x * 0.8f);
}
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\GridRadiusUtility.cs

﻿using UnityEngine;
using WegoSystem;

ns WegoSystem {
pub stat cls GridRadiusUtility {
pub stat List<GridPosition> GetTilesInCircle(GridPosition center, int radius, bool filled = true) {
var result = new List<GridPosition>();

if (radius <= 0) {
result.Add(center);
ret result;
}

for (int dx = -radius; dx <= radius; dx++) {
for (int dy = -radius; dy <= radius; dy++) {
float distance = Mathf.Sqrt(dx * dx + dy * dy);

if (filled) {
if (distance <= radius + 0.5f) {
result.Add(new GridPosition(center.x + dx, center.y + dy));
}
} else {
if (distance >= radius - 0.5f && distance <= radius + 0.5f) {
result.Add(new GridPosition(center.x + dx, center.y + dy));
}
}
}
}

ret result;
}

pub stat List<GridPosition> GetPerfectCircleTiles(GridPosition center, int radius) {
var result = new HashSet<GridPosition>();

if (radius == 0) {
result.Add(center);
ret new List<GridPosition>(result);
}

int x = 0;
int y = radius;
int d = 3 - 2 * radius;

while (x <= y) {
AddCirclePoints(result, center, x, y);

if (d < 0) {
d = d + 4 * x + 6;
} else {
d = d + 4 * (x - y) + 10;
y--;
}
x++;
}

var filledResult = new List<GridPosition>();
int minX = center.x - radius;
int maxX = center.x + radius;

for (int scanY = center.y - radius; scanY <= center.y + radius; scanY++) {
bool inside = false;
int startX = minX;

for (int scanX = minX; scanX <= maxX; scanX++) {
var pos = new GridPosition(scanX, scanY);
if (result.Contains(pos)) {
if (!inside) {
inside = true;
startX = scanX;
}
} else if (inside) {
for (int fillX = startX; fillX < scanX; fillX++) {
filledResult.Add(new GridPosition(fillX, scanY));
}
inside = false;
}
}

if (inside) {
for (int fillX = startX; fillX <= maxX; fillX++) {
var pos = new GridPosition(fillX, scanY);
if (result.Contains(pos) || fillX == maxX) {
for (int fill = startX; fill <= fillX; fill++) {
filledResult.Add(new GridPosition(fill, scanY));
}
break;
}
}
}
}

ret filledResult;
}

stat void AddCirclePoints(HashSet<GridPosition> result, GridPosition center, int x, int y) {
result.Add(new GridPosition(center.x + x, center.y + y));
result.Add(new GridPosition(center.x - x, center.y + y));
result.Add(new GridPosition(center.x + x, center.y - y));
result.Add(new GridPosition(center.x - x, center.y - y));
result.Add(new GridPosition(center.x + y, center.y + x));
result.Add(new GridPosition(center.x - y, center.y + x));
result.Add(new GridPosition(center.x + y, center.y - x));
result.Add(new GridPosition(center.x - y, center.y - x));
}

pub stat bool IsWithinCircleRadius(GridPosition position, GridPosition center, int radius) {
int dx = position.x - center.x;
int dy = position.y - center.y;
float distance = Mathf.Sqrt(dx * dx + dy * dy);
ret distance <= radius + 0.5f;
}

pub stat List<GridPosition> GetCircleOutline(GridPosition center, int radius) {
ret GetTilesInCircle(center, radius, false);
}

pub stat void DebugPrintRadius(GridPosition center, int radius) {
var tiles = GetTilesInCircle(center, radius);
var tileSet = new HashSet<GridPosition>(tiles);

Debug.Log($"Circle pattern for radius {radius}:");

for (int y = radius; y >= -radius; y--) {
string line = "";
for (int x = -radius; x <= radius; x++) {
var pos = new GridPosition(center.x + x, center.y + y);
if (pos.Equals(center)) {
line += "◉ "; // Center
} else if (tileSet.Contains(pos)) {
line += "● "; // Included tile
} else {
line += "· "; // Not included
}
}
Debug.Log(line);
}
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\TickConfiguration.cs

﻿using UnityEngine;

namespace WegoSystem {
pub cls TickConfiguration : ScriptableObject {
[SerializeField] pub float ticksPerRealSecond = 2f;

pub int ticksPerDay = 100;
pub int dayPhaseTicks = 60;
pub int nightPhaseTicks = 40;
pub int transitionTicks = 10;

pub int animalHungerTickInterval = 3;
pub int animalThinkingInterval = 3;

pub int movementTicksPerTile = 1;
pub int movementCooldownTicks = 0;

pub float GetRealSecondsPerTick() {
ret ticksPerRealSecond > 0 ? 1f / ticksPerRealSecond : 0.5f;
}

pub int ConvertSecondsToTicks(float seconds) {
ret Mathf.RoundToInt(seconds * ticksPerRealSecond);
}

pub float ConvertTicksToSeconds(int ticks) {
ret ticks / ticksPerRealSecond;
}

pub int GetDayProgress(int currentTick) {
ret currentTick % ticksPerDay;
}

pub float GetDayProgressNormalized(int currentTick) {
ret (float)(currentTick % ticksPerDay) / ticksPerDay;
}

pub void SetTicksPerSecond(float newRate) {
ticksPerRealSecond = Mathf.Max(0.1f, newRate);
}

void OnValidate() {
ticksPerRealSecond = Mathf.Max(0.1f, ticksPerRealSecond);
ticksPerDay = Mathf.Max(10, ticksPerDay);
dayPhaseTicks = Mathf.Max(1, dayPhaseTicks);
nightPhaseTicks = Mathf.Max(1, nightPhaseTicks);
transitionTicks = Mathf.Max(1, transitionTicks);
animalHungerTickInterval = Mathf.Max(1, animalHungerTickInterval);
animalThinkingInterval = Mathf.Max(1, animalThinkingInterval);
}

void ApplySlowPacedPreset() {
ticksPerRealSecond = 1f;
ticksPerDay = 200;
dayPhaseTicks = 120;
nightPhaseTicks = 80;
transitionTicks = 20;
animalHungerTickInterval = 5;
}

void ApplyFastPacedPreset() {
ticksPerRealSecond = 4f;
ticksPerDay = 50;
dayPhaseTicks = 30;
nightPhaseTicks = 20;
transitionTicks = 5;
animalHungerTickInterval = 2;
}

void ApplyBalancedPreset() {
ticksPerRealSecond = 2f;
ticksPerDay = 100;
dayPhaseTicks = 60;
nightPhaseTicks = 40;
transitionTicks = 10;
animalHungerTickInterval = 3;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ticks\TickManager.cs

﻿// Assets/Scripts/Ticks/TickManager.cs

namespace WegoSystem {
pub ifc ITickUpdateable {
void OnTickUpdate(int currentTick);
}

pub cls TickManager : SingletonMonoBehaviour<TickManager> {
[SerializeField] TickConfiguration tickConfig;
[SerializeField] bool debugMode = false;
[SerializeField] int currentTick = 0;

pub int CurrentTick => currentTick;
pub TickConfiguration Config => tickConfig;

pub event Action<int> OnTickAdvanced;
pub event Action<int> OnTickStarted;
pub event Action<int> OnTickCompleted;

ro List<ITickUpdateable> tickUpdateables = new List<ITickUpdateable>();
ro List<ITickUpdateable> pendingAdditions = new List<ITickUpdateable>();
ro List<ITickUpdateable> pendingRemovals = new List<ITickUpdateable>();
bool isProcessingTick = false;

prot ovr void OnAwake() {
if (tickConfig == null) {
Debug.LogError("[TickManager] No TickConfiguration assigned! Creating default config.");
tickConfig = ScriptableObject.CreateInstance<TickConfiguration>();
}
}

void OnDestroy() {
if (Instance == this) {
}
}

void Update() {
#if UNITY_EDITOR
if (debugMode && Input.GetKeyDown(KeyCode.T)) {
Debug.Log("[TickManager] Debug: Manual tick advance");
AdvanceTick();
}
#endif
}

pub void AdvanceTick() {
AdvanceMultipleTicks(1);
}

pub void AdvanceMultipleTicks(int tickCount) {
if (tickCount <= 0) return;

for (int i = 0; i < tickCount; i++) {
currentTick++;
ProcessTick();
}
}

void ProcessTick() {
if (debugMode) {
Debug.Log($"[TickManager] Processing tick {currentTick}");
}

OnTickStarted?.Invoke(currentTick);

ProcessPendingUpdates();

isProcessingTick = true;
foreach (var tickUpdateable in tickUpdateables) {
try {
tickUpdateable?.OnTickUpdate(currentTick);
}
catch (Exception e) {
Debug.LogError($"[TickManager] Error in tick update: {e.Message}");
}
}
isProcessingTick = false;

OnTickAdvanced?.Invoke(currentTick);
OnTickCompleted?.Invoke(currentTick);
}

pub void RegisterTickUpdateable(ITickUpdateable updateable) {
if (updateable == null) return;

if (isProcessingTick) {
if (!pendingAdditions.Contains(updateable))
pendingAdditions.Add(updateable);
}
else {
if (!tickUpdateables.Contains(updateable))
tickUpdateables.Add(updateable);
}
}

pub void UnregisterTickUpdateable(ITickUpdateable updateable) {
if (updateable == null) return;

if (isProcessingTick) {
if (!pendingRemovals.Contains(updateable))
pendingRemovals.Add(updateable);
}
else {
tickUpdateables.Remove(updateable);
}
}

void ProcessPendingUpdates() {
foreach (var updateable in pendingAdditions) {
if (!tickUpdateables.Contains(updateable))
tickUpdateables.Add(updateable);
}
pendingAdditions.Clear();

foreach (var updateable in pendingRemovals) {
tickUpdateables.Remove(updateable);
}
pendingRemovals.Clear();
}

pub void ResetTicks() {
currentTick = 0;
if (debugMode) Debug.Log("[TickManager] Reset tick counter");
}

pub int GetTicksSince(int pastTick) {
ret currentTick - pastTick;
}

pub bool HasTicksPassed(int lastTick, int tickInterval) {
ret GetTicksSince(lastTick) >= tickInterval;
}

pub int GetNextIntervalTick(int tickInterval) {
ret currentTick + tickInterval;
}

pub void DebugAdvanceTick() {
if (Application.isEditor || Debug.isDebugBuild) {
AdvanceTick();
}
}

pub int GetRegisteredUpdateableCount() {
ret tickUpdateables.Count;
}
}
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Ecosystem\Management\FaunaManager.cs

﻿// Assets/Scripts/Ecosystem/Management/FaunaManager.cs

using WegoSystem; // Correctly referencing the ns for RunManager

pub cls FaunaManager : MonoBehaviour {
[SerializeField] Vector2 spawnCenter = Vector2.zero;
[SerializeField] Vector2 spawnAreaSize = new Vector2(20f, 10f);

[SerializeField] Transform ecosystemParent;
[SerializeField] [Min(0f)] float screenBoundsPadding = 0.5f;
[SerializeField] [Min(0f)] float offscreenSpawnMargin = 2.0f;

[SerializeField] bool showBoundsGizmos = false;

[SerializeField] [Range(-10f, 10f)] float boundsOffsetX = 0f;
[SerializeField] [Range(-10f, 10f)] float boundsOffsetY = 0f;

List<Coroutine> activeSpawnCoroutines = new List<Coroutine>();
Camera mainCamera; // Ensure this is assigned or found

pub void Initialize() {
InitializeManager();
}

void InitializeManager() {
activeSpawnCoroutines.Clear();
if (WaveManager.Instance != null) mainCamera = WaveManager.Instance.GetMainCamera();
if (mainCamera == null) mainCamera = Camera.main;
if (mainCamera == null) Debug.LogError("[FaunaManager] Cannot find Main Camera!", this);

if (ecosystemParent == null) {
if (EcosystemManager.Instance != null && EcosystemManager.Instance.animalParent != null) {
ecosystemParent = EcosystemManager.Instance.animalParent;
Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned from EcosystemManager.animalParent.", this);
}
else {
ecosystemParent = transform;
Debug.LogWarning("[FaunaManager] Ecosystem Parent assigned to self as fallback.", this);
}
}
}

pub void ExecuteSpawnWave(WaveDefinition waveDef) {
if (waveDef == null) { Debug.LogError("[FaunaManager] ExecuteSpawnWave called with null WaveDefinition!", this); return; }
if (waveDef.spawnEntries == null || waveDef.spawnEntries.Count == 0) { Debug.LogWarning($"[FaunaManager] Wave '{waveDef.waveName}' has no spawn entries.", this); return; }

Debug.Log($"[FaunaManager] Executing spawn for Wave: '{waveDef.waveName}'");
StopAllSpawnCoroutines(); // Ensures only one waveDef's entries are spawning at a time from this manager

foreach (WaveSpawnEntry entry in waveDef.spawnEntries) {
if (entry.animalDefinition == null) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', null AnimalDefinition for wave '{waveDef.waveName}'."); continue; }
if (entry.spawnCount <= 0) { Debug.LogWarning($"[FaunaManager] Skipping entry '{entry.description}', Spawn Count <= 0 for wave '{waveDef.waveName}'."); continue; }

if (RunManager.Instance != null && RunManager.Instance.CurrentState != RunState.GrowthAndThreat) {
Debug.Log($"[FaunaManager] Halting further spawn entry processing for wave '{waveDef.waveName}', RunManager not in GrowthAndThreat state.");
break; // Don't start new coroutines if not in the correct game state
}

WaveSpawnEntry currentEntry = entry; // Closure capture
Coroutine spawnCoroutine = StartCoroutine(SpawnWaveEntryCoroutine(currentEntry, waveDef.waveName));
activeSpawnCoroutines.Add(spawnCoroutine);
}
Debug.Log($"[FaunaManager] Started {activeSpawnCoroutines.Count} spawn entry coroutine(s) for '{waveDef.waveName}'.");
}

pub void StopAllSpawnCoroutines() {
if (activeSpawnCoroutines.Count > 0) {
Debug.Log($"[FaunaManager] Stopping all ({activeSpawnCoroutines.Count}) active spawn coroutines.");
foreach (Coroutine co in activeSpawnCoroutines) {
if (co != null) StopCoroutine(co);
}
activeSpawnCoroutines.Clear();
}
}

IEnumerator SpawnWaveEntryCoroutine(WaveSpawnEntry entry, string waveNameForDebug) {
if (entry.delayAfterSpawnTime > 0) {
yield ret new WaitForSeconds(entry.delayAfterSpawnTime);
}

for (int i = 0; i < entry.spawnCount; i++) {
if (RunManager.Instance != null && RunManager.Instance.CurrentState != RunState.GrowthAndThreat) {
Debug.Log($"[FaunaManager] Halting spawn for entry '{entry.description}' in wave '{waveNameForDebug}', RunManager no longer in GrowthAndThreat state.");
break; // Exit loop if game state changed
}

Vector2 spawnPos = CalculateSpawnPosition(entry.spawnLocationType, entry.spawnRadius);
bool isOffscreen = entry.spawnLocationType == WaveSpawnLocationType.Offscreen;
GameObject spawnedAnimal = SpawnAnimal(entry.animalDefinition, spawnPos, isOffscreen);

if (entry.spawnInterval > 0 && i < entry.spawnCount - 1) // Don't wait after the last one {
yield ret new WaitForSeconds(entry.spawnInterval);
}
}
}

Vector2 CalculateSpawnPosition(WaveSpawnLocationType locationType, float radius) {
if (mainCamera == null) { Debug.LogError("[FaunaManager] Missing Main Camera for CalculateSpawnPosition!"); ret spawnCenter; }

Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

Vector2 spawnPos = Vector2.zero;
float camHeight = mainCamera.orthographicSize * 2f;
float camWidth = camHeight * mainCamera.aspect;

switch (locationType) {
case WaveSpawnLocationType.Offscreen:
float marginMinX = effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin;
float marginMaxX = effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin;
float marginMinY = effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin;
float marginMaxY = effectiveCamPos.y + camHeight / 2f + offscreenSpawnMargin;
float extraOffset = 0.1f;
int edge = Random.Range(0, 4);
if (edge == 0) { spawnPos.x = marginMinX - extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
else if (edge == 1) { spawnPos.x = marginMaxX + extraOffset; spawnPos.y = Random.Range(marginMinY, marginMaxY); }
else if (edge == 2) { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMinY - extraOffset; }
else { spawnPos.x = Random.Range(marginMinX, marginMaxX); spawnPos.y = marginMaxY + extraOffset; }
break;

case WaveSpawnLocationType.RandomNearPlayer:
Transform playerT = FindPlayerTransform();
if (playerT != null) {
spawnPos = (Vector2)playerT.position + Random.insideUnitCircle * radius;
}
else {
Debug.LogWarning("[FaunaManager] Player not found for RandomNearPlayer. Falling back to Global.");
goto case WaveSpawnLocationType.GlobalSpawnArea;
}
break;

case WaveSpawnLocationType.GlobalSpawnArea:
default:
spawnPos.x = effectiveCamPos.x + Random.Range(-spawnAreaSize.x / 2f, spawnAreaSize.x / 2f);
spawnPos.y = effectiveCamPos.y + Random.Range(-spawnAreaSize.y / 2f, spawnAreaSize.y / 2f);
break;
}
ret spawnPos;
}

Transform FindPlayerTransform() {
GameObject playerGO = GameObject.FindGameObjectWithTag("Player");
if (playerGO != null) ret playerGO.transform;

PlayerTileInteractor pti = FindAnyObjectByType<PlayerTileInteractor>();
if (pti != null) ret pti.transform;

GardenerController gc = FindAnyObjectByType<GardenerController>();
if (gc != null) ret gc.transform;

ret null;
}

GameObject SpawnAnimal(AnimalDefinition definition, Vector2 position, bool isOffscreenSpawn) {
if (definition == null || definition.prefab == null) {
Debug.LogError("[FaunaManager] Cannot spawn animal: null definition or prefab.");
ret null;
}

if (mainCamera == null) {
Debug.LogError("[FaunaManager] Missing Main Camera for SpawnAnimal bounds calculation!");
ret null;
}

Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;

Vector2 minPaddedBounds, maxPaddedBounds;
float camHeight = mainCamera.orthographicSize * 2f;
float camWidth = camHeight * mainCamera.aspect;

minPaddedBounds.x = effectiveCamPos.x - camWidth / 2f + screenBoundsPadding;
maxPaddedBounds.x = effectiveCamPos.x + camWidth / 2f - screenBoundsPadding;
minPaddedBounds.y = effectiveCamPos.y - camHeight / 2f + screenBoundsPadding;
maxPaddedBounds.y = effectiveCamPos.y + camHeight / 2f - screenBoundsPadding;

GameObject animalObj = Instantiate(definition.prefab, position, Quaternion.identity);

if (ecosystemParent != null) {
Transform speciesParent = ecosystemParent;
if (EcosystemManager.Instance != null && EcosystemManager.Instance.sortAnimalsBySpecies && !string.IsNullOrEmpty(definition.animalName)) {
speciesParent = ecosystemParent.Find(definition.animalName);
if (speciesParent == null) {
GameObject subParentGO = new GameObject(definition.animalName);
subParentGO.transform.SetParent(ecosystemParent);
speciesParent = subParentGO.transform;
}
}
animalObj.transform.SetParent(speciesParent);
}

AnimalController controller = animalObj.GetComponent<AnimalController>();
if (controller != null) {
if (isOffscreenSpawn) {
Vector2 screenCenter = (minPaddedBounds + maxPaddedBounds) / 2f;
controller.SetSeekingScreenCenter(screenCenter, minPaddedBounds, maxPaddedBounds);
}
}
else {
Debug.LogError($"[FaunaManager] Spawned animal prefab '{definition.prefab.name}' missing AnimalController script!", animalObj);
}

ret animalObj;
}

void OnDrawGizmos() {
if (!showBoundsGizmos || mainCamera == null) return;
Vector2 functionalOffset = new Vector2(boundsOffsetX, boundsOffsetY);
Vector2 effectiveCamPos = (Vector2)mainCamera.transform.position + functionalOffset;
float camHeight = mainCamera.orthographicSize * 2f;
float camWidth = camHeight * mainCamera.aspect;
Vector2 paddedMin = new Vector2(effectiveCamPos.x - camWidth / 2f + screenBoundsPadding, effectiveCamPos.y - camHeight / 2f + screenBoundsPadding);
Vector2 paddedMax = new Vector2(effectiveCamPos.x + camWidth / 2f - screenBoundsPadding, effectiveCamPos.y + camHeight / 2f - screenBoundsPadding);
DrawWireRectangleGizmo(paddedMin, paddedMax, Color.green);
Vector2 marginMin = new Vector2(effectiveCamPos.x - camWidth / 2f - offscreenSpawnMargin, effectiveCamPos.y - camHeight / 2f - offscreenSpawnMargin);
Vector2 marginMax = new Vector2(effectiveCamPos.x + camWidth / 2f + offscreenSpawnMargin, effectiveCamPos.y + camHeight / 2f - offscreenSpawnMargin);
DrawWireRectangleGizmo(marginMin, marginMax, Color.red);
}

void DrawWireRectangleGizmo(Vector2 min, Vector2 max, Color color) { Gizmos.color = color; Gizmos.DrawLine(new Vector3(min.x, min.y, 0), new Vector3(max.x, min.y, 0)); Gizmos.DrawLine(new Vector3(max.x, min.y, 0), new Vector3(max.x, max.y, 0)); Gizmos.DrawLine(new Vector3(max.x, max.y, 0), new Vector3(min.x, max.y, 0)); Gizmos.DrawLine(new Vector3(min.x, max.y, 0), new Vector3(min.x, min.y, 0)); }
}

////////////////////////////////////////////////////////////
// Assets\Scripts\Genes\Services\GeneEventBus.cs

﻿// File: Assets/Scripts/Genes/Services/GeneEventBus.cs
using Abracodabra.Genes.Core; // Assuming Gene classes will be in this namespace

namespace Abracodabra.Genes.Services {
pub cls GeneEventBus : IGeneEventBus {
Dictionary<Type, List<Delegate>> handlers = new Dictionary<Type, List<Delegate>>();

pub void Subscribe<T>(Action<T> handler) where T : class {
var type = typeof(T);
if (!handlers.ContainsKey(type))
handlers[type] = new List<Delegate>();
handlers[type].Add(handler);
}

pub void Unsubscribe<T>(Action<T> handler) where T : class {
var type = typeof(T);
if (handlers.ContainsKey(type))
handlers[type].Remove(handler);
}

pub void Publish<T>(T message) where T : class {
var type = typeof(T);
if (handlers.TryGetValue(type, out var list)) {
var handlersToInvoke = new List<Delegate>(list);
foreach (Action<T> handler in handlersToInvoke)
handler?.Invoke(message);
}
}
}

pub cls GeneExecutedEvent {
pub ActiveGene Gene { get; set; }
pub int SequencePosition { get; set; }
pub bool Success { get; set; }
pub float EnergyCost { get; set; }
}

pub cls SequenceCompletedEvent {
pub int TotalSlotsExecuted { get; set; }
pub float TotalEnergyUsed { get; set; }
}

pub cls GeneValidationFailedEvent {
pub string GeneId { get; set; }
pub string Reason { get; set; }
}

}
